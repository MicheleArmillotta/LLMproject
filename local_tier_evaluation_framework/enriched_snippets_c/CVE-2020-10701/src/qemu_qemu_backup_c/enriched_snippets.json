[
  {
    "function_name": "qemuBackupGetJobInfoStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "1086-1142",
    "snippet": "int\nqemuBackupGetJobInfoStats(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          qemuDomainJobInfoPtr jobInfo)\n{\n    qemuDomainBackupStats *stats = &jobInfo->stats.backup;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorJobInfoPtr *blockjobs = NULL;\n    size_t nblockjobs = 0;\n    size_t i;\n    int rc;\n    int ret = -1;\n\n    if (!priv->backup) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"backup job data missing\"));\n        return -1;\n    }\n\n    if (qemuDomainJobInfoUpdateTime(jobInfo) < 0)\n        return -1;\n\n    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_ACTIVE;\n\n    qemuDomainObjEnterMonitor(driver, vm);\n\n    rc = qemuMonitorGetJobInfo(priv->mon, &blockjobs, &nblockjobs);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        goto cleanup;\n\n    /* count in completed jobs */\n    stats->total = priv->backup->push_total;\n    stats->transferred = priv->backup->push_transferred;\n    stats->tmp_used = priv->backup->pull_tmp_used;\n    stats->tmp_total = priv->backup->pull_tmp_total;\n\n    for (i = 0; i < priv->backup->ndisks; i++) {\n        if (priv->backup->disks[i].state != VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING)\n            continue;\n\n        qemuBackupGetJobInfoStatsUpdateOne(vm,\n                                           priv->backup->type == VIR_DOMAIN_BACKUP_TYPE_PUSH,\n                                           priv->backup->disks[i].name,\n                                           stats,\n                                           blockjobs,\n                                           nblockjobs);\n    }\n\n    ret = 0;\n\n cleanup:\n    for (i = 0; i < nblockjobs; i++)\n        qemuMonitorJobInfoFree(blockjobs[i]);\n    g_free(blockjobs);\n    return ret;\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "blockjobs"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorJobInfoFree",
          "args": [
            "blockjobs[i]"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJobInfoFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "4475-4484",
          "snippet": "void\nqemuMonitorJobInfoFree(qemuMonitorJobInfoPtr job)\n{\n    if (!job)\n        return;\n\n    VIR_FREE(job->id);\n    VIR_FREE(job->error);\n    VIR_FREE(job);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorJobInfoFree(qemuMonitorJobInfoPtr job)\n{\n    if (!job)\n        return;\n\n    VIR_FREE(job->id);\n    VIR_FREE(job->error);\n    VIR_FREE(job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBackupGetJobInfoStatsUpdateOne",
          "args": [
            "vm",
            "priv->backup->type == VIR_DOMAIN_BACKUP_TYPE_PUSH",
            "priv->backup->disks[i].name",
            "stats",
            "blockjobs",
            "nblockjobs"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupGetJobInfoStatsUpdateOne",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "1047-1083",
          "snippet": "static void\nqemuBackupGetJobInfoStatsUpdateOne(virDomainObjPtr vm,\n                                   bool push,\n                                   const char *diskdst,\n                                   qemuDomainBackupStats *stats,\n                                   qemuMonitorJobInfoPtr *blockjobs,\n                                   size_t nblockjobs)\n{\n    virDomainDiskDefPtr domdisk;\n    qemuMonitorJobInfoPtr monblockjob = NULL;\n    g_autoptr(qemuBlockJobData) diskblockjob = NULL;\n    size_t i;\n\n    /* it's just statistics so let's not worry so much about errors */\n    if (!(domdisk = virDomainDiskByTarget(vm->def, diskdst)))\n        return;\n\n    if (!(diskblockjob = qemuBlockJobDiskGetJob(domdisk)))\n        return;\n\n    for (i = 0; i < nblockjobs; i++) {\n        if (STREQ_NULLABLE(blockjobs[i]->id, diskblockjob->name)) {\n            monblockjob = blockjobs[i];\n            break;\n        }\n    }\n    if (!monblockjob)\n        return;\n\n    if (push) {\n        stats->total += monblockjob->progressTotal;\n        stats->transferred += monblockjob->progressCurrent;\n    } else {\n        stats->tmp_used += monblockjob->progressCurrent;\n        stats->tmp_total += monblockjob->progressTotal;\n    }\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic void\nqemuBackupGetJobInfoStatsUpdateOne(virDomainObjPtr vm,\n                                   bool push,\n                                   const char *diskdst,\n                                   qemuDomainBackupStats *stats,\n                                   qemuMonitorJobInfoPtr *blockjobs,\n                                   size_t nblockjobs)\n{\n    virDomainDiskDefPtr domdisk;\n    qemuMonitorJobInfoPtr monblockjob = NULL;\n    g_autoptr(qemuBlockJobData) diskblockjob = NULL;\n    size_t i;\n\n    /* it's just statistics so let's not worry so much about errors */\n    if (!(domdisk = virDomainDiskByTarget(vm->def, diskdst)))\n        return;\n\n    if (!(diskblockjob = qemuBlockJobDiskGetJob(domdisk)))\n        return;\n\n    for (i = 0; i < nblockjobs; i++) {\n        if (STREQ_NULLABLE(blockjobs[i]->id, diskblockjob->name)) {\n            monblockjob = blockjobs[i];\n            break;\n        }\n    }\n    if (!monblockjob)\n        return;\n\n    if (push) {\n        stats->total += monblockjob->progressTotal;\n        stats->transferred += monblockjob->progressCurrent;\n    } else {\n        stats->tmp_used += monblockjob->progressCurrent;\n        stats->tmp_total += monblockjob->progressTotal;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetJobInfo",
          "args": [
            "priv->mon",
            "&blockjobs",
            "&nblockjobs"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetJobInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "4487-4495",
          "snippet": "int\nqemuMonitorGetJobInfo(qemuMonitorPtr mon,\n                      qemuMonitorJobInfoPtr **jobs,\n                      size_t *njobs)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetJobInfo(mon, jobs, njobs);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetJobInfo(qemuMonitorPtr mon,\n                      qemuMonitorJobInfoPtr **jobs,\n                      size_t *njobs)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetJobInfo(mon, jobs, njobs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10172-10177",
          "snippet": "void qemuDomainObjEnterMonitor(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj)\n{\n    ignore_value(qemuDomainObjEnterMonitorInternal(driver, obj,\n                                                   QEMU_ASYNC_JOB_NONE));\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nvoid qemuDomainObjEnterMonitor(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj)\n{\n    ignore_value(qemuDomainObjEnterMonitorInternal(driver, obj,\n                                                   QEMU_ASYNC_JOB_NONE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainJobInfoUpdateTime",
          "args": [
            "jobInfo"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainJobInfoUpdateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "430-449",
          "snippet": "int\nqemuDomainJobInfoUpdateTime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->started)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->started) {\n        VIR_WARN(\"Async job starts in the future\");\n        jobInfo->started = 0;\n        return 0;\n    }\n\n    jobInfo->timeElapsed = now - jobInfo->started;\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainJobInfoUpdateTime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->started)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->started) {\n        VIR_WARN(\"Async job starts in the future\");\n        jobInfo->started = 0;\n        return 0;\n    }\n\n    jobInfo->timeElapsed = now - jobInfo->started;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"backup job data missing\")"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"backup job data missing\""
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBackupGetJobInfoStats(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          qemuDomainJobInfoPtr jobInfo)\n{\n    qemuDomainBackupStats *stats = &jobInfo->stats.backup;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorJobInfoPtr *blockjobs = NULL;\n    size_t nblockjobs = 0;\n    size_t i;\n    int rc;\n    int ret = -1;\n\n    if (!priv->backup) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"backup job data missing\"));\n        return -1;\n    }\n\n    if (qemuDomainJobInfoUpdateTime(jobInfo) < 0)\n        return -1;\n\n    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_ACTIVE;\n\n    qemuDomainObjEnterMonitor(driver, vm);\n\n    rc = qemuMonitorGetJobInfo(priv->mon, &blockjobs, &nblockjobs);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        goto cleanup;\n\n    /* count in completed jobs */\n    stats->total = priv->backup->push_total;\n    stats->transferred = priv->backup->push_transferred;\n    stats->tmp_used = priv->backup->pull_tmp_used;\n    stats->tmp_total = priv->backup->pull_tmp_total;\n\n    for (i = 0; i < priv->backup->ndisks; i++) {\n        if (priv->backup->disks[i].state != VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING)\n            continue;\n\n        qemuBackupGetJobInfoStatsUpdateOne(vm,\n                                           priv->backup->type == VIR_DOMAIN_BACKUP_TYPE_PUSH,\n                                           priv->backup->disks[i].name,\n                                           stats,\n                                           blockjobs,\n                                           nblockjobs);\n    }\n\n    ret = 0;\n\n cleanup:\n    for (i = 0; i < nblockjobs; i++)\n        qemuMonitorJobInfoFree(blockjobs[i]);\n    g_free(blockjobs);\n    return ret;\n}"
  },
  {
    "function_name": "qemuBackupGetJobInfoStatsUpdateOne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "1047-1083",
    "snippet": "static void\nqemuBackupGetJobInfoStatsUpdateOne(virDomainObjPtr vm,\n                                   bool push,\n                                   const char *diskdst,\n                                   qemuDomainBackupStats *stats,\n                                   qemuMonitorJobInfoPtr *blockjobs,\n                                   size_t nblockjobs)\n{\n    virDomainDiskDefPtr domdisk;\n    qemuMonitorJobInfoPtr monblockjob = NULL;\n    g_autoptr(qemuBlockJobData) diskblockjob = NULL;\n    size_t i;\n\n    /* it's just statistics so let's not worry so much about errors */\n    if (!(domdisk = virDomainDiskByTarget(vm->def, diskdst)))\n        return;\n\n    if (!(diskblockjob = qemuBlockJobDiskGetJob(domdisk)))\n        return;\n\n    for (i = 0; i < nblockjobs; i++) {\n        if (STREQ_NULLABLE(blockjobs[i]->id, diskblockjob->name)) {\n            monblockjob = blockjobs[i];\n            break;\n        }\n    }\n    if (!monblockjob)\n        return;\n\n    if (push) {\n        stats->total += monblockjob->progressTotal;\n        stats->transferred += monblockjob->progressCurrent;\n    } else {\n        stats->tmp_used += monblockjob->progressCurrent;\n        stats->tmp_total += monblockjob->progressTotal;\n    }\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "blockjobs[i]->id",
            "diskblockjob->name"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDiskGetJob",
          "args": [
            "domdisk"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDiskGetJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "422-431",
          "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDiskGetJob(virDomainDiskDefPtr disk)\n{\n    qemuBlockJobDataPtr job = QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob;\n\n    if (!job)\n        return NULL;\n\n    return virObjectRef(job);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockJobDataPtr\nqemuBlockJobDiskGetJob(virDomainDiskDefPtr disk)\n{\n    qemuBlockJobDataPtr job = QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob;\n\n    if (!job)\n        return NULL;\n\n    return virObjectRef(job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskByTarget",
          "args": [
            "vm->def",
            "diskdst"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskByTarget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17337-17349",
          "snippet": "virDomainDiskDefPtr\nvirDomainDiskByTarget(virDomainDefPtr def,\n                      const char *dst)\n{\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (STREQ(def->disks[i]->dst, dst))\n            return def->disks[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDiskDefPtr\nvirDomainDiskByTarget(virDomainDefPtr def,\n                      const char *dst)\n{\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (STREQ(def->disks[i]->dst, dst))\n            return def->disks[i];\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic void\nqemuBackupGetJobInfoStatsUpdateOne(virDomainObjPtr vm,\n                                   bool push,\n                                   const char *diskdst,\n                                   qemuDomainBackupStats *stats,\n                                   qemuMonitorJobInfoPtr *blockjobs,\n                                   size_t nblockjobs)\n{\n    virDomainDiskDefPtr domdisk;\n    qemuMonitorJobInfoPtr monblockjob = NULL;\n    g_autoptr(qemuBlockJobData) diskblockjob = NULL;\n    size_t i;\n\n    /* it's just statistics so let's not worry so much about errors */\n    if (!(domdisk = virDomainDiskByTarget(vm->def, diskdst)))\n        return;\n\n    if (!(diskblockjob = qemuBlockJobDiskGetJob(domdisk)))\n        return;\n\n    for (i = 0; i < nblockjobs; i++) {\n        if (STREQ_NULLABLE(blockjobs[i]->id, diskblockjob->name)) {\n            monblockjob = blockjobs[i];\n            break;\n        }\n    }\n    if (!monblockjob)\n        return;\n\n    if (push) {\n        stats->total += monblockjob->progressTotal;\n        stats->transferred += monblockjob->progressCurrent;\n    } else {\n        stats->tmp_used += monblockjob->progressCurrent;\n        stats->tmp_total += monblockjob->progressTotal;\n    }\n}"
  },
  {
    "function_name": "qemuBackupNotifyBlockjobEnd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "933-1044",
    "snippet": "void\nqemuBackupNotifyBlockjobEnd(virDomainObjPtr vm,\n                            virDomainDiskDefPtr disk,\n                            qemuBlockjobState state,\n                            unsigned long long cur,\n                            unsigned long long end,\n                            int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool has_running = false;\n    bool has_cancelling = false;\n    bool has_cancelled = false;\n    bool has_failed = false;\n    qemuDomainJobStatus jobstatus = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n    virDomainBackupDefPtr backup = priv->backup;\n    size_t i;\n\n    VIR_DEBUG(\"vm: '%s', disk:'%s', state:'%d'\",\n              vm->def->name, disk->dst, state);\n\n    if (!backup)\n        return;\n\n    if (backup->type == VIR_DOMAIN_BACKUP_TYPE_PULL) {\n        if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n            return;\n        ignore_value(qemuMonitorNBDServerStop(priv->mon));\n        if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n            return;\n\n        /* update the final statistics with the current job's data */\n        backup->pull_tmp_used += cur;\n        backup->pull_tmp_total += end;\n    } else {\n        backup->push_transferred += cur;\n        backup->push_total += end;\n    }\n\n    for (i = 0; i < backup->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = backup->disks + i;\n\n        if (!backupdisk->store)\n            continue;\n\n        if (STREQ(disk->dst, backupdisk->name)) {\n            switch (state) {\n            case QEMU_BLOCKJOB_STATE_COMPLETED:\n                backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_COMPLETE;\n                break;\n\n            case QEMU_BLOCKJOB_STATE_CONCLUDED:\n            case QEMU_BLOCKJOB_STATE_FAILED:\n                backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_FAILED;\n                break;\n\n            case QEMU_BLOCKJOB_STATE_CANCELLED:\n                backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLED;\n                break;\n\n            case QEMU_BLOCKJOB_STATE_READY:\n            case QEMU_BLOCKJOB_STATE_NEW:\n            case QEMU_BLOCKJOB_STATE_RUNNING:\n            case QEMU_BLOCKJOB_STATE_ABORTING:\n            case QEMU_BLOCKJOB_STATE_PIVOTING:\n            case QEMU_BLOCKJOB_STATE_LAST:\n            default:\n                break;\n            }\n        }\n\n        switch (backupdisk->state) {\n        case VIR_DOMAIN_BACKUP_DISK_STATE_COMPLETE:\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING:\n            has_running = true;\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLING:\n            has_cancelling = true;\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_FAILED:\n            has_failed = true;\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLED:\n            has_cancelled = true;\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_NONE:\n        case VIR_DOMAIN_BACKUP_DISK_STATE_LAST:\n            break;\n        }\n    }\n\n    if (has_running && (has_failed || has_cancelled)) {\n        /* cancel the rest of the jobs */\n        qemuBackupJobCancelBlockjobs(vm, backup, false, asyncJob);\n    } else if (!has_running && !has_cancelling) {\n        /* all sub-jobs have stopped */\n\n        if (has_failed)\n            jobstatus = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        else if (has_cancelled && backup->type == VIR_DOMAIN_BACKUP_TYPE_PUSH)\n            jobstatus = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n\n        qemuBackupJobTerminate(vm, jobstatus);\n    }\n\n    /* otherwise we must wait for the jobs to end */\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuBackupJobTerminate",
          "args": [
            "vm",
            "jobstatus"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupJobTerminate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "616-665",
          "snippet": "void\nqemuBackupJobTerminate(virDomainObjPtr vm,\n                       qemuDomainJobStatus jobstatus)\n\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n\n    qemuDomainJobInfoUpdateTime(priv->job.current);\n\n    g_free(priv->job.completed);\n    priv->job.completed = g_new0(qemuDomainJobInfo, 1);\n    *priv->job.completed = *priv->job.current;\n\n    priv->job.completed->stats.backup.total = priv->backup->push_total;\n    priv->job.completed->stats.backup.transferred = priv->backup->push_transferred;\n    priv->job.completed->stats.backup.tmp_used = priv->backup->pull_tmp_used;\n    priv->job.completed->stats.backup.tmp_total = priv->backup->pull_tmp_total;\n\n    priv->job.completed->status = jobstatus;\n\n    qemuDomainEventEmitJobCompleted(priv->driver, vm);\n\n    if (!(priv->job.apiFlags & VIR_DOMAIN_BACKUP_BEGIN_REUSE_EXTERNAL) &&\n        (priv->backup->type == VIR_DOMAIN_BACKUP_TYPE_PULL ||\n         (priv->backup->type == VIR_DOMAIN_BACKUP_TYPE_PUSH &&\n          jobstatus != QEMU_DOMAIN_JOB_STATUS_COMPLETED))) {\n\n        g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(priv->driver);\n\n        for (i = 0; i < priv->backup->ndisks; i++) {\n            virDomainBackupDiskDefPtr backupdisk = priv->backup->disks + i;\n            uid_t uid;\n            gid_t gid;\n\n            if (!backupdisk->store ||\n                backupdisk->store->type != VIR_STORAGE_TYPE_FILE)\n                continue;\n\n            qemuDomainGetImageIds(cfg, vm, backupdisk->store, NULL, &uid, &gid);\n            if (virFileRemove(backupdisk->store->path, uid, gid) < 0)\n                VIR_WARN(\"failed to remove scratch file '%s'\",\n                         backupdisk->store->path);\n        }\n    }\n\n    virDomainBackupDefFree(priv->backup);\n    priv->backup = NULL;\n    qemuDomainObjEndAsyncJob(priv->driver, vm);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvoid\nqemuBackupJobTerminate(virDomainObjPtr vm,\n                       qemuDomainJobStatus jobstatus)\n\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n\n    qemuDomainJobInfoUpdateTime(priv->job.current);\n\n    g_free(priv->job.completed);\n    priv->job.completed = g_new0(qemuDomainJobInfo, 1);\n    *priv->job.completed = *priv->job.current;\n\n    priv->job.completed->stats.backup.total = priv->backup->push_total;\n    priv->job.completed->stats.backup.transferred = priv->backup->push_transferred;\n    priv->job.completed->stats.backup.tmp_used = priv->backup->pull_tmp_used;\n    priv->job.completed->stats.backup.tmp_total = priv->backup->pull_tmp_total;\n\n    priv->job.completed->status = jobstatus;\n\n    qemuDomainEventEmitJobCompleted(priv->driver, vm);\n\n    if (!(priv->job.apiFlags & VIR_DOMAIN_BACKUP_BEGIN_REUSE_EXTERNAL) &&\n        (priv->backup->type == VIR_DOMAIN_BACKUP_TYPE_PULL ||\n         (priv->backup->type == VIR_DOMAIN_BACKUP_TYPE_PUSH &&\n          jobstatus != QEMU_DOMAIN_JOB_STATUS_COMPLETED))) {\n\n        g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(priv->driver);\n\n        for (i = 0; i < priv->backup->ndisks; i++) {\n            virDomainBackupDiskDefPtr backupdisk = priv->backup->disks + i;\n            uid_t uid;\n            gid_t gid;\n\n            if (!backupdisk->store ||\n                backupdisk->store->type != VIR_STORAGE_TYPE_FILE)\n                continue;\n\n            qemuDomainGetImageIds(cfg, vm, backupdisk->store, NULL, &uid, &gid);\n            if (virFileRemove(backupdisk->store->path, uid, gid) < 0)\n                VIR_WARN(\"failed to remove scratch file '%s'\",\n                         backupdisk->store->path);\n        }\n    }\n\n    virDomainBackupDefFree(priv->backup);\n    priv->backup = NULL;\n    qemuDomainObjEndAsyncJob(priv->driver, vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBackupJobCancelBlockjobs",
          "args": [
            "vm",
            "backup",
            "false",
            "asyncJob"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupJobCancelBlockjobs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "679-733",
          "snippet": "void\nqemuBackupJobCancelBlockjobs(virDomainObjPtr vm,\n                             virDomainBackupDefPtr backup,\n                             bool terminatebackup,\n                             int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n    int rc = 0;\n    bool has_active = false;\n\n    if (!backup)\n        return;\n\n    for (i = 0; i < backup->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = backup->disks + i;\n        virDomainDiskDefPtr disk;\n        g_autoptr(qemuBlockJobData) job = NULL;\n\n        if (!backupdisk->store)\n            continue;\n\n        /* Look up corresponding disk as backupdisk->idx is no longer reliable */\n        if (!(disk = virDomainDiskByTarget(vm->def, backupdisk->name)))\n            continue;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)))\n            continue;\n\n        if (backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING &&\n            backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLING)\n            continue;\n\n        has_active = true;\n\n        if (backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING)\n            continue;\n\n        if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n            return;\n\n        rc = qemuMonitorJobCancel(priv->mon, job->name, false);\n\n        if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n            return;\n\n        if (rc == 0) {\n            backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLING;\n            job->state = QEMU_BLOCKJOB_STATE_ABORTING;\n        }\n    }\n\n    if (terminatebackup && !has_active)\n        qemuBackupJobTerminate(vm, QEMU_DOMAIN_JOB_STATUS_CANCELED);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvoid\nqemuBackupJobCancelBlockjobs(virDomainObjPtr vm,\n                             virDomainBackupDefPtr backup,\n                             bool terminatebackup,\n                             int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n    int rc = 0;\n    bool has_active = false;\n\n    if (!backup)\n        return;\n\n    for (i = 0; i < backup->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = backup->disks + i;\n        virDomainDiskDefPtr disk;\n        g_autoptr(qemuBlockJobData) job = NULL;\n\n        if (!backupdisk->store)\n            continue;\n\n        /* Look up corresponding disk as backupdisk->idx is no longer reliable */\n        if (!(disk = virDomainDiskByTarget(vm->def, backupdisk->name)))\n            continue;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)))\n            continue;\n\n        if (backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING &&\n            backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLING)\n            continue;\n\n        has_active = true;\n\n        if (backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING)\n            continue;\n\n        if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n            return;\n\n        rc = qemuMonitorJobCancel(priv->mon, job->name, false);\n\n        if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n            return;\n\n        if (rc == 0) {\n            backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLING;\n            job->state = QEMU_BLOCKJOB_STATE_ABORTING;\n        }\n    }\n\n    if (terminatebackup && !has_active)\n        qemuBackupJobTerminate(vm, QEMU_DOMAIN_JOB_STATUS_CANCELED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "disk->dst",
            "backupdisk->name"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "priv->driver",
            "vm"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuMonitorNBDServerStop(priv->mon)"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorNBDServerStop",
          "args": [
            "priv->mon"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorNBDServerStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3878-3884",
          "snippet": "int\nqemuMonitorNBDServerStop(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerStop(mon);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorNBDServerStop(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerStop(mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "priv->driver",
            "vm",
            "asyncJob"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"vm: '%s', disk:'%s', state:'%d'\"",
            "vm->def->name",
            "disk->dst",
            "state"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvoid\nqemuBackupNotifyBlockjobEnd(virDomainObjPtr vm,\n                            virDomainDiskDefPtr disk,\n                            qemuBlockjobState state,\n                            unsigned long long cur,\n                            unsigned long long end,\n                            int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool has_running = false;\n    bool has_cancelling = false;\n    bool has_cancelled = false;\n    bool has_failed = false;\n    qemuDomainJobStatus jobstatus = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n    virDomainBackupDefPtr backup = priv->backup;\n    size_t i;\n\n    VIR_DEBUG(\"vm: '%s', disk:'%s', state:'%d'\",\n              vm->def->name, disk->dst, state);\n\n    if (!backup)\n        return;\n\n    if (backup->type == VIR_DOMAIN_BACKUP_TYPE_PULL) {\n        if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n            return;\n        ignore_value(qemuMonitorNBDServerStop(priv->mon));\n        if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n            return;\n\n        /* update the final statistics with the current job's data */\n        backup->pull_tmp_used += cur;\n        backup->pull_tmp_total += end;\n    } else {\n        backup->push_transferred += cur;\n        backup->push_total += end;\n    }\n\n    for (i = 0; i < backup->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = backup->disks + i;\n\n        if (!backupdisk->store)\n            continue;\n\n        if (STREQ(disk->dst, backupdisk->name)) {\n            switch (state) {\n            case QEMU_BLOCKJOB_STATE_COMPLETED:\n                backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_COMPLETE;\n                break;\n\n            case QEMU_BLOCKJOB_STATE_CONCLUDED:\n            case QEMU_BLOCKJOB_STATE_FAILED:\n                backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_FAILED;\n                break;\n\n            case QEMU_BLOCKJOB_STATE_CANCELLED:\n                backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLED;\n                break;\n\n            case QEMU_BLOCKJOB_STATE_READY:\n            case QEMU_BLOCKJOB_STATE_NEW:\n            case QEMU_BLOCKJOB_STATE_RUNNING:\n            case QEMU_BLOCKJOB_STATE_ABORTING:\n            case QEMU_BLOCKJOB_STATE_PIVOTING:\n            case QEMU_BLOCKJOB_STATE_LAST:\n            default:\n                break;\n            }\n        }\n\n        switch (backupdisk->state) {\n        case VIR_DOMAIN_BACKUP_DISK_STATE_COMPLETE:\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING:\n            has_running = true;\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLING:\n            has_cancelling = true;\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_FAILED:\n            has_failed = true;\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLED:\n            has_cancelled = true;\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_NONE:\n        case VIR_DOMAIN_BACKUP_DISK_STATE_LAST:\n            break;\n        }\n    }\n\n    if (has_running && (has_failed || has_cancelled)) {\n        /* cancel the rest of the jobs */\n        qemuBackupJobCancelBlockjobs(vm, backup, false, asyncJob);\n    } else if (!has_running && !has_cancelling) {\n        /* all sub-jobs have stopped */\n\n        if (has_failed)\n            jobstatus = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        else if (has_cancelled && backup->type == VIR_DOMAIN_BACKUP_TYPE_PUSH)\n            jobstatus = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n\n        qemuBackupJobTerminate(vm, jobstatus);\n    }\n\n    /* otherwise we must wait for the jobs to end */\n}"
  },
  {
    "function_name": "qemuBackupGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "914-930",
    "snippet": "char *\nqemuBackupGetXMLDesc(virDomainObjPtr vm,\n                     unsigned int flags)\n{\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    virDomainBackupDefPtr backup;\n\n    virCheckFlags(0, NULL);\n\n    if (!(backup = qemuDomainGetBackup(vm)))\n        return NULL;\n\n    if (virDomainBackupDefFormat(&buf, backup, false) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainBackupDefFormat",
          "args": [
            "&buf",
            "backup",
            "false"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainBackupDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
          "lines": "360-397",
          "snippet": "int\nvirDomainBackupDefFormat(virBufferPtr buf,\n                         virDomainBackupDefPtr def,\n                         bool internal)\n{\n    g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n    g_auto(virBuffer) childBuf = VIR_BUFFER_INIT_CHILD(buf);\n    g_auto(virBuffer) serverAttrBuf = VIR_BUFFER_INITIALIZER;\n    g_auto(virBuffer) disksChildBuf = VIR_BUFFER_INIT_CHILD(&childBuf);\n    size_t i;\n\n    virBufferAsprintf(&attrBuf, \" mode='%s'\", virDomainBackupTypeToString(def->type));\n\n    virBufferEscapeString(&childBuf, \"<incremental>%s</incremental>\\n\", def->incremental);\n\n    if (def->server) {\n        virBufferAsprintf(&serverAttrBuf, \" transport='%s'\",\n                          virStorageNetHostTransportTypeToString(def->server->transport));\n        virBufferEscapeString(&serverAttrBuf, \" name='%s'\", def->server->name);\n        if (def->server->port)\n            virBufferAsprintf(&serverAttrBuf, \" port='%u'\", def->server->port);\n        virBufferEscapeString(&serverAttrBuf, \" socket='%s'\", def->server->socket);\n    }\n\n    virXMLFormatElement(&childBuf, \"server\", &serverAttrBuf, NULL);\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (virDomainBackupDiskDefFormat(&disksChildBuf, &def->disks[i],\n                                         def->type == VIR_DOMAIN_BACKUP_TYPE_PUSH,\n                                         internal) < 0)\n            return -1;\n    }\n\n    virXMLFormatElement(&childBuf, \"disks\", NULL, &disksChildBuf);\n    virXMLFormatElement(buf, \"domainbackup\", &attrBuf, &childBuf);\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virhash.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"backup_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nint\nvirDomainBackupDefFormat(virBufferPtr buf,\n                         virDomainBackupDefPtr def,\n                         bool internal)\n{\n    g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n    g_auto(virBuffer) childBuf = VIR_BUFFER_INIT_CHILD(buf);\n    g_auto(virBuffer) serverAttrBuf = VIR_BUFFER_INITIALIZER;\n    g_auto(virBuffer) disksChildBuf = VIR_BUFFER_INIT_CHILD(&childBuf);\n    size_t i;\n\n    virBufferAsprintf(&attrBuf, \" mode='%s'\", virDomainBackupTypeToString(def->type));\n\n    virBufferEscapeString(&childBuf, \"<incremental>%s</incremental>\\n\", def->incremental);\n\n    if (def->server) {\n        virBufferAsprintf(&serverAttrBuf, \" transport='%s'\",\n                          virStorageNetHostTransportTypeToString(def->server->transport));\n        virBufferEscapeString(&serverAttrBuf, \" name='%s'\", def->server->name);\n        if (def->server->port)\n            virBufferAsprintf(&serverAttrBuf, \" port='%u'\", def->server->port);\n        virBufferEscapeString(&serverAttrBuf, \" socket='%s'\", def->server->socket);\n    }\n\n    virXMLFormatElement(&childBuf, \"server\", &serverAttrBuf, NULL);\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (virDomainBackupDiskDefFormat(&disksChildBuf, &def->disks[i],\n                                         def->type == VIR_DOMAIN_BACKUP_TYPE_PUSH,\n                                         internal) < 0)\n            return -1;\n    }\n\n    virXMLFormatElement(&childBuf, \"disks\", NULL, &disksChildBuf);\n    virXMLFormatElement(buf, \"domainbackup\", &attrBuf, &childBuf);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainGetBackup",
          "args": [
            "vm"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainGetBackup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "46-58",
          "snippet": "static virDomainBackupDefPtr\nqemuDomainGetBackup(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!priv->backup) {\n        virReportError(VIR_ERR_NO_DOMAIN_BACKUP, \"%s\",\n                       _(\"no domain backup job present\"));\n        return NULL;\n    }\n\n    return priv->backup;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic virDomainBackupDefPtr\nqemuDomainGetBackup(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!priv->backup) {\n        virReportError(VIR_ERR_NO_DOMAIN_BACKUP, \"%s\",\n                       _(\"no domain backup job present\"));\n        return NULL;\n    }\n\n    return priv->backup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nchar *\nqemuBackupGetXMLDesc(virDomainObjPtr vm,\n                     unsigned int flags)\n{\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    virDomainBackupDefPtr backup;\n\n    virCheckFlags(0, NULL);\n\n    if (!(backup = qemuDomainGetBackup(vm)))\n        return NULL;\n\n    if (virDomainBackupDefFormat(&buf, backup, false) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
  },
  {
    "function_name": "qemuBackupBegin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "736-911",
    "snippet": "int\nqemuBackupBegin(virDomainObjPtr vm,\n                const char *backupXML,\n                const char *checkpointXML,\n                unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(priv->driver);\n    g_autoptr(virDomainBackupDef) def = NULL;\n    g_autofree char *suffix = NULL;\n    bool pull = false;\n    virDomainMomentObjPtr chk = NULL;\n    g_autoptr(virDomainCheckpointDef) chkdef = NULL;\n    g_autofree virDomainMomentDefPtr *incremental = NULL;\n    g_autoptr(virJSONValue) actions = NULL;\n    struct qemuBackupDiskData *dd = NULL;\n    ssize_t ndd = 0;\n    g_autoptr(virHashTable) blockNamedNodeData = NULL;\n    bool job_started = false;\n    bool nbd_running = false;\n    bool reuse = (flags & VIR_DOMAIN_BACKUP_BEGIN_REUSE_EXTERNAL);\n    int rc = 0;\n    int ret = -1;\n\n    virCheckFlags(VIR_DOMAIN_BACKUP_BEGIN_REUSE_EXTERNAL, -1);\n\n    if (!(def = virDomainBackupDefParseString(backupXML, priv->driver->xmlopt, 0)))\n        return -1;\n\n    if (checkpointXML) {\n        if (!(chkdef = virDomainCheckpointDefParseString(checkpointXML,\n                                                         priv->driver->xmlopt,\n                                                         priv->qemuCaps, 0)))\n            return -1;\n\n        suffix = g_strdup(chkdef->parent.name);\n    } else {\n        gint64 now_us = g_get_real_time();\n        suffix = g_strdup_printf(\"%lld\", (long long)now_us/(1000*1000));\n    }\n\n    if (def->type == VIR_DOMAIN_BACKUP_TYPE_PULL)\n        pull = true;\n\n    /* we'll treat this kind of backup job as an asyncjob as it uses some of the\n     * infrastructure for async jobs. We'll allow standard modify-type jobs\n     * as the interlocking of conflicting operations is handled on the block\n     * job level */\n    if (qemuDomainObjBeginAsyncJob(priv->driver, vm, QEMU_ASYNC_JOB_BACKUP,\n                                   VIR_DOMAIN_JOB_OPERATION_BACKUP, flags) < 0)\n        return -1;\n\n    qemuDomainObjSetAsyncJobMask(vm, (QEMU_JOB_DEFAULT_MASK |\n                                      JOB_MASK(QEMU_JOB_SUSPEND) |\n                                      JOB_MASK(QEMU_JOB_MODIFY)));\n    priv->job.current->statsType = QEMU_DOMAIN_JOB_STATS_TYPE_BACKUP;\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"cannot perform disk backup for inactive domain\"));\n        goto endjob;\n    }\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_INCREMENTAL_BACKUP)) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"incremental backup is not supported yet\"));\n        goto endjob;\n    }\n\n    if (priv->backup) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"another backup job is already running\"));\n        goto endjob;\n    }\n\n    if (qemuBackupPrepare(def) < 0)\n        goto endjob;\n\n    if (virDomainBackupAlignDisks(def, vm->def, suffix) < 0)\n        goto endjob;\n\n    if (def->incremental &&\n        !(incremental = qemuBackupBeginCollectIncrementalCheckpoints(vm, def->incremental)))\n        goto endjob;\n\n    actions = virJSONValueNewArray();\n\n    /* The 'chk' checkpoint must be rolled back if the transaction command\n     * which creates it on disk is not executed or fails */\n    if (chkdef) {\n        if (qemuCheckpointCreateCommon(priv->driver, vm, &chkdef,\n                                       &actions, &chk) < 0)\n            goto endjob;\n    }\n\n    if (!(blockNamedNodeData = qemuBlockGetNamedNodeData(vm, QEMU_ASYNC_JOB_BACKUP)))\n        goto endjob;\n\n    if ((ndd = qemuBackupDiskPrepareData(vm, def, incremental, blockNamedNodeData,\n                                         actions, cfg, &dd)) <= 0) {\n        if (ndd == 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"no disks selected for backup\"));\n        }\n\n        goto endjob;\n    }\n\n    if (qemuBackupDiskPrepareStorage(vm, dd, ndd, blockNamedNodeData, reuse) < 0)\n        goto endjob;\n\n    priv->backup = g_steal_pointer(&def);\n\n    if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, QEMU_ASYNC_JOB_BACKUP) < 0)\n        goto endjob;\n\n    /* TODO: TLS is a must-have for the modern age */\n    if (pull) {\n        if ((rc = qemuMonitorNBDServerStart(priv->mon, priv->backup->server, NULL)) == 0)\n            nbd_running = true;\n    }\n\n    if (rc == 0)\n        rc = qemuMonitorTransaction(priv->mon, &actions);\n\n    if (qemuDomainObjExitMonitor(priv->driver, vm) < 0 || rc < 0)\n        goto endjob;\n\n    job_started = true;\n    qemuBackupDiskStarted(vm, dd, ndd);\n\n    if (chk) {\n        virDomainMomentObjPtr tmpchk = g_steal_pointer(&chk);\n        if (qemuCheckpointCreateFinalize(priv->driver, vm, cfg, tmpchk, true) < 0)\n            goto endjob;\n    }\n\n    if (pull) {\n        if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, QEMU_ASYNC_JOB_BACKUP) < 0)\n            goto endjob;\n        /* note that if the export fails we've already created the checkpoint\n         * and we will not delete it */\n        rc = qemuBackupBeginPullExportDisks(vm, dd, ndd);\n        if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n            goto endjob;\n\n        if (rc < 0) {\n            qemuBackupJobCancelBlockjobs(vm, priv->backup, false, QEMU_ASYNC_JOB_BACKUP);\n            goto endjob;\n        }\n    }\n\n    ret = 0;\n\n endjob:\n    qemuBackupDiskDataCleanup(vm, dd, ndd);\n\n    /* if 'chk' is non-NULL here it's a failure and it must be rolled back */\n    qemuCheckpointRollbackMetadata(vm, chk);\n\n    if (!job_started && nbd_running &&\n        qemuDomainObjEnterMonitorAsync(priv->driver, vm, QEMU_ASYNC_JOB_BACKUP) < 0) {\n        ignore_value(qemuMonitorNBDServerStop(priv->mon));\n        ignore_value(qemuDomainObjExitMonitor(priv->driver, vm));\n    }\n\n    if (ret < 0 && !job_started)\n        def = g_steal_pointer(&priv->backup);\n\n    if (ret == 0)\n        qemuDomainObjReleaseAsyncJob(vm);\n    else\n        qemuDomainObjEndAsyncJob(priv->driver, vm);\n\n    return ret;\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainObjEndAsyncJob",
          "args": [
            "priv->driver",
            "vm"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEndAsyncJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10072-10086",
          "snippet": "void\nqemuDomainObjEndAsyncJob(virQEMUDriverPtr driver, virDomainObjPtr obj)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    priv->jobs_queued--;\n\n    VIR_DEBUG(\"Stopping async job: %s (vm=%p name=%s)\",\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n              obj, obj->def->name);\n\n    qemuDomainObjResetAsyncJob(priv);\n    qemuDomainObjSaveStatus(driver, obj);\n    virCondBroadcast(&priv->job.asyncCond);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));",
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\nobj, obj->def->name);\n\nvoid\nqemuDomainObjEndAsyncJob(virQEMUDriverPtr driver, virDomainObjPtr obj)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    priv->jobs_queued--;\n\n    VIR_DEBUG(\"Stopping async job: %s (vm=%p name=%s)\",\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n              obj, obj->def->name);\n\n    qemuDomainObjResetAsyncJob(priv);\n    qemuDomainObjSaveStatus(driver, obj);\n    virCondBroadcast(&priv->job.asyncCond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjReleaseAsyncJob",
          "args": [
            "vm"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjReleaseAsyncJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "9647-9661",
          "snippet": "void\nqemuDomainObjReleaseAsyncJob(virDomainObjPtr obj)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    VIR_DEBUG(\"Releasing ownership of '%s' async job\",\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\n    if (priv->job.asyncOwner != virThreadSelfID()) {\n        VIR_WARN(\"'%s' async job is owned by thread %llu\",\n                 qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n                 priv->job.asyncOwner);\n    }\n    priv->job.asyncOwner = 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nvoid\nqemuDomainObjReleaseAsyncJob(virDomainObjPtr obj)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    VIR_DEBUG(\"Releasing ownership of '%s' async job\",\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\n    if (priv->job.asyncOwner != virThreadSelfID()) {\n        VIR_WARN(\"'%s' async job is owned by thread %llu\",\n                 qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n                 priv->job.asyncOwner);\n    }\n    priv->job.asyncOwner = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&priv->backup"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuDomainObjExitMonitor(priv->driver, vm)"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "priv->driver",
            "vm"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuMonitorNBDServerStop(priv->mon)"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorNBDServerStop",
          "args": [
            "priv->mon"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorNBDServerStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3878-3884",
          "snippet": "int\nqemuMonitorNBDServerStop(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerStop(mon);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorNBDServerStop(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerStop(mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "priv->driver",
            "vm",
            "QEMU_ASYNC_JOB_BACKUP"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuCheckpointRollbackMetadata",
          "args": [
            "vm",
            "chk"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "qemuCheckpointRollbackMetadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_checkpoint.c",
          "lines": "565-573",
          "snippet": "void\nqemuCheckpointRollbackMetadata(virDomainObjPtr vm,\n                               virDomainMomentObjPtr chk)\n{\n    if (!chk)\n        return;\n\n    virDomainCheckpointObjListRemove(vm->checkpoints, chk);\n}",
          "includes": [
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomainsnapshotobjlist.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"domain_conf.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_block.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_checkpoint.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nqemuCheckpointRollbackMetadata(virDomainObjPtr vm,\n                               virDomainMomentObjPtr chk)\n{\n    if (!chk)\n        return;\n\n    virDomainCheckpointObjListRemove(vm->checkpoints, chk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBackupDiskDataCleanup",
          "args": [
            "vm",
            "dd",
            "ndd"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupDiskDataCleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "152-170",
          "snippet": "static void\nqemuBackupDiskDataCleanup(virDomainObjPtr vm,\n                          struct qemuBackupDiskData *dd,\n                          size_t ndd)\n{\n    virErrorPtr orig_err;\n    size_t i;\n\n    if (!dd)\n        return;\n\n    virErrorPreserveLast(&orig_err);\n\n    for (i = 0; i < ndd; i++)\n        qemuBackupDiskDataCleanupOne(vm, dd + i);\n\n    g_free(dd);\n    virErrorRestore(&orig_err);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic void\nqemuBackupDiskDataCleanup(virDomainObjPtr vm,\n                          struct qemuBackupDiskData *dd,\n                          size_t ndd)\n{\n    virErrorPtr orig_err;\n    size_t i;\n\n    if (!dd)\n        return;\n\n    virErrorPreserveLast(&orig_err);\n\n    for (i = 0; i < ndd; i++)\n        qemuBackupDiskDataCleanupOne(vm, dd + i);\n\n    g_free(dd);\n    virErrorRestore(&orig_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBackupJobCancelBlockjobs",
          "args": [
            "vm",
            "priv->backup",
            "false",
            "QEMU_ASYNC_JOB_BACKUP"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupJobCancelBlockjobs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "679-733",
          "snippet": "void\nqemuBackupJobCancelBlockjobs(virDomainObjPtr vm,\n                             virDomainBackupDefPtr backup,\n                             bool terminatebackup,\n                             int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n    int rc = 0;\n    bool has_active = false;\n\n    if (!backup)\n        return;\n\n    for (i = 0; i < backup->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = backup->disks + i;\n        virDomainDiskDefPtr disk;\n        g_autoptr(qemuBlockJobData) job = NULL;\n\n        if (!backupdisk->store)\n            continue;\n\n        /* Look up corresponding disk as backupdisk->idx is no longer reliable */\n        if (!(disk = virDomainDiskByTarget(vm->def, backupdisk->name)))\n            continue;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)))\n            continue;\n\n        if (backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING &&\n            backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLING)\n            continue;\n\n        has_active = true;\n\n        if (backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING)\n            continue;\n\n        if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n            return;\n\n        rc = qemuMonitorJobCancel(priv->mon, job->name, false);\n\n        if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n            return;\n\n        if (rc == 0) {\n            backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLING;\n            job->state = QEMU_BLOCKJOB_STATE_ABORTING;\n        }\n    }\n\n    if (terminatebackup && !has_active)\n        qemuBackupJobTerminate(vm, QEMU_DOMAIN_JOB_STATUS_CANCELED);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvoid\nqemuBackupJobCancelBlockjobs(virDomainObjPtr vm,\n                             virDomainBackupDefPtr backup,\n                             bool terminatebackup,\n                             int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n    int rc = 0;\n    bool has_active = false;\n\n    if (!backup)\n        return;\n\n    for (i = 0; i < backup->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = backup->disks + i;\n        virDomainDiskDefPtr disk;\n        g_autoptr(qemuBlockJobData) job = NULL;\n\n        if (!backupdisk->store)\n            continue;\n\n        /* Look up corresponding disk as backupdisk->idx is no longer reliable */\n        if (!(disk = virDomainDiskByTarget(vm->def, backupdisk->name)))\n            continue;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)))\n            continue;\n\n        if (backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING &&\n            backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLING)\n            continue;\n\n        has_active = true;\n\n        if (backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING)\n            continue;\n\n        if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n            return;\n\n        rc = qemuMonitorJobCancel(priv->mon, job->name, false);\n\n        if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n            return;\n\n        if (rc == 0) {\n            backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLING;\n            job->state = QEMU_BLOCKJOB_STATE_ABORTING;\n        }\n    }\n\n    if (terminatebackup && !has_active)\n        qemuBackupJobTerminate(vm, QEMU_DOMAIN_JOB_STATUS_CANCELED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBackupBeginPullExportDisks",
          "args": [
            "vm",
            "dd",
            "ndd"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupBeginPullExportDisks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "546-569",
          "snippet": "static int\nqemuBackupBeginPullExportDisks(virDomainObjPtr vm,\n                               struct qemuBackupDiskData *disks,\n                               size_t ndisks)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n\n    for (i = 0; i < ndisks; i++) {\n        struct qemuBackupDiskData *dd = disks + i;\n\n        if (!dd->backupdisk->exportname)\n            dd->backupdisk->exportname = g_strdup(dd->domdisk->dst);\n\n        if (qemuMonitorNBDServerAdd(priv->mon,\n                                    dd->store->nodeformat,\n                                    dd->backupdisk->exportname,\n                                    false,\n                                    dd->incrementalBitmap) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic int\nqemuBackupBeginPullExportDisks(virDomainObjPtr vm,\n                               struct qemuBackupDiskData *disks,\n                               size_t ndisks)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n\n    for (i = 0; i < ndisks; i++) {\n        struct qemuBackupDiskData *dd = disks + i;\n\n        if (!dd->backupdisk->exportname)\n            dd->backupdisk->exportname = g_strdup(dd->domdisk->dst);\n\n        if (qemuMonitorNBDServerAdd(priv->mon,\n                                    dd->store->nodeformat,\n                                    dd->backupdisk->exportname,\n                                    false,\n                                    dd->incrementalBitmap) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuCheckpointCreateFinalize",
          "args": [
            "priv->driver",
            "vm",
            "cfg",
            "tmpchk",
            "true"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "qemuCheckpointCreateFinalize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_checkpoint.c",
          "lines": "599-624",
          "snippet": "int\nqemuCheckpointCreateFinalize(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             virQEMUDriverConfigPtr cfg,\n                             virDomainMomentObjPtr chk,\n                             bool update_current)\n{\n    if (update_current)\n        virDomainCheckpointSetCurrent(vm->checkpoints, chk);\n\n    if (qemuCheckpointWriteMetadata(vm, chk,\n                                    driver->xmlopt,\n                                    cfg->checkpointDir) < 0) {\n        /* if writing of metadata fails, error out rather than trying\n         * to silently carry on without completing the checkpoint */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to save metadata for checkpoint %s\"),\n                       chk->def->name);\n        qemuCheckpointRollbackMetadata(vm, chk);\n        return -1;\n    }\n\n    virDomainCheckpointLinkParent(vm->checkpoints, chk);\n\n    return 0;\n}",
          "includes": [
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomainsnapshotobjlist.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"domain_conf.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_block.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_checkpoint.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nqemuCheckpointCreateFinalize(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             virQEMUDriverConfigPtr cfg,\n                             virDomainMomentObjPtr chk,\n                             bool update_current)\n{\n    if (update_current)\n        virDomainCheckpointSetCurrent(vm->checkpoints, chk);\n\n    if (qemuCheckpointWriteMetadata(vm, chk,\n                                    driver->xmlopt,\n                                    cfg->checkpointDir) < 0) {\n        /* if writing of metadata fails, error out rather than trying\n         * to silently carry on without completing the checkpoint */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to save metadata for checkpoint %s\"),\n                       chk->def->name);\n        qemuCheckpointRollbackMetadata(vm, chk);\n        return -1;\n    }\n\n    virDomainCheckpointLinkParent(vm->checkpoints, chk);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&chk"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuBackupDiskStarted",
          "args": [
            "vm",
            "dd",
            "ndd"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupDiskStarted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "522-534",
          "snippet": "static void\nqemuBackupDiskStarted(virDomainObjPtr vm,\n                      struct qemuBackupDiskData *dd,\n                      size_t ndd)\n{\n    size_t i;\n\n    for (i = 0; i < ndd; i++) {\n        dd[i].started = true;\n        dd[i].backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING;\n        qemuBlockJobStarted(dd->blockjob, vm);\n    }\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic void\nqemuBackupDiskStarted(virDomainObjPtr vm,\n                      struct qemuBackupDiskData *dd,\n                      size_t ndd)\n{\n    size_t i;\n\n    for (i = 0; i < ndd; i++) {\n        dd[i].started = true;\n        dd[i].backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING;\n        qemuBlockJobStarted(dd->blockjob, vm);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorTransaction",
          "args": [
            "priv->mon",
            "&actions"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3073-3081",
          "snippet": "int\nqemuMonitorTransaction(qemuMonitorPtr mon, virJSONValuePtr *actions)\n{\n    VIR_DEBUG(\"actions=%p\", *actions);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONTransaction(mon, actions);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransaction(qemuMonitorPtr mon, virJSONValuePtr *actions)\n{\n    VIR_DEBUG(\"actions=%p\", *actions);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONTransaction(mon, actions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorNBDServerStart",
          "args": [
            "priv->mon",
            "priv->backup->server",
            "NULL"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorNBDServerStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3842-3858",
          "snippet": "int\nqemuMonitorNBDServerStart(qemuMonitorPtr mon,\n                          const virStorageNetHostDef *server,\n                          const char *tls_alias)\n{\n    /* Peek inside the struct for nicer logging */\n    if (server->transport == VIR_STORAGE_NET_HOST_TRANS_TCP)\n        VIR_DEBUG(\"server={tcp host=%s port=%u} tls_alias=%s\",\n                  NULLSTR(server->name), server->port, NULLSTR(tls_alias));\n    else\n        VIR_DEBUG(\"server={unix socket=%s} tls_alias=%s\",\n                  NULLSTR(server->socket), NULLSTR(tls_alias));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerStart(mon, server, tls_alias);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorNBDServerStart(qemuMonitorPtr mon,\n                          const virStorageNetHostDef *server,\n                          const char *tls_alias)\n{\n    /* Peek inside the struct for nicer logging */\n    if (server->transport == VIR_STORAGE_NET_HOST_TRANS_TCP)\n        VIR_DEBUG(\"server={tcp host=%s port=%u} tls_alias=%s\",\n                  NULLSTR(server->name), server->port, NULLSTR(tls_alias));\n    else\n        VIR_DEBUG(\"server={unix socket=%s} tls_alias=%s\",\n                  NULLSTR(server->socket), NULLSTR(tls_alias));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerStart(mon, server, tls_alias);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&def"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuBackupDiskPrepareStorage",
          "args": [
            "vm",
            "dd",
            "ndd",
            "blockNamedNodeData",
            "reuse"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupDiskPrepareStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "503-519",
          "snippet": "static int\nqemuBackupDiskPrepareStorage(virDomainObjPtr vm,\n                             struct qemuBackupDiskData *disks,\n                             size_t ndisks,\n                             virHashTablePtr blockNamedNodeData,\n                             bool reuse_external)\n{\n    size_t i;\n\n    for (i = 0; i < ndisks; i++) {\n        if (qemuBackupDiskPrepareOneStorage(vm, blockNamedNodeData, disks + i,\n                                            reuse_external) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic int\nqemuBackupDiskPrepareStorage(virDomainObjPtr vm,\n                             struct qemuBackupDiskData *disks,\n                             size_t ndisks,\n                             virHashTablePtr blockNamedNodeData,\n                             bool reuse_external)\n{\n    size_t i;\n\n    for (i = 0; i < ndisks; i++) {\n        if (qemuBackupDiskPrepareOneStorage(vm, blockNamedNodeData, disks + i,\n                                            reuse_external) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"no disks selected for backup\")"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no disks selected for backup\""
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBackupDiskPrepareData",
          "args": [
            "vm",
            "def",
            "incremental",
            "blockNamedNodeData",
            "actions",
            "cfg",
            "&dd"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupDiskPrepareData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "389-434",
          "snippet": "static ssize_t\nqemuBackupDiskPrepareData(virDomainObjPtr vm,\n                          virDomainBackupDefPtr def,\n                          virDomainMomentDefPtr *incremental,\n                          virHashTablePtr blockNamedNodeData,\n                          virJSONValuePtr actions,\n                          virQEMUDriverConfigPtr cfg,\n                          struct qemuBackupDiskData **rdd)\n{\n    struct qemuBackupDiskData *disks = NULL;\n    ssize_t ndisks = 0;\n    size_t i;\n\n    disks = g_new0(struct qemuBackupDiskData, def->ndisks);\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainBackupDiskDef *backupdisk = &def->disks[i];\n        struct qemuBackupDiskData *dd = disks + ndisks;\n\n        if (!backupdisk->store)\n            continue;\n\n        ndisks++;\n\n        if (qemuBackupDiskPrepareDataOne(vm, backupdisk, dd, actions,\n                                         incremental, blockNamedNodeData,\n                                         cfg) < 0)\n            goto error;\n\n        if (def->type == VIR_DOMAIN_BACKUP_TYPE_PULL) {\n            if (qemuBackupDiskPrepareDataOnePull(actions, dd) < 0)\n                goto error;\n        } else {\n            if (qemuBackupDiskPrepareDataOnePush(actions, dd) < 0)\n                goto error;\n        }\n    }\n\n    *rdd = g_steal_pointer(&disks);\n\n    return ndisks;\n\n error:\n    qemuBackupDiskDataCleanup(vm, disks, ndisks);\n    return -1;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic ssize_t\nqemuBackupDiskPrepareData(virDomainObjPtr vm,\n                          virDomainBackupDefPtr def,\n                          virDomainMomentDefPtr *incremental,\n                          virHashTablePtr blockNamedNodeData,\n                          virJSONValuePtr actions,\n                          virQEMUDriverConfigPtr cfg,\n                          struct qemuBackupDiskData **rdd)\n{\n    struct qemuBackupDiskData *disks = NULL;\n    ssize_t ndisks = 0;\n    size_t i;\n\n    disks = g_new0(struct qemuBackupDiskData, def->ndisks);\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainBackupDiskDef *backupdisk = &def->disks[i];\n        struct qemuBackupDiskData *dd = disks + ndisks;\n\n        if (!backupdisk->store)\n            continue;\n\n        ndisks++;\n\n        if (qemuBackupDiskPrepareDataOne(vm, backupdisk, dd, actions,\n                                         incremental, blockNamedNodeData,\n                                         cfg) < 0)\n            goto error;\n\n        if (def->type == VIR_DOMAIN_BACKUP_TYPE_PULL) {\n            if (qemuBackupDiskPrepareDataOnePull(actions, dd) < 0)\n                goto error;\n        } else {\n            if (qemuBackupDiskPrepareDataOnePush(actions, dd) < 0)\n                goto error;\n        }\n    }\n\n    *rdd = g_steal_pointer(&disks);\n\n    return ndisks;\n\n error:\n    qemuBackupDiskDataCleanup(vm, disks, ndisks);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockGetNamedNodeData",
          "args": [
            "vm",
            "QEMU_ASYNC_JOB_BACKUP"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockGetNamedNodeData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "2805-2824",
          "snippet": "virHashTablePtr\nqemuBlockGetNamedNodeData(virDomainObjPtr vm,\n                          qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virQEMUDriverPtr driver = priv->driver;\n    g_autoptr(virHashTable) blockNamedNodeData = NULL;\n    bool supports_flat = virQEMUCapsGet(priv->qemuCaps,\n                                        QEMU_CAPS_QMP_QUERY_NAMED_BLOCK_NODES_FLAT);\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return NULL;\n\n    blockNamedNodeData = qemuMonitorBlockGetNamedNodeData(priv->mon, supports_flat);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || !blockNamedNodeData)\n        return NULL;\n\n    return g_steal_pointer(&blockNamedNodeData);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvirHashTablePtr\nqemuBlockGetNamedNodeData(virDomainObjPtr vm,\n                          qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virQEMUDriverPtr driver = priv->driver;\n    g_autoptr(virHashTable) blockNamedNodeData = NULL;\n    bool supports_flat = virQEMUCapsGet(priv->qemuCaps,\n                                        QEMU_CAPS_QMP_QUERY_NAMED_BLOCK_NODES_FLAT);\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return NULL;\n\n    blockNamedNodeData = qemuMonitorBlockGetNamedNodeData(priv->mon, supports_flat);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || !blockNamedNodeData)\n        return NULL;\n\n    return g_steal_pointer(&blockNamedNodeData);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuCheckpointCreateCommon",
          "args": [
            "priv->driver",
            "vm",
            "&chkdef",
            "&actions",
            "&chk"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "qemuCheckpointCreateCommon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_checkpoint.c",
          "lines": "527-555",
          "snippet": "int\nqemuCheckpointCreateCommon(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           virDomainCheckpointDefPtr *def,\n                           virJSONValuePtr *actions,\n                           virDomainMomentObjPtr *chk)\n{\n    g_autoptr(virJSONValue) tmpactions = NULL;\n    virDomainMomentObjPtr parent;\n\n    if (qemuCheckpointPrepare(driver, vm, *def) < 0)\n        return -1;\n\n    if ((parent = virDomainCheckpointGetCurrent(vm->checkpoints)))\n        (*def)->parent.parent_name = g_strdup(parent->def->name);\n\n    tmpactions = virJSONValueNewArray();\n\n    if (qemuCheckpointAddActions(vm, tmpactions, parent, *def) < 0)\n        return -1;\n\n    if (!(*chk = virDomainCheckpointAssignDef(vm->checkpoints, *def)))\n        return -1;\n\n    *def = NULL;\n\n    *actions = g_steal_pointer(&tmpactions);\n    return 0;\n}",
          "includes": [
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomainsnapshotobjlist.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"domain_conf.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_block.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_checkpoint.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nqemuCheckpointCreateCommon(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           virDomainCheckpointDefPtr *def,\n                           virJSONValuePtr *actions,\n                           virDomainMomentObjPtr *chk)\n{\n    g_autoptr(virJSONValue) tmpactions = NULL;\n    virDomainMomentObjPtr parent;\n\n    if (qemuCheckpointPrepare(driver, vm, *def) < 0)\n        return -1;\n\n    if ((parent = virDomainCheckpointGetCurrent(vm->checkpoints)))\n        (*def)->parent.parent_name = g_strdup(parent->def->name);\n\n    tmpactions = virJSONValueNewArray();\n\n    if (qemuCheckpointAddActions(vm, tmpactions, parent, *def) < 0)\n        return -1;\n\n    if (!(*chk = virDomainCheckpointAssignDef(vm->checkpoints, *def)))\n        return -1;\n\n    *def = NULL;\n\n    *actions = g_steal_pointer(&tmpactions);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueNewArray",
          "args": [],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "560-568",
          "snippet": "virJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBackupBeginCollectIncrementalCheckpoints",
          "args": [
            "vm",
            "def->incremental"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupBeginCollectIncrementalCheckpoints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "581-613",
          "snippet": "static virDomainMomentDefPtr *\nqemuBackupBeginCollectIncrementalCheckpoints(virDomainObjPtr vm,\n                                             const char *incrFrom)\n{\n    virDomainMomentObjPtr n = virDomainCheckpointGetCurrent(vm->checkpoints);\n    g_autofree virDomainMomentDefPtr *incr = NULL;\n    size_t nincr = 0;\n\n    while (n) {\n        virDomainMomentDefPtr def = n->def;\n\n        if (VIR_APPEND_ELEMENT_COPY(incr, nincr, def) < 0)\n            return NULL;\n\n        if (STREQ(def->name, incrFrom)) {\n            def = NULL;\n            if (VIR_APPEND_ELEMENT_COPY(incr, nincr, def) < 0)\n                return NULL;\n\n            return g_steal_pointer(&incr);\n        }\n\n        if (!n->def->parent_name)\n            break;\n\n        n = virDomainCheckpointFindByName(vm->checkpoints, n->def->parent_name);\n    }\n\n    virReportError(VIR_ERR_OPERATION_INVALID,\n                   _(\"could not locate checkpoint '%s' for incremental backup\"),\n                   incrFrom);\n    return NULL;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic virDomainMomentDefPtr *\nqemuBackupBeginCollectIncrementalCheckpoints(virDomainObjPtr vm,\n                                             const char *incrFrom)\n{\n    virDomainMomentObjPtr n = virDomainCheckpointGetCurrent(vm->checkpoints);\n    g_autofree virDomainMomentDefPtr *incr = NULL;\n    size_t nincr = 0;\n\n    while (n) {\n        virDomainMomentDefPtr def = n->def;\n\n        if (VIR_APPEND_ELEMENT_COPY(incr, nincr, def) < 0)\n            return NULL;\n\n        if (STREQ(def->name, incrFrom)) {\n            def = NULL;\n            if (VIR_APPEND_ELEMENT_COPY(incr, nincr, def) < 0)\n                return NULL;\n\n            return g_steal_pointer(&incr);\n        }\n\n        if (!n->def->parent_name)\n            break;\n\n        n = virDomainCheckpointFindByName(vm->checkpoints, n->def->parent_name);\n    }\n\n    virReportError(VIR_ERR_OPERATION_INVALID,\n                   _(\"could not locate checkpoint '%s' for incremental backup\"),\n                   incrFrom);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainBackupAlignDisks",
          "args": [
            "def",
            "vm->def",
            "suffix"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainBackupAlignDisks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
          "lines": "437-507",
          "snippet": "int\nvirDomainBackupAlignDisks(virDomainBackupDefPtr def,\n                          virDomainDefPtr dom,\n                          const char *suffix)\n{\n    g_autoptr(virHashTable) disks = virHashNew(NULL);\n    size_t i;\n    int ndisks;\n    bool backup_all = false;\n\n    /* Unlikely to have a guest without disks but technically possible.  */\n    if (!dom->ndisks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"domain must have at least one disk to perform backup\"));\n        return -1;\n    }\n\n    /* Double check requested disks.  */\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = &def->disks[i];\n        virDomainDiskDefPtr domdisk;\n\n        if (!(domdisk = virDomainDiskByTarget(dom, backupdisk->name))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"no disk named '%s'\"), backupdisk->name);\n            return -1;\n        }\n\n        if (virHashAddEntry(disks, backupdisk->name, NULL) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"disk '%s' specified twice\"),\n                           backupdisk->name);\n            return -1;\n        }\n\n        if (backupdisk->backup == VIR_TRISTATE_BOOL_YES &&\n            virDomainBackupDefAssignStore(backupdisk, domdisk->src, suffix) < 0)\n            return -1;\n    }\n\n    if (def->ndisks == 0)\n        backup_all = true;\n\n    ndisks = def->ndisks;\n    if (VIR_EXPAND_N(def->disks, def->ndisks, dom->ndisks - def->ndisks) < 0)\n        return -1;\n\n    for (i = 0; i < dom->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = NULL;\n        virDomainDiskDefPtr domdisk =  dom->disks[i];\n\n        if (virHashHasEntry(disks, domdisk->dst))\n            continue;\n\n        backupdisk = &def->disks[ndisks++];\n        backupdisk->name = g_strdup(domdisk->dst);\n\n        if (backup_all &&\n            !virStorageSourceIsEmpty(domdisk->src) &&\n            !domdisk->src->readonly) {\n            backupdisk->backup = VIR_TRISTATE_BOOL_YES;\n\n            if (virDomainBackupDefAssignStore(backupdisk, domdisk->src, suffix) < 0)\n                return -1;\n        } else {\n            backupdisk->backup = VIR_TRISTATE_BOOL_NO;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virhash.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"backup_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nint\nvirDomainBackupAlignDisks(virDomainBackupDefPtr def,\n                          virDomainDefPtr dom,\n                          const char *suffix)\n{\n    g_autoptr(virHashTable) disks = virHashNew(NULL);\n    size_t i;\n    int ndisks;\n    bool backup_all = false;\n\n    /* Unlikely to have a guest without disks but technically possible.  */\n    if (!dom->ndisks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"domain must have at least one disk to perform backup\"));\n        return -1;\n    }\n\n    /* Double check requested disks.  */\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = &def->disks[i];\n        virDomainDiskDefPtr domdisk;\n\n        if (!(domdisk = virDomainDiskByTarget(dom, backupdisk->name))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"no disk named '%s'\"), backupdisk->name);\n            return -1;\n        }\n\n        if (virHashAddEntry(disks, backupdisk->name, NULL) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"disk '%s' specified twice\"),\n                           backupdisk->name);\n            return -1;\n        }\n\n        if (backupdisk->backup == VIR_TRISTATE_BOOL_YES &&\n            virDomainBackupDefAssignStore(backupdisk, domdisk->src, suffix) < 0)\n            return -1;\n    }\n\n    if (def->ndisks == 0)\n        backup_all = true;\n\n    ndisks = def->ndisks;\n    if (VIR_EXPAND_N(def->disks, def->ndisks, dom->ndisks - def->ndisks) < 0)\n        return -1;\n\n    for (i = 0; i < dom->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = NULL;\n        virDomainDiskDefPtr domdisk =  dom->disks[i];\n\n        if (virHashHasEntry(disks, domdisk->dst))\n            continue;\n\n        backupdisk = &def->disks[ndisks++];\n        backupdisk->name = g_strdup(domdisk->dst);\n\n        if (backup_all &&\n            !virStorageSourceIsEmpty(domdisk->src) &&\n            !domdisk->src->readonly) {\n            backupdisk->backup = VIR_TRISTATE_BOOL_YES;\n\n            if (virDomainBackupDefAssignStore(backupdisk, domdisk->src, suffix) < 0)\n                return -1;\n        } else {\n            backupdisk->backup = VIR_TRISTATE_BOOL_NO;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBackupPrepare",
          "args": [
            "def"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupPrepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "61-100",
          "snippet": "static int\nqemuBackupPrepare(virDomainBackupDefPtr def)\n{\n\n    if (def->type == VIR_DOMAIN_BACKUP_TYPE_PULL) {\n        if (!def->server) {\n            def->server = g_new(virStorageNetHostDef, 1);\n\n            def->server->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n            def->server->name = g_strdup(\"localhost\");\n        }\n\n        switch ((virStorageNetHostTransport) def->server->transport) {\n        case VIR_STORAGE_NET_HOST_TRANS_TCP:\n            /* TODO: Update qemu.conf to provide a port range,\n             * probably starting at 10809, for obtaining automatic\n             * port via virPortAllocatorAcquire, as well as store\n             * somewhere if we need to call virPortAllocatorRelease\n             * during BackupEnd. Until then, user must provide port */\n            if (!def->server->port) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"<domainbackup> must specify TCP port for now\"));\n                return -1;\n            }\n            break;\n\n        case VIR_STORAGE_NET_HOST_TRANS_UNIX:\n            /* TODO: Do we need to mess with selinux? */\n            break;\n\n        case VIR_STORAGE_NET_HOST_TRANS_RDMA:\n        case VIR_STORAGE_NET_HOST_TRANS_LAST:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"unexpected transport in <domainbackup>\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic int\nqemuBackupPrepare(virDomainBackupDefPtr def)\n{\n\n    if (def->type == VIR_DOMAIN_BACKUP_TYPE_PULL) {\n        if (!def->server) {\n            def->server = g_new(virStorageNetHostDef, 1);\n\n            def->server->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n            def->server->name = g_strdup(\"localhost\");\n        }\n\n        switch ((virStorageNetHostTransport) def->server->transport) {\n        case VIR_STORAGE_NET_HOST_TRANS_TCP:\n            /* TODO: Update qemu.conf to provide a port range,\n             * probably starting at 10809, for obtaining automatic\n             * port via virPortAllocatorAcquire, as well as store\n             * somewhere if we need to call virPortAllocatorRelease\n             * during BackupEnd. Until then, user must provide port */\n            if (!def->server->port) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"<domainbackup> must specify TCP port for now\"));\n                return -1;\n            }\n            break;\n\n        case VIR_STORAGE_NET_HOST_TRANS_UNIX:\n            /* TODO: Do we need to mess with selinux? */\n            break;\n\n        case VIR_STORAGE_NET_HOST_TRANS_RDMA:\n        case VIR_STORAGE_NET_HOST_TRANS_LAST:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"unexpected transport in <domainbackup>\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"another backup job is already running\")"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"incremental backup is not supported yet\")"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "priv->qemuCaps",
            "QEMU_CAPS_INCREMENTAL_BACKUP"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"cannot perform disk backup for inactive domain\")"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjIsActive",
          "args": [
            "vm"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.h",
          "lines": "2845-2849",
          "snippet": "static inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virresctrl.h\"",
            "#include \"virsavecookie.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virperf.h\"",
            "#include \"virgic.h\"",
            "#include \"virprocess.h\"",
            "#include \"virseclabel.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virbitmap.h\"",
            "#include \"device_conf.h\"",
            "#include \"virobject.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"numa_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virthread.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"capabilities.h\"",
            "#include \"virconftypes.h\"",
            "#include \"internal.h\"",
            "#include <libxml/xpath.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parser.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void virDomainMemoryDefFree(virDomainMemoryDefPtr def);",
            "void virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);",
            "unsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);",
            "unsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);",
            "bool virDomainDefHasMemoryHotplug(const virDomainDef *def);",
            "int virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);",
            "bool virDomainDefHasUSB(const virDomainDef *def);",
            "int virDomainObjCheckActive(virDomainObjPtr dom);",
            "bool virDomainDefHasVcpusOffline(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpusMax(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpus(const virDomainDef *def);",
            "virBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);",
            "void virDomainDefVcpuOrderClear(virDomainDefPtr def);",
            "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);",
            "void virDomainInputDefFree(virDomainInputDefPtr def);",
            "void virDomainDiskDefFree(virDomainDiskDefPtr def);",
            "void virDomainLeaseDefFree(virDomainLeaseDefPtr def);",
            "int virDomainDiskGetType(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetSource(virDomainDiskDef const *def);",
            "void virDomainDiskEmptySource(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetDriver(const virDomainDiskDef *def);",
            "int virDomainDiskGetFormat(virDomainDiskDefPtr def);",
            "void virDomainControllerDefFree(virDomainControllerDefPtr def);",
            "void virDomainFSDefFree(virDomainFSDefPtr def);",
            "void virDomainActualNetDefFree(virDomainActualNetDefPtr def);",
            "void virDomainNetDefClear(virDomainNetDefPtr def);",
            "void virDomainNetDefFree(virDomainNetDefPtr def);",
            "void virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);",
            "void virDomainChrDefFree(virDomainChrDefPtr def);",
            "void virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);",
            "void virDomainSoundDefFree(virDomainSoundDefPtr def);",
            "void virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);",
            "void virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);",
            "void virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);",
            "void virDomainVideoDefFree(virDomainVideoDefPtr def);",
            "void virDomainVideoDefClear(virDomainVideoDefPtr def);",
            "void virDomainHostdevDefClear(virDomainHostdevDefPtr def);",
            "void virDomainHostdevDefFree(virDomainHostdevDefPtr def);",
            "void virDomainHubDefFree(virDomainHubDefPtr def);",
            "void virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);",
            "void virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);",
            "void virDomainShmemDefFree(virDomainShmemDefPtr def);",
            "void virDomainDeviceDefFree(virDomainDeviceDefPtr def);",
            "void virDomainTPMDefFree(virDomainTPMDefPtr def);",
            "void virDomainRNGDefFree(virDomainRNGDefPtr def);",
            "int virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);",
            "int virDomainVideoDefaultType(const virDomainDef *def);",
            "void virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);",
            "int virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);",
            "bool\nvirDomainDefHasManagedPR(const virDomainDef *def);",
            "bool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);",
            "bool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);",
            "bool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virresctrl.h\"\n#include \"virsavecookie.h\"\n#include \"virtypedparam.h\"\n#include \"virperf.h\"\n#include \"virgic.h\"\n#include \"virprocess.h\"\n#include \"virseclabel.h\"\n#include \"virstoragefile.h\"\n#include \"virbitmap.h\"\n#include \"device_conf.h\"\n#include \"virobject.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevvlan.h\"\n#include \"virnetdevbandwidth.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virsysinfo.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"numa_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"networkcommon_conf.h\"\n#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virthread.h\"\n#include \"cpu_conf.h\"\n#include \"virstorageencryption.h\"\n#include \"capabilities.h\"\n#include \"virconftypes.h\"\n#include \"internal.h\"\n#include <libxml/xpath.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n\nvoid virDomainMemoryDefFree(virDomainMemoryDefPtr def);\nvoid virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);\nunsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);\nunsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);\nbool virDomainDefHasMemoryHotplug(const virDomainDef *def);\nint virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);\nbool virDomainDefHasUSB(const virDomainDef *def);\nint virDomainObjCheckActive(virDomainObjPtr dom);\nbool virDomainDefHasVcpusOffline(const virDomainDef *def);\nunsigned int virDomainDefGetVcpusMax(const virDomainDef *def);\nunsigned int virDomainDefGetVcpus(const virDomainDef *def);\nvirBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);\nvoid virDomainDefVcpuOrderClear(virDomainDefPtr def);\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);\nvoid virDomainInputDefFree(virDomainInputDefPtr def);\nvoid virDomainDiskDefFree(virDomainDiskDefPtr def);\nvoid virDomainLeaseDefFree(virDomainLeaseDefPtr def);\nint virDomainDiskGetType(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetSource(virDomainDiskDef const *def);\nvoid virDomainDiskEmptySource(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetDriver(const virDomainDiskDef *def);\nint virDomainDiskGetFormat(virDomainDiskDefPtr def);\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def);\nvoid virDomainFSDefFree(virDomainFSDefPtr def);\nvoid virDomainActualNetDefFree(virDomainActualNetDefPtr def);\nvoid virDomainNetDefClear(virDomainNetDefPtr def);\nvoid virDomainNetDefFree(virDomainNetDefPtr def);\nvoid virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);\nvoid virDomainChrDefFree(virDomainChrDefPtr def);\nvoid virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def);\nvoid virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);\nvoid virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);\nvoid virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def);\nvoid virDomainVideoDefClear(virDomainVideoDefPtr def);\nvoid virDomainHostdevDefClear(virDomainHostdevDefPtr def);\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def);\nvoid virDomainHubDefFree(virDomainHubDefPtr def);\nvoid virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);\nvoid virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);\nvoid virDomainShmemDefFree(virDomainShmemDefPtr def);\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def);\nvoid virDomainTPMDefFree(virDomainTPMDefPtr def);\nvoid virDomainRNGDefFree(virDomainRNGDefPtr def);\nint virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);\nint virDomainVideoDefaultType(const virDomainDef *def);\nvoid virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);\nint virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);\nbool\nvirDomainDefHasManagedPR(const virDomainDef *def);\nbool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);\nbool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);\nbool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);\n\nstatic inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjSetAsyncJobMask",
          "args": [
            "vm",
            "(QEMU_JOB_DEFAULT_MASK |\n                                      JOB_MASK(QEMU_JOB_SUSPEND) |\n                                      JOB_MASK(QEMU_JOB_MODIFY))"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjSetAsyncJobMask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "9624-9634",
          "snippet": "void\nqemuDomainObjSetAsyncJobMask(virDomainObjPtr obj,\n                             unsigned long long allowedJobs)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    if (!priv->job.asyncJob)\n        return;\n\n    priv->job.mask = allowedJobs | JOB_MASK(QEMU_JOB_DESTROY);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nvoid\nqemuDomainObjSetAsyncJobMask(virDomainObjPtr obj,\n                             unsigned long long allowedJobs)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    if (!priv->job.asyncJob)\n        return;\n\n    priv->job.mask = allowedJobs | JOB_MASK(QEMU_JOB_DESTROY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JOB_MASK",
          "args": [
            "QEMU_JOB_MODIFY"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JOB_MASK",
          "args": [
            "QEMU_JOB_SUSPEND"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainObjBeginAsyncJob",
          "args": [
            "priv->driver",
            "vm",
            "QEMU_ASYNC_JOB_BACKUP",
            "VIR_DOMAIN_JOB_OPERATION_BACKUP",
            "flags"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjBeginAsyncJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "9958-9975",
          "snippet": "int qemuDomainObjBeginAsyncJob(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob,\n                               virDomainJobOperation operation,\n                               unsigned long apiFlags)\n{\n    qemuDomainObjPrivatePtr priv;\n\n    if (qemuDomainObjBeginJobInternal(driver, obj, QEMU_JOB_ASYNC,\n                                      QEMU_AGENT_JOB_NONE,\n                                      asyncJob, false) < 0)\n        return -1;\n\n    priv = obj->privateData;\n    priv->job.current->operation = operation;\n    priv->job.apiFlags = apiFlags;\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint qemuDomainObjBeginAsyncJob(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob,\n                               virDomainJobOperation operation,\n                               unsigned long apiFlags)\n{\n    qemuDomainObjPrivatePtr priv;\n\n    if (qemuDomainObjBeginJobInternal(driver, obj, QEMU_JOB_ASYNC,\n                                      QEMU_AGENT_JOB_NONE,\n                                      asyncJob, false) < 0)\n        return -1;\n\n    priv = obj->privateData;\n    priv->job.current->operation = operation;\n    priv->job.apiFlags = apiFlags;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%lld\"",
            "(long long)now_us/(1000*1000)"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_get_real_time",
          "args": [],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainCheckpointDefParseString",
          "args": [
            "checkpointXML",
            "priv->driver->xmlopt",
            "priv->qemuCaps",
            "0"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCheckpointDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/checkpoint_conf.c",
          "lines": "229-248",
          "snippet": "virDomainCheckpointDefPtr\nvirDomainCheckpointDefParseString(const char *xmlStr,\n                                  virDomainXMLOptionPtr xmlopt,\n                                  void *parseOpaque,\n                                  unsigned int flags)\n{\n    virDomainCheckpointDefPtr ret = NULL;\n    xmlDocPtr xml;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_checkpoint)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainCheckpointDefParseNode(xml, xmlDocGetRootElement(xml),\n                                              xmlopt, parseOpaque, flags);\n        xmlFreeDoc(xml);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"checkpoint_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nvirDomainCheckpointDefPtr\nvirDomainCheckpointDefParseString(const char *xmlStr,\n                                  virDomainXMLOptionPtr xmlopt,\n                                  void *parseOpaque,\n                                  unsigned int flags)\n{\n    virDomainCheckpointDefPtr ret = NULL;\n    xmlDocPtr xml;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_checkpoint)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainCheckpointDefParseNode(xml, xmlDocGetRootElement(xml),\n                                              xmlopt, parseOpaque, flags);\n        xmlFreeDoc(xml);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainBackupDefParseString",
          "args": [
            "backupXML",
            "priv->driver->xmlopt",
            "0"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainBackupDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
          "lines": "266-283",
          "snippet": "virDomainBackupDefPtr\nvirDomainBackupDefParseString(const char *xmlStr,\n                              virDomainXMLOptionPtr xmlopt,\n                              unsigned int flags)\n{\n    virDomainBackupDefPtr ret = NULL;\n    g_autoptr(xmlDoc) xml = NULL;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_backup)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainBackupDefParseNode(xml, xmlDocGetRootElement(xml),\n                                          xmlopt, flags);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virhash.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"backup_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nvirDomainBackupDefPtr\nvirDomainBackupDefParseString(const char *xmlStr,\n                              virDomainXMLOptionPtr xmlopt,\n                              unsigned int flags)\n{\n    virDomainBackupDefPtr ret = NULL;\n    g_autoptr(xmlDoc) xml = NULL;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_backup)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainBackupDefParseNode(xml, xmlDocGetRootElement(xml),\n                                          xmlopt, flags);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_BACKUP_BEGIN_REUSE_EXTERNAL",
            "-1"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "priv->driver"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBackupBegin(virDomainObjPtr vm,\n                const char *backupXML,\n                const char *checkpointXML,\n                unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(priv->driver);\n    g_autoptr(virDomainBackupDef) def = NULL;\n    g_autofree char *suffix = NULL;\n    bool pull = false;\n    virDomainMomentObjPtr chk = NULL;\n    g_autoptr(virDomainCheckpointDef) chkdef = NULL;\n    g_autofree virDomainMomentDefPtr *incremental = NULL;\n    g_autoptr(virJSONValue) actions = NULL;\n    struct qemuBackupDiskData *dd = NULL;\n    ssize_t ndd = 0;\n    g_autoptr(virHashTable) blockNamedNodeData = NULL;\n    bool job_started = false;\n    bool nbd_running = false;\n    bool reuse = (flags & VIR_DOMAIN_BACKUP_BEGIN_REUSE_EXTERNAL);\n    int rc = 0;\n    int ret = -1;\n\n    virCheckFlags(VIR_DOMAIN_BACKUP_BEGIN_REUSE_EXTERNAL, -1);\n\n    if (!(def = virDomainBackupDefParseString(backupXML, priv->driver->xmlopt, 0)))\n        return -1;\n\n    if (checkpointXML) {\n        if (!(chkdef = virDomainCheckpointDefParseString(checkpointXML,\n                                                         priv->driver->xmlopt,\n                                                         priv->qemuCaps, 0)))\n            return -1;\n\n        suffix = g_strdup(chkdef->parent.name);\n    } else {\n        gint64 now_us = g_get_real_time();\n        suffix = g_strdup_printf(\"%lld\", (long long)now_us/(1000*1000));\n    }\n\n    if (def->type == VIR_DOMAIN_BACKUP_TYPE_PULL)\n        pull = true;\n\n    /* we'll treat this kind of backup job as an asyncjob as it uses some of the\n     * infrastructure for async jobs. We'll allow standard modify-type jobs\n     * as the interlocking of conflicting operations is handled on the block\n     * job level */\n    if (qemuDomainObjBeginAsyncJob(priv->driver, vm, QEMU_ASYNC_JOB_BACKUP,\n                                   VIR_DOMAIN_JOB_OPERATION_BACKUP, flags) < 0)\n        return -1;\n\n    qemuDomainObjSetAsyncJobMask(vm, (QEMU_JOB_DEFAULT_MASK |\n                                      JOB_MASK(QEMU_JOB_SUSPEND) |\n                                      JOB_MASK(QEMU_JOB_MODIFY)));\n    priv->job.current->statsType = QEMU_DOMAIN_JOB_STATS_TYPE_BACKUP;\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"cannot perform disk backup for inactive domain\"));\n        goto endjob;\n    }\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_INCREMENTAL_BACKUP)) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"incremental backup is not supported yet\"));\n        goto endjob;\n    }\n\n    if (priv->backup) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"another backup job is already running\"));\n        goto endjob;\n    }\n\n    if (qemuBackupPrepare(def) < 0)\n        goto endjob;\n\n    if (virDomainBackupAlignDisks(def, vm->def, suffix) < 0)\n        goto endjob;\n\n    if (def->incremental &&\n        !(incremental = qemuBackupBeginCollectIncrementalCheckpoints(vm, def->incremental)))\n        goto endjob;\n\n    actions = virJSONValueNewArray();\n\n    /* The 'chk' checkpoint must be rolled back if the transaction command\n     * which creates it on disk is not executed or fails */\n    if (chkdef) {\n        if (qemuCheckpointCreateCommon(priv->driver, vm, &chkdef,\n                                       &actions, &chk) < 0)\n            goto endjob;\n    }\n\n    if (!(blockNamedNodeData = qemuBlockGetNamedNodeData(vm, QEMU_ASYNC_JOB_BACKUP)))\n        goto endjob;\n\n    if ((ndd = qemuBackupDiskPrepareData(vm, def, incremental, blockNamedNodeData,\n                                         actions, cfg, &dd)) <= 0) {\n        if (ndd == 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"no disks selected for backup\"));\n        }\n\n        goto endjob;\n    }\n\n    if (qemuBackupDiskPrepareStorage(vm, dd, ndd, blockNamedNodeData, reuse) < 0)\n        goto endjob;\n\n    priv->backup = g_steal_pointer(&def);\n\n    if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, QEMU_ASYNC_JOB_BACKUP) < 0)\n        goto endjob;\n\n    /* TODO: TLS is a must-have for the modern age */\n    if (pull) {\n        if ((rc = qemuMonitorNBDServerStart(priv->mon, priv->backup->server, NULL)) == 0)\n            nbd_running = true;\n    }\n\n    if (rc == 0)\n        rc = qemuMonitorTransaction(priv->mon, &actions);\n\n    if (qemuDomainObjExitMonitor(priv->driver, vm) < 0 || rc < 0)\n        goto endjob;\n\n    job_started = true;\n    qemuBackupDiskStarted(vm, dd, ndd);\n\n    if (chk) {\n        virDomainMomentObjPtr tmpchk = g_steal_pointer(&chk);\n        if (qemuCheckpointCreateFinalize(priv->driver, vm, cfg, tmpchk, true) < 0)\n            goto endjob;\n    }\n\n    if (pull) {\n        if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, QEMU_ASYNC_JOB_BACKUP) < 0)\n            goto endjob;\n        /* note that if the export fails we've already created the checkpoint\n         * and we will not delete it */\n        rc = qemuBackupBeginPullExportDisks(vm, dd, ndd);\n        if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n            goto endjob;\n\n        if (rc < 0) {\n            qemuBackupJobCancelBlockjobs(vm, priv->backup, false, QEMU_ASYNC_JOB_BACKUP);\n            goto endjob;\n        }\n    }\n\n    ret = 0;\n\n endjob:\n    qemuBackupDiskDataCleanup(vm, dd, ndd);\n\n    /* if 'chk' is non-NULL here it's a failure and it must be rolled back */\n    qemuCheckpointRollbackMetadata(vm, chk);\n\n    if (!job_started && nbd_running &&\n        qemuDomainObjEnterMonitorAsync(priv->driver, vm, QEMU_ASYNC_JOB_BACKUP) < 0) {\n        ignore_value(qemuMonitorNBDServerStop(priv->mon));\n        ignore_value(qemuDomainObjExitMonitor(priv->driver, vm));\n    }\n\n    if (ret < 0 && !job_started)\n        def = g_steal_pointer(&priv->backup);\n\n    if (ret == 0)\n        qemuDomainObjReleaseAsyncJob(vm);\n    else\n        qemuDomainObjEndAsyncJob(priv->driver, vm);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuBackupJobCancelBlockjobs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "679-733",
    "snippet": "void\nqemuBackupJobCancelBlockjobs(virDomainObjPtr vm,\n                             virDomainBackupDefPtr backup,\n                             bool terminatebackup,\n                             int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n    int rc = 0;\n    bool has_active = false;\n\n    if (!backup)\n        return;\n\n    for (i = 0; i < backup->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = backup->disks + i;\n        virDomainDiskDefPtr disk;\n        g_autoptr(qemuBlockJobData) job = NULL;\n\n        if (!backupdisk->store)\n            continue;\n\n        /* Look up corresponding disk as backupdisk->idx is no longer reliable */\n        if (!(disk = virDomainDiskByTarget(vm->def, backupdisk->name)))\n            continue;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)))\n            continue;\n\n        if (backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING &&\n            backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLING)\n            continue;\n\n        has_active = true;\n\n        if (backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING)\n            continue;\n\n        if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n            return;\n\n        rc = qemuMonitorJobCancel(priv->mon, job->name, false);\n\n        if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n            return;\n\n        if (rc == 0) {\n            backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLING;\n            job->state = QEMU_BLOCKJOB_STATE_ABORTING;\n        }\n    }\n\n    if (terminatebackup && !has_active)\n        qemuBackupJobTerminate(vm, QEMU_DOMAIN_JOB_STATUS_CANCELED);\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuBackupJobTerminate",
          "args": [
            "vm",
            "QEMU_DOMAIN_JOB_STATUS_CANCELED"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupJobTerminate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "616-665",
          "snippet": "void\nqemuBackupJobTerminate(virDomainObjPtr vm,\n                       qemuDomainJobStatus jobstatus)\n\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n\n    qemuDomainJobInfoUpdateTime(priv->job.current);\n\n    g_free(priv->job.completed);\n    priv->job.completed = g_new0(qemuDomainJobInfo, 1);\n    *priv->job.completed = *priv->job.current;\n\n    priv->job.completed->stats.backup.total = priv->backup->push_total;\n    priv->job.completed->stats.backup.transferred = priv->backup->push_transferred;\n    priv->job.completed->stats.backup.tmp_used = priv->backup->pull_tmp_used;\n    priv->job.completed->stats.backup.tmp_total = priv->backup->pull_tmp_total;\n\n    priv->job.completed->status = jobstatus;\n\n    qemuDomainEventEmitJobCompleted(priv->driver, vm);\n\n    if (!(priv->job.apiFlags & VIR_DOMAIN_BACKUP_BEGIN_REUSE_EXTERNAL) &&\n        (priv->backup->type == VIR_DOMAIN_BACKUP_TYPE_PULL ||\n         (priv->backup->type == VIR_DOMAIN_BACKUP_TYPE_PUSH &&\n          jobstatus != QEMU_DOMAIN_JOB_STATUS_COMPLETED))) {\n\n        g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(priv->driver);\n\n        for (i = 0; i < priv->backup->ndisks; i++) {\n            virDomainBackupDiskDefPtr backupdisk = priv->backup->disks + i;\n            uid_t uid;\n            gid_t gid;\n\n            if (!backupdisk->store ||\n                backupdisk->store->type != VIR_STORAGE_TYPE_FILE)\n                continue;\n\n            qemuDomainGetImageIds(cfg, vm, backupdisk->store, NULL, &uid, &gid);\n            if (virFileRemove(backupdisk->store->path, uid, gid) < 0)\n                VIR_WARN(\"failed to remove scratch file '%s'\",\n                         backupdisk->store->path);\n        }\n    }\n\n    virDomainBackupDefFree(priv->backup);\n    priv->backup = NULL;\n    qemuDomainObjEndAsyncJob(priv->driver, vm);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvoid\nqemuBackupJobTerminate(virDomainObjPtr vm,\n                       qemuDomainJobStatus jobstatus)\n\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n\n    qemuDomainJobInfoUpdateTime(priv->job.current);\n\n    g_free(priv->job.completed);\n    priv->job.completed = g_new0(qemuDomainJobInfo, 1);\n    *priv->job.completed = *priv->job.current;\n\n    priv->job.completed->stats.backup.total = priv->backup->push_total;\n    priv->job.completed->stats.backup.transferred = priv->backup->push_transferred;\n    priv->job.completed->stats.backup.tmp_used = priv->backup->pull_tmp_used;\n    priv->job.completed->stats.backup.tmp_total = priv->backup->pull_tmp_total;\n\n    priv->job.completed->status = jobstatus;\n\n    qemuDomainEventEmitJobCompleted(priv->driver, vm);\n\n    if (!(priv->job.apiFlags & VIR_DOMAIN_BACKUP_BEGIN_REUSE_EXTERNAL) &&\n        (priv->backup->type == VIR_DOMAIN_BACKUP_TYPE_PULL ||\n         (priv->backup->type == VIR_DOMAIN_BACKUP_TYPE_PUSH &&\n          jobstatus != QEMU_DOMAIN_JOB_STATUS_COMPLETED))) {\n\n        g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(priv->driver);\n\n        for (i = 0; i < priv->backup->ndisks; i++) {\n            virDomainBackupDiskDefPtr backupdisk = priv->backup->disks + i;\n            uid_t uid;\n            gid_t gid;\n\n            if (!backupdisk->store ||\n                backupdisk->store->type != VIR_STORAGE_TYPE_FILE)\n                continue;\n\n            qemuDomainGetImageIds(cfg, vm, backupdisk->store, NULL, &uid, &gid);\n            if (virFileRemove(backupdisk->store->path, uid, gid) < 0)\n                VIR_WARN(\"failed to remove scratch file '%s'\",\n                         backupdisk->store->path);\n        }\n    }\n\n    virDomainBackupDefFree(priv->backup);\n    priv->backup = NULL;\n    qemuDomainObjEndAsyncJob(priv->driver, vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "priv->driver",
            "vm"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJobCancel",
          "args": [
            "priv->mon",
            "job->name",
            "false"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJobCancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3306-3316",
          "snippet": "int\nqemuMonitorJobCancel(qemuMonitorPtr mon,\n                     const char *jobname,\n                     bool quiet)\n{\n    VIR_DEBUG(\"jobname='%s' quiet=%d\", jobname, quiet);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONJobCancel(mon, jobname, quiet);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJobCancel(qemuMonitorPtr mon,\n                     const char *jobname,\n                     bool quiet)\n{\n    VIR_DEBUG(\"jobname='%s' quiet=%d\", jobname, quiet);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONJobCancel(mon, jobname, quiet);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "priv->driver",
            "vm",
            "asyncJob"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDiskGetJob",
          "args": [
            "disk"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDiskGetJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "422-431",
          "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDiskGetJob(virDomainDiskDefPtr disk)\n{\n    qemuBlockJobDataPtr job = QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob;\n\n    if (!job)\n        return NULL;\n\n    return virObjectRef(job);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockJobDataPtr\nqemuBlockJobDiskGetJob(virDomainDiskDefPtr disk)\n{\n    qemuBlockJobDataPtr job = QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob;\n\n    if (!job)\n        return NULL;\n\n    return virObjectRef(job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskByTarget",
          "args": [
            "vm->def",
            "backupdisk->name"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskByTarget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17337-17349",
          "snippet": "virDomainDiskDefPtr\nvirDomainDiskByTarget(virDomainDefPtr def,\n                      const char *dst)\n{\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (STREQ(def->disks[i]->dst, dst))\n            return def->disks[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDiskDefPtr\nvirDomainDiskByTarget(virDomainDefPtr def,\n                      const char *dst)\n{\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (STREQ(def->disks[i]->dst, dst))\n            return def->disks[i];\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvoid\nqemuBackupJobCancelBlockjobs(virDomainObjPtr vm,\n                             virDomainBackupDefPtr backup,\n                             bool terminatebackup,\n                             int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n    int rc = 0;\n    bool has_active = false;\n\n    if (!backup)\n        return;\n\n    for (i = 0; i < backup->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = backup->disks + i;\n        virDomainDiskDefPtr disk;\n        g_autoptr(qemuBlockJobData) job = NULL;\n\n        if (!backupdisk->store)\n            continue;\n\n        /* Look up corresponding disk as backupdisk->idx is no longer reliable */\n        if (!(disk = virDomainDiskByTarget(vm->def, backupdisk->name)))\n            continue;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)))\n            continue;\n\n        if (backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING &&\n            backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLING)\n            continue;\n\n        has_active = true;\n\n        if (backupdisk->state != VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING)\n            continue;\n\n        if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n            return;\n\n        rc = qemuMonitorJobCancel(priv->mon, job->name, false);\n\n        if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n            return;\n\n        if (rc == 0) {\n            backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLING;\n            job->state = QEMU_BLOCKJOB_STATE_ABORTING;\n        }\n    }\n\n    if (terminatebackup && !has_active)\n        qemuBackupJobTerminate(vm, QEMU_DOMAIN_JOB_STATUS_CANCELED);\n}"
  },
  {
    "function_name": "qemuBackupJobTerminate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "616-665",
    "snippet": "void\nqemuBackupJobTerminate(virDomainObjPtr vm,\n                       qemuDomainJobStatus jobstatus)\n\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n\n    qemuDomainJobInfoUpdateTime(priv->job.current);\n\n    g_free(priv->job.completed);\n    priv->job.completed = g_new0(qemuDomainJobInfo, 1);\n    *priv->job.completed = *priv->job.current;\n\n    priv->job.completed->stats.backup.total = priv->backup->push_total;\n    priv->job.completed->stats.backup.transferred = priv->backup->push_transferred;\n    priv->job.completed->stats.backup.tmp_used = priv->backup->pull_tmp_used;\n    priv->job.completed->stats.backup.tmp_total = priv->backup->pull_tmp_total;\n\n    priv->job.completed->status = jobstatus;\n\n    qemuDomainEventEmitJobCompleted(priv->driver, vm);\n\n    if (!(priv->job.apiFlags & VIR_DOMAIN_BACKUP_BEGIN_REUSE_EXTERNAL) &&\n        (priv->backup->type == VIR_DOMAIN_BACKUP_TYPE_PULL ||\n         (priv->backup->type == VIR_DOMAIN_BACKUP_TYPE_PUSH &&\n          jobstatus != QEMU_DOMAIN_JOB_STATUS_COMPLETED))) {\n\n        g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(priv->driver);\n\n        for (i = 0; i < priv->backup->ndisks; i++) {\n            virDomainBackupDiskDefPtr backupdisk = priv->backup->disks + i;\n            uid_t uid;\n            gid_t gid;\n\n            if (!backupdisk->store ||\n                backupdisk->store->type != VIR_STORAGE_TYPE_FILE)\n                continue;\n\n            qemuDomainGetImageIds(cfg, vm, backupdisk->store, NULL, &uid, &gid);\n            if (virFileRemove(backupdisk->store->path, uid, gid) < 0)\n                VIR_WARN(\"failed to remove scratch file '%s'\",\n                         backupdisk->store->path);\n        }\n    }\n\n    virDomainBackupDefFree(priv->backup);\n    priv->backup = NULL;\n    qemuDomainObjEndAsyncJob(priv->driver, vm);\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainObjEndAsyncJob",
          "args": [
            "priv->driver",
            "vm"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEndAsyncJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10072-10086",
          "snippet": "void\nqemuDomainObjEndAsyncJob(virQEMUDriverPtr driver, virDomainObjPtr obj)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    priv->jobs_queued--;\n\n    VIR_DEBUG(\"Stopping async job: %s (vm=%p name=%s)\",\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n              obj, obj->def->name);\n\n    qemuDomainObjResetAsyncJob(priv);\n    qemuDomainObjSaveStatus(driver, obj);\n    virCondBroadcast(&priv->job.asyncCond);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));",
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\nobj, obj->def->name);\n\nvoid\nqemuDomainObjEndAsyncJob(virQEMUDriverPtr driver, virDomainObjPtr obj)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    priv->jobs_queued--;\n\n    VIR_DEBUG(\"Stopping async job: %s (vm=%p name=%s)\",\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n              obj, obj->def->name);\n\n    qemuDomainObjResetAsyncJob(priv);\n    qemuDomainObjSaveStatus(driver, obj);\n    virCondBroadcast(&priv->job.asyncCond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainBackupDefFree",
          "args": [
            "priv->backup"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainBackupDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
          "lines": "59-81",
          "snippet": "void\nvirDomainBackupDefFree(virDomainBackupDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    g_free(def->incremental);\n    virStorageNetHostDefFree(1, def->server);\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainBackupDiskDefPtr disk = def->disks + i;\n\n        g_free(disk->name);\n        g_free(disk->exportname);\n        g_free(disk->exportbitmap);\n        virObjectUnref(disk->store);\n    }\n\n    g_free(def->disks);\n    g_free(def);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virhash.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"backup_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nvoid\nvirDomainBackupDefFree(virDomainBackupDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    g_free(def->incremental);\n    virStorageNetHostDefFree(1, def->server);\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainBackupDiskDefPtr disk = def->disks + i;\n\n        g_free(disk->name);\n        g_free(disk->exportname);\n        g_free(disk->exportbitmap);\n        virObjectUnref(disk->store);\n    }\n\n    g_free(def->disks);\n    g_free(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"failed to remove scratch file '%s'\"",
            "backupdisk->store->path"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileRemove",
          "args": [
            "backupdisk->store->path",
            "uid",
            "gid"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "virFileRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2844-2856",
          "snippet": "int\nvirFileRemove(const char *path,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED)\n{\n    if (unlink(path) < 0) {\n        virReportSystemError(errno, _(\"Unable to unlink path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileRemove(const char *path,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED)\n{\n    if (unlink(path) < 0) {\n        virReportSystemError(errno, _(\"Unable to unlink path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainGetImageIds",
          "args": [
            "cfg",
            "vm",
            "backupdisk->store",
            "NULL",
            "&uid",
            "&gid"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainGetImageIds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "11527-11562",
          "snippet": "void\nqemuDomainGetImageIds(virQEMUDriverConfigPtr cfg,\n                      virDomainObjPtr vm,\n                      virStorageSourcePtr src,\n                      virStorageSourcePtr parentSrc,\n                      uid_t *uid, gid_t *gid)\n{\n    virSecurityLabelDefPtr vmlabel;\n    virSecurityDeviceLabelDefPtr disklabel;\n\n    if (uid)\n        *uid = -1;\n    if (gid)\n        *gid = -1;\n\n    if (cfg) {\n        if (uid)\n            *uid = cfg->user;\n\n        if (gid)\n            *gid = cfg->group;\n    }\n\n    if (vm && (vmlabel = virDomainDefGetSecurityLabelDef(vm->def, \"dac\")) &&\n        vmlabel->label)\n        virParseOwnershipIds(vmlabel->label, uid, gid);\n\n    if (parentSrc &&\n        (disklabel = virStorageSourceGetSecurityLabelDef(parentSrc, \"dac\")) &&\n        disklabel->label)\n        virParseOwnershipIds(disklabel->label, uid, gid);\n\n    if ((disklabel = virStorageSourceGetSecurityLabelDef(src, \"dac\")) &&\n        disklabel->label)\n        virParseOwnershipIds(disklabel->label, uid, gid);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nvoid\nqemuDomainGetImageIds(virQEMUDriverConfigPtr cfg,\n                      virDomainObjPtr vm,\n                      virStorageSourcePtr src,\n                      virStorageSourcePtr parentSrc,\n                      uid_t *uid, gid_t *gid)\n{\n    virSecurityLabelDefPtr vmlabel;\n    virSecurityDeviceLabelDefPtr disklabel;\n\n    if (uid)\n        *uid = -1;\n    if (gid)\n        *gid = -1;\n\n    if (cfg) {\n        if (uid)\n            *uid = cfg->user;\n\n        if (gid)\n            *gid = cfg->group;\n    }\n\n    if (vm && (vmlabel = virDomainDefGetSecurityLabelDef(vm->def, \"dac\")) &&\n        vmlabel->label)\n        virParseOwnershipIds(vmlabel->label, uid, gid);\n\n    if (parentSrc &&\n        (disklabel = virStorageSourceGetSecurityLabelDef(parentSrc, \"dac\")) &&\n        disklabel->label)\n        virParseOwnershipIds(disklabel->label, uid, gid);\n\n    if ((disklabel = virStorageSourceGetSecurityLabelDef(src, \"dac\")) &&\n        disklabel->label)\n        virParseOwnershipIds(disklabel->label, uid, gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "priv->driver"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainEventEmitJobCompleted",
          "args": [
            "priv->driver",
            "vm"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainEventEmitJobCompleted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "307-328",
          "snippet": "void\nqemuDomainEventEmitJobCompleted(virQEMUDriverPtr driver,\n                                virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virObjectEventPtr event;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    int type;\n\n    if (!priv->job.completed)\n        return;\n\n    if (qemuDomainJobInfoToParams(priv->job.completed, &type,\n                                  &params, &nparams) < 0) {\n        VIR_WARN(\"Could not get stats for completed job; domain %s\",\n                 vm->def->name);\n    }\n\n    event = virDomainEventJobCompletedNewFromObj(vm, params, nparams);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nobj, obj->def->name);\n\nvoid\nqemuDomainEventEmitJobCompleted(virQEMUDriverPtr driver,\n                                virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virObjectEventPtr event;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    int type;\n\n    if (!priv->job.completed)\n        return;\n\n    if (qemuDomainJobInfoToParams(priv->job.completed, &type,\n                                  &params, &nparams) < 0) {\n        VIR_WARN(\"Could not get stats for completed job; domain %s\",\n                 vm->def->name);\n    }\n\n    event = virDomainEventJobCompletedNewFromObj(vm, params, nparams);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "qemuDomainJobInfo",
            "1"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "priv->job.completed"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainJobInfoUpdateTime",
          "args": [
            "priv->job.current"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainJobInfoUpdateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "430-449",
          "snippet": "int\nqemuDomainJobInfoUpdateTime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->started)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->started) {\n        VIR_WARN(\"Async job starts in the future\");\n        jobInfo->started = 0;\n        return 0;\n    }\n\n    jobInfo->timeElapsed = now - jobInfo->started;\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainJobInfoUpdateTime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->started)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->started) {\n        VIR_WARN(\"Async job starts in the future\");\n        jobInfo->started = 0;\n        return 0;\n    }\n\n    jobInfo->timeElapsed = now - jobInfo->started;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvoid\nqemuBackupJobTerminate(virDomainObjPtr vm,\n                       qemuDomainJobStatus jobstatus)\n\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n\n    qemuDomainJobInfoUpdateTime(priv->job.current);\n\n    g_free(priv->job.completed);\n    priv->job.completed = g_new0(qemuDomainJobInfo, 1);\n    *priv->job.completed = *priv->job.current;\n\n    priv->job.completed->stats.backup.total = priv->backup->push_total;\n    priv->job.completed->stats.backup.transferred = priv->backup->push_transferred;\n    priv->job.completed->stats.backup.tmp_used = priv->backup->pull_tmp_used;\n    priv->job.completed->stats.backup.tmp_total = priv->backup->pull_tmp_total;\n\n    priv->job.completed->status = jobstatus;\n\n    qemuDomainEventEmitJobCompleted(priv->driver, vm);\n\n    if (!(priv->job.apiFlags & VIR_DOMAIN_BACKUP_BEGIN_REUSE_EXTERNAL) &&\n        (priv->backup->type == VIR_DOMAIN_BACKUP_TYPE_PULL ||\n         (priv->backup->type == VIR_DOMAIN_BACKUP_TYPE_PUSH &&\n          jobstatus != QEMU_DOMAIN_JOB_STATUS_COMPLETED))) {\n\n        g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(priv->driver);\n\n        for (i = 0; i < priv->backup->ndisks; i++) {\n            virDomainBackupDiskDefPtr backupdisk = priv->backup->disks + i;\n            uid_t uid;\n            gid_t gid;\n\n            if (!backupdisk->store ||\n                backupdisk->store->type != VIR_STORAGE_TYPE_FILE)\n                continue;\n\n            qemuDomainGetImageIds(cfg, vm, backupdisk->store, NULL, &uid, &gid);\n            if (virFileRemove(backupdisk->store->path, uid, gid) < 0)\n                VIR_WARN(\"failed to remove scratch file '%s'\",\n                         backupdisk->store->path);\n        }\n    }\n\n    virDomainBackupDefFree(priv->backup);\n    priv->backup = NULL;\n    qemuDomainObjEndAsyncJob(priv->driver, vm);\n}"
  },
  {
    "function_name": "qemuBackupBeginCollectIncrementalCheckpoints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "581-613",
    "snippet": "static virDomainMomentDefPtr *\nqemuBackupBeginCollectIncrementalCheckpoints(virDomainObjPtr vm,\n                                             const char *incrFrom)\n{\n    virDomainMomentObjPtr n = virDomainCheckpointGetCurrent(vm->checkpoints);\n    g_autofree virDomainMomentDefPtr *incr = NULL;\n    size_t nincr = 0;\n\n    while (n) {\n        virDomainMomentDefPtr def = n->def;\n\n        if (VIR_APPEND_ELEMENT_COPY(incr, nincr, def) < 0)\n            return NULL;\n\n        if (STREQ(def->name, incrFrom)) {\n            def = NULL;\n            if (VIR_APPEND_ELEMENT_COPY(incr, nincr, def) < 0)\n                return NULL;\n\n            return g_steal_pointer(&incr);\n        }\n\n        if (!n->def->parent_name)\n            break;\n\n        n = virDomainCheckpointFindByName(vm->checkpoints, n->def->parent_name);\n    }\n\n    virReportError(VIR_ERR_OPERATION_INVALID,\n                   _(\"could not locate checkpoint '%s' for incremental backup\"),\n                   incrFrom);\n    return NULL;\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"could not locate checkpoint '%s' for incremental backup\")",
            "incrFrom"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not locate checkpoint '%s' for incremental backup\""
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainCheckpointFindByName",
          "args": [
            "vm->checkpoints",
            "n->def->parent_name"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCheckpointFindByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomaincheckpointobjlist.c",
          "lines": "109-114",
          "snippet": "virDomainMomentObjPtr\nvirDomainCheckpointFindByName(virDomainCheckpointObjListPtr checkpoints,\n                              const char *name)\n{\n    return virDomainMomentFindByName(checkpoints->base, name);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainMomentObjPtr\nvirDomainCheckpointFindByName(virDomainCheckpointObjListPtr checkpoints,\n                              const char *name)\n{\n    return virDomainMomentFindByName(checkpoints->base, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&incr"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT_COPY",
          "args": [
            "incr",
            "nincr",
            "def"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->name",
            "incrFrom"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT_COPY",
          "args": [
            "incr",
            "nincr",
            "def"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainCheckpointGetCurrent",
          "args": [
            "vm->checkpoints"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCheckpointGetCurrentName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomaincheckpointobjlist.c",
          "lines": "126-130",
          "snippet": "const char *\nvirDomainCheckpointGetCurrentName(virDomainCheckpointObjListPtr checkpoints)\n{\n    return virDomainMomentGetCurrentName(checkpoints->base);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nconst char *\nvirDomainCheckpointGetCurrentName(virDomainCheckpointObjListPtr checkpoints)\n{\n    return virDomainMomentGetCurrentName(checkpoints->base);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic virDomainMomentDefPtr *\nqemuBackupBeginCollectIncrementalCheckpoints(virDomainObjPtr vm,\n                                             const char *incrFrom)\n{\n    virDomainMomentObjPtr n = virDomainCheckpointGetCurrent(vm->checkpoints);\n    g_autofree virDomainMomentDefPtr *incr = NULL;\n    size_t nincr = 0;\n\n    while (n) {\n        virDomainMomentDefPtr def = n->def;\n\n        if (VIR_APPEND_ELEMENT_COPY(incr, nincr, def) < 0)\n            return NULL;\n\n        if (STREQ(def->name, incrFrom)) {\n            def = NULL;\n            if (VIR_APPEND_ELEMENT_COPY(incr, nincr, def) < 0)\n                return NULL;\n\n            return g_steal_pointer(&incr);\n        }\n\n        if (!n->def->parent_name)\n            break;\n\n        n = virDomainCheckpointFindByName(vm->checkpoints, n->def->parent_name);\n    }\n\n    virReportError(VIR_ERR_OPERATION_INVALID,\n                   _(\"could not locate checkpoint '%s' for incremental backup\"),\n                   incrFrom);\n    return NULL;\n}"
  },
  {
    "function_name": "qemuBackupBeginPullExportDisks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "546-569",
    "snippet": "static int\nqemuBackupBeginPullExportDisks(virDomainObjPtr vm,\n                               struct qemuBackupDiskData *disks,\n                               size_t ndisks)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n\n    for (i = 0; i < ndisks; i++) {\n        struct qemuBackupDiskData *dd = disks + i;\n\n        if (!dd->backupdisk->exportname)\n            dd->backupdisk->exportname = g_strdup(dd->domdisk->dst);\n\n        if (qemuMonitorNBDServerAdd(priv->mon,\n                                    dd->store->nodeformat,\n                                    dd->backupdisk->exportname,\n                                    false,\n                                    dd->incrementalBitmap) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorNBDServerAdd",
          "args": [
            "priv->mon",
            "dd->store->nodeformat",
            "dd->backupdisk->exportname",
            "false",
            "dd->incrementalBitmap"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorNBDServerAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3861-3875",
          "snippet": "int\nqemuMonitorNBDServerAdd(qemuMonitorPtr mon,\n                        const char *deviceID,\n                        const char *export,\n                        bool writable,\n                        const char *bitmap)\n{\n    VIR_DEBUG(\"deviceID=%s, export=%s, bitmap=%s\", deviceID, NULLSTR(export),\n              NULLSTR(bitmap));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerAdd(mon, deviceID, export, writable,\n                                       bitmap);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorNBDServerAdd(qemuMonitorPtr mon,\n                        const char *deviceID,\n                        const char *export,\n                        bool writable,\n                        const char *bitmap)\n{\n    VIR_DEBUG(\"deviceID=%s, export=%s, bitmap=%s\", deviceID, NULLSTR(export),\n              NULLSTR(bitmap));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerAdd(mon, deviceID, export, writable,\n                                       bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "dd->domdisk->dst"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic int\nqemuBackupBeginPullExportDisks(virDomainObjPtr vm,\n                               struct qemuBackupDiskData *disks,\n                               size_t ndisks)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n\n    for (i = 0; i < ndisks; i++) {\n        struct qemuBackupDiskData *dd = disks + i;\n\n        if (!dd->backupdisk->exportname)\n            dd->backupdisk->exportname = g_strdup(dd->domdisk->dst);\n\n        if (qemuMonitorNBDServerAdd(priv->mon,\n                                    dd->store->nodeformat,\n                                    dd->backupdisk->exportname,\n                                    false,\n                                    dd->incrementalBitmap) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuBackupDiskStarted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "522-534",
    "snippet": "static void\nqemuBackupDiskStarted(virDomainObjPtr vm,\n                      struct qemuBackupDiskData *dd,\n                      size_t ndd)\n{\n    size_t i;\n\n    for (i = 0; i < ndd; i++) {\n        dd[i].started = true;\n        dd[i].backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING;\n        qemuBlockJobStarted(dd->blockjob, vm);\n    }\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuBlockJobStarted",
          "args": [
            "dd->blockjob",
            "vm"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobStarted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "440-448",
          "snippet": "void\nqemuBlockJobStarted(qemuBlockJobDataPtr job,\n                    virDomainObjPtr vm)\n{\n    if (job->state == QEMU_BLOCKJOB_STATE_NEW)\n        job->state = QEMU_BLOCKJOB_STATE_RUNNING;\n\n    qemuDomainSaveStatus(vm);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nqemuBlockJobStarted(qemuBlockJobDataPtr job,\n                    virDomainObjPtr vm)\n{\n    if (job->state == QEMU_BLOCKJOB_STATE_NEW)\n        job->state = QEMU_BLOCKJOB_STATE_RUNNING;\n\n    qemuDomainSaveStatus(vm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic void\nqemuBackupDiskStarted(virDomainObjPtr vm,\n                      struct qemuBackupDiskData *dd,\n                      size_t ndd)\n{\n    size_t i;\n\n    for (i = 0; i < ndd; i++) {\n        dd[i].started = true;\n        dd[i].backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING;\n        qemuBlockJobStarted(dd->blockjob, vm);\n    }\n}"
  },
  {
    "function_name": "qemuBackupDiskPrepareStorage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "503-519",
    "snippet": "static int\nqemuBackupDiskPrepareStorage(virDomainObjPtr vm,\n                             struct qemuBackupDiskData *disks,\n                             size_t ndisks,\n                             virHashTablePtr blockNamedNodeData,\n                             bool reuse_external)\n{\n    size_t i;\n\n    for (i = 0; i < ndisks; i++) {\n        if (qemuBackupDiskPrepareOneStorage(vm, blockNamedNodeData, disks + i,\n                                            reuse_external) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuBackupDiskPrepareOneStorage",
          "args": [
            "vm",
            "blockNamedNodeData",
            "disks + i",
            "reuse_external"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupDiskPrepareOneStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "437-500",
          "snippet": "static int\nqemuBackupDiskPrepareOneStorage(virDomainObjPtr vm,\n                                virHashTablePtr blockNamedNodeData,\n                                struct qemuBackupDiskData *dd,\n                                bool reuse_external)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int rc;\n\n    if (!reuse_external &&\n        dd->store->type == VIR_STORAGE_TYPE_FILE &&\n        virStorageFileSupportsCreate(dd->store)) {\n\n        if (virFileExists(dd->store->path)) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"store '%s' for backup of '%s' exists\"),\n                           dd->store->path, dd->domdisk->dst);\n            return -1;\n        }\n\n        if (qemuDomainStorageFileInit(priv->driver, vm, dd->store, NULL) < 0)\n            return -1;\n\n        dd->initialized = true;\n\n        if (virStorageFileCreate(dd->store) < 0) {\n            virReportSystemError(errno,\n                                 _(\"failed to create image file '%s'\"),\n                                 NULLSTR(dd->store->path));\n            return -1;\n        }\n\n        dd->created = true;\n    }\n\n    if (qemuDomainStorageSourceAccessAllow(priv->driver, vm, dd->store,\n                                           false, true, true) < 0)\n        return -1;\n\n    dd->labelled = true;\n\n    if (!reuse_external) {\n        if (qemuBlockStorageSourceCreateDetectSize(blockNamedNodeData,\n                                                   dd->store, dd->domdisk->src) < 0)\n            return -1;\n\n        if (qemuBlockStorageSourceCreate(vm, dd->store, NULL, NULL,\n                                         dd->crdata->srcdata[0],\n                                         QEMU_ASYNC_JOB_BACKUP) < 0)\n            return -1;\n    } else {\n        if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, QEMU_ASYNC_JOB_BACKUP) < 0)\n            return -1;\n\n        rc = qemuBlockStorageSourceAttachApply(priv->mon, dd->crdata->srcdata[0]);\n\n        if (qemuDomainObjExitMonitor(priv->driver, vm) < 0 || rc < 0)\n            return -1;\n    }\n\n    dd->added = true;\n\n    return 0;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic int\nqemuBackupDiskPrepareOneStorage(virDomainObjPtr vm,\n                                virHashTablePtr blockNamedNodeData,\n                                struct qemuBackupDiskData *dd,\n                                bool reuse_external)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int rc;\n\n    if (!reuse_external &&\n        dd->store->type == VIR_STORAGE_TYPE_FILE &&\n        virStorageFileSupportsCreate(dd->store)) {\n\n        if (virFileExists(dd->store->path)) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"store '%s' for backup of '%s' exists\"),\n                           dd->store->path, dd->domdisk->dst);\n            return -1;\n        }\n\n        if (qemuDomainStorageFileInit(priv->driver, vm, dd->store, NULL) < 0)\n            return -1;\n\n        dd->initialized = true;\n\n        if (virStorageFileCreate(dd->store) < 0) {\n            virReportSystemError(errno,\n                                 _(\"failed to create image file '%s'\"),\n                                 NULLSTR(dd->store->path));\n            return -1;\n        }\n\n        dd->created = true;\n    }\n\n    if (qemuDomainStorageSourceAccessAllow(priv->driver, vm, dd->store,\n                                           false, true, true) < 0)\n        return -1;\n\n    dd->labelled = true;\n\n    if (!reuse_external) {\n        if (qemuBlockStorageSourceCreateDetectSize(blockNamedNodeData,\n                                                   dd->store, dd->domdisk->src) < 0)\n            return -1;\n\n        if (qemuBlockStorageSourceCreate(vm, dd->store, NULL, NULL,\n                                         dd->crdata->srcdata[0],\n                                         QEMU_ASYNC_JOB_BACKUP) < 0)\n            return -1;\n    } else {\n        if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, QEMU_ASYNC_JOB_BACKUP) < 0)\n            return -1;\n\n        rc = qemuBlockStorageSourceAttachApply(priv->mon, dd->crdata->srcdata[0]);\n\n        if (qemuDomainObjExitMonitor(priv->driver, vm) < 0 || rc < 0)\n            return -1;\n    }\n\n    dd->added = true;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic int\nqemuBackupDiskPrepareStorage(virDomainObjPtr vm,\n                             struct qemuBackupDiskData *disks,\n                             size_t ndisks,\n                             virHashTablePtr blockNamedNodeData,\n                             bool reuse_external)\n{\n    size_t i;\n\n    for (i = 0; i < ndisks; i++) {\n        if (qemuBackupDiskPrepareOneStorage(vm, blockNamedNodeData, disks + i,\n                                            reuse_external) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuBackupDiskPrepareOneStorage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "437-500",
    "snippet": "static int\nqemuBackupDiskPrepareOneStorage(virDomainObjPtr vm,\n                                virHashTablePtr blockNamedNodeData,\n                                struct qemuBackupDiskData *dd,\n                                bool reuse_external)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int rc;\n\n    if (!reuse_external &&\n        dd->store->type == VIR_STORAGE_TYPE_FILE &&\n        virStorageFileSupportsCreate(dd->store)) {\n\n        if (virFileExists(dd->store->path)) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"store '%s' for backup of '%s' exists\"),\n                           dd->store->path, dd->domdisk->dst);\n            return -1;\n        }\n\n        if (qemuDomainStorageFileInit(priv->driver, vm, dd->store, NULL) < 0)\n            return -1;\n\n        dd->initialized = true;\n\n        if (virStorageFileCreate(dd->store) < 0) {\n            virReportSystemError(errno,\n                                 _(\"failed to create image file '%s'\"),\n                                 NULLSTR(dd->store->path));\n            return -1;\n        }\n\n        dd->created = true;\n    }\n\n    if (qemuDomainStorageSourceAccessAllow(priv->driver, vm, dd->store,\n                                           false, true, true) < 0)\n        return -1;\n\n    dd->labelled = true;\n\n    if (!reuse_external) {\n        if (qemuBlockStorageSourceCreateDetectSize(blockNamedNodeData,\n                                                   dd->store, dd->domdisk->src) < 0)\n            return -1;\n\n        if (qemuBlockStorageSourceCreate(vm, dd->store, NULL, NULL,\n                                         dd->crdata->srcdata[0],\n                                         QEMU_ASYNC_JOB_BACKUP) < 0)\n            return -1;\n    } else {\n        if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, QEMU_ASYNC_JOB_BACKUP) < 0)\n            return -1;\n\n        rc = qemuBlockStorageSourceAttachApply(priv->mon, dd->crdata->srcdata[0]);\n\n        if (qemuDomainObjExitMonitor(priv->driver, vm) < 0 || rc < 0)\n            return -1;\n    }\n\n    dd->added = true;\n\n    return 0;\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "priv->driver",
            "vm"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockStorageSourceAttachApply",
          "args": [
            "priv->mon",
            "dd->crdata->srcdata[0]"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockStorageSourceAttachApply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "1692-1711",
          "snippet": "int\nqemuBlockStorageSourceAttachApply(qemuMonitorPtr mon,\n                                  qemuBlockStorageSourceAttachDataPtr data)\n{\n    if (qemuBlockStorageSourceAttachApplyStorageDeps(mon, data) < 0 ||\n        qemuBlockStorageSourceAttachApplyStorage(mon, data) < 0 ||\n        qemuBlockStorageSourceAttachApplyStorageSlice(mon, data) < 0 ||\n        qemuBlockStorageSourceAttachApplyFormatDeps(mon, data) < 0 ||\n        qemuBlockStorageSourceAttachApplyFormat(mon, data) < 0)\n        return -1;\n\n    if (data->driveCmd) {\n        if (qemuMonitorAddDrive(mon, data->driveCmd) < 0)\n            return -1;\n\n        data->driveAdded = true;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockStorageSourceAttachApply(qemuMonitorPtr mon,\n                                  qemuBlockStorageSourceAttachDataPtr data)\n{\n    if (qemuBlockStorageSourceAttachApplyStorageDeps(mon, data) < 0 ||\n        qemuBlockStorageSourceAttachApplyStorage(mon, data) < 0 ||\n        qemuBlockStorageSourceAttachApplyStorageSlice(mon, data) < 0 ||\n        qemuBlockStorageSourceAttachApplyFormatDeps(mon, data) < 0 ||\n        qemuBlockStorageSourceAttachApplyFormat(mon, data) < 0)\n        return -1;\n\n    if (data->driveCmd) {\n        if (qemuMonitorAddDrive(mon, data->driveCmd) < 0)\n            return -1;\n\n        data->driveAdded = true;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "priv->driver",
            "vm",
            "QEMU_ASYNC_JOB_BACKUP"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockStorageSourceCreate",
          "args": [
            "vm",
            "dd->store",
            "NULL",
            "NULL",
            "dd->crdata->srcdata[0]",
            "QEMU_ASYNC_JOB_BACKUP"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockStorageSourceCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "2645-2709",
          "snippet": "int\nqemuBlockStorageSourceCreate(virDomainObjPtr vm,\n                             virStorageSourcePtr src,\n                             virStorageSourcePtr backingStore,\n                             virStorageSourcePtr chain,\n                             qemuBlockStorageSourceAttachDataPtr data,\n                             qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n    int rc;\n\n    if (src->sliceStorage) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"creation of images with slice type='storage' is not supported\"));\n        return -1;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    rc = qemuBlockStorageSourceAttachApplyStorageDeps(priv->mon, data);\n\n    if (qemuDomainObjExitMonitor(priv->driver, vm) < 0 || rc < 0)\n        goto cleanup;\n\n    if (qemuBlockStorageSourceCreateStorage(vm, src, chain, asyncJob) < 0)\n        goto cleanup;\n\n    if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    rc = qemuBlockStorageSourceAttachApplyStorage(priv->mon, data);\n\n    if (rc == 0)\n        rc = qemuBlockStorageSourceAttachApplyFormatDeps(priv->mon, data);\n\n    if (qemuDomainObjExitMonitor(priv->driver, vm) < 0 || rc < 0)\n        goto cleanup;\n\n    if (qemuBlockStorageSourceCreateFormat(vm, src, backingStore, chain,\n                                           asyncJob) < 0)\n        goto cleanup;\n\n    if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    rc = qemuBlockStorageSourceAttachApplyFormat(priv->mon, data);\n\n    if (qemuDomainObjExitMonitor(priv->driver, vm) < 0 || rc < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0 &&\n        virDomainObjIsActive(vm) &&\n        qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) == 0) {\n\n        qemuBlockStorageSourceAttachRollback(priv->mon, data);\n        ignore_value(qemuDomainObjExitMonitor(priv->driver, vm));\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockStorageSourceCreate(virDomainObjPtr vm,\n                             virStorageSourcePtr src,\n                             virStorageSourcePtr backingStore,\n                             virStorageSourcePtr chain,\n                             qemuBlockStorageSourceAttachDataPtr data,\n                             qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n    int rc;\n\n    if (src->sliceStorage) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"creation of images with slice type='storage' is not supported\"));\n        return -1;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    rc = qemuBlockStorageSourceAttachApplyStorageDeps(priv->mon, data);\n\n    if (qemuDomainObjExitMonitor(priv->driver, vm) < 0 || rc < 0)\n        goto cleanup;\n\n    if (qemuBlockStorageSourceCreateStorage(vm, src, chain, asyncJob) < 0)\n        goto cleanup;\n\n    if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    rc = qemuBlockStorageSourceAttachApplyStorage(priv->mon, data);\n\n    if (rc == 0)\n        rc = qemuBlockStorageSourceAttachApplyFormatDeps(priv->mon, data);\n\n    if (qemuDomainObjExitMonitor(priv->driver, vm) < 0 || rc < 0)\n        goto cleanup;\n\n    if (qemuBlockStorageSourceCreateFormat(vm, src, backingStore, chain,\n                                           asyncJob) < 0)\n        goto cleanup;\n\n    if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    rc = qemuBlockStorageSourceAttachApplyFormat(priv->mon, data);\n\n    if (qemuDomainObjExitMonitor(priv->driver, vm) < 0 || rc < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0 &&\n        virDomainObjIsActive(vm) &&\n        qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) == 0) {\n\n        qemuBlockStorageSourceAttachRollback(priv->mon, data);\n        ignore_value(qemuDomainObjExitMonitor(priv->driver, vm));\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockStorageSourceCreateDetectSize",
          "args": [
            "blockNamedNodeData",
            "dd->store",
            "dd->domdisk->src"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockStorageSourceCreateDetectSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "2723-2746",
          "snippet": "int\nqemuBlockStorageSourceCreateDetectSize(virHashTablePtr blockNamedNodeData,\n                                       virStorageSourcePtr src,\n                                       virStorageSourcePtr templ)\n{\n    qemuBlockNamedNodeDataPtr entry;\n\n    if (!(entry = virHashLookup(blockNamedNodeData, templ->nodeformat))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to update capacity data for block node '%s'\"),\n                       templ->nodeformat);\n        return -1;\n    }\n\n    if (src->format == VIR_STORAGE_FILE_RAW) {\n        src->physical = entry->capacity;\n    } else {\n        src->physical = entry->physical;\n    }\n\n    src->capacity = entry->capacity;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockStorageSourceCreateDetectSize(virHashTablePtr blockNamedNodeData,\n                                       virStorageSourcePtr src,\n                                       virStorageSourcePtr templ)\n{\n    qemuBlockNamedNodeDataPtr entry;\n\n    if (!(entry = virHashLookup(blockNamedNodeData, templ->nodeformat))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to update capacity data for block node '%s'\"),\n                       templ->nodeformat);\n        return -1;\n    }\n\n    if (src->format == VIR_STORAGE_FILE_RAW) {\n        src->physical = entry->capacity;\n    } else {\n        src->physical = entry->physical;\n    }\n\n    src->capacity = entry->capacity;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainStorageSourceAccessAllow",
          "args": [
            "priv->driver",
            "vm",
            "dd->store",
            "false",
            "true",
            "true"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainStorageSourceAccessAllow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12115-12137",
          "snippet": "int\nqemuDomainStorageSourceAccessAllow(virQEMUDriverPtr driver,\n                                   virDomainObjPtr vm,\n                                   virStorageSourcePtr elem,\n                                   bool readonly,\n                                   bool newSource,\n                                   bool chainTop)\n{\n    qemuDomainStorageSourceAccessFlags flags = QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_SKIP_REVOKE;\n\n    if (readonly)\n        flags |= QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_FORCE_READ_ONLY;\n    else\n        flags |= QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_FORCE_READ_WRITE;\n\n    if (!newSource)\n        flags |= QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_MODIFY_ACCESS;\n\n    if (chainTop)\n        flags |= QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_CHAIN_TOP;\n\n    return qemuDomainStorageSourceAccessModify(driver, vm, elem, flags);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainStorageSourceAccessAllow(virQEMUDriverPtr driver,\n                                   virDomainObjPtr vm,\n                                   virStorageSourcePtr elem,\n                                   bool readonly,\n                                   bool newSource,\n                                   bool chainTop)\n{\n    qemuDomainStorageSourceAccessFlags flags = QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_SKIP_REVOKE;\n\n    if (readonly)\n        flags |= QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_FORCE_READ_ONLY;\n    else\n        flags |= QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_FORCE_READ_WRITE;\n\n    if (!newSource)\n        flags |= QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_MODIFY_ACCESS;\n\n    if (chainTop)\n        flags |= QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_CHAIN_TOP;\n\n    return qemuDomainStorageSourceAccessModify(driver, vm, elem, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"failed to create image file '%s'\")",
            "NULLSTR(dd->store->path)"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "dd->store->path"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to create image file '%s'\""
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileCreate",
          "args": [
            "dd->store"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4914-4931",
          "snippet": "int\nvirStorageFileCreate(virStorageSourcePtr src)\n{\n    int ret;\n\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileCreate) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    ret = src->drv->backend->storageFileCreate(src);\n\n    VIR_DEBUG(\"created storage file %p: ret=%d, errno=%d\",\n              src, ret, errno);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileCreate(virStorageSourcePtr src)\n{\n    int ret;\n\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileCreate) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    ret = src->drv->backend->storageFileCreate(src);\n\n    VIR_DEBUG(\"created storage file %p: ret=%d, errno=%d\",\n              src, ret, errno);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainStorageFileInit",
          "args": [
            "priv->driver",
            "vm",
            "dd->store",
            "NULL"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainStorageFileInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "11565-11581",
          "snippet": "int\nqemuDomainStorageFileInit(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          virStorageSourcePtr src,\n                          virStorageSourcePtr parent)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    uid_t uid;\n    gid_t gid;\n\n    qemuDomainGetImageIds(cfg, vm, src, parent, &uid, &gid);\n\n    if (virStorageFileInitAs(src, uid, gid) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainStorageFileInit(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          virStorageSourcePtr src,\n                          virStorageSourcePtr parent)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    uid_t uid;\n    gid_t gid;\n\n    qemuDomainGetImageIds(cfg, vm, src, parent, &uid, &gid);\n\n    if (virStorageFileInitAs(src, uid, gid) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"store '%s' for backup of '%s' exists\")",
            "dd->store->path",
            "dd->domdisk->dst"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "dd->store->path"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileSupportsCreate",
          "args": [
            "dd->store"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileSupportsCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4817-4827",
          "snippet": "int\nvirStorageFileSupportsCreate(const virStorageSource *src)\n{\n    virStorageFileBackendPtr backend;\n    int rv;\n\n    if ((rv = virStorageFileGetBackendForSupportCheck(src, &backend)) < 1)\n        return rv;\n\n    return backend->storageFileCreate ? 1 : 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileSupportsCreate(const virStorageSource *src)\n{\n    virStorageFileBackendPtr backend;\n    int rv;\n\n    if ((rv = virStorageFileGetBackendForSupportCheck(src, &backend)) < 1)\n        return rv;\n\n    return backend->storageFileCreate ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic int\nqemuBackupDiskPrepareOneStorage(virDomainObjPtr vm,\n                                virHashTablePtr blockNamedNodeData,\n                                struct qemuBackupDiskData *dd,\n                                bool reuse_external)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int rc;\n\n    if (!reuse_external &&\n        dd->store->type == VIR_STORAGE_TYPE_FILE &&\n        virStorageFileSupportsCreate(dd->store)) {\n\n        if (virFileExists(dd->store->path)) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"store '%s' for backup of '%s' exists\"),\n                           dd->store->path, dd->domdisk->dst);\n            return -1;\n        }\n\n        if (qemuDomainStorageFileInit(priv->driver, vm, dd->store, NULL) < 0)\n            return -1;\n\n        dd->initialized = true;\n\n        if (virStorageFileCreate(dd->store) < 0) {\n            virReportSystemError(errno,\n                                 _(\"failed to create image file '%s'\"),\n                                 NULLSTR(dd->store->path));\n            return -1;\n        }\n\n        dd->created = true;\n    }\n\n    if (qemuDomainStorageSourceAccessAllow(priv->driver, vm, dd->store,\n                                           false, true, true) < 0)\n        return -1;\n\n    dd->labelled = true;\n\n    if (!reuse_external) {\n        if (qemuBlockStorageSourceCreateDetectSize(blockNamedNodeData,\n                                                   dd->store, dd->domdisk->src) < 0)\n            return -1;\n\n        if (qemuBlockStorageSourceCreate(vm, dd->store, NULL, NULL,\n                                         dd->crdata->srcdata[0],\n                                         QEMU_ASYNC_JOB_BACKUP) < 0)\n            return -1;\n    } else {\n        if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, QEMU_ASYNC_JOB_BACKUP) < 0)\n            return -1;\n\n        rc = qemuBlockStorageSourceAttachApply(priv->mon, dd->crdata->srcdata[0]);\n\n        if (qemuDomainObjExitMonitor(priv->driver, vm) < 0 || rc < 0)\n            return -1;\n    }\n\n    dd->added = true;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuBackupDiskPrepareData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "389-434",
    "snippet": "static ssize_t\nqemuBackupDiskPrepareData(virDomainObjPtr vm,\n                          virDomainBackupDefPtr def,\n                          virDomainMomentDefPtr *incremental,\n                          virHashTablePtr blockNamedNodeData,\n                          virJSONValuePtr actions,\n                          virQEMUDriverConfigPtr cfg,\n                          struct qemuBackupDiskData **rdd)\n{\n    struct qemuBackupDiskData *disks = NULL;\n    ssize_t ndisks = 0;\n    size_t i;\n\n    disks = g_new0(struct qemuBackupDiskData, def->ndisks);\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainBackupDiskDef *backupdisk = &def->disks[i];\n        struct qemuBackupDiskData *dd = disks + ndisks;\n\n        if (!backupdisk->store)\n            continue;\n\n        ndisks++;\n\n        if (qemuBackupDiskPrepareDataOne(vm, backupdisk, dd, actions,\n                                         incremental, blockNamedNodeData,\n                                         cfg) < 0)\n            goto error;\n\n        if (def->type == VIR_DOMAIN_BACKUP_TYPE_PULL) {\n            if (qemuBackupDiskPrepareDataOnePull(actions, dd) < 0)\n                goto error;\n        } else {\n            if (qemuBackupDiskPrepareDataOnePush(actions, dd) < 0)\n                goto error;\n        }\n    }\n\n    *rdd = g_steal_pointer(&disks);\n\n    return ndisks;\n\n error:\n    qemuBackupDiskDataCleanup(vm, disks, ndisks);\n    return -1;\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuBackupDiskDataCleanup",
          "args": [
            "vm",
            "disks",
            "ndisks"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupDiskDataCleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "152-170",
          "snippet": "static void\nqemuBackupDiskDataCleanup(virDomainObjPtr vm,\n                          struct qemuBackupDiskData *dd,\n                          size_t ndd)\n{\n    virErrorPtr orig_err;\n    size_t i;\n\n    if (!dd)\n        return;\n\n    virErrorPreserveLast(&orig_err);\n\n    for (i = 0; i < ndd; i++)\n        qemuBackupDiskDataCleanupOne(vm, dd + i);\n\n    g_free(dd);\n    virErrorRestore(&orig_err);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic void\nqemuBackupDiskDataCleanup(virDomainObjPtr vm,\n                          struct qemuBackupDiskData *dd,\n                          size_t ndd)\n{\n    virErrorPtr orig_err;\n    size_t i;\n\n    if (!dd)\n        return;\n\n    virErrorPreserveLast(&orig_err);\n\n    for (i = 0; i < ndd; i++)\n        qemuBackupDiskDataCleanupOne(vm, dd + i);\n\n    g_free(dd);\n    virErrorRestore(&orig_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&disks"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuBackupDiskPrepareDataOnePush",
          "args": [
            "actions",
            "dd"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupDiskPrepareDataOnePush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "348-366",
          "snippet": "static int\nqemuBackupDiskPrepareDataOnePush(virJSONValuePtr actions,\n                                 struct qemuBackupDiskData *dd)\n{\n    qemuMonitorTransactionBackupSyncMode syncmode = QEMU_MONITOR_TRANSACTION_BACKUP_SYNC_MODE_FULL;\n\n    if (dd->incrementalBitmap)\n        syncmode = QEMU_MONITOR_TRANSACTION_BACKUP_SYNC_MODE_INCREMENTAL;\n\n    if (qemuMonitorTransactionBackup(actions,\n                                     dd->domdisk->src->nodeformat,\n                                     dd->blockjob->name,\n                                     dd->store->nodeformat,\n                                     dd->incrementalBitmap,\n                                     syncmode) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic int\nqemuBackupDiskPrepareDataOnePush(virJSONValuePtr actions,\n                                 struct qemuBackupDiskData *dd)\n{\n    qemuMonitorTransactionBackupSyncMode syncmode = QEMU_MONITOR_TRANSACTION_BACKUP_SYNC_MODE_FULL;\n\n    if (dd->incrementalBitmap)\n        syncmode = QEMU_MONITOR_TRANSACTION_BACKUP_SYNC_MODE_INCREMENTAL;\n\n    if (qemuMonitorTransactionBackup(actions,\n                                     dd->domdisk->src->nodeformat,\n                                     dd->blockjob->name,\n                                     dd->store->nodeformat,\n                                     dd->incrementalBitmap,\n                                     syncmode) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBackupDiskPrepareDataOnePull",
          "args": [
            "actions",
            "dd"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupDiskPrepareDataOnePull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "369-386",
          "snippet": "static int\nqemuBackupDiskPrepareDataOnePull(virJSONValuePtr actions,\n                                 struct qemuBackupDiskData *dd)\n{\n    if (!dd->backupdisk->exportbitmap &&\n        dd->incrementalBitmap)\n        dd->backupdisk->exportbitmap = g_strdup(dd->incrementalBitmap);\n\n    if (qemuMonitorTransactionBackup(actions,\n                                     dd->domdisk->src->nodeformat,\n                                     dd->blockjob->name,\n                                     dd->store->nodeformat,\n                                     NULL,\n                                     QEMU_MONITOR_TRANSACTION_BACKUP_SYNC_MODE_NONE) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic int\nqemuBackupDiskPrepareDataOnePull(virJSONValuePtr actions,\n                                 struct qemuBackupDiskData *dd)\n{\n    if (!dd->backupdisk->exportbitmap &&\n        dd->incrementalBitmap)\n        dd->backupdisk->exportbitmap = g_strdup(dd->incrementalBitmap);\n\n    if (qemuMonitorTransactionBackup(actions,\n                                     dd->domdisk->src->nodeformat,\n                                     dd->blockjob->name,\n                                     dd->store->nodeformat,\n                                     NULL,\n                                     QEMU_MONITOR_TRANSACTION_BACKUP_SYNC_MODE_NONE) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBackupDiskPrepareDataOne",
          "args": [
            "vm",
            "backupdisk",
            "dd",
            "actions",
            "incremental",
            "blockNamedNodeData",
            "cfg"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupDiskPrepareDataOne",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "293-345",
          "snippet": "static int\nqemuBackupDiskPrepareDataOne(virDomainObjPtr vm,\n                             virDomainBackupDiskDefPtr backupdisk,\n                             struct qemuBackupDiskData *dd,\n                             virJSONValuePtr actions,\n                             virDomainMomentDefPtr *incremental,\n                             virHashTablePtr blockNamedNodeData,\n                             virQEMUDriverConfigPtr cfg)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    /* set data structure */\n    dd->backupdisk = backupdisk;\n    dd->store = dd->backupdisk->store;\n\n    if (!(dd->domdisk = virDomainDiskByTarget(vm->def, dd->backupdisk->name))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"no disk named '%s'\"), dd->backupdisk->name);\n        return -1;\n    }\n\n    if (!dd->store->format)\n        dd->store->format = VIR_STORAGE_FILE_QCOW2;\n\n    if (qemuDomainStorageFileInit(priv->driver, vm, dd->store, dd->domdisk->src) < 0)\n        return -1;\n\n    if (qemuDomainPrepareStorageSourceBlockdev(NULL, dd->store, priv, cfg) < 0)\n        return -1;\n\n    if (incremental) {\n        if (dd->backupdisk->exportbitmap)\n            dd->incrementalBitmap = g_strdup(dd->backupdisk->exportbitmap);\n        else\n            dd->incrementalBitmap = g_strdup_printf(\"backup-%s\", dd->domdisk->dst);\n\n        if (qemuBackupDiskPrepareOneBitmaps(dd, actions, incremental,\n                                            blockNamedNodeData) < 0)\n            return -1;\n    }\n\n    if (!(dd->blockjob = qemuBlockJobDiskNewBackup(vm, dd->domdisk, dd->store,\n                                                   dd->incrementalBitmap)))\n        return -1;\n\n    /* use original disk as backing to prevent opening the backing chain */\n    if (!(dd->crdata = qemuBuildStorageSourceChainAttachPrepareBlockdevTop(dd->store,\n                                                                           dd->domdisk->src,\n                                                                           priv->qemuCaps)))\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic int\nqemuBackupDiskPrepareDataOne(virDomainObjPtr vm,\n                             virDomainBackupDiskDefPtr backupdisk,\n                             struct qemuBackupDiskData *dd,\n                             virJSONValuePtr actions,\n                             virDomainMomentDefPtr *incremental,\n                             virHashTablePtr blockNamedNodeData,\n                             virQEMUDriverConfigPtr cfg)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    /* set data structure */\n    dd->backupdisk = backupdisk;\n    dd->store = dd->backupdisk->store;\n\n    if (!(dd->domdisk = virDomainDiskByTarget(vm->def, dd->backupdisk->name))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"no disk named '%s'\"), dd->backupdisk->name);\n        return -1;\n    }\n\n    if (!dd->store->format)\n        dd->store->format = VIR_STORAGE_FILE_QCOW2;\n\n    if (qemuDomainStorageFileInit(priv->driver, vm, dd->store, dd->domdisk->src) < 0)\n        return -1;\n\n    if (qemuDomainPrepareStorageSourceBlockdev(NULL, dd->store, priv, cfg) < 0)\n        return -1;\n\n    if (incremental) {\n        if (dd->backupdisk->exportbitmap)\n            dd->incrementalBitmap = g_strdup(dd->backupdisk->exportbitmap);\n        else\n            dd->incrementalBitmap = g_strdup_printf(\"backup-%s\", dd->domdisk->dst);\n\n        if (qemuBackupDiskPrepareOneBitmaps(dd, actions, incremental,\n                                            blockNamedNodeData) < 0)\n            return -1;\n    }\n\n    if (!(dd->blockjob = qemuBlockJobDiskNewBackup(vm, dd->domdisk, dd->store,\n                                                   dd->incrementalBitmap)))\n        return -1;\n\n    /* use original disk as backing to prevent opening the backing chain */\n    if (!(dd->crdata = qemuBuildStorageSourceChainAttachPrepareBlockdevTop(dd->store,\n                                                                           dd->domdisk->src,\n                                                                           priv->qemuCaps)))\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "structqemuBackupDiskData",
            "def->ndisks"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic ssize_t\nqemuBackupDiskPrepareData(virDomainObjPtr vm,\n                          virDomainBackupDefPtr def,\n                          virDomainMomentDefPtr *incremental,\n                          virHashTablePtr blockNamedNodeData,\n                          virJSONValuePtr actions,\n                          virQEMUDriverConfigPtr cfg,\n                          struct qemuBackupDiskData **rdd)\n{\n    struct qemuBackupDiskData *disks = NULL;\n    ssize_t ndisks = 0;\n    size_t i;\n\n    disks = g_new0(struct qemuBackupDiskData, def->ndisks);\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainBackupDiskDef *backupdisk = &def->disks[i];\n        struct qemuBackupDiskData *dd = disks + ndisks;\n\n        if (!backupdisk->store)\n            continue;\n\n        ndisks++;\n\n        if (qemuBackupDiskPrepareDataOne(vm, backupdisk, dd, actions,\n                                         incremental, blockNamedNodeData,\n                                         cfg) < 0)\n            goto error;\n\n        if (def->type == VIR_DOMAIN_BACKUP_TYPE_PULL) {\n            if (qemuBackupDiskPrepareDataOnePull(actions, dd) < 0)\n                goto error;\n        } else {\n            if (qemuBackupDiskPrepareDataOnePush(actions, dd) < 0)\n                goto error;\n        }\n    }\n\n    *rdd = g_steal_pointer(&disks);\n\n    return ndisks;\n\n error:\n    qemuBackupDiskDataCleanup(vm, disks, ndisks);\n    return -1;\n}"
  },
  {
    "function_name": "qemuBackupDiskPrepareDataOnePull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "369-386",
    "snippet": "static int\nqemuBackupDiskPrepareDataOnePull(virJSONValuePtr actions,\n                                 struct qemuBackupDiskData *dd)\n{\n    if (!dd->backupdisk->exportbitmap &&\n        dd->incrementalBitmap)\n        dd->backupdisk->exportbitmap = g_strdup(dd->incrementalBitmap);\n\n    if (qemuMonitorTransactionBackup(actions,\n                                     dd->domdisk->src->nodeformat,\n                                     dd->blockjob->name,\n                                     dd->store->nodeformat,\n                                     NULL,\n                                     QEMU_MONITOR_TRANSACTION_BACKUP_SYNC_MODE_NONE) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorTransactionBackup",
          "args": [
            "actions",
            "dd->domdisk->src->nodeformat",
            "dd->blockjob->name",
            "dd->store->nodeformat",
            "NULL",
            "QEMU_MONITOR_TRANSACTION_BACKUP_SYNC_MODE_NONE"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTransactionBackup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "4578-4588",
          "snippet": "int\nqemuMonitorTransactionBackup(virJSONValuePtr actions,\n                             const char *device,\n                             const char *jobname,\n                             const char *target,\n                             const char *bitmap,\n                             qemuMonitorTransactionBackupSyncMode syncmode)\n{\n    return qemuMonitorJSONTransactionBackup(actions, device, jobname, target,\n                                            bitmap, syncmode);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransactionBackup(virJSONValuePtr actions,\n                             const char *device,\n                             const char *jobname,\n                             const char *target,\n                             const char *bitmap,\n                             qemuMonitorTransactionBackupSyncMode syncmode)\n{\n    return qemuMonitorJSONTransactionBackup(actions, device, jobname, target,\n                                            bitmap, syncmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "dd->incrementalBitmap"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic int\nqemuBackupDiskPrepareDataOnePull(virJSONValuePtr actions,\n                                 struct qemuBackupDiskData *dd)\n{\n    if (!dd->backupdisk->exportbitmap &&\n        dd->incrementalBitmap)\n        dd->backupdisk->exportbitmap = g_strdup(dd->incrementalBitmap);\n\n    if (qemuMonitorTransactionBackup(actions,\n                                     dd->domdisk->src->nodeformat,\n                                     dd->blockjob->name,\n                                     dd->store->nodeformat,\n                                     NULL,\n                                     QEMU_MONITOR_TRANSACTION_BACKUP_SYNC_MODE_NONE) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuBackupDiskPrepareDataOnePush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "348-366",
    "snippet": "static int\nqemuBackupDiskPrepareDataOnePush(virJSONValuePtr actions,\n                                 struct qemuBackupDiskData *dd)\n{\n    qemuMonitorTransactionBackupSyncMode syncmode = QEMU_MONITOR_TRANSACTION_BACKUP_SYNC_MODE_FULL;\n\n    if (dd->incrementalBitmap)\n        syncmode = QEMU_MONITOR_TRANSACTION_BACKUP_SYNC_MODE_INCREMENTAL;\n\n    if (qemuMonitorTransactionBackup(actions,\n                                     dd->domdisk->src->nodeformat,\n                                     dd->blockjob->name,\n                                     dd->store->nodeformat,\n                                     dd->incrementalBitmap,\n                                     syncmode) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorTransactionBackup",
          "args": [
            "actions",
            "dd->domdisk->src->nodeformat",
            "dd->blockjob->name",
            "dd->store->nodeformat",
            "dd->incrementalBitmap",
            "syncmode"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTransactionBackup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "4578-4588",
          "snippet": "int\nqemuMonitorTransactionBackup(virJSONValuePtr actions,\n                             const char *device,\n                             const char *jobname,\n                             const char *target,\n                             const char *bitmap,\n                             qemuMonitorTransactionBackupSyncMode syncmode)\n{\n    return qemuMonitorJSONTransactionBackup(actions, device, jobname, target,\n                                            bitmap, syncmode);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransactionBackup(virJSONValuePtr actions,\n                             const char *device,\n                             const char *jobname,\n                             const char *target,\n                             const char *bitmap,\n                             qemuMonitorTransactionBackupSyncMode syncmode)\n{\n    return qemuMonitorJSONTransactionBackup(actions, device, jobname, target,\n                                            bitmap, syncmode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic int\nqemuBackupDiskPrepareDataOnePush(virJSONValuePtr actions,\n                                 struct qemuBackupDiskData *dd)\n{\n    qemuMonitorTransactionBackupSyncMode syncmode = QEMU_MONITOR_TRANSACTION_BACKUP_SYNC_MODE_FULL;\n\n    if (dd->incrementalBitmap)\n        syncmode = QEMU_MONITOR_TRANSACTION_BACKUP_SYNC_MODE_INCREMENTAL;\n\n    if (qemuMonitorTransactionBackup(actions,\n                                     dd->domdisk->src->nodeformat,\n                                     dd->blockjob->name,\n                                     dd->store->nodeformat,\n                                     dd->incrementalBitmap,\n                                     syncmode) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuBackupDiskPrepareDataOne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "293-345",
    "snippet": "static int\nqemuBackupDiskPrepareDataOne(virDomainObjPtr vm,\n                             virDomainBackupDiskDefPtr backupdisk,\n                             struct qemuBackupDiskData *dd,\n                             virJSONValuePtr actions,\n                             virDomainMomentDefPtr *incremental,\n                             virHashTablePtr blockNamedNodeData,\n                             virQEMUDriverConfigPtr cfg)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    /* set data structure */\n    dd->backupdisk = backupdisk;\n    dd->store = dd->backupdisk->store;\n\n    if (!(dd->domdisk = virDomainDiskByTarget(vm->def, dd->backupdisk->name))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"no disk named '%s'\"), dd->backupdisk->name);\n        return -1;\n    }\n\n    if (!dd->store->format)\n        dd->store->format = VIR_STORAGE_FILE_QCOW2;\n\n    if (qemuDomainStorageFileInit(priv->driver, vm, dd->store, dd->domdisk->src) < 0)\n        return -1;\n\n    if (qemuDomainPrepareStorageSourceBlockdev(NULL, dd->store, priv, cfg) < 0)\n        return -1;\n\n    if (incremental) {\n        if (dd->backupdisk->exportbitmap)\n            dd->incrementalBitmap = g_strdup(dd->backupdisk->exportbitmap);\n        else\n            dd->incrementalBitmap = g_strdup_printf(\"backup-%s\", dd->domdisk->dst);\n\n        if (qemuBackupDiskPrepareOneBitmaps(dd, actions, incremental,\n                                            blockNamedNodeData) < 0)\n            return -1;\n    }\n\n    if (!(dd->blockjob = qemuBlockJobDiskNewBackup(vm, dd->domdisk, dd->store,\n                                                   dd->incrementalBitmap)))\n        return -1;\n\n    /* use original disk as backing to prevent opening the backing chain */\n    if (!(dd->crdata = qemuBuildStorageSourceChainAttachPrepareBlockdevTop(dd->store,\n                                                                           dd->domdisk->src,\n                                                                           priv->qemuCaps)))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuBuildStorageSourceChainAttachPrepareBlockdevTop",
          "args": [
            "dd->store",
            "dd->domdisk->src",
            "priv->qemuCaps"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBuildStorageSourceChainAttachPrepareBlockdevTop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_command.c",
          "lines": "10442-10457",
          "snippet": "qemuBlockStorageSourceChainDataPtr\nqemuBuildStorageSourceChainAttachPrepareBlockdevTop(virStorageSourcePtr top,\n                                                    virStorageSourcePtr backingStore,\n                                                    virQEMUCapsPtr qemuCaps)\n{\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    if (qemuBuildStorageSourceChainAttachPrepareBlockdevOne(data, top, backingStore,\n                                                            qemuCaps) < 0)\n        return NULL;\n\n    return g_steal_pointer(&data);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include \"virutil.h\"",
            "#include \"logging/log_manager.h\"",
            "# include <linux/capability.h>",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virgic.h\"",
            "#include \"virnuma.h\"",
            "#include \"virscsi.h\"",
            "#include \"virtpm.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"device_conf.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"secret_conf.h\"",
            "#include \"storage_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_addr.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/stat.h>\n#include \"virutil.h\"\n#include \"logging/log_manager.h\"\n# include <linux/capability.h>\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virgic.h\"\n#include \"virnuma.h\"\n#include \"virscsi.h\"\n#include \"virtpm.h\"\n#include \"virstoragefile.h\"\n#include \"device_conf.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"secret_conf.h\"\n#include \"storage_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_audit.h\"\n#include \"domain_addr.h\"\n#include \"domain_nwfilter.h\"\n#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virarch.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include <config.h>\n\nqemuBlockStorageSourceChainDataPtr\nqemuBuildStorageSourceChainAttachPrepareBlockdevTop(virStorageSourcePtr top,\n                                                    virStorageSourcePtr backingStore,\n                                                    virQEMUCapsPtr qemuCaps)\n{\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    if (qemuBuildStorageSourceChainAttachPrepareBlockdevOne(data, top, backingStore,\n                                                            qemuCaps) < 0)\n        return NULL;\n\n    return g_steal_pointer(&data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDiskNewBackup",
          "args": [
            "vm",
            "dd->domdisk",
            "dd->store",
            "dd->incrementalBitmap"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDiskNewBackup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "390-413",
          "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDiskNewBackup(virDomainObjPtr vm,\n                          virDomainDiskDefPtr disk,\n                          virStorageSourcePtr store,\n                          const char *bitmap)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n    g_autofree char *jobname = NULL;\n\n    jobname = g_strdup_printf(\"backup-%s-%s\", disk->dst, disk->src->nodeformat);\n\n    if (!(job = qemuBlockJobDataNew(QEMU_BLOCKJOB_TYPE_BACKUP, jobname)))\n        return NULL;\n\n    job->data.backup.bitmap = g_strdup(bitmap);\n    job->data.backup.store = virObjectRef(store);\n\n    /* backup jobs are usually started in bulk by transaction so the caller\n     * shall save the status XML */\n    if (qemuBlockJobRegister(job, vm, disk, false) < 0)\n        return NULL;\n\n    return g_steal_pointer(&job);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockJobDataPtr\nqemuBlockJobDiskNewBackup(virDomainObjPtr vm,\n                          virDomainDiskDefPtr disk,\n                          virStorageSourcePtr store,\n                          const char *bitmap)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n    g_autofree char *jobname = NULL;\n\n    jobname = g_strdup_printf(\"backup-%s-%s\", disk->dst, disk->src->nodeformat);\n\n    if (!(job = qemuBlockJobDataNew(QEMU_BLOCKJOB_TYPE_BACKUP, jobname)))\n        return NULL;\n\n    job->data.backup.bitmap = g_strdup(bitmap);\n    job->data.backup.store = virObjectRef(store);\n\n    /* backup jobs are usually started in bulk by transaction so the caller\n     * shall save the status XML */\n    if (qemuBlockJobRegister(job, vm, disk, false) < 0)\n        return NULL;\n\n    return g_steal_pointer(&job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBackupDiskPrepareOneBitmaps",
          "args": [
            "dd",
            "actions",
            "incremental",
            "blockNamedNodeData"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupDiskPrepareOneBitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "245-290",
          "snippet": "static int\nqemuBackupDiskPrepareOneBitmaps(struct qemuBackupDiskData *dd,\n                                virJSONValuePtr actions,\n                                virDomainMomentDefPtr *incremental,\n                                virHashTablePtr blockNamedNodeData)\n{\n    g_autoptr(virJSONValue) mergebitmaps = NULL;\n    g_autoptr(virJSONValue) mergebitmapsstore = NULL;\n\n    if (!(mergebitmaps = qemuBackupDiskPrepareOneBitmapsChain(incremental,\n                                                              dd->domdisk->src,\n                                                              blockNamedNodeData,\n                                                              dd->domdisk->dst)))\n        return -1;\n\n    if (!(mergebitmapsstore = virJSONValueCopy(mergebitmaps)))\n        return -1;\n\n    if (qemuMonitorTransactionBitmapAdd(actions,\n                                        dd->domdisk->src->nodeformat,\n                                        dd->incrementalBitmap,\n                                        false,\n                                        true, 0) < 0)\n        return -1;\n\n    if (qemuMonitorTransactionBitmapMerge(actions,\n                                          dd->domdisk->src->nodeformat,\n                                          dd->incrementalBitmap,\n                                          &mergebitmaps) < 0)\n        return -1;\n\n    if (qemuMonitorTransactionBitmapAdd(actions,\n                                        dd->store->nodeformat,\n                                        dd->incrementalBitmap,\n                                        false,\n                                        true, 0) < 0)\n        return -1;\n\n    if (qemuMonitorTransactionBitmapMerge(actions,\n                                          dd->store->nodeformat,\n                                          dd->incrementalBitmap,\n                                          &mergebitmapsstore) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic int\nqemuBackupDiskPrepareOneBitmaps(struct qemuBackupDiskData *dd,\n                                virJSONValuePtr actions,\n                                virDomainMomentDefPtr *incremental,\n                                virHashTablePtr blockNamedNodeData)\n{\n    g_autoptr(virJSONValue) mergebitmaps = NULL;\n    g_autoptr(virJSONValue) mergebitmapsstore = NULL;\n\n    if (!(mergebitmaps = qemuBackupDiskPrepareOneBitmapsChain(incremental,\n                                                              dd->domdisk->src,\n                                                              blockNamedNodeData,\n                                                              dd->domdisk->dst)))\n        return -1;\n\n    if (!(mergebitmapsstore = virJSONValueCopy(mergebitmaps)))\n        return -1;\n\n    if (qemuMonitorTransactionBitmapAdd(actions,\n                                        dd->domdisk->src->nodeformat,\n                                        dd->incrementalBitmap,\n                                        false,\n                                        true, 0) < 0)\n        return -1;\n\n    if (qemuMonitorTransactionBitmapMerge(actions,\n                                          dd->domdisk->src->nodeformat,\n                                          dd->incrementalBitmap,\n                                          &mergebitmaps) < 0)\n        return -1;\n\n    if (qemuMonitorTransactionBitmapAdd(actions,\n                                        dd->store->nodeformat,\n                                        dd->incrementalBitmap,\n                                        false,\n                                        true, 0) < 0)\n        return -1;\n\n    if (qemuMonitorTransactionBitmapMerge(actions,\n                                          dd->store->nodeformat,\n                                          dd->incrementalBitmap,\n                                          &mergebitmapsstore) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"backup-%s\"",
            "dd->domdisk->dst"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainPrepareStorageSourceBlockdev",
          "args": [
            "NULL",
            "dd->store",
            "priv",
            "cfg"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainPrepareStorageSourceBlockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "16590-16623",
          "snippet": "int\nqemuDomainPrepareStorageSourceBlockdev(virDomainDiskDefPtr disk,\n                                       virStorageSourcePtr src,\n                                       qemuDomainObjPrivatePtr priv,\n                                       virQEMUDriverConfigPtr cfg)\n{\n    src->id = qemuDomainStorageIdNew(priv);\n\n    src->nodestorage = g_strdup_printf(\"libvirt-%u-storage\", src->id);\n    src->nodeformat = g_strdup_printf(\"libvirt-%u-format\", src->id);\n\n    if (qemuBlockStorageSourceNeedsStorageSliceLayer(src))\n        src->sliceStorage->nodename = g_strdup_printf(\"libvirt-%u-slice-sto\", src->id);\n\n    if (qemuDomainValidateStorageSource(src, priv->qemuCaps) < 0)\n        return -1;\n\n    qemuDomainPrepareStorageSourceConfig(src, cfg, priv->qemuCaps);\n    qemuDomainPrepareDiskSourceData(disk, src);\n\n    if (qemuDomainSecretStorageSourcePrepare(priv, src,\n                                             src->nodestorage,\n                                             src->nodeformat) < 0)\n        return -1;\n\n    if (qemuDomainPrepareStorageSourcePR(src, priv, src->nodestorage) < 0)\n        return -1;\n\n    if (qemuDomainPrepareStorageSourceTLS(src, cfg, src->nodestorage,\n                                          priv->qemuCaps) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainPrepareStorageSourceBlockdev(virDomainDiskDefPtr disk,\n                                       virStorageSourcePtr src,\n                                       qemuDomainObjPrivatePtr priv,\n                                       virQEMUDriverConfigPtr cfg)\n{\n    src->id = qemuDomainStorageIdNew(priv);\n\n    src->nodestorage = g_strdup_printf(\"libvirt-%u-storage\", src->id);\n    src->nodeformat = g_strdup_printf(\"libvirt-%u-format\", src->id);\n\n    if (qemuBlockStorageSourceNeedsStorageSliceLayer(src))\n        src->sliceStorage->nodename = g_strdup_printf(\"libvirt-%u-slice-sto\", src->id);\n\n    if (qemuDomainValidateStorageSource(src, priv->qemuCaps) < 0)\n        return -1;\n\n    qemuDomainPrepareStorageSourceConfig(src, cfg, priv->qemuCaps);\n    qemuDomainPrepareDiskSourceData(disk, src);\n\n    if (qemuDomainSecretStorageSourcePrepare(priv, src,\n                                             src->nodestorage,\n                                             src->nodeformat) < 0)\n        return -1;\n\n    if (qemuDomainPrepareStorageSourcePR(src, priv, src->nodestorage) < 0)\n        return -1;\n\n    if (qemuDomainPrepareStorageSourceTLS(src, cfg, src->nodestorage,\n                                          priv->qemuCaps) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainStorageFileInit",
          "args": [
            "priv->driver",
            "vm",
            "dd->store",
            "dd->domdisk->src"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainStorageFileInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "11565-11581",
          "snippet": "int\nqemuDomainStorageFileInit(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          virStorageSourcePtr src,\n                          virStorageSourcePtr parent)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    uid_t uid;\n    gid_t gid;\n\n    qemuDomainGetImageIds(cfg, vm, src, parent, &uid, &gid);\n\n    if (virStorageFileInitAs(src, uid, gid) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainStorageFileInit(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          virStorageSourcePtr src,\n                          virStorageSourcePtr parent)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    uid_t uid;\n    gid_t gid;\n\n    qemuDomainGetImageIds(cfg, vm, src, parent, &uid, &gid);\n\n    if (virStorageFileInitAs(src, uid, gid) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"no disk named '%s'\")",
            "dd->backupdisk->name"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no disk named '%s'\""
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskByTarget",
          "args": [
            "vm->def",
            "dd->backupdisk->name"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskByTarget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17337-17349",
          "snippet": "virDomainDiskDefPtr\nvirDomainDiskByTarget(virDomainDefPtr def,\n                      const char *dst)\n{\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (STREQ(def->disks[i]->dst, dst))\n            return def->disks[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDiskDefPtr\nvirDomainDiskByTarget(virDomainDefPtr def,\n                      const char *dst)\n{\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (STREQ(def->disks[i]->dst, dst))\n            return def->disks[i];\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic int\nqemuBackupDiskPrepareDataOne(virDomainObjPtr vm,\n                             virDomainBackupDiskDefPtr backupdisk,\n                             struct qemuBackupDiskData *dd,\n                             virJSONValuePtr actions,\n                             virDomainMomentDefPtr *incremental,\n                             virHashTablePtr blockNamedNodeData,\n                             virQEMUDriverConfigPtr cfg)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    /* set data structure */\n    dd->backupdisk = backupdisk;\n    dd->store = dd->backupdisk->store;\n\n    if (!(dd->domdisk = virDomainDiskByTarget(vm->def, dd->backupdisk->name))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"no disk named '%s'\"), dd->backupdisk->name);\n        return -1;\n    }\n\n    if (!dd->store->format)\n        dd->store->format = VIR_STORAGE_FILE_QCOW2;\n\n    if (qemuDomainStorageFileInit(priv->driver, vm, dd->store, dd->domdisk->src) < 0)\n        return -1;\n\n    if (qemuDomainPrepareStorageSourceBlockdev(NULL, dd->store, priv, cfg) < 0)\n        return -1;\n\n    if (incremental) {\n        if (dd->backupdisk->exportbitmap)\n            dd->incrementalBitmap = g_strdup(dd->backupdisk->exportbitmap);\n        else\n            dd->incrementalBitmap = g_strdup_printf(\"backup-%s\", dd->domdisk->dst);\n\n        if (qemuBackupDiskPrepareOneBitmaps(dd, actions, incremental,\n                                            blockNamedNodeData) < 0)\n            return -1;\n    }\n\n    if (!(dd->blockjob = qemuBlockJobDiskNewBackup(vm, dd->domdisk, dd->store,\n                                                   dd->incrementalBitmap)))\n        return -1;\n\n    /* use original disk as backing to prevent opening the backing chain */\n    if (!(dd->crdata = qemuBuildStorageSourceChainAttachPrepareBlockdevTop(dd->store,\n                                                                           dd->domdisk->src,\n                                                                           priv->qemuCaps)))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuBackupDiskPrepareOneBitmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "245-290",
    "snippet": "static int\nqemuBackupDiskPrepareOneBitmaps(struct qemuBackupDiskData *dd,\n                                virJSONValuePtr actions,\n                                virDomainMomentDefPtr *incremental,\n                                virHashTablePtr blockNamedNodeData)\n{\n    g_autoptr(virJSONValue) mergebitmaps = NULL;\n    g_autoptr(virJSONValue) mergebitmapsstore = NULL;\n\n    if (!(mergebitmaps = qemuBackupDiskPrepareOneBitmapsChain(incremental,\n                                                              dd->domdisk->src,\n                                                              blockNamedNodeData,\n                                                              dd->domdisk->dst)))\n        return -1;\n\n    if (!(mergebitmapsstore = virJSONValueCopy(mergebitmaps)))\n        return -1;\n\n    if (qemuMonitorTransactionBitmapAdd(actions,\n                                        dd->domdisk->src->nodeformat,\n                                        dd->incrementalBitmap,\n                                        false,\n                                        true, 0) < 0)\n        return -1;\n\n    if (qemuMonitorTransactionBitmapMerge(actions,\n                                          dd->domdisk->src->nodeformat,\n                                          dd->incrementalBitmap,\n                                          &mergebitmaps) < 0)\n        return -1;\n\n    if (qemuMonitorTransactionBitmapAdd(actions,\n                                        dd->store->nodeformat,\n                                        dd->incrementalBitmap,\n                                        false,\n                                        true, 0) < 0)\n        return -1;\n\n    if (qemuMonitorTransactionBitmapMerge(actions,\n                                          dd->store->nodeformat,\n                                          dd->incrementalBitmap,\n                                          &mergebitmapsstore) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorTransactionBitmapMerge",
          "args": [
            "actions",
            "dd->store->nodeformat",
            "dd->incrementalBitmap",
            "&mergebitmapsstore"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTransactionBitmapMerge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "4538-4545",
          "snippet": "int\nqemuMonitorTransactionBitmapMerge(virJSONValuePtr actions,\n                                  const char *node,\n                                  const char *target,\n                                  virJSONValuePtr *sources)\n{\n    return qemuMonitorJSONTransactionBitmapMerge(actions, node, target, sources);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransactionBitmapMerge(virJSONValuePtr actions,\n                                  const char *node,\n                                  const char *target,\n                                  virJSONValuePtr *sources)\n{\n    return qemuMonitorJSONTransactionBitmapMerge(actions, node, target, sources);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorTransactionBitmapAdd",
          "args": [
            "actions",
            "dd->store->nodeformat",
            "dd->incrementalBitmap",
            "false",
            "true",
            "0"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTransactionBitmapAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "4498-4508",
          "snippet": "int\nqemuMonitorTransactionBitmapAdd(virJSONValuePtr actions,\n                                const char *node,\n                                const char *name,\n                                bool persistent,\n                                bool disabled,\n                                unsigned long long granularity)\n{\n    return qemuMonitorJSONTransactionBitmapAdd(actions, node, name, persistent,\n                                               disabled, granularity);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransactionBitmapAdd(virJSONValuePtr actions,\n                                const char *node,\n                                const char *name,\n                                bool persistent,\n                                bool disabled,\n                                unsigned long long granularity)\n{\n    return qemuMonitorJSONTransactionBitmapAdd(actions, node, name, persistent,\n                                               disabled, granularity);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueCopy",
          "args": [
            "mergebitmaps"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1490-1546",
          "snippet": "virJSONValuePtr\nvirJSONValueCopy(const virJSONValue *in)\n{\n    size_t i;\n    virJSONValuePtr out = NULL;\n\n    if (!in)\n        return NULL;\n\n    switch ((virJSONType) in->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        out = virJSONValueNewObject();\n        for (i = 0; i < in->data.object.npairs; i++) {\n            virJSONValuePtr val = NULL;\n            if (!(val = virJSONValueCopy(in->data.object.pairs[i].value)))\n                goto error;\n            if (virJSONValueObjectAppend(out, in->data.object.pairs[i].key,\n                                         val) < 0) {\n                virJSONValueFree(val);\n                goto error;\n            }\n        }\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        out = virJSONValueNewArray();\n        for (i = 0; i < in->data.array.nvalues; i++) {\n            virJSONValuePtr val = NULL;\n            if (!(val = virJSONValueCopy(in->data.array.values[i])))\n                goto error;\n            if (virJSONValueArrayAppend(out, val) < 0) {\n                virJSONValueFree(val);\n                goto error;\n            }\n        }\n        break;\n\n    /* No need to error out in the following cases */\n    case VIR_JSON_TYPE_STRING:\n        out = virJSONValueNewString(in->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        out = virJSONValueNewNumber(in->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n        out = virJSONValueNewBoolean(in->data.boolean);\n        break;\n    case VIR_JSON_TYPE_NULL:\n        out = virJSONValueNewNull();\n        break;\n    }\n\n    return out;\n\n error:\n    virJSONValueFree(out);\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueCopy(const virJSONValue *in)\n{\n    size_t i;\n    virJSONValuePtr out = NULL;\n\n    if (!in)\n        return NULL;\n\n    switch ((virJSONType) in->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        out = virJSONValueNewObject();\n        for (i = 0; i < in->data.object.npairs; i++) {\n            virJSONValuePtr val = NULL;\n            if (!(val = virJSONValueCopy(in->data.object.pairs[i].value)))\n                goto error;\n            if (virJSONValueObjectAppend(out, in->data.object.pairs[i].key,\n                                         val) < 0) {\n                virJSONValueFree(val);\n                goto error;\n            }\n        }\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        out = virJSONValueNewArray();\n        for (i = 0; i < in->data.array.nvalues; i++) {\n            virJSONValuePtr val = NULL;\n            if (!(val = virJSONValueCopy(in->data.array.values[i])))\n                goto error;\n            if (virJSONValueArrayAppend(out, val) < 0) {\n                virJSONValueFree(val);\n                goto error;\n            }\n        }\n        break;\n\n    /* No need to error out in the following cases */\n    case VIR_JSON_TYPE_STRING:\n        out = virJSONValueNewString(in->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        out = virJSONValueNewNumber(in->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n        out = virJSONValueNewBoolean(in->data.boolean);\n        break;\n    case VIR_JSON_TYPE_NULL:\n        out = virJSONValueNewNull();\n        break;\n    }\n\n    return out;\n\n error:\n    virJSONValueFree(out);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBackupDiskPrepareOneBitmapsChain",
          "args": [
            "incremental",
            "dd->domdisk->src",
            "blockNamedNodeData",
            "dd->domdisk->dst"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupDiskPrepareOneBitmapsChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "173-242",
          "snippet": "virJSONValuePtr\nqemuBackupDiskPrepareOneBitmapsChain(virDomainMomentDefPtr *incremental,\n                                     virStorageSourcePtr backingChain,\n                                     virHashTablePtr blockNamedNodeData,\n                                     const char *diskdst)\n{\n    qemuBlockNamedNodeDataBitmapPtr bitmap;\n    g_autoptr(virJSONValue) ret = NULL;\n    size_t incridx = 0;\n\n    ret = virJSONValueNewArray();\n\n    if (!(bitmap = qemuBlockNamedNodeDataGetBitmapByName(blockNamedNodeData,\n                                                         backingChain,\n                                                         incremental[0]->name))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"failed to find bitmap '%s' in image '%s%u'\"),\n                       incremental[0]->name, diskdst, backingChain->id);\n        return NULL;\n    }\n\n    while (bitmap) {\n        if (bitmap->inconsistent) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"bitmap '%s' for image '%s%u' is inconsistent\"),\n                           bitmap->name, diskdst, backingChain->id);\n            return NULL;\n        }\n\n        if (qemuMonitorTransactionBitmapMergeSourceAddBitmap(ret,\n                                                             backingChain->nodeformat,\n                                                             bitmap->name) < 0)\n            return NULL;\n\n        if (backingChain->backingStore &&\n            (bitmap = qemuBlockNamedNodeDataGetBitmapByName(blockNamedNodeData,\n                                                            backingChain->backingStore,\n                                                            incremental[incridx]->name))) {\n            backingChain = backingChain->backingStore;\n            continue;\n        }\n\n        if (incremental[incridx + 1]) {\n            if ((bitmap = qemuBlockNamedNodeDataGetBitmapByName(blockNamedNodeData,\n                                                                backingChain,\n                                                                incremental[incridx + 1]->name))) {\n                incridx++;\n                continue;\n            }\n\n            if (backingChain->backingStore &&\n                (bitmap = qemuBlockNamedNodeDataGetBitmapByName(blockNamedNodeData,\n                                                                backingChain->backingStore,\n                                                                incremental[incridx + 1]->name))) {\n                incridx++;\n                backingChain = backingChain->backingStore;\n                continue;\n            }\n\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"failed to find bitmap '%s' in image '%s%u'\"),\n                           incremental[incridx]->name, diskdst, backingChain->id);\n            return NULL;\n        } else {\n            break;\n        }\n    }\n\n    return g_steal_pointer(&ret);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvirJSONValuePtr\nqemuBackupDiskPrepareOneBitmapsChain(virDomainMomentDefPtr *incremental,\n                                     virStorageSourcePtr backingChain,\n                                     virHashTablePtr blockNamedNodeData,\n                                     const char *diskdst)\n{\n    qemuBlockNamedNodeDataBitmapPtr bitmap;\n    g_autoptr(virJSONValue) ret = NULL;\n    size_t incridx = 0;\n\n    ret = virJSONValueNewArray();\n\n    if (!(bitmap = qemuBlockNamedNodeDataGetBitmapByName(blockNamedNodeData,\n                                                         backingChain,\n                                                         incremental[0]->name))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"failed to find bitmap '%s' in image '%s%u'\"),\n                       incremental[0]->name, diskdst, backingChain->id);\n        return NULL;\n    }\n\n    while (bitmap) {\n        if (bitmap->inconsistent) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"bitmap '%s' for image '%s%u' is inconsistent\"),\n                           bitmap->name, diskdst, backingChain->id);\n            return NULL;\n        }\n\n        if (qemuMonitorTransactionBitmapMergeSourceAddBitmap(ret,\n                                                             backingChain->nodeformat,\n                                                             bitmap->name) < 0)\n            return NULL;\n\n        if (backingChain->backingStore &&\n            (bitmap = qemuBlockNamedNodeDataGetBitmapByName(blockNamedNodeData,\n                                                            backingChain->backingStore,\n                                                            incremental[incridx]->name))) {\n            backingChain = backingChain->backingStore;\n            continue;\n        }\n\n        if (incremental[incridx + 1]) {\n            if ((bitmap = qemuBlockNamedNodeDataGetBitmapByName(blockNamedNodeData,\n                                                                backingChain,\n                                                                incremental[incridx + 1]->name))) {\n                incridx++;\n                continue;\n            }\n\n            if (backingChain->backingStore &&\n                (bitmap = qemuBlockNamedNodeDataGetBitmapByName(blockNamedNodeData,\n                                                                backingChain->backingStore,\n                                                                incremental[incridx + 1]->name))) {\n                incridx++;\n                backingChain = backingChain->backingStore;\n                continue;\n            }\n\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"failed to find bitmap '%s' in image '%s%u'\"),\n                           incremental[incridx]->name, diskdst, backingChain->id);\n            return NULL;\n        } else {\n            break;\n        }\n    }\n\n    return g_steal_pointer(&ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic int\nqemuBackupDiskPrepareOneBitmaps(struct qemuBackupDiskData *dd,\n                                virJSONValuePtr actions,\n                                virDomainMomentDefPtr *incremental,\n                                virHashTablePtr blockNamedNodeData)\n{\n    g_autoptr(virJSONValue) mergebitmaps = NULL;\n    g_autoptr(virJSONValue) mergebitmapsstore = NULL;\n\n    if (!(mergebitmaps = qemuBackupDiskPrepareOneBitmapsChain(incremental,\n                                                              dd->domdisk->src,\n                                                              blockNamedNodeData,\n                                                              dd->domdisk->dst)))\n        return -1;\n\n    if (!(mergebitmapsstore = virJSONValueCopy(mergebitmaps)))\n        return -1;\n\n    if (qemuMonitorTransactionBitmapAdd(actions,\n                                        dd->domdisk->src->nodeformat,\n                                        dd->incrementalBitmap,\n                                        false,\n                                        true, 0) < 0)\n        return -1;\n\n    if (qemuMonitorTransactionBitmapMerge(actions,\n                                          dd->domdisk->src->nodeformat,\n                                          dd->incrementalBitmap,\n                                          &mergebitmaps) < 0)\n        return -1;\n\n    if (qemuMonitorTransactionBitmapAdd(actions,\n                                        dd->store->nodeformat,\n                                        dd->incrementalBitmap,\n                                        false,\n                                        true, 0) < 0)\n        return -1;\n\n    if (qemuMonitorTransactionBitmapMerge(actions,\n                                          dd->store->nodeformat,\n                                          dd->incrementalBitmap,\n                                          &mergebitmapsstore) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuBackupDiskPrepareOneBitmapsChain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "173-242",
    "snippet": "virJSONValuePtr\nqemuBackupDiskPrepareOneBitmapsChain(virDomainMomentDefPtr *incremental,\n                                     virStorageSourcePtr backingChain,\n                                     virHashTablePtr blockNamedNodeData,\n                                     const char *diskdst)\n{\n    qemuBlockNamedNodeDataBitmapPtr bitmap;\n    g_autoptr(virJSONValue) ret = NULL;\n    size_t incridx = 0;\n\n    ret = virJSONValueNewArray();\n\n    if (!(bitmap = qemuBlockNamedNodeDataGetBitmapByName(blockNamedNodeData,\n                                                         backingChain,\n                                                         incremental[0]->name))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"failed to find bitmap '%s' in image '%s%u'\"),\n                       incremental[0]->name, diskdst, backingChain->id);\n        return NULL;\n    }\n\n    while (bitmap) {\n        if (bitmap->inconsistent) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"bitmap '%s' for image '%s%u' is inconsistent\"),\n                           bitmap->name, diskdst, backingChain->id);\n            return NULL;\n        }\n\n        if (qemuMonitorTransactionBitmapMergeSourceAddBitmap(ret,\n                                                             backingChain->nodeformat,\n                                                             bitmap->name) < 0)\n            return NULL;\n\n        if (backingChain->backingStore &&\n            (bitmap = qemuBlockNamedNodeDataGetBitmapByName(blockNamedNodeData,\n                                                            backingChain->backingStore,\n                                                            incremental[incridx]->name))) {\n            backingChain = backingChain->backingStore;\n            continue;\n        }\n\n        if (incremental[incridx + 1]) {\n            if ((bitmap = qemuBlockNamedNodeDataGetBitmapByName(blockNamedNodeData,\n                                                                backingChain,\n                                                                incremental[incridx + 1]->name))) {\n                incridx++;\n                continue;\n            }\n\n            if (backingChain->backingStore &&\n                (bitmap = qemuBlockNamedNodeDataGetBitmapByName(blockNamedNodeData,\n                                                                backingChain->backingStore,\n                                                                incremental[incridx + 1]->name))) {\n                incridx++;\n                backingChain = backingChain->backingStore;\n                continue;\n            }\n\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"failed to find bitmap '%s' in image '%s%u'\"),\n                           incremental[incridx]->name, diskdst, backingChain->id);\n            return NULL;\n        } else {\n            break;\n        }\n    }\n\n    return g_steal_pointer(&ret);\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&ret"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"failed to find bitmap '%s' in image '%s%u'\")",
            "incremental[incridx]->name",
            "diskdst",
            "backingChain->id"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to find bitmap '%s' in image '%s%u'\""
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockNamedNodeDataGetBitmapByName",
          "args": [
            "blockNamedNodeData",
            "backingChain->backingStore",
            "incremental[incridx + 1]->name"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockNamedNodeDataGetBitmapByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "2781-2802",
          "snippet": "qemuBlockNamedNodeDataBitmapPtr\nqemuBlockNamedNodeDataGetBitmapByName(virHashTablePtr blockNamedNodeData,\n                                      virStorageSourcePtr src,\n                                      const char *bitmap)\n{\n    qemuBlockNamedNodeDataPtr nodedata;\n    size_t i;\n\n    if (!(nodedata = virHashLookup(blockNamedNodeData, src->nodeformat)))\n        return NULL;\n\n    for (i = 0; i < nodedata->nbitmaps; i++) {\n        qemuBlockNamedNodeDataBitmapPtr bitmapdata = nodedata->bitmaps[i];\n\n        if (STRNEQ(bitmapdata->name, bitmap))\n            continue;\n\n        return bitmapdata;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nqemuBlockNamedNodeDataBitmapPtr\nqemuBlockNamedNodeDataGetBitmapByName(virHashTablePtr blockNamedNodeData,\n                                      virStorageSourcePtr src,\n                                      const char *bitmap)\n{\n    qemuBlockNamedNodeDataPtr nodedata;\n    size_t i;\n\n    if (!(nodedata = virHashLookup(blockNamedNodeData, src->nodeformat)))\n        return NULL;\n\n    for (i = 0; i < nodedata->nbitmaps; i++) {\n        qemuBlockNamedNodeDataBitmapPtr bitmapdata = nodedata->bitmaps[i];\n\n        if (STRNEQ(bitmapdata->name, bitmap))\n            continue;\n\n        return bitmapdata;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorTransactionBitmapMergeSourceAddBitmap",
          "args": [
            "ret",
            "backingChain->nodeformat",
            "bitmap->name"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTransactionBitmapMergeSourceAddBitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "4548-4554",
          "snippet": "int\nqemuMonitorTransactionBitmapMergeSourceAddBitmap(virJSONValuePtr sources,\n                                                 const char *sourcenode,\n                                                 const char *sourcebitmap)\n{\n    return qemuMonitorJSONTransactionBitmapMergeSourceAddBitmap(sources, sourcenode, sourcebitmap);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransactionBitmapMergeSourceAddBitmap(virJSONValuePtr sources,\n                                                 const char *sourcenode,\n                                                 const char *sourcebitmap)\n{\n    return qemuMonitorJSONTransactionBitmapMergeSourceAddBitmap(sources, sourcenode, sourcebitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"bitmap '%s' for image '%s%u' is inconsistent\")",
            "bitmap->name",
            "diskdst",
            "backingChain->id"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"failed to find bitmap '%s' in image '%s%u'\")",
            "incremental[0]->name",
            "diskdst",
            "backingChain->id"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueNewArray",
          "args": [],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "560-568",
          "snippet": "virJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvirJSONValuePtr\nqemuBackupDiskPrepareOneBitmapsChain(virDomainMomentDefPtr *incremental,\n                                     virStorageSourcePtr backingChain,\n                                     virHashTablePtr blockNamedNodeData,\n                                     const char *diskdst)\n{\n    qemuBlockNamedNodeDataBitmapPtr bitmap;\n    g_autoptr(virJSONValue) ret = NULL;\n    size_t incridx = 0;\n\n    ret = virJSONValueNewArray();\n\n    if (!(bitmap = qemuBlockNamedNodeDataGetBitmapByName(blockNamedNodeData,\n                                                         backingChain,\n                                                         incremental[0]->name))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"failed to find bitmap '%s' in image '%s%u'\"),\n                       incremental[0]->name, diskdst, backingChain->id);\n        return NULL;\n    }\n\n    while (bitmap) {\n        if (bitmap->inconsistent) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"bitmap '%s' for image '%s%u' is inconsistent\"),\n                           bitmap->name, diskdst, backingChain->id);\n            return NULL;\n        }\n\n        if (qemuMonitorTransactionBitmapMergeSourceAddBitmap(ret,\n                                                             backingChain->nodeformat,\n                                                             bitmap->name) < 0)\n            return NULL;\n\n        if (backingChain->backingStore &&\n            (bitmap = qemuBlockNamedNodeDataGetBitmapByName(blockNamedNodeData,\n                                                            backingChain->backingStore,\n                                                            incremental[incridx]->name))) {\n            backingChain = backingChain->backingStore;\n            continue;\n        }\n\n        if (incremental[incridx + 1]) {\n            if ((bitmap = qemuBlockNamedNodeDataGetBitmapByName(blockNamedNodeData,\n                                                                backingChain,\n                                                                incremental[incridx + 1]->name))) {\n                incridx++;\n                continue;\n            }\n\n            if (backingChain->backingStore &&\n                (bitmap = qemuBlockNamedNodeDataGetBitmapByName(blockNamedNodeData,\n                                                                backingChain->backingStore,\n                                                                incremental[incridx + 1]->name))) {\n                incridx++;\n                backingChain = backingChain->backingStore;\n                continue;\n            }\n\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"failed to find bitmap '%s' in image '%s%u'\"),\n                           incremental[incridx]->name, diskdst, backingChain->id);\n            return NULL;\n        } else {\n            break;\n        }\n    }\n\n    return g_steal_pointer(&ret);\n}"
  },
  {
    "function_name": "qemuBackupDiskDataCleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "152-170",
    "snippet": "static void\nqemuBackupDiskDataCleanup(virDomainObjPtr vm,\n                          struct qemuBackupDiskData *dd,\n                          size_t ndd)\n{\n    virErrorPtr orig_err;\n    size_t i;\n\n    if (!dd)\n        return;\n\n    virErrorPreserveLast(&orig_err);\n\n    for (i = 0; i < ndd; i++)\n        qemuBackupDiskDataCleanupOne(vm, dd + i);\n\n    g_free(dd);\n    virErrorRestore(&orig_err);\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&orig_err"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "dd"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuBackupDiskDataCleanupOne",
          "args": [
            "vm",
            "dd + i"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupDiskDataCleanupOne",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "119-149",
          "snippet": "static void\nqemuBackupDiskDataCleanupOne(virDomainObjPtr vm,\n                             struct qemuBackupDiskData *dd)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (dd->started)\n        return;\n\n    if (dd->added) {\n        qemuDomainObjEnterMonitor(priv->driver, vm);\n        qemuBlockStorageSourceAttachRollback(priv->mon, dd->crdata->srcdata[0]);\n        ignore_value(qemuDomainObjExitMonitor(priv->driver, vm));\n    }\n\n    if (dd->created) {\n        if (virStorageFileUnlink(dd->store) < 0)\n            VIR_WARN(\"Unable to remove just-created %s\", NULLSTR(dd->store->path));\n    }\n\n    if (dd->initialized)\n        virStorageFileDeinit(dd->store);\n\n    if (dd->labelled)\n        qemuDomainStorageSourceAccessRevoke(priv->driver, vm, dd->store);\n\n    if (dd->blockjob)\n        qemuBlockJobStartupFinalize(vm, dd->blockjob);\n\n    qemuBlockStorageSourceChainDataFree(dd->crdata);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic void\nqemuBackupDiskDataCleanupOne(virDomainObjPtr vm,\n                             struct qemuBackupDiskData *dd)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (dd->started)\n        return;\n\n    if (dd->added) {\n        qemuDomainObjEnterMonitor(priv->driver, vm);\n        qemuBlockStorageSourceAttachRollback(priv->mon, dd->crdata->srcdata[0]);\n        ignore_value(qemuDomainObjExitMonitor(priv->driver, vm));\n    }\n\n    if (dd->created) {\n        if (virStorageFileUnlink(dd->store) < 0)\n            VIR_WARN(\"Unable to remove just-created %s\", NULLSTR(dd->store->path));\n    }\n\n    if (dd->initialized)\n        virStorageFileDeinit(dd->store);\n\n    if (dd->labelled)\n        qemuDomainStorageSourceAccessRevoke(priv->driver, vm, dd->store);\n\n    if (dd->blockjob)\n        qemuBlockJobStartupFinalize(vm, dd->blockjob);\n\n    qemuBlockStorageSourceChainDataFree(dd->crdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&orig_err"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic void\nqemuBackupDiskDataCleanup(virDomainObjPtr vm,\n                          struct qemuBackupDiskData *dd,\n                          size_t ndd)\n{\n    virErrorPtr orig_err;\n    size_t i;\n\n    if (!dd)\n        return;\n\n    virErrorPreserveLast(&orig_err);\n\n    for (i = 0; i < ndd; i++)\n        qemuBackupDiskDataCleanupOne(vm, dd + i);\n\n    g_free(dd);\n    virErrorRestore(&orig_err);\n}"
  },
  {
    "function_name": "qemuBackupDiskDataCleanupOne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "119-149",
    "snippet": "static void\nqemuBackupDiskDataCleanupOne(virDomainObjPtr vm,\n                             struct qemuBackupDiskData *dd)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (dd->started)\n        return;\n\n    if (dd->added) {\n        qemuDomainObjEnterMonitor(priv->driver, vm);\n        qemuBlockStorageSourceAttachRollback(priv->mon, dd->crdata->srcdata[0]);\n        ignore_value(qemuDomainObjExitMonitor(priv->driver, vm));\n    }\n\n    if (dd->created) {\n        if (virStorageFileUnlink(dd->store) < 0)\n            VIR_WARN(\"Unable to remove just-created %s\", NULLSTR(dd->store->path));\n    }\n\n    if (dd->initialized)\n        virStorageFileDeinit(dd->store);\n\n    if (dd->labelled)\n        qemuDomainStorageSourceAccessRevoke(priv->driver, vm, dd->store);\n\n    if (dd->blockjob)\n        qemuBlockJobStartupFinalize(vm, dd->blockjob);\n\n    qemuBlockStorageSourceChainDataFree(dd->crdata);\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuBlockStorageSourceChainDataFree",
          "args": [
            "dd->crdata"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockStorageSourceChainDataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "1823-1836",
          "snippet": "void\nqemuBlockStorageSourceChainDataFree(qemuBlockStorageSourceChainDataPtr data)\n{\n    size_t i;\n\n    if (!data)\n        return;\n\n    for (i = 0; i < data->nsrcdata; i++)\n        qemuBlockStorageSourceAttachDataFree(data->srcdata[i]);\n\n    VIR_FREE(data->srcdata);\n    VIR_FREE(data);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvoid\nqemuBlockStorageSourceChainDataFree(qemuBlockStorageSourceChainDataPtr data)\n{\n    size_t i;\n\n    if (!data)\n        return;\n\n    for (i = 0; i < data->nsrcdata; i++)\n        qemuBlockStorageSourceAttachDataFree(data->srcdata[i]);\n\n    VIR_FREE(data->srcdata);\n    VIR_FREE(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobStartupFinalize",
          "args": [
            "vm",
            "dd->blockjob"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobStartupFinalize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "459-470",
          "snippet": "void\nqemuBlockJobStartupFinalize(virDomainObjPtr vm,\n                            qemuBlockJobDataPtr job)\n{\n    if (!job)\n        return;\n\n    if (job->state == QEMU_BLOCKJOB_STATE_NEW)\n        qemuBlockJobUnregister(job, vm);\n\n    virObjectUnref(job);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nqemuBlockJobStartupFinalize(virDomainObjPtr vm,\n                            qemuBlockJobDataPtr job)\n{\n    if (!job)\n        return;\n\n    if (job->state == QEMU_BLOCKJOB_STATE_NEW)\n        qemuBlockJobUnregister(job, vm);\n\n    virObjectUnref(job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainStorageSourceAccessRevoke",
          "args": [
            "priv->driver",
            "vm",
            "dd->store"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainStorageSourceAccessRevoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12082-12090",
          "snippet": "void\nqemuDomainStorageSourceAccessRevoke(virQEMUDriverPtr driver,\n                                    virDomainObjPtr vm,\n                                    virStorageSourcePtr elem)\n{\n    qemuDomainStorageSourceAccessFlags flags = QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_REVOKE;\n\n    ignore_value(qemuDomainStorageSourceAccessModify(driver, vm, elem, flags));\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nvoid\nqemuDomainStorageSourceAccessRevoke(virQEMUDriverPtr driver,\n                                    virDomainObjPtr vm,\n                                    virStorageSourcePtr elem)\n{\n    qemuDomainStorageSourceAccessFlags flags = QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_REVOKE;\n\n    ignore_value(qemuDomainStorageSourceAccessModify(driver, vm, elem, flags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileDeinit",
          "args": [
            "dd->store"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileDeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4830-4841",
          "snippet": "void\nvirStorageFileDeinit(virStorageSourcePtr src)\n{\n    if (!virStorageFileIsInitialized(src))\n        return;\n\n    if (src->drv->backend &&\n        src->drv->backend->backendDeinit)\n        src->drv->backend->backendDeinit(src);\n\n    VIR_FREE(src->drv);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageFileDeinit(virStorageSourcePtr src)\n{\n    if (!virStorageFileIsInitialized(src))\n        return;\n\n    if (src->drv->backend &&\n        src->drv->backend->backendDeinit)\n        src->drv->backend->backendDeinit(src);\n\n    VIR_FREE(src->drv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to remove just-created %s\"",
            "NULLSTR(dd->store->path)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "dd->store->path"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileUnlink",
          "args": [
            "dd->store"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileUnlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4944-4961",
          "snippet": "int\nvirStorageFileUnlink(virStorageSourcePtr src)\n{\n    int ret;\n\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileUnlink) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    ret = src->drv->backend->storageFileUnlink(src);\n\n    VIR_DEBUG(\"unlinked storage file %p: ret=%d, errno=%d\",\n              src, ret, errno);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileUnlink(virStorageSourcePtr src)\n{\n    int ret;\n\n    if (!virStorageFileIsInitialized(src) ||\n        !src->drv->backend->storageFileUnlink) {\n        errno = ENOSYS;\n        return -2;\n    }\n\n    ret = src->drv->backend->storageFileUnlink(src);\n\n    VIR_DEBUG(\"unlinked storage file %p: ret=%d, errno=%d\",\n              src, ret, errno);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuDomainObjExitMonitor(priv->driver, vm)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "priv->driver",
            "vm"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockStorageSourceAttachRollback",
          "args": [
            "priv->mon",
            "dd->crdata->srcdata[0]"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockStorageSourceAttachRollback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "1724-1764",
          "snippet": "void\nqemuBlockStorageSourceAttachRollback(qemuMonitorPtr mon,\n                                     qemuBlockStorageSourceAttachDataPtr data)\n{\n    virErrorPtr orig_err;\n\n    virErrorPreserveLast(&orig_err);\n\n    if (data->driveAdded) {\n        if (qemuMonitorDriveDel(mon, data->driveAlias) < 0)\n            VIR_WARN(\"Unable to remove drive %s (%s) after failed \"\n                     \"qemuMonitorAddDevice\", data->driveAlias, data->driveCmd);\n    }\n\n    if (data->formatAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->formatNodeName));\n\n    if (data->storageSliceAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->storageSliceNodeName));\n\n    if (data->storageAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->storageNodeName));\n\n    if (data->prmgrAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->prmgrAlias, false));\n\n    if (data->authsecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->authsecretAlias, false));\n\n    if (data->encryptsecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->encryptsecretAlias, false));\n\n    if (data->httpcookiesecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->httpcookiesecretAlias, false));\n\n    if (data->tlsAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->tlsAlias, false));\n\n\n    virErrorRestore(&orig_err);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvoid\nqemuBlockStorageSourceAttachRollback(qemuMonitorPtr mon,\n                                     qemuBlockStorageSourceAttachDataPtr data)\n{\n    virErrorPtr orig_err;\n\n    virErrorPreserveLast(&orig_err);\n\n    if (data->driveAdded) {\n        if (qemuMonitorDriveDel(mon, data->driveAlias) < 0)\n            VIR_WARN(\"Unable to remove drive %s (%s) after failed \"\n                     \"qemuMonitorAddDevice\", data->driveAlias, data->driveCmd);\n    }\n\n    if (data->formatAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->formatNodeName));\n\n    if (data->storageSliceAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->storageSliceNodeName));\n\n    if (data->storageAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->storageNodeName));\n\n    if (data->prmgrAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->prmgrAlias, false));\n\n    if (data->authsecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->authsecretAlias, false));\n\n    if (data->encryptsecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->encryptsecretAlias, false));\n\n    if (data->httpcookiesecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->httpcookiesecretAlias, false));\n\n    if (data->tlsAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->tlsAlias, false));\n\n\n    virErrorRestore(&orig_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitor",
          "args": [
            "priv->driver",
            "vm"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10172-10177",
          "snippet": "void qemuDomainObjEnterMonitor(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj)\n{\n    ignore_value(qemuDomainObjEnterMonitorInternal(driver, obj,\n                                                   QEMU_ASYNC_JOB_NONE));\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nvoid qemuDomainObjEnterMonitor(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj)\n{\n    ignore_value(qemuDomainObjEnterMonitorInternal(driver, obj,\n                                                   QEMU_ASYNC_JOB_NONE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic void\nqemuBackupDiskDataCleanupOne(virDomainObjPtr vm,\n                             struct qemuBackupDiskData *dd)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (dd->started)\n        return;\n\n    if (dd->added) {\n        qemuDomainObjEnterMonitor(priv->driver, vm);\n        qemuBlockStorageSourceAttachRollback(priv->mon, dd->crdata->srcdata[0]);\n        ignore_value(qemuDomainObjExitMonitor(priv->driver, vm));\n    }\n\n    if (dd->created) {\n        if (virStorageFileUnlink(dd->store) < 0)\n            VIR_WARN(\"Unable to remove just-created %s\", NULLSTR(dd->store->path));\n    }\n\n    if (dd->initialized)\n        virStorageFileDeinit(dd->store);\n\n    if (dd->labelled)\n        qemuDomainStorageSourceAccessRevoke(priv->driver, vm, dd->store);\n\n    if (dd->blockjob)\n        qemuBlockJobStartupFinalize(vm, dd->blockjob);\n\n    qemuBlockStorageSourceChainDataFree(dd->crdata);\n}"
  },
  {
    "function_name": "qemuBackupPrepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "61-100",
    "snippet": "static int\nqemuBackupPrepare(virDomainBackupDefPtr def)\n{\n\n    if (def->type == VIR_DOMAIN_BACKUP_TYPE_PULL) {\n        if (!def->server) {\n            def->server = g_new(virStorageNetHostDef, 1);\n\n            def->server->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n            def->server->name = g_strdup(\"localhost\");\n        }\n\n        switch ((virStorageNetHostTransport) def->server->transport) {\n        case VIR_STORAGE_NET_HOST_TRANS_TCP:\n            /* TODO: Update qemu.conf to provide a port range,\n             * probably starting at 10809, for obtaining automatic\n             * port via virPortAllocatorAcquire, as well as store\n             * somewhere if we need to call virPortAllocatorRelease\n             * during BackupEnd. Until then, user must provide port */\n            if (!def->server->port) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"<domainbackup> must specify TCP port for now\"));\n                return -1;\n            }\n            break;\n\n        case VIR_STORAGE_NET_HOST_TRANS_UNIX:\n            /* TODO: Do we need to mess with selinux? */\n            break;\n\n        case VIR_STORAGE_NET_HOST_TRANS_RDMA:\n        case VIR_STORAGE_NET_HOST_TRANS_LAST:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"unexpected transport in <domainbackup>\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"unexpected transport in <domainbackup>\")"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unexpected transport in <domainbackup>\""
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"<domainbackup> must specify TCP port for now\")"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"localhost\""
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_new",
          "args": [
            "virStorageNetHostDef",
            "1"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic int\nqemuBackupPrepare(virDomainBackupDefPtr def)\n{\n\n    if (def->type == VIR_DOMAIN_BACKUP_TYPE_PULL) {\n        if (!def->server) {\n            def->server = g_new(virStorageNetHostDef, 1);\n\n            def->server->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n            def->server->name = g_strdup(\"localhost\");\n        }\n\n        switch ((virStorageNetHostTransport) def->server->transport) {\n        case VIR_STORAGE_NET_HOST_TRANS_TCP:\n            /* TODO: Update qemu.conf to provide a port range,\n             * probably starting at 10809, for obtaining automatic\n             * port via virPortAllocatorAcquire, as well as store\n             * somewhere if we need to call virPortAllocatorRelease\n             * during BackupEnd. Until then, user must provide port */\n            if (!def->server->port) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"<domainbackup> must specify TCP port for now\"));\n                return -1;\n            }\n            break;\n\n        case VIR_STORAGE_NET_HOST_TRANS_UNIX:\n            /* TODO: Do we need to mess with selinux? */\n            break;\n\n        case VIR_STORAGE_NET_HOST_TRANS_RDMA:\n        case VIR_STORAGE_NET_HOST_TRANS_LAST:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"unexpected transport in <domainbackup>\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainGetBackup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
    "lines": "46-58",
    "snippet": "static virDomainBackupDefPtr\nqemuDomainGetBackup(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!priv->backup) {\n        virReportError(VIR_ERR_NO_DOMAIN_BACKUP, \"%s\",\n                       _(\"no domain backup job present\"));\n        return NULL;\n    }\n\n    return priv->backup;\n}",
    "includes": [
      "#include \"virdomaincheckpointobjlist.h\"",
      "#include \"backup_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_command.h\"",
      "#include \"qemu_checkpoint.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_block.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN_BACKUP",
            "\"%s\"",
            "_(\"no domain backup job present\")"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no domain backup job present\""
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nstatic virDomainBackupDefPtr\nqemuDomainGetBackup(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!priv->backup) {\n        virReportError(VIR_ERR_NO_DOMAIN_BACKUP, \"%s\",\n                       _(\"no domain backup job present\"));\n        return NULL;\n    }\n\n    return priv->backup;\n}"
  }
]