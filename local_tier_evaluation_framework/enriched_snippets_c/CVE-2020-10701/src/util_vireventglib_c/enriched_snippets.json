[
  {
    "function_name": "virEventGLibRunOnce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
    "lines": "494-499",
    "snippet": "int virEventGLibRunOnce(void)\n{\n    g_main_context_iteration(NULL, TRUE);\n\n    return 0;\n}",
    "includes": [
      "# include <io.h>",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vireventglibwatch.h\"",
      "#include \"vireventglib.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_main_context_iteration",
          "args": [
            "NULL",
            "TRUE"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nint virEventGLibRunOnce(void)\n{\n    g_main_context_iteration(NULL, TRUE);\n\n    return 0;\n}"
  },
  {
    "function_name": "virEventGLibRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
    "lines": "486-491",
    "snippet": "void virEventGLibRegister(void)\n{\n    static GOnce once = G_ONCE_INIT;\n\n    g_once(&once, virEventGLibRegisterOnce, NULL);\n}",
    "includes": [
      "# include <io.h>",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vireventglibwatch.h\"",
      "#include \"vireventglib.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_once",
          "args": [
            "&once",
            "virEventGLibRegisterOnce",
            "NULL"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nvoid virEventGLibRegister(void)\n{\n    static GOnce once = G_ONCE_INIT;\n\n    g_once(&once, virEventGLibRegisterOnce, NULL);\n}"
  },
  {
    "function_name": "virEventGLibRegisterOnce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
    "lines": "471-483",
    "snippet": "static gpointer virEventGLibRegisterOnce(gpointer data G_GNUC_UNUSED)\n{\n    eventlock = g_new0(GMutex, 1);\n    timeouts = g_ptr_array_new_with_free_func(g_free);\n    handles = g_ptr_array_new_with_free_func(g_free);\n    virEventRegisterImpl(virEventGLibHandleAdd,\n                         virEventGLibHandleUpdate,\n                         virEventGLibHandleRemove,\n                         virEventGLibTimeoutAdd,\n                         virEventGLibTimeoutUpdate,\n                         virEventGLibTimeoutRemove);\n    return NULL;\n}",
    "includes": [
      "# include <io.h>",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vireventglibwatch.h\"",
      "#include \"vireventglib.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static GMutex *eventlock;",
      "static GPtrArray *handles;",
      "static GPtrArray *timeouts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virEventRegisterImpl",
          "args": [
            "virEventGLibHandleAdd",
            "virEventGLibHandleUpdate",
            "virEventGLibHandleRemove",
            "virEventGLibTimeoutAdd",
            "virEventGLibTimeoutUpdate",
            "virEventGLibTimeoutRemove"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "virEventRegisterImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "236-260",
          "snippet": "void virEventRegisterImpl(virEventAddHandleFunc addHandle,\n                          virEventUpdateHandleFunc updateHandle,\n                          virEventRemoveHandleFunc removeHandle,\n                          virEventAddTimeoutFunc addTimeout,\n                          virEventUpdateTimeoutFunc updateTimeout,\n                          virEventRemoveTimeoutFunc removeTimeout)\n{\n    VIR_DEBUG(\"addHandle=%p updateHandle=%p removeHandle=%p \"\n              \"addTimeout=%p updateTimeout=%p removeTimeout=%p\",\n              addHandle, updateHandle, removeHandle,\n              addTimeout, updateTimeout, removeTimeout);\n\n    if (addHandleImpl || updateHandleImpl || removeHandleImpl ||\n        addTimeoutImpl || updateTimeoutImpl || removeTimeoutImpl) {\n        VIR_WARN(\"Ignoring attempt to replace registered event loop\");\n        return;\n    }\n\n    addHandleImpl = addHandle;\n    updateHandleImpl = updateHandle;\n    removeHandleImpl = removeHandle;\n    addTimeoutImpl = addTimeout;\n    updateTimeoutImpl = updateTimeout;\n    removeTimeoutImpl = removeTimeout;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventAddHandleFunc addHandleImpl;",
            "static virEventUpdateHandleFunc updateHandleImpl;",
            "static virEventRemoveHandleFunc removeHandleImpl;",
            "static virEventAddTimeoutFunc addTimeoutImpl;",
            "static virEventUpdateTimeoutFunc updateTimeoutImpl;",
            "static virEventRemoveTimeoutFunc removeTimeoutImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventAddHandleFunc addHandleImpl;\nstatic virEventUpdateHandleFunc updateHandleImpl;\nstatic virEventRemoveHandleFunc removeHandleImpl;\nstatic virEventAddTimeoutFunc addTimeoutImpl;\nstatic virEventUpdateTimeoutFunc updateTimeoutImpl;\nstatic virEventRemoveTimeoutFunc removeTimeoutImpl;\n\nvoid virEventRegisterImpl(virEventAddHandleFunc addHandle,\n                          virEventUpdateHandleFunc updateHandle,\n                          virEventRemoveHandleFunc removeHandle,\n                          virEventAddTimeoutFunc addTimeout,\n                          virEventUpdateTimeoutFunc updateTimeout,\n                          virEventRemoveTimeoutFunc removeTimeout)\n{\n    VIR_DEBUG(\"addHandle=%p updateHandle=%p removeHandle=%p \"\n              \"addTimeout=%p updateTimeout=%p removeTimeout=%p\",\n              addHandle, updateHandle, removeHandle,\n              addTimeout, updateTimeout, removeTimeout);\n\n    if (addHandleImpl || updateHandleImpl || removeHandleImpl ||\n        addTimeoutImpl || updateTimeoutImpl || removeTimeoutImpl) {\n        VIR_WARN(\"Ignoring attempt to replace registered event loop\");\n        return;\n    }\n\n    addHandleImpl = addHandle;\n    updateHandleImpl = updateHandle;\n    removeHandleImpl = removeHandle;\n    addTimeoutImpl = addTimeout;\n    updateTimeoutImpl = updateTimeout;\n    removeTimeoutImpl = removeTimeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_ptr_array_new_with_free_func",
          "args": [
            "g_free"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ptr_array_new_with_free_func",
          "args": [
            "g_free"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "GMutex",
            "1"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GMutex *eventlock;\nstatic GPtrArray *handles;\nstatic GPtrArray *timeouts;\n\nstatic gpointer virEventGLibRegisterOnce(gpointer data G_GNUC_UNUSED)\n{\n    eventlock = g_new0(GMutex, 1);\n    timeouts = g_ptr_array_new_with_free_func(g_free);\n    handles = g_ptr_array_new_with_free_func(g_free);\n    virEventRegisterImpl(virEventGLibHandleAdd,\n                         virEventGLibHandleUpdate,\n                         virEventGLibHandleRemove,\n                         virEventGLibTimeoutAdd,\n                         virEventGLibTimeoutUpdate,\n                         virEventGLibTimeoutRemove);\n    return NULL;\n}"
  },
  {
    "function_name": "virEventGLibTimeoutRemove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
    "lines": "431-468",
    "snippet": "static int\nvirEventGLibTimeoutRemove(int timer)\n{\n    struct virEventGLibTimeout *data;\n    int ret = -1;\n\n    PROBE(EVENT_GLIB_REMOVE_TIMEOUT,\n          \"timer=%d\",\n          timer);\n    g_mutex_lock(eventlock);\n\n    data = virEventGLibTimeoutFind(timer);\n    if (!data) {\n        VIR_DEBUG(\"Remove of missing timeout timer=%d\", timer);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Remove timeout data=%p timer=%d\",\n              data, timer);\n\n    if (data->source != 0) {\n        g_source_remove(data->source);\n        data->source = 0;\n    }\n\n    /* since the actual timeout deletion is done asynchronously, a timeoutUpdate call may\n     * reschedule the timeout before it's fully deleted, that's why we need to mark it as\n     * 'removed' to prevent reuse\n     */\n    data->removed = TRUE;\n    g_idle_add(virEventGLibTimeoutRemoveIdle, data);\n\n    ret = 0;\n\n cleanup:\n    g_mutex_unlock(eventlock);\n    return ret;\n}",
    "includes": [
      "# include <io.h>",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vireventglibwatch.h\"",
      "#include \"vireventglib.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static GMutex *eventlock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_mutex_unlock",
          "args": [
            "eventlock"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_idle_add",
          "args": [
            "virEventGLibTimeoutRemoveIdle",
            "data"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_source_remove",
          "args": [
            "data->source"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Remove timeout data=%p timer=%d\"",
            "data",
            "timer"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Remove of missing timeout timer=%d\"",
            "timer"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventGLibTimeoutFind",
          "args": [
            "timer"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "virEventGLibTimeoutFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
          "lines": "350-370",
          "snippet": "static struct virEventGLibTimeout *\nvirEventGLibTimeoutFind(int timer)\n{\n    guint i;\n\n    g_return_val_if_fail(timeouts != NULL, NULL);\n\n    for (i = 0; i < timeouts->len; i++) {\n        struct virEventGLibTimeout *t = g_ptr_array_index(timeouts, i);\n\n        if (t == NULL) {\n            g_warn_if_reached();\n            continue;\n        }\n\n        if ((t->timer == timer) && !t->removed)\n            return t;\n    }\n\n    return NULL;\n}",
          "includes": [
            "# include <io.h>",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vireventglibwatch.h\"",
            "#include \"vireventglib.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static GPtrArray *timeouts;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GPtrArray *timeouts;\n\nstatic struct virEventGLibTimeout *\nvirEventGLibTimeoutFind(int timer)\n{\n    guint i;\n\n    g_return_val_if_fail(timeouts != NULL, NULL);\n\n    for (i = 0; i < timeouts->len; i++) {\n        struct virEventGLibTimeout *t = g_ptr_array_index(timeouts, i);\n\n        if (t == NULL) {\n            g_warn_if_reached();\n            continue;\n        }\n\n        if ((t->timer == timer) && !t->removed)\n            return t;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_mutex_lock",
          "args": [
            "eventlock"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "EVENT_GLIB_REMOVE_TIMEOUT",
            "\"timer=%d\"",
            "timer"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GMutex *eventlock;\n\nstatic int\nvirEventGLibTimeoutRemove(int timer)\n{\n    struct virEventGLibTimeout *data;\n    int ret = -1;\n\n    PROBE(EVENT_GLIB_REMOVE_TIMEOUT,\n          \"timer=%d\",\n          timer);\n    g_mutex_lock(eventlock);\n\n    data = virEventGLibTimeoutFind(timer);\n    if (!data) {\n        VIR_DEBUG(\"Remove of missing timeout timer=%d\", timer);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Remove timeout data=%p timer=%d\",\n              data, timer);\n\n    if (data->source != 0) {\n        g_source_remove(data->source);\n        data->source = 0;\n    }\n\n    /* since the actual timeout deletion is done asynchronously, a timeoutUpdate call may\n     * reschedule the timeout before it's fully deleted, that's why we need to mark it as\n     * 'removed' to prevent reuse\n     */\n    data->removed = TRUE;\n    g_idle_add(virEventGLibTimeoutRemoveIdle, data);\n\n    ret = 0;\n\n cleanup:\n    g_mutex_unlock(eventlock);\n    return ret;\n}"
  },
  {
    "function_name": "virEventGLibTimeoutRemoveIdle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
    "lines": "412-429",
    "snippet": "static gboolean\nvirEventGLibTimeoutRemoveIdle(gpointer data)\n{\n    struct virEventGLibTimeout *t = data;\n\n    PROBE(EVENT_GLIB_REMOVE_TIMEOUT_IDLE,\n          \"timer=%d ff=%p opaque=%p\",\n          t->timer, t->ff, t->opaque);\n\n    if (t->ff)\n        (t->ff)(t->opaque);\n\n    g_mutex_lock(eventlock);\n    g_ptr_array_remove_fast(timeouts, t);\n    g_mutex_unlock(eventlock);\n\n    return FALSE;\n}",
    "includes": [
      "# include <io.h>",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vireventglibwatch.h\"",
      "#include \"vireventglib.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static GMutex *eventlock;",
      "static GPtrArray *timeouts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_mutex_unlock",
          "args": [
            "eventlock"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ptr_array_remove_fast",
          "args": [
            "timeouts",
            "t"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_mutex_lock",
          "args": [
            "eventlock"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "t->opaque"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "EVENT_GLIB_REMOVE_TIMEOUT_IDLE",
            "\"timer=%d ff=%p opaque=%p\"",
            "t->timer",
            "t->ff",
            "t->opaque"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GMutex *eventlock;\nstatic GPtrArray *timeouts;\n\nstatic gboolean\nvirEventGLibTimeoutRemoveIdle(gpointer data)\n{\n    struct virEventGLibTimeout *t = data;\n\n    PROBE(EVENT_GLIB_REMOVE_TIMEOUT_IDLE,\n          \"timer=%d ff=%p opaque=%p\",\n          t->timer, t->ff, t->opaque);\n\n    if (t->ff)\n        (t->ff)(t->opaque);\n\n    g_mutex_lock(eventlock);\n    g_ptr_array_remove_fast(timeouts, t);\n    g_mutex_unlock(eventlock);\n\n    return FALSE;\n}"
  },
  {
    "function_name": "virEventGLibTimeoutUpdate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
    "lines": "373-410",
    "snippet": "static void\nvirEventGLibTimeoutUpdate(int timer,\n                          int interval)\n{\n    struct virEventGLibTimeout *data;\n\n    PROBE(EVENT_GLIB_UPDATE_TIMEOUT,\n          \"timer=%d interval=%d\",\n          timer, interval);\n    g_mutex_lock(eventlock);\n\n    data = virEventGLibTimeoutFind(timer);\n    if (!data) {\n        VIR_DEBUG(\"Update of missing timeout timer=%d\", timer);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Update timeout data=%p timer=%d interval=%d ms\", data, timer, interval);\n\n    if (interval >= 0) {\n        if (data->source != 0)\n            g_source_remove(data->source);\n\n        data->interval = interval;\n        data->source = g_timeout_add(data->interval,\n                                     virEventGLibTimeoutDispatch,\n                                     data);\n    } else {\n        if (data->source == 0)\n            goto cleanup;\n\n        g_source_remove(data->source);\n        data->source = 0;\n    }\n\n cleanup:\n    g_mutex_unlock(eventlock);\n}",
    "includes": [
      "# include <io.h>",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vireventglibwatch.h\"",
      "#include \"vireventglib.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static GMutex *eventlock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_mutex_unlock",
          "args": [
            "eventlock"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_source_remove",
          "args": [
            "data->source"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_timeout_add",
          "args": [
            "data->interval",
            "virEventGLibTimeoutDispatch",
            "data"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_source_remove",
          "args": [
            "data->source"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Update timeout data=%p timer=%d interval=%d ms\"",
            "data",
            "timer",
            "interval"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Update of missing timeout timer=%d\"",
            "timer"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventGLibTimeoutFind",
          "args": [
            "timer"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "virEventGLibTimeoutFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
          "lines": "350-370",
          "snippet": "static struct virEventGLibTimeout *\nvirEventGLibTimeoutFind(int timer)\n{\n    guint i;\n\n    g_return_val_if_fail(timeouts != NULL, NULL);\n\n    for (i = 0; i < timeouts->len; i++) {\n        struct virEventGLibTimeout *t = g_ptr_array_index(timeouts, i);\n\n        if (t == NULL) {\n            g_warn_if_reached();\n            continue;\n        }\n\n        if ((t->timer == timer) && !t->removed)\n            return t;\n    }\n\n    return NULL;\n}",
          "includes": [
            "# include <io.h>",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vireventglibwatch.h\"",
            "#include \"vireventglib.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static GPtrArray *timeouts;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GPtrArray *timeouts;\n\nstatic struct virEventGLibTimeout *\nvirEventGLibTimeoutFind(int timer)\n{\n    guint i;\n\n    g_return_val_if_fail(timeouts != NULL, NULL);\n\n    for (i = 0; i < timeouts->len; i++) {\n        struct virEventGLibTimeout *t = g_ptr_array_index(timeouts, i);\n\n        if (t == NULL) {\n            g_warn_if_reached();\n            continue;\n        }\n\n        if ((t->timer == timer) && !t->removed)\n            return t;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_mutex_lock",
          "args": [
            "eventlock"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "EVENT_GLIB_UPDATE_TIMEOUT",
            "\"timer=%d interval=%d\"",
            "timer",
            "interval"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GMutex *eventlock;\n\nstatic void\nvirEventGLibTimeoutUpdate(int timer,\n                          int interval)\n{\n    struct virEventGLibTimeout *data;\n\n    PROBE(EVENT_GLIB_UPDATE_TIMEOUT,\n          \"timer=%d interval=%d\",\n          timer, interval);\n    g_mutex_lock(eventlock);\n\n    data = virEventGLibTimeoutFind(timer);\n    if (!data) {\n        VIR_DEBUG(\"Update of missing timeout timer=%d\", timer);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Update timeout data=%p timer=%d interval=%d ms\", data, timer, interval);\n\n    if (interval >= 0) {\n        if (data->source != 0)\n            g_source_remove(data->source);\n\n        data->interval = interval;\n        data->source = g_timeout_add(data->interval,\n                                     virEventGLibTimeoutDispatch,\n                                     data);\n    } else {\n        if (data->source == 0)\n            goto cleanup;\n\n        g_source_remove(data->source);\n        data->source = 0;\n    }\n\n cleanup:\n    g_mutex_unlock(eventlock);\n}"
  },
  {
    "function_name": "virEventGLibTimeoutFind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
    "lines": "350-370",
    "snippet": "static struct virEventGLibTimeout *\nvirEventGLibTimeoutFind(int timer)\n{\n    guint i;\n\n    g_return_val_if_fail(timeouts != NULL, NULL);\n\n    for (i = 0; i < timeouts->len; i++) {\n        struct virEventGLibTimeout *t = g_ptr_array_index(timeouts, i);\n\n        if (t == NULL) {\n            g_warn_if_reached();\n            continue;\n        }\n\n        if ((t->timer == timer) && !t->removed)\n            return t;\n    }\n\n    return NULL;\n}",
    "includes": [
      "# include <io.h>",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vireventglibwatch.h\"",
      "#include \"vireventglib.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static GPtrArray *timeouts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_warn_if_reached",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ptr_array_index",
          "args": [
            "timeouts",
            "i"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_return_val_if_fail",
          "args": [
            "timeouts != NULL",
            "NULL"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GPtrArray *timeouts;\n\nstatic struct virEventGLibTimeout *\nvirEventGLibTimeoutFind(int timer)\n{\n    guint i;\n\n    g_return_val_if_fail(timeouts != NULL, NULL);\n\n    for (i = 0; i < timeouts->len; i++) {\n        struct virEventGLibTimeout *t = g_ptr_array_index(timeouts, i);\n\n        if (t == NULL) {\n            g_warn_if_reached();\n            continue;\n        }\n\n        if ((t->timer == timer) && !t->removed)\n            return t;\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "virEventGLibTimeoutAdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
    "lines": "312-347",
    "snippet": "static int\nvirEventGLibTimeoutAdd(int interval,\n                       virEventTimeoutCallback cb,\n                       void *opaque,\n                       virFreeCallback ff)\n{\n    struct virEventGLibTimeout *data;\n    int ret;\n\n    g_mutex_lock(eventlock);\n\n    data = g_new0(struct virEventGLibTimeout, 1);\n    data->timer = nexttimer++;\n    data->interval = interval;\n    data->cb = cb;\n    data->opaque = opaque;\n    data->ff = ff;\n    if (interval >= 0)\n        data->source = g_timeout_add(interval,\n                                     virEventGLibTimeoutDispatch,\n                                     data);\n\n    g_ptr_array_add(timeouts, data);\n\n    VIR_DEBUG(\"Add timeout data=%p interval=%d ms cb=%p opaque=%p timer=%d\",\n              data, interval, cb, opaque, data->timer);\n\n    ret = data->timer;\n\n    PROBE(EVENT_GLIB_ADD_TIMEOUT,\n          \"timer=%d interval=%d cb=%p opaque=%p ff=%p\",\n          ret, interval, cb, opaque, ff);\n    g_mutex_unlock(eventlock);\n\n    return ret;\n}",
    "includes": [
      "# include <io.h>",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vireventglibwatch.h\"",
      "#include \"vireventglib.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static GMutex *eventlock;",
      "static int nexttimer = 1;",
      "static GPtrArray *timeouts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_mutex_unlock",
          "args": [
            "eventlock"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "EVENT_GLIB_ADD_TIMEOUT",
            "\"timer=%d interval=%d cb=%p opaque=%p ff=%p\"",
            "ret",
            "interval",
            "cb",
            "opaque",
            "ff"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Add timeout data=%p interval=%d ms cb=%p opaque=%p timer=%d\"",
            "data",
            "interval",
            "cb",
            "opaque",
            "data->timer"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ptr_array_add",
          "args": [
            "timeouts",
            "data"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_timeout_add",
          "args": [
            "interval",
            "virEventGLibTimeoutDispatch",
            "data"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "structvirEventGLibTimeout",
            "1"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_mutex_lock",
          "args": [
            "eventlock"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GMutex *eventlock;\nstatic int nexttimer = 1;\nstatic GPtrArray *timeouts;\n\nstatic int\nvirEventGLibTimeoutAdd(int interval,\n                       virEventTimeoutCallback cb,\n                       void *opaque,\n                       virFreeCallback ff)\n{\n    struct virEventGLibTimeout *data;\n    int ret;\n\n    g_mutex_lock(eventlock);\n\n    data = g_new0(struct virEventGLibTimeout, 1);\n    data->timer = nexttimer++;\n    data->interval = interval;\n    data->cb = cb;\n    data->opaque = opaque;\n    data->ff = ff;\n    if (interval >= 0)\n        data->source = g_timeout_add(interval,\n                                     virEventGLibTimeoutDispatch,\n                                     data);\n\n    g_ptr_array_add(timeouts, data);\n\n    VIR_DEBUG(\"Add timeout data=%p interval=%d ms cb=%p opaque=%p timer=%d\",\n              data, interval, cb, opaque, data->timer);\n\n    ret = data->timer;\n\n    PROBE(EVENT_GLIB_ADD_TIMEOUT,\n          \"timer=%d interval=%d cb=%p opaque=%p ff=%p\",\n          ret, interval, cb, opaque, ff);\n    g_mutex_unlock(eventlock);\n\n    return ret;\n}"
  },
  {
    "function_name": "virEventGLibTimeoutDispatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
    "lines": "296-310",
    "snippet": "static gboolean\nvirEventGLibTimeoutDispatch(void *opaque)\n{\n    struct virEventGLibTimeout *data = opaque;\n\n    VIR_DEBUG(\"Dispatch timeout data=%p cb=%p timer=%d opaque=%p\",\n              data, data->cb, data->timer, data->opaque);\n\n    PROBE(EVENT_GLIB_DISPATCH_TIMEOUT,\n          \"timer=%d cb=%p opaque=%p\",\n          data->timer, data->cb, data->opaque);\n    (data->cb)(data->timer, data->opaque);\n\n    return TRUE;\n}",
    "includes": [
      "# include <io.h>",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vireventglibwatch.h\"",
      "#include \"vireventglib.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "data->timer",
            "data->opaque"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "EVENT_GLIB_DISPATCH_TIMEOUT",
            "\"timer=%d cb=%p opaque=%p\"",
            "data->timer",
            "data->cb",
            "data->opaque"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Dispatch timeout data=%p cb=%p timer=%d opaque=%p\"",
            "data",
            "data->cb",
            "data->timer",
            "data->opaque"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic gboolean\nvirEventGLibTimeoutDispatch(void *opaque)\n{\n    struct virEventGLibTimeout *data = opaque;\n\n    VIR_DEBUG(\"Dispatch timeout data=%p cb=%p timer=%d opaque=%p\",\n              data, data->cb, data->timer, data->opaque);\n\n    PROBE(EVENT_GLIB_DISPATCH_TIMEOUT,\n          \"timer=%d cb=%p opaque=%p\",\n          data->timer, data->cb, data->opaque);\n    (data->cb)(data->timer, data->opaque);\n\n    return TRUE;\n}"
  },
  {
    "function_name": "virEventGLibHandleRemove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
    "lines": "255-293",
    "snippet": "static int\nvirEventGLibHandleRemove(int watch)\n{\n    struct virEventGLibHandle *data;\n    int ret = -1;\n\n    PROBE(EVENT_GLIB_REMOVE_HANDLE,\n          \"watch=%d\",\n          watch);\n    g_mutex_lock(eventlock);\n\n    data = virEventGLibHandleFind(watch);\n    if (!data) {\n        VIR_DEBUG(\"Remove of missing handle watch=%d\", watch);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Remove handle data=%p watch=%d fd=%d\",\n              data, watch, data->fd);\n\n    if (data->source != 0) {\n        g_source_remove(data->source);\n        data->source = 0;\n        data->events = 0;\n    }\n\n    /* since the actual watch deletion is done asynchronously, a handleUpdate call may\n     * reschedule the watch before it's fully deleted, that's why we need to mark it as\n     * 'removed' to prevent reuse\n     */\n    data->removed = TRUE;\n    g_idle_add(virEventGLibHandleRemoveIdle, data);\n\n    ret = 0;\n\n cleanup:\n    g_mutex_unlock(eventlock);\n    return ret;\n}",
    "includes": [
      "# include <io.h>",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vireventglibwatch.h\"",
      "#include \"vireventglib.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static GMutex *eventlock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_mutex_unlock",
          "args": [
            "eventlock"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_idle_add",
          "args": [
            "virEventGLibHandleRemoveIdle",
            "data"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_source_remove",
          "args": [
            "data->source"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Remove handle data=%p watch=%d fd=%d\"",
            "data",
            "watch",
            "data->fd"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Remove of missing handle watch=%d\"",
            "watch"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventGLibHandleFind",
          "args": [
            "watch"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "virEventGLibHandleFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
          "lines": "168-186",
          "snippet": "static struct virEventGLibHandle *\nvirEventGLibHandleFind(int watch)\n{\n    guint i;\n\n    for (i = 0; i < handles->len; i++) {\n        struct virEventGLibHandle *h = g_ptr_array_index(handles, i);\n\n        if (h == NULL) {\n            g_warn_if_reached();\n            continue;\n        }\n\n        if ((h->watch == watch) && !h->removed)\n            return h;\n    }\n\n    return NULL;\n}",
          "includes": [
            "# include <io.h>",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vireventglibwatch.h\"",
            "#include \"vireventglib.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static GPtrArray *handles;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GPtrArray *handles;\n\nstatic struct virEventGLibHandle *\nvirEventGLibHandleFind(int watch)\n{\n    guint i;\n\n    for (i = 0; i < handles->len; i++) {\n        struct virEventGLibHandle *h = g_ptr_array_index(handles, i);\n\n        if (h == NULL) {\n            g_warn_if_reached();\n            continue;\n        }\n\n        if ((h->watch == watch) && !h->removed)\n            return h;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_mutex_lock",
          "args": [
            "eventlock"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "EVENT_GLIB_REMOVE_HANDLE",
            "\"watch=%d\"",
            "watch"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GMutex *eventlock;\n\nstatic int\nvirEventGLibHandleRemove(int watch)\n{\n    struct virEventGLibHandle *data;\n    int ret = -1;\n\n    PROBE(EVENT_GLIB_REMOVE_HANDLE,\n          \"watch=%d\",\n          watch);\n    g_mutex_lock(eventlock);\n\n    data = virEventGLibHandleFind(watch);\n    if (!data) {\n        VIR_DEBUG(\"Remove of missing handle watch=%d\", watch);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Remove handle data=%p watch=%d fd=%d\",\n              data, watch, data->fd);\n\n    if (data->source != 0) {\n        g_source_remove(data->source);\n        data->source = 0;\n        data->events = 0;\n    }\n\n    /* since the actual watch deletion is done asynchronously, a handleUpdate call may\n     * reschedule the watch before it's fully deleted, that's why we need to mark it as\n     * 'removed' to prevent reuse\n     */\n    data->removed = TRUE;\n    g_idle_add(virEventGLibHandleRemoveIdle, data);\n\n    ret = 0;\n\n cleanup:\n    g_mutex_unlock(eventlock);\n    return ret;\n}"
  },
  {
    "function_name": "virEventGLibHandleRemoveIdle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
    "lines": "237-253",
    "snippet": "static gboolean\nvirEventGLibHandleRemoveIdle(gpointer data)\n{\n    struct virEventGLibHandle *h = data;\n\n    PROBE(EVENT_GLIB_REMOVE_HANDLE_IDLE,\n          \"watch=%d ff=%p opaque=%p\",\n          h->watch, h->ff, h->opaque);\n    if (h->ff)\n        (h->ff)(h->opaque);\n\n    g_mutex_lock(eventlock);\n    g_ptr_array_remove_fast(handles, h);\n    g_mutex_unlock(eventlock);\n\n    return FALSE;\n}",
    "includes": [
      "# include <io.h>",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vireventglibwatch.h\"",
      "#include \"vireventglib.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static GMutex *eventlock;",
      "static GPtrArray *handles;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_mutex_unlock",
          "args": [
            "eventlock"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ptr_array_remove_fast",
          "args": [
            "handles",
            "h"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_mutex_lock",
          "args": [
            "eventlock"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "h->opaque"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "EVENT_GLIB_REMOVE_HANDLE_IDLE",
            "\"watch=%d ff=%p opaque=%p\"",
            "h->watch",
            "h->ff",
            "h->opaque"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GMutex *eventlock;\nstatic GPtrArray *handles;\n\nstatic gboolean\nvirEventGLibHandleRemoveIdle(gpointer data)\n{\n    struct virEventGLibHandle *h = data;\n\n    PROBE(EVENT_GLIB_REMOVE_HANDLE_IDLE,\n          \"watch=%d ff=%p opaque=%p\",\n          h->watch, h->ff, h->opaque);\n    if (h->ff)\n        (h->ff)(h->opaque);\n\n    g_mutex_lock(eventlock);\n    g_ptr_array_remove_fast(handles, h);\n    g_mutex_unlock(eventlock);\n\n    return FALSE;\n}"
  },
  {
    "function_name": "virEventGLibHandleUpdate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
    "lines": "188-235",
    "snippet": "static void\nvirEventGLibHandleUpdate(int watch,\n                         int events)\n{\n    struct virEventGLibHandle *data;\n\n    PROBE(EVENT_GLIB_UPDATE_HANDLE,\n          \"watch=%d events=%d\",\n          watch, events);\n    g_mutex_lock(eventlock);\n\n    data = virEventGLibHandleFind(watch);\n    if (!data) {\n        VIR_DEBUG(\"Update for missing handle watch=%d\", watch);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Update handle data=%p watch=%d fd=%d events=%d\",\n              data, watch, data->fd, events);\n\n    if (events != 0) {\n        GIOCondition cond = virEventGLibEventsToCondition(events);\n        if (events == data->events)\n            goto cleanup;\n\n        if (data->source != 0) {\n            VIR_DEBUG(\"Removed old handle watch=%d\", data->source);\n            g_source_remove(data->source);\n        }\n\n        data->source = virEventGLibAddSocketWatch(\n            data->fd, cond, NULL, virEventGLibHandleDispatch, data, NULL);\n\n        data->events = events;\n        VIR_DEBUG(\"Added new handle watch=%d\", data->source);\n    } else {\n        if (data->source == 0)\n            goto cleanup;\n\n        VIR_DEBUG(\"Removed old handle watch=%d\", data->source);\n        g_source_remove(data->source);\n        data->source = 0;\n        data->events = 0;\n    }\n\n cleanup:\n    g_mutex_unlock(eventlock);\n}",
    "includes": [
      "# include <io.h>",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vireventglibwatch.h\"",
      "#include \"vireventglib.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static GMutex *eventlock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_mutex_unlock",
          "args": [
            "eventlock"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_source_remove",
          "args": [
            "data->source"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Removed old handle watch=%d\"",
            "data->source"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Added new handle watch=%d\"",
            "data->source"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventGLibAddSocketWatch",
          "args": [
            "data->fd",
            "cond",
            "NULL",
            "virEventGLibHandleDispatch",
            "data",
            "NULL"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "virEventGLibAddSocketWatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglibwatch.c",
          "lines": "236-249",
          "snippet": "guint virEventGLibAddSocketWatch(int fd,\n                                 GIOCondition condition,\n                                 GMainContext *context,\n                                 virEventGLibSocketFunc func,\n                                 gpointer opaque,\n                                 GDestroyNotify notify)\n{\n    g_autoptr(GSource) source = NULL;\n\n    source = virEventGLibCreateSocketWatch(fd, condition);\n    g_source_set_callback(source, (GSourceFunc)func, opaque, notify);\n\n    return g_source_attach(source, context);\n}",
          "includes": [
            "# include <winsock2.h>",
            "#include \"vireventglibwatch.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <winsock2.h>\n#include \"vireventglibwatch.h\"\n#include <config.h>\n\nguint virEventGLibAddSocketWatch(int fd,\n                                 GIOCondition condition,\n                                 GMainContext *context,\n                                 virEventGLibSocketFunc func,\n                                 gpointer opaque,\n                                 GDestroyNotify notify)\n{\n    g_autoptr(GSource) source = NULL;\n\n    source = virEventGLibCreateSocketWatch(fd, condition);\n    g_source_set_callback(source, (GSourceFunc)func, opaque, notify);\n\n    return g_source_attach(source, context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_source_remove",
          "args": [
            "data->source"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Removed old handle watch=%d\"",
            "data->source"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventGLibEventsToCondition",
          "args": [
            "events"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "virEventGLibEventsToCondition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
          "lines": "73-86",
          "snippet": "static GIOCondition\nvirEventGLibEventsToCondition(int events)\n{\n    GIOCondition cond = 0;\n    if (events & VIR_EVENT_HANDLE_READABLE)\n        cond |= G_IO_IN;\n    if (events & VIR_EVENT_HANDLE_WRITABLE)\n        cond |= G_IO_OUT;\n    if (events & VIR_EVENT_HANDLE_ERROR)\n        cond |= G_IO_ERR;\n    if (events & VIR_EVENT_HANDLE_HANGUP)\n        cond |= G_IO_HUP;\n    return cond;\n}",
          "includes": [
            "# include <io.h>",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vireventglibwatch.h\"",
            "#include \"vireventglib.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GIOCondition\nvirEventGLibEventsToCondition(int events)\n{\n    GIOCondition cond = 0;\n    if (events & VIR_EVENT_HANDLE_READABLE)\n        cond |= G_IO_IN;\n    if (events & VIR_EVENT_HANDLE_WRITABLE)\n        cond |= G_IO_OUT;\n    if (events & VIR_EVENT_HANDLE_ERROR)\n        cond |= G_IO_ERR;\n    if (events & VIR_EVENT_HANDLE_HANGUP)\n        cond |= G_IO_HUP;\n    return cond;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Update handle data=%p watch=%d fd=%d events=%d\"",
            "data",
            "watch",
            "data->fd",
            "events"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Update for missing handle watch=%d\"",
            "watch"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventGLibHandleFind",
          "args": [
            "watch"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "virEventGLibHandleFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
          "lines": "168-186",
          "snippet": "static struct virEventGLibHandle *\nvirEventGLibHandleFind(int watch)\n{\n    guint i;\n\n    for (i = 0; i < handles->len; i++) {\n        struct virEventGLibHandle *h = g_ptr_array_index(handles, i);\n\n        if (h == NULL) {\n            g_warn_if_reached();\n            continue;\n        }\n\n        if ((h->watch == watch) && !h->removed)\n            return h;\n    }\n\n    return NULL;\n}",
          "includes": [
            "# include <io.h>",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vireventglibwatch.h\"",
            "#include \"vireventglib.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static GPtrArray *handles;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GPtrArray *handles;\n\nstatic struct virEventGLibHandle *\nvirEventGLibHandleFind(int watch)\n{\n    guint i;\n\n    for (i = 0; i < handles->len; i++) {\n        struct virEventGLibHandle *h = g_ptr_array_index(handles, i);\n\n        if (h == NULL) {\n            g_warn_if_reached();\n            continue;\n        }\n\n        if ((h->watch == watch) && !h->removed)\n            return h;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_mutex_lock",
          "args": [
            "eventlock"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "EVENT_GLIB_UPDATE_HANDLE",
            "\"watch=%d events=%d\"",
            "watch",
            "events"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GMutex *eventlock;\n\nstatic void\nvirEventGLibHandleUpdate(int watch,\n                         int events)\n{\n    struct virEventGLibHandle *data;\n\n    PROBE(EVENT_GLIB_UPDATE_HANDLE,\n          \"watch=%d events=%d\",\n          watch, events);\n    g_mutex_lock(eventlock);\n\n    data = virEventGLibHandleFind(watch);\n    if (!data) {\n        VIR_DEBUG(\"Update for missing handle watch=%d\", watch);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Update handle data=%p watch=%d fd=%d events=%d\",\n              data, watch, data->fd, events);\n\n    if (events != 0) {\n        GIOCondition cond = virEventGLibEventsToCondition(events);\n        if (events == data->events)\n            goto cleanup;\n\n        if (data->source != 0) {\n            VIR_DEBUG(\"Removed old handle watch=%d\", data->source);\n            g_source_remove(data->source);\n        }\n\n        data->source = virEventGLibAddSocketWatch(\n            data->fd, cond, NULL, virEventGLibHandleDispatch, data, NULL);\n\n        data->events = events;\n        VIR_DEBUG(\"Added new handle watch=%d\", data->source);\n    } else {\n        if (data->source == 0)\n            goto cleanup;\n\n        VIR_DEBUG(\"Removed old handle watch=%d\", data->source);\n        g_source_remove(data->source);\n        data->source = 0;\n        data->events = 0;\n    }\n\n cleanup:\n    g_mutex_unlock(eventlock);\n}"
  },
  {
    "function_name": "virEventGLibHandleFind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
    "lines": "168-186",
    "snippet": "static struct virEventGLibHandle *\nvirEventGLibHandleFind(int watch)\n{\n    guint i;\n\n    for (i = 0; i < handles->len; i++) {\n        struct virEventGLibHandle *h = g_ptr_array_index(handles, i);\n\n        if (h == NULL) {\n            g_warn_if_reached();\n            continue;\n        }\n\n        if ((h->watch == watch) && !h->removed)\n            return h;\n    }\n\n    return NULL;\n}",
    "includes": [
      "# include <io.h>",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vireventglibwatch.h\"",
      "#include \"vireventglib.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static GPtrArray *handles;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_warn_if_reached",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ptr_array_index",
          "args": [
            "handles",
            "i"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GPtrArray *handles;\n\nstatic struct virEventGLibHandle *\nvirEventGLibHandleFind(int watch)\n{\n    guint i;\n\n    for (i = 0; i < handles->len; i++) {\n        struct virEventGLibHandle *h = g_ptr_array_index(handles, i);\n\n        if (h == NULL) {\n            g_warn_if_reached();\n            continue;\n        }\n\n        if ((h->watch == watch) && !h->removed)\n            return h;\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "virEventGLibHandleAdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
    "lines": "126-166",
    "snippet": "static int\nvirEventGLibHandleAdd(int fd,\n                      int events,\n                      virEventHandleCallback cb,\n                      void *opaque,\n                      virFreeCallback ff)\n{\n    struct virEventGLibHandle *data;\n    GIOCondition cond = virEventGLibEventsToCondition(events);\n    int ret;\n\n    g_mutex_lock(eventlock);\n\n    data = g_new0(struct virEventGLibHandle, 1);\n\n    data->watch = nextwatch++;\n    data->fd = fd;\n    data->events = events;\n    data->cb = cb;\n    data->opaque = opaque;\n    data->ff = ff;\n\n    VIR_DEBUG(\"Add handle data=%p watch=%d fd=%d events=%d opaque=%p\",\n              data, data->watch, data->fd, events, data->opaque);\n\n    if (events != 0) {\n        data->source = virEventGLibAddSocketWatch(\n            fd, cond, NULL, virEventGLibHandleDispatch, data, NULL);\n    }\n\n    g_ptr_array_add(handles, data);\n\n    ret = data->watch;\n\n    PROBE(EVENT_GLIB_ADD_HANDLE,\n          \"watch=%d fd=%d events=%d cb=%p opaque=%p ff=%p\",\n          ret, fd, events, cb, opaque, ff);\n    g_mutex_unlock(eventlock);\n\n    return ret;\n}",
    "includes": [
      "# include <io.h>",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vireventglibwatch.h\"",
      "#include \"vireventglib.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static GMutex *eventlock;",
      "static int nextwatch = 1;",
      "static GPtrArray *handles;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_mutex_unlock",
          "args": [
            "eventlock"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "EVENT_GLIB_ADD_HANDLE",
            "\"watch=%d fd=%d events=%d cb=%p opaque=%p ff=%p\"",
            "ret",
            "fd",
            "events",
            "cb",
            "opaque",
            "ff"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ptr_array_add",
          "args": [
            "handles",
            "data"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventGLibAddSocketWatch",
          "args": [
            "fd",
            "cond",
            "NULL",
            "virEventGLibHandleDispatch",
            "data",
            "NULL"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "virEventGLibAddSocketWatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglibwatch.c",
          "lines": "236-249",
          "snippet": "guint virEventGLibAddSocketWatch(int fd,\n                                 GIOCondition condition,\n                                 GMainContext *context,\n                                 virEventGLibSocketFunc func,\n                                 gpointer opaque,\n                                 GDestroyNotify notify)\n{\n    g_autoptr(GSource) source = NULL;\n\n    source = virEventGLibCreateSocketWatch(fd, condition);\n    g_source_set_callback(source, (GSourceFunc)func, opaque, notify);\n\n    return g_source_attach(source, context);\n}",
          "includes": [
            "# include <winsock2.h>",
            "#include \"vireventglibwatch.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <winsock2.h>\n#include \"vireventglibwatch.h\"\n#include <config.h>\n\nguint virEventGLibAddSocketWatch(int fd,\n                                 GIOCondition condition,\n                                 GMainContext *context,\n                                 virEventGLibSocketFunc func,\n                                 gpointer opaque,\n                                 GDestroyNotify notify)\n{\n    g_autoptr(GSource) source = NULL;\n\n    source = virEventGLibCreateSocketWatch(fd, condition);\n    g_source_set_callback(source, (GSourceFunc)func, opaque, notify);\n\n    return g_source_attach(source, context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Add handle data=%p watch=%d fd=%d events=%d opaque=%p\"",
            "data",
            "data->watch",
            "data->fd",
            "events",
            "data->opaque"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "structvirEventGLibHandle",
            "1"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_mutex_lock",
          "args": [
            "eventlock"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventGLibEventsToCondition",
          "args": [
            "events"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "virEventGLibEventsToCondition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
          "lines": "73-86",
          "snippet": "static GIOCondition\nvirEventGLibEventsToCondition(int events)\n{\n    GIOCondition cond = 0;\n    if (events & VIR_EVENT_HANDLE_READABLE)\n        cond |= G_IO_IN;\n    if (events & VIR_EVENT_HANDLE_WRITABLE)\n        cond |= G_IO_OUT;\n    if (events & VIR_EVENT_HANDLE_ERROR)\n        cond |= G_IO_ERR;\n    if (events & VIR_EVENT_HANDLE_HANGUP)\n        cond |= G_IO_HUP;\n    return cond;\n}",
          "includes": [
            "# include <io.h>",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vireventglibwatch.h\"",
            "#include \"vireventglib.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GIOCondition\nvirEventGLibEventsToCondition(int events)\n{\n    GIOCondition cond = 0;\n    if (events & VIR_EVENT_HANDLE_READABLE)\n        cond |= G_IO_IN;\n    if (events & VIR_EVENT_HANDLE_WRITABLE)\n        cond |= G_IO_OUT;\n    if (events & VIR_EVENT_HANDLE_ERROR)\n        cond |= G_IO_ERR;\n    if (events & VIR_EVENT_HANDLE_HANGUP)\n        cond |= G_IO_HUP;\n    return cond;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GMutex *eventlock;\nstatic int nextwatch = 1;\nstatic GPtrArray *handles;\n\nstatic int\nvirEventGLibHandleAdd(int fd,\n                      int events,\n                      virEventHandleCallback cb,\n                      void *opaque,\n                      virFreeCallback ff)\n{\n    struct virEventGLibHandle *data;\n    GIOCondition cond = virEventGLibEventsToCondition(events);\n    int ret;\n\n    g_mutex_lock(eventlock);\n\n    data = g_new0(struct virEventGLibHandle, 1);\n\n    data->watch = nextwatch++;\n    data->fd = fd;\n    data->events = events;\n    data->cb = cb;\n    data->opaque = opaque;\n    data->ff = ff;\n\n    VIR_DEBUG(\"Add handle data=%p watch=%d fd=%d events=%d opaque=%p\",\n              data, data->watch, data->fd, events, data->opaque);\n\n    if (events != 0) {\n        data->source = virEventGLibAddSocketWatch(\n            fd, cond, NULL, virEventGLibHandleDispatch, data, NULL);\n    }\n\n    g_ptr_array_add(handles, data);\n\n    ret = data->watch;\n\n    PROBE(EVENT_GLIB_ADD_HANDLE,\n          \"watch=%d fd=%d events=%d cb=%p opaque=%p ff=%p\",\n          ret, fd, events, cb, opaque, ff);\n    g_mutex_unlock(eventlock);\n\n    return ret;\n}"
  },
  {
    "function_name": "virEventGLibHandleDispatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
    "lines": "105-123",
    "snippet": "static gboolean\nvirEventGLibHandleDispatch(int fd G_GNUC_UNUSED,\n                           GIOCondition condition,\n                           gpointer opaque)\n{\n    struct virEventGLibHandle *data = opaque;\n    int events = virEventGLibConditionToEvents(condition);\n\n    VIR_DEBUG(\"Dispatch handler data=%p watch=%d fd=%d events=%d opaque=%p\",\n              data, data->watch, data->fd, events, data->opaque);\n\n    PROBE(EVENT_GLIB_DISPATCH_HANDLE,\n          \"watch=%d events=%d cb=%p opaque=%p\",\n          data->watch, events, data->cb, data->opaque);\n\n    (data->cb)(data->watch, data->fd, events, data->opaque);\n\n    return TRUE;\n}",
    "includes": [
      "# include <io.h>",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vireventglibwatch.h\"",
      "#include \"vireventglib.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "data->watch",
            "data->fd",
            "events",
            "data->opaque"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "EVENT_GLIB_DISPATCH_HANDLE",
            "\"watch=%d events=%d cb=%p opaque=%p\"",
            "data->watch",
            "events",
            "data->cb",
            "data->opaque"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Dispatch handler data=%p watch=%d fd=%d events=%d opaque=%p\"",
            "data",
            "data->watch",
            "data->fd",
            "events",
            "data->opaque"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventGLibConditionToEvents",
          "args": [
            "condition"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "virEventGLibConditionToEvents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
          "lines": "88-103",
          "snippet": "static int\nvirEventGLibConditionToEvents(GIOCondition cond)\n{\n    int events = 0;\n    if (cond & G_IO_IN)\n        events |= VIR_EVENT_HANDLE_READABLE;\n    if (cond & G_IO_OUT)\n        events |= VIR_EVENT_HANDLE_WRITABLE;\n    if (cond & G_IO_ERR)\n        events |= VIR_EVENT_HANDLE_ERROR;\n    if (cond & G_IO_NVAL) /* Treat NVAL as error, since libvirt doesn't distinguish */\n        events |= VIR_EVENT_HANDLE_ERROR;\n    if (cond & G_IO_HUP)\n        events |= VIR_EVENT_HANDLE_HANGUP;\n    return events;\n}",
          "includes": [
            "# include <io.h>",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vireventglibwatch.h\"",
            "#include \"vireventglib.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int\nvirEventGLibConditionToEvents(GIOCondition cond)\n{\n    int events = 0;\n    if (cond & G_IO_IN)\n        events |= VIR_EVENT_HANDLE_READABLE;\n    if (cond & G_IO_OUT)\n        events |= VIR_EVENT_HANDLE_WRITABLE;\n    if (cond & G_IO_ERR)\n        events |= VIR_EVENT_HANDLE_ERROR;\n    if (cond & G_IO_NVAL) /* Treat NVAL as error, since libvirt doesn't distinguish */\n        events |= VIR_EVENT_HANDLE_ERROR;\n    if (cond & G_IO_HUP)\n        events |= VIR_EVENT_HANDLE_HANGUP;\n    return events;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic gboolean\nvirEventGLibHandleDispatch(int fd G_GNUC_UNUSED,\n                           GIOCondition condition,\n                           gpointer opaque)\n{\n    struct virEventGLibHandle *data = opaque;\n    int events = virEventGLibConditionToEvents(condition);\n\n    VIR_DEBUG(\"Dispatch handler data=%p watch=%d fd=%d events=%d opaque=%p\",\n              data, data->watch, data->fd, events, data->opaque);\n\n    PROBE(EVENT_GLIB_DISPATCH_HANDLE,\n          \"watch=%d events=%d cb=%p opaque=%p\",\n          data->watch, events, data->cb, data->opaque);\n\n    (data->cb)(data->watch, data->fd, events, data->opaque);\n\n    return TRUE;\n}"
  },
  {
    "function_name": "virEventGLibConditionToEvents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
    "lines": "88-103",
    "snippet": "static int\nvirEventGLibConditionToEvents(GIOCondition cond)\n{\n    int events = 0;\n    if (cond & G_IO_IN)\n        events |= VIR_EVENT_HANDLE_READABLE;\n    if (cond & G_IO_OUT)\n        events |= VIR_EVENT_HANDLE_WRITABLE;\n    if (cond & G_IO_ERR)\n        events |= VIR_EVENT_HANDLE_ERROR;\n    if (cond & G_IO_NVAL) /* Treat NVAL as error, since libvirt doesn't distinguish */\n        events |= VIR_EVENT_HANDLE_ERROR;\n    if (cond & G_IO_HUP)\n        events |= VIR_EVENT_HANDLE_HANGUP;\n    return events;\n}",
    "includes": [
      "# include <io.h>",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vireventglibwatch.h\"",
      "#include \"vireventglib.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int\nvirEventGLibConditionToEvents(GIOCondition cond)\n{\n    int events = 0;\n    if (cond & G_IO_IN)\n        events |= VIR_EVENT_HANDLE_READABLE;\n    if (cond & G_IO_OUT)\n        events |= VIR_EVENT_HANDLE_WRITABLE;\n    if (cond & G_IO_ERR)\n        events |= VIR_EVENT_HANDLE_ERROR;\n    if (cond & G_IO_NVAL) /* Treat NVAL as error, since libvirt doesn't distinguish */\n        events |= VIR_EVENT_HANDLE_ERROR;\n    if (cond & G_IO_HUP)\n        events |= VIR_EVENT_HANDLE_HANGUP;\n    return events;\n}"
  },
  {
    "function_name": "virEventGLibEventsToCondition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vireventglib.c",
    "lines": "73-86",
    "snippet": "static GIOCondition\nvirEventGLibEventsToCondition(int events)\n{\n    GIOCondition cond = 0;\n    if (events & VIR_EVENT_HANDLE_READABLE)\n        cond |= G_IO_IN;\n    if (events & VIR_EVENT_HANDLE_WRITABLE)\n        cond |= G_IO_OUT;\n    if (events & VIR_EVENT_HANDLE_ERROR)\n        cond |= G_IO_ERR;\n    if (events & VIR_EVENT_HANDLE_HANGUP)\n        cond |= G_IO_HUP;\n    return cond;\n}",
    "includes": [
      "# include <io.h>",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vireventglibwatch.h\"",
      "#include \"vireventglib.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "# include <io.h>\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vireventglibwatch.h\"\n#include \"vireventglib.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GIOCondition\nvirEventGLibEventsToCondition(int events)\n{\n    GIOCondition cond = 0;\n    if (events & VIR_EVENT_HANDLE_READABLE)\n        cond |= G_IO_IN;\n    if (events & VIR_EVENT_HANDLE_WRITABLE)\n        cond |= G_IO_OUT;\n    if (events & VIR_EVENT_HANDLE_ERROR)\n        cond |= G_IO_ERR;\n    if (events & VIR_EVENT_HANDLE_HANGUP)\n        cond |= G_IO_HUP;\n    return cond;\n}"
  }
]