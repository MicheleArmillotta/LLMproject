[
  {
    "function_name": "virNumaGetHostMemoryNodeset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "1018-1042",
    "snippet": "virBitmapPtr\nvirNumaGetHostMemoryNodeset(void)\n{\n    int maxnode = virNumaGetMaxNode();\n    unsigned long long nodesize;\n    size_t i = 0;\n    virBitmapPtr nodeset = NULL;\n\n    if (maxnode < 0)\n        return NULL;\n\n    if (!(nodeset = virBitmapNew(maxnode + 1)))\n        return NULL;\n\n    for (i = 0; i <= maxnode; i++) {\n        if (!virNumaNodeIsAvailable(i))\n            continue;\n\n        /* if we can't detect NUMA node size assume that it's present */\n        if (virNumaGetNodeMemory(i, &nodesize, NULL) < 0 || nodesize > 0)\n            ignore_value(virBitmapSetBit(nodeset, i));\n    }\n\n    return nodeset;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(nodeset, i)"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "nodeset",
            "i"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaGetNodeMemory",
          "args": [
            "i",
            "&nodesize",
            "NULL"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetNodeMemory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "371-384",
          "snippet": "int\nvirNumaGetNodeMemory(int node G_GNUC_UNUSED,\n                     unsigned long long *memsize,\n                     unsigned long long *memfree)\n{\n    if (memsize)\n        *memsize = 0;\n\n    if (memfree)\n        *memfree = 0;\n\n    VIR_DEBUG(\"NUMA isn't available on this host\");\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetNodeMemory(int node G_GNUC_UNUSED,\n                     unsigned long long *memsize,\n                     unsigned long long *memfree)\n{\n    if (memsize)\n        *memsize = 0;\n\n    if (memfree)\n        *memfree = 0;\n\n    VIR_DEBUG(\"NUMA isn't available on this host\");\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaNodeIsAvailable",
          "args": [
            "i"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaNodeIsAvailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "497-507",
          "snippet": "bool\nvirNumaNodeIsAvailable(int node)\n{\n    int max_node = virNumaGetMaxNode();\n\n    if (max_node < 0)\n        return false;\n\n    /* Do we have anything better? */\n    return (node >= 0) && (node <= max_node);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaNodeIsAvailable(int node)\n{\n    int max_node = virNumaGetMaxNode();\n\n    if (max_node < 0)\n        return false;\n\n    /* Do we have anything better? */\n    return (node >= 0) && (node <= max_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "maxnode + 1"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaGetMaxNode",
          "args": [],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetMaxNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "362-368",
          "snippet": "int\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nvirBitmapPtr\nvirNumaGetHostMemoryNodeset(void)\n{\n    int maxnode = virNumaGetMaxNode();\n    unsigned long long nodesize;\n    size_t i = 0;\n    virBitmapPtr nodeset = NULL;\n\n    if (maxnode < 0)\n        return NULL;\n\n    if (!(nodeset = virBitmapNew(maxnode + 1)))\n        return NULL;\n\n    for (i = 0; i <= maxnode; i++) {\n        if (!virNumaNodeIsAvailable(i))\n            continue;\n\n        /* if we can't detect NUMA node size assume that it's present */\n        if (virNumaGetNodeMemory(i, &nodesize, NULL) < 0 || nodesize > 0)\n            ignore_value(virBitmapSetBit(nodeset, i));\n    }\n\n    return nodeset;\n}"
  },
  {
    "function_name": "virNumaNodesetIsAvailable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "993-1010",
    "snippet": "bool\nvirNumaNodesetIsAvailable(virBitmapPtr nodeset)\n{\n    ssize_t bit = -1;\n\n    if (!nodeset)\n        return true;\n\n    while ((bit = virBitmapNextSetBit(nodeset, bit)) >= 0) {\n        if (virNumaNodeIsAvailable(bit))\n            continue;\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"NUMA node %zd is unavailable\"), bit);\n        return false;\n    }\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"NUMA node %zd is unavailable\")",
            "bit"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"NUMA node %zd is unavailable\""
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaNodeIsAvailable",
          "args": [
            "bit"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaNodeIsAvailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "497-507",
          "snippet": "bool\nvirNumaNodeIsAvailable(int node)\n{\n    int max_node = virNumaGetMaxNode();\n\n    if (max_node < 0)\n        return false;\n\n    /* Do we have anything better? */\n    return (node >= 0) && (node <= max_node);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaNodeIsAvailable(int node)\n{\n    int max_node = virNumaGetMaxNode();\n\n    if (max_node < 0)\n        return false;\n\n    /* Do we have anything better? */\n    return (node >= 0) && (node <= max_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNextSetBit",
          "args": [
            "nodeset",
            "bit"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNextSetBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "986-1014",
          "snippet": "ssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaNodesetIsAvailable(virBitmapPtr nodeset)\n{\n    ssize_t bit = -1;\n\n    if (!nodeset)\n        return true;\n\n    while ((bit = virBitmapNextSetBit(nodeset, bit)) >= 0) {\n        if (virNumaNodeIsAvailable(bit))\n            continue;\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"NUMA node %zd is unavailable\"), bit);\n        return false;\n    }\n    return true;\n}"
  },
  {
    "function_name": "virNumaSetPagePoolSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "981-990",
    "snippet": "int\nvirNumaSetPagePoolSize(int node G_GNUC_UNUSED,\n                       unsigned int page_size G_GNUC_UNUSED,\n                       unsigned long long page_count G_GNUC_UNUSED,\n                       bool add G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                   _(\"page pool allocation is not supported on this platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"page pool allocation is not supported on this platform\")"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"page pool allocation is not supported on this platform\""
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaSetPagePoolSize(int node G_GNUC_UNUSED,\n                       unsigned int page_size G_GNUC_UNUSED,\n                       unsigned long long page_count G_GNUC_UNUSED,\n                       bool add G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                   _(\"page pool allocation is not supported on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNumaGetPages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "968-978",
    "snippet": "int\nvirNumaGetPages(int node G_GNUC_UNUSED,\n                unsigned int **pages_size G_GNUC_UNUSED,\n                unsigned long long **pages_avail G_GNUC_UNUSED,\n                unsigned long long **pages_free G_GNUC_UNUSED,\n                size_t *npages G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                   _(\"page info is not supported on this platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"page info is not supported on this platform\")"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"page info is not supported on this platform\""
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetPages(int node G_GNUC_UNUSED,\n                unsigned int **pages_size G_GNUC_UNUSED,\n                unsigned long long **pages_avail G_GNUC_UNUSED,\n                unsigned long long **pages_free G_GNUC_UNUSED,\n                size_t *npages G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                   _(\"page info is not supported on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNumaGetPageInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "955-965",
    "snippet": "int\nvirNumaGetPageInfo(int node G_GNUC_UNUSED,\n                   unsigned int page_size G_GNUC_UNUSED,\n                   unsigned long long huge_page_sum G_GNUC_UNUSED,\n                   unsigned long long *page_avail G_GNUC_UNUSED,\n                   unsigned long long *page_free G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                   _(\"page info is not supported on this platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"page info is not supported on this platform\")"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"page info is not supported on this platform\""
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetPageInfo(int node G_GNUC_UNUSED,\n                   unsigned int page_size G_GNUC_UNUSED,\n                   unsigned long long huge_page_sum G_GNUC_UNUSED,\n                   unsigned long long *page_avail G_GNUC_UNUSED,\n                   unsigned long long *page_free G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                   _(\"page info is not supported on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNumaSetPagePoolSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "865-951",
    "snippet": "int\nvirNumaSetPagePoolSize(int node,\n                       unsigned int page_size,\n                       unsigned long long page_count,\n                       bool add)\n{\n    char *end;\n    unsigned long long nr_count;\n    g_autofree char *nr_path = NULL;\n    g_autofree char *nr_buf =  NULL;\n\n    if (page_size == virGetSystemPageSizeKB()) {\n        /* Special case as kernel handles system pages\n         * differently to huge pages. */\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"system pages pool can't be modified\"));\n        return -1;\n    }\n\n    if (virNumaGetHugePageInfoPath(&nr_path, node, page_size, \"nr_hugepages\") < 0)\n        return -1;\n\n    /* Firstly check, if there's anything for us to do */\n    if (virFileReadAll(nr_path, 1024, &nr_buf) < 0)\n        return -1;\n\n    if (virStrToLong_ull(nr_buf, &end, 10, &nr_count) < 0 ||\n        *end != '\\n') {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"invalid number '%s' in '%s'\"),\n                       nr_buf, nr_path);\n        return -1;\n    }\n\n    if (add) {\n        if (!page_count) {\n            VIR_DEBUG(\"Nothing left to do: add = true page_count = 0\");\n            return 0;\n        }\n        page_count += nr_count;\n    } else {\n        if (nr_count == page_count) {\n            VIR_DEBUG(\"Nothing left to do: nr_count = page_count = %llu\",\n                      page_count);\n            return 0;\n        }\n    }\n\n    /* Okay, page pool adjustment must be done in two steps. In\n     * first we write the desired number into nr_hugepages file.\n     * Kernel then starts to allocate the pages (return from\n     * write should be postponed until the kernel is finished).\n     * However, kernel may have not been successful and reserved\n     * all the pages we wanted. So do the second read to check.\n     */\n    VIR_FREE(nr_buf);\n    nr_buf = g_strdup_printf(\"%llu\", page_count);\n\n    if (virFileWriteStr(nr_path, nr_buf, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to write to: %s\"), nr_path);\n        return -1;\n    }\n\n    /* And now do the check. */\n\n    VIR_FREE(nr_buf);\n    if (virFileReadAll(nr_path, 1024, &nr_buf) < 0)\n        return -1;\n\n    if (virStrToLong_ull(nr_buf, &end, 10, &nr_count) < 0 ||\n        *end != '\\n') {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"invalid number '%s' in '%s'\"),\n                       nr_buf, nr_path);\n        return -1;\n    }\n\n    if (nr_count != page_count) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Unable to allocate %llu pages. Allocated only %llu\"),\n                       page_count, nr_count);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Unable to allocate %llu pages. Allocated only %llu\")",
            "page_count",
            "nr_count"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to allocate %llu pages. Allocated only %llu\""
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"invalid number '%s' in '%s'\")",
            "nr_buf",
            "nr_path"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ull",
          "args": [
            "nr_buf",
            "&end",
            "10",
            "&nr_count"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ullp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "568-586",
          "snippet": "int\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "nr_path",
            "1024",
            "&nr_buf"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nr_buf"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to write to: %s\")",
            "nr_path"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileWriteStr",
          "args": [
            "nr_path",
            "nr_buf",
            "0"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "virFileWriteStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1502-1524",
          "snippet": "int\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nr_buf"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Nothing left to do: nr_count = page_count = %llu\"",
            "page_count"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Nothing left to do: add = true page_count = 0\""
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"invalid number '%s' in '%s'\")",
            "nr_buf",
            "nr_path"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNumaGetHugePageInfoPath",
          "args": [
            "&nr_path",
            "node",
            "page_size",
            "\"nr_hugepages\""
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetHugePageInfoPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "530-567",
          "snippet": "static int\nvirNumaGetHugePageInfoPath(char **path,\n                           int node,\n                           unsigned int page_size,\n                           const char *suffix)\n{\n    if (node == -1) {\n        /* We are aiming at overall system info */\n        *path = g_strdup_printf(HUGEPAGES_SYSTEM_PREFIX HUGEPAGES_PREFIX \"%ukB/%s\",\n                                page_size, NULLSTR_EMPTY(suffix));\n    } else {\n        /* We are aiming on specific NUMA node */\n        *path = g_strdup_printf(HUGEPAGES_NUMA_PREFIX \"node%d/hugepages/\"\n                                HUGEPAGES_PREFIX \"%ukB/%s\",\n                                node, page_size, NULLSTR_EMPTY(suffix));\n    }\n\n    if (!virFileExists(*path)) {\n        if (node != -1) {\n            if (!virNumaNodeIsAvailable(node)) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"NUMA node %d is not available\"),\n                               node);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"page size %u is not available on node %d\"),\n                               page_size, node);\n            }\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"page size %u is not available\"),\n                           page_size);\n        }\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nstatic int\nvirNumaGetHugePageInfoPath(char **path,\n                           int node,\n                           unsigned int page_size,\n                           const char *suffix)\n{\n    if (node == -1) {\n        /* We are aiming at overall system info */\n        *path = g_strdup_printf(HUGEPAGES_SYSTEM_PREFIX HUGEPAGES_PREFIX \"%ukB/%s\",\n                                page_size, NULLSTR_EMPTY(suffix));\n    } else {\n        /* We are aiming on specific NUMA node */\n        *path = g_strdup_printf(HUGEPAGES_NUMA_PREFIX \"node%d/hugepages/\"\n                                HUGEPAGES_PREFIX \"%ukB/%s\",\n                                node, page_size, NULLSTR_EMPTY(suffix));\n    }\n\n    if (!virFileExists(*path)) {\n        if (node != -1) {\n            if (!virNumaNodeIsAvailable(node)) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"NUMA node %d is not available\"),\n                               node);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"page size %u is not available on node %d\"),\n                               page_size, node);\n            }\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"page size %u is not available\"),\n                           page_size);\n        }\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"system pages pool can't be modified\")"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetSystemPageSizeKB",
          "args": [],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "virGetSystemPageSizeKB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1602-1608",
          "snippet": "long virGetSystemPageSizeKB(void)\n{\n    long val = virGetSystemPageSize();\n    if (val < 0)\n        return val;\n    return val / 1024;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nlong virGetSystemPageSizeKB(void)\n{\n    long val = virGetSystemPageSize();\n    if (val < 0)\n        return val;\n    return val / 1024;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaSetPagePoolSize(int node,\n                       unsigned int page_size,\n                       unsigned long long page_count,\n                       bool add)\n{\n    char *end;\n    unsigned long long nr_count;\n    g_autofree char *nr_path = NULL;\n    g_autofree char *nr_buf =  NULL;\n\n    if (page_size == virGetSystemPageSizeKB()) {\n        /* Special case as kernel handles system pages\n         * differently to huge pages. */\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"system pages pool can't be modified\"));\n        return -1;\n    }\n\n    if (virNumaGetHugePageInfoPath(&nr_path, node, page_size, \"nr_hugepages\") < 0)\n        return -1;\n\n    /* Firstly check, if there's anything for us to do */\n    if (virFileReadAll(nr_path, 1024, &nr_buf) < 0)\n        return -1;\n\n    if (virStrToLong_ull(nr_buf, &end, 10, &nr_count) < 0 ||\n        *end != '\\n') {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"invalid number '%s' in '%s'\"),\n                       nr_buf, nr_path);\n        return -1;\n    }\n\n    if (add) {\n        if (!page_count) {\n            VIR_DEBUG(\"Nothing left to do: add = true page_count = 0\");\n            return 0;\n        }\n        page_count += nr_count;\n    } else {\n        if (nr_count == page_count) {\n            VIR_DEBUG(\"Nothing left to do: nr_count = page_count = %llu\",\n                      page_count);\n            return 0;\n        }\n    }\n\n    /* Okay, page pool adjustment must be done in two steps. In\n     * first we write the desired number into nr_hugepages file.\n     * Kernel then starts to allocate the pages (return from\n     * write should be postponed until the kernel is finished).\n     * However, kernel may have not been successful and reserved\n     * all the pages we wanted. So do the second read to check.\n     */\n    VIR_FREE(nr_buf);\n    nr_buf = g_strdup_printf(\"%llu\", page_count);\n\n    if (virFileWriteStr(nr_path, nr_buf, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to write to: %s\"), nr_path);\n        return -1;\n    }\n\n    /* And now do the check. */\n\n    VIR_FREE(nr_buf);\n    if (virFileReadAll(nr_path, 1024, &nr_buf) < 0)\n        return -1;\n\n    if (virStrToLong_ull(nr_buf, &end, 10, &nr_count) < 0 ||\n        *end != '\\n') {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"invalid number '%s' in '%s'\"),\n                       nr_buf, nr_path);\n        return -1;\n    }\n\n    if (nr_count != page_count) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Unable to allocate %llu pages. Allocated only %llu\"),\n                       page_count, nr_count);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNumaGetPages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "738-862",
    "snippet": "int\nvirNumaGetPages(int node,\n                unsigned int **pages_size,\n                unsigned long long **pages_avail,\n                unsigned long long **pages_free,\n                size_t *npages)\n{\n    int ret = -1;\n    DIR *dir = NULL;\n    int direrr = 0;\n    struct dirent *entry;\n    unsigned int ntmp = 0;\n    size_t i;\n    bool exchange;\n    long system_page_size;\n    unsigned long long huge_page_sum = 0;\n    g_autofree char *path = NULL;\n    g_autofree unsigned int *tmp_size = NULL;\n    g_autofree unsigned long long *tmp_avail = NULL;\n    g_autofree unsigned long long *tmp_free = NULL;\n\n    /* sysconf() returns page size in bytes,\n     * but we are storing the page size in kibibytes. */\n    system_page_size = virGetSystemPageSizeKB();\n\n    /* Query huge pages at first.\n     * On Linux systems, the huge pages pool cuts off the available memory and\n     * is always shown as used memory. Here, however, we want to report\n     * slightly different information. So we take the total memory on a node\n     * and subtract memory taken by the huge pages. */\n    if (virNumaGetHugePageInfoDir(&path, node) < 0)\n        goto cleanup;\n\n    /* It's okay if the @path doesn't exist. Maybe we are running on\n     * system without huge pages support where the path may not exist. */\n    if (virDirOpenIfExists(&dir, path) < 0)\n        goto cleanup;\n\n    while (dir && (direrr = virDirRead(dir, &entry, path)) > 0) {\n        const char *page_name = entry->d_name;\n        unsigned int page_size;\n        unsigned long long page_avail = 0;\n        unsigned long long page_free = 0;\n        char *end;\n\n        /* Just to give you a hint, we're dealing with this:\n         * hugepages-2048kB/  or   hugepages-1048576kB/ */\n        if (!STRPREFIX(entry->d_name, HUGEPAGES_PREFIX))\n            continue;\n\n        page_name += strlen(HUGEPAGES_PREFIX);\n\n        if (virStrToLong_ui(page_name, &end, 10, &page_size) < 0 ||\n            STRCASENEQ(end, \"kB\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse %s\"),\n                           entry->d_name);\n            goto cleanup;\n        }\n\n        if (virNumaGetHugePageInfo(node, page_size,\n                                   &page_avail, &page_free) < 0)\n            goto cleanup;\n\n        if (VIR_REALLOC_N(tmp_size, ntmp + 1) < 0 ||\n            VIR_REALLOC_N(tmp_avail, ntmp + 1) < 0 ||\n            VIR_REALLOC_N(tmp_free, ntmp + 1) < 0)\n            goto cleanup;\n\n        tmp_size[ntmp] = page_size;\n        tmp_avail[ntmp] = page_avail;\n        tmp_free[ntmp] = page_free;\n        ntmp++;\n\n        /* page_size is in kibibytes while we want huge_page_sum\n         * in just bytes. */\n        huge_page_sum += 1024 * page_size * page_avail;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    /* Now append the ordinary system pages */\n    if (VIR_REALLOC_N(tmp_size, ntmp + 1) < 0 ||\n        VIR_REALLOC_N(tmp_avail, ntmp + 1) < 0 ||\n        VIR_REALLOC_N(tmp_free, ntmp + 1) < 0)\n        goto cleanup;\n\n    if (virNumaGetPageInfo(node, system_page_size, huge_page_sum,\n                           &tmp_avail[ntmp], &tmp_free[ntmp]) < 0)\n        goto cleanup;\n    tmp_size[ntmp] = system_page_size;\n    ntmp++;\n\n    /* Just to produce nice output, sort the arrays by increasing page size */\n    do {\n        exchange = false;\n        for (i = 0; i < ntmp -1; i++) {\n            if (tmp_size[i] > tmp_size[i + 1]) {\n                exchange = true;\n                SWAP(tmp_size[i], tmp_size[i + 1]);\n                SWAP(tmp_avail[i], tmp_avail[i + 1]);\n                SWAP(tmp_free[i], tmp_free[i + 1]);\n            }\n        }\n    } while (exchange);\n\n    if (pages_size) {\n        *pages_size = tmp_size;\n        tmp_size = NULL;\n    }\n    if (pages_avail) {\n        *pages_avail = tmp_avail;\n        tmp_avail = NULL;\n    }\n    if (pages_free) {\n        *pages_free = tmp_free;\n        tmp_free = NULL;\n    }\n    *npages = ntmp;\n    ret = 0;\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "dir"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAP",
          "args": [
            "tmp_free[i]",
            "tmp_free[i + 1]"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAP",
          "args": [
            "tmp_avail[i]",
            "tmp_avail[i + 1]"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAP",
          "args": [
            "tmp_size[i]",
            "tmp_size[i + 1]"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNumaGetPageInfo",
          "args": [
            "node",
            "system_page_size",
            "huge_page_sum",
            "&tmp_avail[ntmp]",
            "&tmp_free[ntmp]"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetPageInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "955-965",
          "snippet": "int\nvirNumaGetPageInfo(int node G_GNUC_UNUSED,\n                   unsigned int page_size G_GNUC_UNUSED,\n                   unsigned long long huge_page_sum G_GNUC_UNUSED,\n                   unsigned long long *page_avail G_GNUC_UNUSED,\n                   unsigned long long *page_free G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                   _(\"page info is not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetPageInfo(int node G_GNUC_UNUSED,\n                   unsigned int page_size G_GNUC_UNUSED,\n                   unsigned long long huge_page_sum G_GNUC_UNUSED,\n                   unsigned long long *page_avail G_GNUC_UNUSED,\n                   unsigned long long *page_free G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                   _(\"page info is not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "tmp_free",
            "ntmp + 1"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "tmp_avail",
            "ntmp + 1"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "tmp_size",
            "ntmp + 1"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "tmp_free",
            "ntmp + 1"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "tmp_avail",
            "ntmp + 1"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "tmp_size",
            "ntmp + 1"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNumaGetHugePageInfo",
          "args": [
            "node",
            "page_size",
            "&page_avail",
            "&page_free"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetHugePageInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "600-647",
          "snippet": "static int\nvirNumaGetHugePageInfo(int node,\n                       unsigned int page_size,\n                       unsigned long long *page_avail,\n                       unsigned long long *page_free)\n{\n    char *end;\n    g_autofree char *path = NULL;\n    g_autofree char *buf = NULL;\n\n    if (page_avail) {\n        if (virNumaGetHugePageInfoPath(&path, node,\n                                       page_size, \"nr_hugepages\") < 0)\n            return -1;\n\n        if (virFileReadAll(path, 1024, &buf) < 0)\n            return -1;\n\n        if (virStrToLong_ull(buf, &end, 10, page_avail) < 0 ||\n            *end != '\\n') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse: %s\"),\n                           buf);\n            return -1;\n        }\n        VIR_FREE(buf);\n        VIR_FREE(path);\n    }\n\n    if (page_free) {\n        if (virNumaGetHugePageInfoPath(&path, node,\n                                       page_size, \"free_hugepages\") < 0)\n            return -1;\n\n        if (virFileReadAll(path, 1024, &buf) < 0)\n            return -1;\n\n        if (virStrToLong_ull(buf, &end, 10, page_free) < 0 ||\n            *end != '\\n') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse: %s\"),\n                           buf);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nstatic int\nvirNumaGetHugePageInfo(int node,\n                       unsigned int page_size,\n                       unsigned long long *page_avail,\n                       unsigned long long *page_free)\n{\n    char *end;\n    g_autofree char *path = NULL;\n    g_autofree char *buf = NULL;\n\n    if (page_avail) {\n        if (virNumaGetHugePageInfoPath(&path, node,\n                                       page_size, \"nr_hugepages\") < 0)\n            return -1;\n\n        if (virFileReadAll(path, 1024, &buf) < 0)\n            return -1;\n\n        if (virStrToLong_ull(buf, &end, 10, page_avail) < 0 ||\n            *end != '\\n') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse: %s\"),\n                           buf);\n            return -1;\n        }\n        VIR_FREE(buf);\n        VIR_FREE(path);\n    }\n\n    if (page_free) {\n        if (virNumaGetHugePageInfoPath(&path, node,\n                                       page_size, \"free_hugepages\") < 0)\n            return -1;\n\n        if (virFileReadAll(path, 1024, &buf) < 0)\n            return -1;\n\n        if (virStrToLong_ull(buf, &end, 10, page_free) < 0 ||\n            *end != '\\n') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse: %s\"),\n                           buf);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unable to parse %s\")",
            "entry->d_name"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to parse %s\""
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASENEQ",
          "args": [
            "end",
            "\"kB\""
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "page_name",
            "&end",
            "10",
            "&page_size"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "HUGEPAGES_PREFIX"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "entry->d_name",
            "HUGEPAGES_PREFIX"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "dir",
            "&entry",
            "path"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirOpenIfExists",
          "args": [
            "&dir",
            "path"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenIfExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2898-2902",
          "snippet": "int\nvirDirOpenIfExists(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, true, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenIfExists(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, true, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaGetHugePageInfoDir",
          "args": [
            "&path",
            "node"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetHugePageInfoDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "569-580",
          "snippet": "static int\nvirNumaGetHugePageInfoDir(char **path, int node)\n{\n    if (node == -1) {\n        *path = g_strdup(HUGEPAGES_SYSTEM_PREFIX);\n        return 0;\n    } else {\n        *path = g_strdup_printf(HUGEPAGES_NUMA_PREFIX \"node%d/hugepages/\",\n                                node);\n        return 0;\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nstatic int\nvirNumaGetHugePageInfoDir(char **path, int node)\n{\n    if (node == -1) {\n        *path = g_strdup(HUGEPAGES_SYSTEM_PREFIX);\n        return 0;\n    } else {\n        *path = g_strdup_printf(HUGEPAGES_NUMA_PREFIX \"node%d/hugepages/\",\n                                node);\n        return 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetSystemPageSizeKB",
          "args": [],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "virGetSystemPageSizeKB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1602-1608",
          "snippet": "long virGetSystemPageSizeKB(void)\n{\n    long val = virGetSystemPageSize();\n    if (val < 0)\n        return val;\n    return val / 1024;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nlong virGetSystemPageSizeKB(void)\n{\n    long val = virGetSystemPageSize();\n    if (val < 0)\n        return val;\n    return val / 1024;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetPages(int node,\n                unsigned int **pages_size,\n                unsigned long long **pages_avail,\n                unsigned long long **pages_free,\n                size_t *npages)\n{\n    int ret = -1;\n    DIR *dir = NULL;\n    int direrr = 0;\n    struct dirent *entry;\n    unsigned int ntmp = 0;\n    size_t i;\n    bool exchange;\n    long system_page_size;\n    unsigned long long huge_page_sum = 0;\n    g_autofree char *path = NULL;\n    g_autofree unsigned int *tmp_size = NULL;\n    g_autofree unsigned long long *tmp_avail = NULL;\n    g_autofree unsigned long long *tmp_free = NULL;\n\n    /* sysconf() returns page size in bytes,\n     * but we are storing the page size in kibibytes. */\n    system_page_size = virGetSystemPageSizeKB();\n\n    /* Query huge pages at first.\n     * On Linux systems, the huge pages pool cuts off the available memory and\n     * is always shown as used memory. Here, however, we want to report\n     * slightly different information. So we take the total memory on a node\n     * and subtract memory taken by the huge pages. */\n    if (virNumaGetHugePageInfoDir(&path, node) < 0)\n        goto cleanup;\n\n    /* It's okay if the @path doesn't exist. Maybe we are running on\n     * system without huge pages support where the path may not exist. */\n    if (virDirOpenIfExists(&dir, path) < 0)\n        goto cleanup;\n\n    while (dir && (direrr = virDirRead(dir, &entry, path)) > 0) {\n        const char *page_name = entry->d_name;\n        unsigned int page_size;\n        unsigned long long page_avail = 0;\n        unsigned long long page_free = 0;\n        char *end;\n\n        /* Just to give you a hint, we're dealing with this:\n         * hugepages-2048kB/  or   hugepages-1048576kB/ */\n        if (!STRPREFIX(entry->d_name, HUGEPAGES_PREFIX))\n            continue;\n\n        page_name += strlen(HUGEPAGES_PREFIX);\n\n        if (virStrToLong_ui(page_name, &end, 10, &page_size) < 0 ||\n            STRCASENEQ(end, \"kB\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse %s\"),\n                           entry->d_name);\n            goto cleanup;\n        }\n\n        if (virNumaGetHugePageInfo(node, page_size,\n                                   &page_avail, &page_free) < 0)\n            goto cleanup;\n\n        if (VIR_REALLOC_N(tmp_size, ntmp + 1) < 0 ||\n            VIR_REALLOC_N(tmp_avail, ntmp + 1) < 0 ||\n            VIR_REALLOC_N(tmp_free, ntmp + 1) < 0)\n            goto cleanup;\n\n        tmp_size[ntmp] = page_size;\n        tmp_avail[ntmp] = page_avail;\n        tmp_free[ntmp] = page_free;\n        ntmp++;\n\n        /* page_size is in kibibytes while we want huge_page_sum\n         * in just bytes. */\n        huge_page_sum += 1024 * page_size * page_avail;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    /* Now append the ordinary system pages */\n    if (VIR_REALLOC_N(tmp_size, ntmp + 1) < 0 ||\n        VIR_REALLOC_N(tmp_avail, ntmp + 1) < 0 ||\n        VIR_REALLOC_N(tmp_free, ntmp + 1) < 0)\n        goto cleanup;\n\n    if (virNumaGetPageInfo(node, system_page_size, huge_page_sum,\n                           &tmp_avail[ntmp], &tmp_free[ntmp]) < 0)\n        goto cleanup;\n    tmp_size[ntmp] = system_page_size;\n    ntmp++;\n\n    /* Just to produce nice output, sort the arrays by increasing page size */\n    do {\n        exchange = false;\n        for (i = 0; i < ntmp -1; i++) {\n            if (tmp_size[i] > tmp_size[i + 1]) {\n                exchange = true;\n                SWAP(tmp_size[i], tmp_size[i + 1]);\n                SWAP(tmp_avail[i], tmp_avail[i + 1]);\n                SWAP(tmp_free[i], tmp_free[i + 1]);\n            }\n        }\n    } while (exchange);\n\n    if (pages_size) {\n        *pages_size = tmp_size;\n        tmp_size = NULL;\n    }\n    if (pages_avail) {\n        *pages_avail = tmp_avail;\n        tmp_avail = NULL;\n    }\n    if (pages_free) {\n        *pages_free = tmp_free;\n        tmp_free = NULL;\n    }\n    *npages = ntmp;\n    ret = 0;\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}"
  },
  {
    "function_name": "virNumaGetPageInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "676-714",
    "snippet": "int\nvirNumaGetPageInfo(int node,\n                   unsigned int page_size,\n                   unsigned long long huge_page_sum,\n                   unsigned long long *page_avail,\n                   unsigned long long *page_free)\n{\n    long system_page_size = virGetSystemPageSize();\n\n    /* sysconf() returns page size in bytes,\n     * the @page_size is however in kibibytes */\n    if (page_size == system_page_size / 1024) {\n        unsigned long long memsize, memfree;\n\n        /* TODO: come up with better algorithm that takes huge pages into\n         * account. The problem is huge pages cut off regular memory. */\n        if (node == -1) {\n            if (virHostMemGetInfo(&memsize, &memfree) < 0)\n                return -1;\n        } else {\n            if (virNumaGetNodeMemory(node, &memsize, &memfree) < 0)\n                return -1;\n        }\n\n        /* see description above */\n        memsize -= huge_page_sum;\n\n        if (page_avail)\n            *page_avail = memsize / system_page_size;\n\n        if (page_free)\n            *page_free = memfree / system_page_size;\n    } else {\n        if (virNumaGetHugePageInfo(node, page_size, page_avail, page_free) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNumaGetHugePageInfo",
          "args": [
            "node",
            "page_size",
            "page_avail",
            "page_free"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetHugePageInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "600-647",
          "snippet": "static int\nvirNumaGetHugePageInfo(int node,\n                       unsigned int page_size,\n                       unsigned long long *page_avail,\n                       unsigned long long *page_free)\n{\n    char *end;\n    g_autofree char *path = NULL;\n    g_autofree char *buf = NULL;\n\n    if (page_avail) {\n        if (virNumaGetHugePageInfoPath(&path, node,\n                                       page_size, \"nr_hugepages\") < 0)\n            return -1;\n\n        if (virFileReadAll(path, 1024, &buf) < 0)\n            return -1;\n\n        if (virStrToLong_ull(buf, &end, 10, page_avail) < 0 ||\n            *end != '\\n') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse: %s\"),\n                           buf);\n            return -1;\n        }\n        VIR_FREE(buf);\n        VIR_FREE(path);\n    }\n\n    if (page_free) {\n        if (virNumaGetHugePageInfoPath(&path, node,\n                                       page_size, \"free_hugepages\") < 0)\n            return -1;\n\n        if (virFileReadAll(path, 1024, &buf) < 0)\n            return -1;\n\n        if (virStrToLong_ull(buf, &end, 10, page_free) < 0 ||\n            *end != '\\n') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse: %s\"),\n                           buf);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nstatic int\nvirNumaGetHugePageInfo(int node,\n                       unsigned int page_size,\n                       unsigned long long *page_avail,\n                       unsigned long long *page_free)\n{\n    char *end;\n    g_autofree char *path = NULL;\n    g_autofree char *buf = NULL;\n\n    if (page_avail) {\n        if (virNumaGetHugePageInfoPath(&path, node,\n                                       page_size, \"nr_hugepages\") < 0)\n            return -1;\n\n        if (virFileReadAll(path, 1024, &buf) < 0)\n            return -1;\n\n        if (virStrToLong_ull(buf, &end, 10, page_avail) < 0 ||\n            *end != '\\n') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse: %s\"),\n                           buf);\n            return -1;\n        }\n        VIR_FREE(buf);\n        VIR_FREE(path);\n    }\n\n    if (page_free) {\n        if (virNumaGetHugePageInfoPath(&path, node,\n                                       page_size, \"free_hugepages\") < 0)\n            return -1;\n\n        if (virFileReadAll(path, 1024, &buf) < 0)\n            return -1;\n\n        if (virStrToLong_ull(buf, &end, 10, page_free) < 0 ||\n            *end != '\\n') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse: %s\"),\n                           buf);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaGetNodeMemory",
          "args": [
            "node",
            "&memsize",
            "&memfree"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetNodeMemory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "371-384",
          "snippet": "int\nvirNumaGetNodeMemory(int node G_GNUC_UNUSED,\n                     unsigned long long *memsize,\n                     unsigned long long *memfree)\n{\n    if (memsize)\n        *memsize = 0;\n\n    if (memfree)\n        *memfree = 0;\n\n    VIR_DEBUG(\"NUMA isn't available on this host\");\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetNodeMemory(int node G_GNUC_UNUSED,\n                     unsigned long long *memsize,\n                     unsigned long long *memfree)\n{\n    if (memsize)\n        *memsize = 0;\n\n    if (memfree)\n        *memfree = 0;\n\n    VIR_DEBUG(\"NUMA isn't available on this host\");\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostMemGetInfo",
          "args": [
            "&memsize",
            "&memfree"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "virHostMemGetInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
          "lines": "790-826",
          "snippet": "int\nvirHostMemGetInfo(unsigned long long *mem,\n                  unsigned long long *freeMem)\n{\n    int max_node;\n    int n;\n\n    if (mem)\n        *mem = 0;\n\n    if (freeMem)\n        *freeMem = 0;\n\n    if (!virNumaIsAvailable())\n        return virHostMemGetInfoFake(mem, freeMem);\n\n    if ((max_node = virNumaGetMaxNode()) < 0)\n        return -1;\n\n    for (n = 0; n <= max_node; n++) {\n        unsigned long long tmp_mem = 0, tmp_freeMem = 0;\n\n        if (!virNumaNodeIsAvailable(n))\n            continue;\n\n        if (virNumaGetNodeMemory(n, &tmp_mem, &tmp_freeMem) < 0)\n            return -1;\n\n        if (mem)\n            *mem += tmp_mem;\n\n        if (freeMem)\n            *freeMem += tmp_freeMem;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "# include <windows.h>",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostMemGetInfo(unsigned long long *mem,\n                  unsigned long long *freeMem)\n{\n    int max_node;\n    int n;\n\n    if (mem)\n        *mem = 0;\n\n    if (freeMem)\n        *freeMem = 0;\n\n    if (!virNumaIsAvailable())\n        return virHostMemGetInfoFake(mem, freeMem);\n\n    if ((max_node = virNumaGetMaxNode()) < 0)\n        return -1;\n\n    for (n = 0; n <= max_node; n++) {\n        unsigned long long tmp_mem = 0, tmp_freeMem = 0;\n\n        if (!virNumaNodeIsAvailable(n))\n            continue;\n\n        if (virNumaGetNodeMemory(n, &tmp_mem, &tmp_freeMem) < 0)\n            return -1;\n\n        if (mem)\n            *mem += tmp_mem;\n\n        if (freeMem)\n            *freeMem += tmp_freeMem;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetSystemPageSize",
          "args": [],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "virGetSystemPageSizeKB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1602-1608",
          "snippet": "long virGetSystemPageSizeKB(void)\n{\n    long val = virGetSystemPageSize();\n    if (val < 0)\n        return val;\n    return val / 1024;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nlong virGetSystemPageSizeKB(void)\n{\n    long val = virGetSystemPageSize();\n    if (val < 0)\n        return val;\n    return val / 1024;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetPageInfo(int node,\n                   unsigned int page_size,\n                   unsigned long long huge_page_sum,\n                   unsigned long long *page_avail,\n                   unsigned long long *page_free)\n{\n    long system_page_size = virGetSystemPageSize();\n\n    /* sysconf() returns page size in bytes,\n     * the @page_size is however in kibibytes */\n    if (page_size == system_page_size / 1024) {\n        unsigned long long memsize, memfree;\n\n        /* TODO: come up with better algorithm that takes huge pages into\n         * account. The problem is huge pages cut off regular memory. */\n        if (node == -1) {\n            if (virHostMemGetInfo(&memsize, &memfree) < 0)\n                return -1;\n        } else {\n            if (virNumaGetNodeMemory(node, &memsize, &memfree) < 0)\n                return -1;\n        }\n\n        /* see description above */\n        memsize -= huge_page_sum;\n\n        if (page_avail)\n            *page_avail = memsize / system_page_size;\n\n        if (page_free)\n            *page_free = memfree / system_page_size;\n    } else {\n        if (virNumaGetHugePageInfo(node, page_size, page_avail, page_free) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNumaGetHugePageInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "600-647",
    "snippet": "static int\nvirNumaGetHugePageInfo(int node,\n                       unsigned int page_size,\n                       unsigned long long *page_avail,\n                       unsigned long long *page_free)\n{\n    char *end;\n    g_autofree char *path = NULL;\n    g_autofree char *buf = NULL;\n\n    if (page_avail) {\n        if (virNumaGetHugePageInfoPath(&path, node,\n                                       page_size, \"nr_hugepages\") < 0)\n            return -1;\n\n        if (virFileReadAll(path, 1024, &buf) < 0)\n            return -1;\n\n        if (virStrToLong_ull(buf, &end, 10, page_avail) < 0 ||\n            *end != '\\n') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse: %s\"),\n                           buf);\n            return -1;\n        }\n        VIR_FREE(buf);\n        VIR_FREE(path);\n    }\n\n    if (page_free) {\n        if (virNumaGetHugePageInfoPath(&path, node,\n                                       page_size, \"free_hugepages\") < 0)\n            return -1;\n\n        if (virFileReadAll(path, 1024, &buf) < 0)\n            return -1;\n\n        if (virStrToLong_ull(buf, &end, 10, page_free) < 0 ||\n            *end != '\\n') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse: %s\"),\n                           buf);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unable to parse: %s\")",
            "buf"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to parse: %s\""
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ull",
          "args": [
            "buf",
            "&end",
            "10",
            "page_free"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ullp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "568-586",
          "snippet": "int\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "path",
            "1024",
            "&buf"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaGetHugePageInfoPath",
          "args": [
            "&path",
            "node",
            "page_size",
            "\"free_hugepages\""
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetHugePageInfoPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "530-567",
          "snippet": "static int\nvirNumaGetHugePageInfoPath(char **path,\n                           int node,\n                           unsigned int page_size,\n                           const char *suffix)\n{\n    if (node == -1) {\n        /* We are aiming at overall system info */\n        *path = g_strdup_printf(HUGEPAGES_SYSTEM_PREFIX HUGEPAGES_PREFIX \"%ukB/%s\",\n                                page_size, NULLSTR_EMPTY(suffix));\n    } else {\n        /* We are aiming on specific NUMA node */\n        *path = g_strdup_printf(HUGEPAGES_NUMA_PREFIX \"node%d/hugepages/\"\n                                HUGEPAGES_PREFIX \"%ukB/%s\",\n                                node, page_size, NULLSTR_EMPTY(suffix));\n    }\n\n    if (!virFileExists(*path)) {\n        if (node != -1) {\n            if (!virNumaNodeIsAvailable(node)) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"NUMA node %d is not available\"),\n                               node);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"page size %u is not available on node %d\"),\n                               page_size, node);\n            }\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"page size %u is not available\"),\n                           page_size);\n        }\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nstatic int\nvirNumaGetHugePageInfoPath(char **path,\n                           int node,\n                           unsigned int page_size,\n                           const char *suffix)\n{\n    if (node == -1) {\n        /* We are aiming at overall system info */\n        *path = g_strdup_printf(HUGEPAGES_SYSTEM_PREFIX HUGEPAGES_PREFIX \"%ukB/%s\",\n                                page_size, NULLSTR_EMPTY(suffix));\n    } else {\n        /* We are aiming on specific NUMA node */\n        *path = g_strdup_printf(HUGEPAGES_NUMA_PREFIX \"node%d/hugepages/\"\n                                HUGEPAGES_PREFIX \"%ukB/%s\",\n                                node, page_size, NULLSTR_EMPTY(suffix));\n    }\n\n    if (!virFileExists(*path)) {\n        if (node != -1) {\n            if (!virNumaNodeIsAvailable(node)) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"NUMA node %d is not available\"),\n                               node);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"page size %u is not available on node %d\"),\n                               page_size, node);\n            }\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"page size %u is not available\"),\n                           page_size);\n        }\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buf"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unable to parse: %s\")",
            "buf"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nstatic int\nvirNumaGetHugePageInfo(int node,\n                       unsigned int page_size,\n                       unsigned long long *page_avail,\n                       unsigned long long *page_free)\n{\n    char *end;\n    g_autofree char *path = NULL;\n    g_autofree char *buf = NULL;\n\n    if (page_avail) {\n        if (virNumaGetHugePageInfoPath(&path, node,\n                                       page_size, \"nr_hugepages\") < 0)\n            return -1;\n\n        if (virFileReadAll(path, 1024, &buf) < 0)\n            return -1;\n\n        if (virStrToLong_ull(buf, &end, 10, page_avail) < 0 ||\n            *end != '\\n') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse: %s\"),\n                           buf);\n            return -1;\n        }\n        VIR_FREE(buf);\n        VIR_FREE(path);\n    }\n\n    if (page_free) {\n        if (virNumaGetHugePageInfoPath(&path, node,\n                                       page_size, \"free_hugepages\") < 0)\n            return -1;\n\n        if (virFileReadAll(path, 1024, &buf) < 0)\n            return -1;\n\n        if (virStrToLong_ull(buf, &end, 10, page_free) < 0 ||\n            *end != '\\n') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse: %s\"),\n                           buf);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNumaGetHugePageInfoDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "569-580",
    "snippet": "static int\nvirNumaGetHugePageInfoDir(char **path, int node)\n{\n    if (node == -1) {\n        *path = g_strdup(HUGEPAGES_SYSTEM_PREFIX);\n        return 0;\n    } else {\n        *path = g_strdup_printf(HUGEPAGES_NUMA_PREFIX \"node%d/hugepages/\",\n                                node);\n        return 0;\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "HUGEPAGES_NUMA_PREFIX \"node%d/hugepages/\"",
            "node"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nstatic int\nvirNumaGetHugePageInfoDir(char **path, int node)\n{\n    if (node == -1) {\n        *path = g_strdup(HUGEPAGES_SYSTEM_PREFIX);\n        return 0;\n    } else {\n        *path = g_strdup_printf(HUGEPAGES_NUMA_PREFIX \"node%d/hugepages/\",\n                                node);\n        return 0;\n    }\n}"
  },
  {
    "function_name": "virNumaGetHugePageInfoPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "530-567",
    "snippet": "static int\nvirNumaGetHugePageInfoPath(char **path,\n                           int node,\n                           unsigned int page_size,\n                           const char *suffix)\n{\n    if (node == -1) {\n        /* We are aiming at overall system info */\n        *path = g_strdup_printf(HUGEPAGES_SYSTEM_PREFIX HUGEPAGES_PREFIX \"%ukB/%s\",\n                                page_size, NULLSTR_EMPTY(suffix));\n    } else {\n        /* We are aiming on specific NUMA node */\n        *path = g_strdup_printf(HUGEPAGES_NUMA_PREFIX \"node%d/hugepages/\"\n                                HUGEPAGES_PREFIX \"%ukB/%s\",\n                                node, page_size, NULLSTR_EMPTY(suffix));\n    }\n\n    if (!virFileExists(*path)) {\n        if (node != -1) {\n            if (!virNumaNodeIsAvailable(node)) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"NUMA node %d is not available\"),\n                               node);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"page size %u is not available on node %d\"),\n                               page_size, node);\n            }\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"page size %u is not available\"),\n                           page_size);\n        }\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"page size %u is not available\")",
            "page_size"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"page size %u is not available\""
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"page size %u is not available on node %d\")",
            "page_size",
            "node"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"NUMA node %d is not available\")",
            "node"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNumaNodeIsAvailable",
          "args": [
            "node"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaNodeIsAvailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "497-507",
          "snippet": "bool\nvirNumaNodeIsAvailable(int node)\n{\n    int max_node = virNumaGetMaxNode();\n\n    if (max_node < 0)\n        return false;\n\n    /* Do we have anything better? */\n    return (node >= 0) && (node <= max_node);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaNodeIsAvailable(int node)\n{\n    int max_node = virNumaGetMaxNode();\n\n    if (max_node < 0)\n        return false;\n\n    /* Do we have anything better? */\n    return (node >= 0) && (node <= max_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "*path"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "suffix"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "suffix"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nstatic int\nvirNumaGetHugePageInfoPath(char **path,\n                           int node,\n                           unsigned int page_size,\n                           const char *suffix)\n{\n    if (node == -1) {\n        /* We are aiming at overall system info */\n        *path = g_strdup_printf(HUGEPAGES_SYSTEM_PREFIX HUGEPAGES_PREFIX \"%ukB/%s\",\n                                page_size, NULLSTR_EMPTY(suffix));\n    } else {\n        /* We are aiming on specific NUMA node */\n        *path = g_strdup_printf(HUGEPAGES_NUMA_PREFIX \"node%d/hugepages/\"\n                                HUGEPAGES_PREFIX \"%ukB/%s\",\n                                node, page_size, NULLSTR_EMPTY(suffix));\n    }\n\n    if (!virFileExists(*path)) {\n        if (node != -1) {\n            if (!virNumaNodeIsAvailable(node)) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"NUMA node %d is not available\"),\n                               node);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"page size %u is not available on node %d\"),\n                               page_size, node);\n            }\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"page size %u is not available\"),\n                           page_size);\n        }\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNumaGetDistances",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "510-519",
    "snippet": "int\nvirNumaGetDistances(int node G_GNUC_UNUSED,\n                    int **distances,\n                    int *ndistances)\n{\n    *distances = NULL;\n    *ndistances = 0;\n    VIR_DEBUG(\"NUMA distance information isn't available on this host\");\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"NUMA distance information isn't available on this host\""
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetDistances(int node G_GNUC_UNUSED,\n                    int **distances,\n                    int *ndistances)\n{\n    *distances = NULL;\n    *ndistances = 0;\n    VIR_DEBUG(\"NUMA distance information isn't available on this host\");\n    return 0;\n}"
  },
  {
    "function_name": "virNumaNodeIsAvailable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "497-507",
    "snippet": "bool\nvirNumaNodeIsAvailable(int node)\n{\n    int max_node = virNumaGetMaxNode();\n\n    if (max_node < 0)\n        return false;\n\n    /* Do we have anything better? */\n    return (node >= 0) && (node <= max_node);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNumaGetMaxNode",
          "args": [],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetMaxNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "362-368",
          "snippet": "int\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaNodeIsAvailable(int node)\n{\n    int max_node = virNumaGetMaxNode();\n\n    if (max_node < 0)\n        return false;\n\n    /* Do we have anything better? */\n    return (node >= 0) && (node <= max_node);\n}"
  },
  {
    "function_name": "virNumaGetDistances",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "462-493",
    "snippet": "int\nvirNumaGetDistances(int node,\n                    int **distances,\n                    int *ndistances)\n{\n    int max_node;\n    size_t i;\n\n    if (!virNumaNodeIsAvailable(node)) {\n        VIR_DEBUG(\"Node %d does not exist\", node);\n        *distances = NULL;\n        *ndistances = 0;\n        return 0;\n    }\n\n    if ((max_node = virNumaGetMaxNode()) < 0)\n        return -1;\n\n    if (VIR_ALLOC_N(*distances, max_node + 1) < 0)\n        return -1;\n\n    *ndistances = max_node + 1;\n\n    for (i = 0; i <= max_node; i++) {\n        if (!virNumaNodeIsAvailable(node))\n            continue;\n\n        (*distances)[i] = numa_distance(node, i);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "numa_distance",
          "args": [
            "node",
            "i"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNumaNodeIsAvailable",
          "args": [
            "node"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaNodeIsAvailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "497-507",
          "snippet": "bool\nvirNumaNodeIsAvailable(int node)\n{\n    int max_node = virNumaGetMaxNode();\n\n    if (max_node < 0)\n        return false;\n\n    /* Do we have anything better? */\n    return (node >= 0) && (node <= max_node);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaNodeIsAvailable(int node)\n{\n    int max_node = virNumaGetMaxNode();\n\n    if (max_node < 0)\n        return false;\n\n    /* Do we have anything better? */\n    return (node >= 0) && (node <= max_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*distances",
            "max_node + 1"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNumaGetMaxNode",
          "args": [],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetMaxNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "362-368",
          "snippet": "int\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Node %d does not exist\"",
            "node"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetDistances(int node,\n                    int **distances,\n                    int *ndistances)\n{\n    int max_node;\n    size_t i;\n\n    if (!virNumaNodeIsAvailable(node)) {\n        VIR_DEBUG(\"Node %d does not exist\", node);\n        *distances = NULL;\n        *ndistances = 0;\n        return 0;\n    }\n\n    if ((max_node = virNumaGetMaxNode()) < 0)\n        return -1;\n\n    if (VIR_ALLOC_N(*distances, max_node + 1) < 0)\n        return -1;\n\n    *ndistances = max_node + 1;\n\n    for (i = 0; i <= max_node; i++) {\n        if (!virNumaNodeIsAvailable(node))\n            continue;\n\n        (*distances)[i] = numa_distance(node, i);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNumaNodeIsAvailable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "436-440",
    "snippet": "bool\nvirNumaNodeIsAvailable(int node)\n{\n    return numa_bitmask_isbitset(numa_nodes_ptr, node);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "numa_bitmask_isbitset",
          "args": [
            "numa_nodes_ptr",
            "node"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaNodeIsAvailable(int node)\n{\n    return numa_bitmask_isbitset(numa_nodes_ptr, node);\n}"
  },
  {
    "function_name": "virNumaGetMaxCPUs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "418-422",
    "snippet": "unsigned int\nvirNumaGetMaxCPUs(void)\n{\n    return NUMA_MAX_N_CPUS;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define NUMA_MAX_N_CPUS 4096"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\n#define NUMA_MAX_N_CPUS 4096\n\nunsigned int\nvirNumaGetMaxCPUs(void)\n{\n    return NUMA_MAX_N_CPUS;\n}"
  },
  {
    "function_name": "virNumaNodesetToCPUset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "398-407",
    "snippet": "int\nvirNumaNodesetToCPUset(virBitmapPtr nodeset G_GNUC_UNUSED,\n                       virBitmapPtr *cpuset)\n{\n    *cpuset = NULL;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"NUMA isn't available on this host\")"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"NUMA isn't available on this host\""
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaNodesetToCPUset(virBitmapPtr nodeset G_GNUC_UNUSED,\n                       virBitmapPtr *cpuset)\n{\n    *cpuset = NULL;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNumaGetNodeCPUs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "387-396",
    "snippet": "int\nvirNumaGetNodeCPUs(int node G_GNUC_UNUSED,\n                   virBitmapPtr *cpus)\n{\n    *cpus = NULL;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"NUMA isn't available on this host\")"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"NUMA isn't available on this host\""
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetNodeCPUs(int node G_GNUC_UNUSED,\n                   virBitmapPtr *cpus)\n{\n    *cpus = NULL;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNumaGetNodeMemory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "371-384",
    "snippet": "int\nvirNumaGetNodeMemory(int node G_GNUC_UNUSED,\n                     unsigned long long *memsize,\n                     unsigned long long *memfree)\n{\n    if (memsize)\n        *memsize = 0;\n\n    if (memfree)\n        *memfree = 0;\n\n    VIR_DEBUG(\"NUMA isn't available on this host\");\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"NUMA isn't available on this host\""
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetNodeMemory(int node G_GNUC_UNUSED,\n                     unsigned long long *memsize,\n                     unsigned long long *memfree)\n{\n    if (memsize)\n        *memsize = 0;\n\n    if (memfree)\n        *memfree = 0;\n\n    VIR_DEBUG(\"NUMA isn't available on this host\");\n    return -1;\n}"
  },
  {
    "function_name": "virNumaGetMaxNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "362-368",
    "snippet": "int\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"NUMA isn't available on this host\")"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"NUMA isn't available on this host\""
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNumaIsAvailable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "355-359",
    "snippet": "bool\nvirNumaIsAvailable(void)\n{\n    return false;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaIsAvailable(void)\n{\n    return false;\n}"
  },
  {
    "function_name": "virNumaSetupMemoryPolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "345-353",
    "snippet": "int\nvirNumaSetupMemoryPolicy(virDomainNumatuneMemMode mode G_GNUC_UNUSED,\n                         virBitmapPtr nodeset)\n{\n    if (!virNumaNodesetIsAvailable(nodeset))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNumaNodesetIsAvailable",
          "args": [
            "nodeset"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaNodesetIsAvailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "993-1010",
          "snippet": "bool\nvirNumaNodesetIsAvailable(virBitmapPtr nodeset)\n{\n    ssize_t bit = -1;\n\n    if (!nodeset)\n        return true;\n\n    while ((bit = virBitmapNextSetBit(nodeset, bit)) >= 0) {\n        if (virNumaNodeIsAvailable(bit))\n            continue;\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"NUMA node %zd is unavailable\"), bit);\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaNodesetIsAvailable(virBitmapPtr nodeset)\n{\n    ssize_t bit = -1;\n\n    if (!nodeset)\n        return true;\n\n    while ((bit = virBitmapNextSetBit(nodeset, bit)) >= 0) {\n        if (virNumaNodeIsAvailable(bit))\n            continue;\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"NUMA node %zd is unavailable\"), bit);\n        return false;\n    }\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaSetupMemoryPolicy(virDomainNumatuneMemMode mode G_GNUC_UNUSED,\n                         virBitmapPtr nodeset)\n{\n    if (!virNumaNodesetIsAvailable(nodeset))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virNumaNodesetToCPUset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "309-341",
    "snippet": "int\nvirNumaNodesetToCPUset(virBitmapPtr nodeset,\n                       virBitmapPtr *cpuset)\n{\n    g_autoptr(virBitmap) allNodesCPUs = NULL;\n    size_t nodesetSize;\n    size_t i;\n\n    *cpuset = NULL;\n\n    if (!nodeset)\n        return 0;\n\n    allNodesCPUs = virBitmapNewEmpty();\n    nodesetSize = virBitmapSize(nodeset);\n\n    for (i = 0; i < nodesetSize; i++) {\n        g_autoptr(virBitmap) nodeCPUs = NULL;\n\n        if (!virBitmapIsBitSet(nodeset, i))\n            continue;\n\n        if (virNumaGetNodeCPUs(i, &nodeCPUs) < 0)\n            return -1;\n\n        if (virBitmapUnion(allNodesCPUs, nodeCPUs) < 0)\n            return -1;\n    }\n\n    *cpuset = g_steal_pointer(&allNodesCPUs);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&allNodesCPUs"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapUnion",
          "args": [
            "allNodesCPUs",
            "nodeCPUs"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapUnion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1254-1269",
          "snippet": "int\nvirBitmapUnion(virBitmapPtr a,\n               const virBitmap *b)\n{\n    size_t i;\n\n    if (a->nbits < b->nbits &&\n        virBitmapExpand(a, b->nbits - 1) < 0) {\n        return -1;\n    }\n\n    for (i = 0; i < b->map_len; i++)\n        a->map[i] |= b->map[i];\n\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapUnion(virBitmapPtr a,\n               const virBitmap *b)\n{\n    size_t i;\n\n    if (a->nbits < b->nbits &&\n        virBitmapExpand(a, b->nbits - 1) < 0) {\n        return -1;\n    }\n\n    for (i = 0; i < b->map_len; i++)\n        a->map[i] |= b->map[i];\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaGetNodeCPUs",
          "args": [
            "i",
            "&nodeCPUs"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetNodeCPUs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "387-396",
          "snippet": "int\nvirNumaGetNodeCPUs(int node G_GNUC_UNUSED,\n                   virBitmapPtr *cpus)\n{\n    *cpus = NULL;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetNodeCPUs(int node G_GNUC_UNUSED,\n                   virBitmapPtr *cpus)\n{\n    *cpus = NULL;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapIsBitSet",
          "args": [
            "nodeset",
            "i"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapIsBitSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "298-306",
          "snippet": "bool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapSize",
          "args": [
            "nodeset"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "882-886",
          "snippet": "size_t\nvirBitmapSize(virBitmapPtr bitmap)\n{\n    return bitmap->nbits;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nsize_t\nvirBitmapSize(virBitmapPtr bitmap)\n{\n    return bitmap->nbits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNewEmpty",
          "args": [],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "115-119",
          "snippet": "virBitmapPtr\nvirBitmapNewEmpty(void)\n{\n    return g_new0(virBitmap, 1);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewEmpty(void)\n{\n    return g_new0(virBitmap, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaNodesetToCPUset(virBitmapPtr nodeset,\n                       virBitmapPtr *cpuset)\n{\n    g_autoptr(virBitmap) allNodesCPUs = NULL;\n    size_t nodesetSize;\n    size_t i;\n\n    *cpuset = NULL;\n\n    if (!nodeset)\n        return 0;\n\n    allNodesCPUs = virBitmapNewEmpty();\n    nodesetSize = virBitmapSize(nodeset);\n\n    for (i = 0; i < nodesetSize; i++) {\n        g_autoptr(virBitmap) nodeCPUs = NULL;\n\n        if (!virBitmapIsBitSet(nodeset, i))\n            continue;\n\n        if (virNumaGetNodeCPUs(i, &nodeCPUs) < 0)\n            return -1;\n\n        if (virBitmapUnion(allNodesCPUs, nodeCPUs) < 0)\n            return -1;\n    }\n\n    *cpuset = g_steal_pointer(&allNodesCPUs);\n\n    return 0;\n}"
  },
  {
    "function_name": "virNumaGetNodeCPUs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "250-296",
    "snippet": "int\nvirNumaGetNodeCPUs(int node,\n                   virBitmapPtr *cpus)\n{\n    int ncpus = 0;\n    int max_n_cpus = virNumaGetMaxCPUs();\n    int mask_n_bytes = max_n_cpus / 8;\n    size_t i;\n    g_autofree unsigned long *mask = NULL;\n    g_autofree unsigned long *allonesmask = NULL;\n    g_autoptr(virBitmap) cpumap = NULL;\n\n    *cpus = NULL;\n\n    if (VIR_ALLOC_N(mask, mask_n_bytes / sizeof(*mask)) < 0)\n        return -1;\n\n    if (VIR_ALLOC_N(allonesmask, mask_n_bytes / sizeof(*mask)) < 0)\n        return -1;\n\n    memset(allonesmask, 0xff, mask_n_bytes);\n\n    /* The first time this returns -1, ENOENT if node doesn't exist... */\n    if (numa_node_to_cpus(node, mask, mask_n_bytes) < 0) {\n        VIR_WARN(\"NUMA topology for cell %d is not available, ignoring\", node);\n        return -2;\n    }\n\n    /* second, third... times it returns an all-1's mask */\n    if (memcmp(mask, allonesmask, mask_n_bytes) == 0) {\n        VIR_DEBUG(\"NUMA topology for cell %d is invalid, ignoring\", node);\n        return -2;\n    }\n\n    if (!(cpumap = virBitmapNew(max_n_cpus)))\n        return -1;\n\n    for (i = 0; i < max_n_cpus; i++) {\n        if (MASK_CPU_ISSET(mask, i)) {\n            ignore_value(virBitmapSetBit(cpumap, i));\n            ncpus++;\n        }\n    }\n\n    *cpus = g_steal_pointer(&cpumap);\n    return ncpus;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&cpumap"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(cpumap, i)"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "cpumap",
            "i"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MASK_CPU_ISSET",
          "args": [
            "mask",
            "i"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "max_n_cpus"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"NUMA topology for cell %d is invalid, ignoring\"",
            "node"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "mask",
            "allonesmask",
            "mask_n_bytes"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"NUMA topology for cell %d is not available, ignoring\"",
            "node"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_node_to_cpus",
          "args": [
            "node",
            "mask",
            "mask_n_bytes"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "allonesmask",
            "0xff",
            "mask_n_bytes"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "allonesmask",
            "mask_n_bytes / sizeof(*mask)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "mask",
            "mask_n_bytes / sizeof(*mask)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNumaGetMaxCPUs",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetMaxCPUs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "418-422",
          "snippet": "unsigned int\nvirNumaGetMaxCPUs(void)\n{\n    return NUMA_MAX_N_CPUS;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define NUMA_MAX_N_CPUS 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\n#define NUMA_MAX_N_CPUS 4096\n\nunsigned int\nvirNumaGetMaxCPUs(void)\n{\n    return NUMA_MAX_N_CPUS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetNodeCPUs(int node,\n                   virBitmapPtr *cpus)\n{\n    int ncpus = 0;\n    int max_n_cpus = virNumaGetMaxCPUs();\n    int mask_n_bytes = max_n_cpus / 8;\n    size_t i;\n    g_autofree unsigned long *mask = NULL;\n    g_autofree unsigned long *allonesmask = NULL;\n    g_autoptr(virBitmap) cpumap = NULL;\n\n    *cpus = NULL;\n\n    if (VIR_ALLOC_N(mask, mask_n_bytes / sizeof(*mask)) < 0)\n        return -1;\n\n    if (VIR_ALLOC_N(allonesmask, mask_n_bytes / sizeof(*mask)) < 0)\n        return -1;\n\n    memset(allonesmask, 0xff, mask_n_bytes);\n\n    /* The first time this returns -1, ENOENT if node doesn't exist... */\n    if (numa_node_to_cpus(node, mask, mask_n_bytes) < 0) {\n        VIR_WARN(\"NUMA topology for cell %d is not available, ignoring\", node);\n        return -2;\n    }\n\n    /* second, third... times it returns an all-1's mask */\n    if (memcmp(mask, allonesmask, mask_n_bytes) == 0) {\n        VIR_DEBUG(\"NUMA topology for cell %d is invalid, ignoring\", node);\n        return -2;\n    }\n\n    if (!(cpumap = virBitmapNew(max_n_cpus)))\n        return -1;\n\n    for (i = 0; i < max_n_cpus; i++) {\n        if (MASK_CPU_ISSET(mask, i)) {\n            ignore_value(virBitmapSetBit(cpumap, i));\n            ncpus++;\n        }\n    }\n\n    *cpus = g_steal_pointer(&cpumap);\n    return ncpus;\n}"
  },
  {
    "function_name": "virNumaGetNodeMemory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "209-233",
    "snippet": "int\nvirNumaGetNodeMemory(int node,\n                     unsigned long long *memsize,\n                     unsigned long long *memfree)\n{\n    long long node_size;\n    long long node_free;\n\n    if (memsize)\n        *memsize = 0;\n\n    if (memfree)\n        *memfree = 0;\n\n    if ((node_size = numa_node_size64(node, &node_free)) < 0)\n        return -1;\n\n    if (memsize)\n        *memsize = node_size;\n\n    if (memfree)\n        *memfree = node_free;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "numa_node_size64",
          "args": [
            "node",
            "&node_free"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetNodeMemory(int node,\n                     unsigned long long *memsize,\n                     unsigned long long *memfree)\n{\n    long long node_size;\n    long long node_free;\n\n    if (memsize)\n        *memsize = 0;\n\n    if (memfree)\n        *memfree = 0;\n\n    if ((node_size = numa_node_size64(node, &node_free)) < 0)\n        return -1;\n\n    if (memsize)\n        *memsize = node_size;\n\n    if (memfree)\n        *memfree = node_free;\n\n    return 0;\n}"
  },
  {
    "function_name": "virNumaGetMaxNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "176-194",
    "snippet": "int\nvirNumaGetMaxNode(void)\n{\n    int ret;\n\n    if (!virNumaIsAvailable()) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"NUMA isn't available on this host\"));\n        return -1;\n    }\n\n    if ((ret = numa_max_node()) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to request maximum NUMA node id\"));\n        return -1;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to request maximum NUMA node id\")"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to request maximum NUMA node id\""
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_max_node",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"NUMA isn't available on this host\")"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNumaIsAvailable",
          "args": [],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaIsAvailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "355-359",
          "snippet": "bool\nvirNumaIsAvailable(void)\n{\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaIsAvailable(void)\n{\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetMaxNode(void)\n{\n    int ret;\n\n    if (!virNumaIsAvailable()) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"NUMA isn't available on this host\"));\n        return -1;\n    }\n\n    if ((ret = numa_max_node()) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to request maximum NUMA node id\"));\n        return -1;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virNumaIsAvailable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "162-166",
    "snippet": "bool\nvirNumaIsAvailable(void)\n{\n    return numa_available() != -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "numa_available",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaIsAvailable(void)\n{\n    return numa_available() != -1;\n}"
  },
  {
    "function_name": "virNumaSetupMemoryPolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "91-160",
    "snippet": "int\nvirNumaSetupMemoryPolicy(virDomainNumatuneMemMode mode,\n                         virBitmapPtr nodeset)\n{\n    nodemask_t mask;\n    int node = -1;\n    int bit = 0;\n    size_t i;\n    int maxnode = 0;\n\n    if (!nodeset)\n        return 0;\n\n    if (!virNumaNodesetIsAvailable(nodeset))\n        return -1;\n\n    maxnode = numa_max_node();\n    maxnode = maxnode < NUMA_NUM_NODES ? maxnode : NUMA_NUM_NODES;\n\n    /* Convert nodemask to NUMA bitmask. */\n    nodemask_zero(&mask);\n    bit = -1;\n    while ((bit = virBitmapNextSetBit(nodeset, bit)) >= 0) {\n        if (bit > maxnode) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"NUMA node %d is out of range\"), bit);\n            return -1;\n        }\n        nodemask_set(&mask, bit);\n    }\n\n    switch (mode) {\n    case VIR_DOMAIN_NUMATUNE_MEM_STRICT:\n        numa_set_bind_policy(1);\n        numa_set_membind(&mask);\n        numa_set_bind_policy(0);\n        break;\n\n    case VIR_DOMAIN_NUMATUNE_MEM_PREFERRED:\n    {\n        int nnodes = 0;\n        for (i = 0; i < NUMA_NUM_NODES; i++) {\n            if (nodemask_isset(&mask, i)) {\n                node = i;\n                nnodes++;\n            }\n        }\n\n        if (nnodes != 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"NUMA memory tuning in 'preferred' mode \"\n                                   \"only supports single node\"));\n            return -1;\n        }\n\n        numa_set_bind_policy(0);\n        numa_set_preferred(node);\n    }\n    break;\n\n    case VIR_DOMAIN_NUMATUNE_MEM_INTERLEAVE:\n        numa_set_interleave_mask(&mask);\n        break;\n\n    case VIR_DOMAIN_NUMATUNE_MEM_LAST:\n        break;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "numa_set_interleave_mask",
          "args": [
            "&mask"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_set_preferred",
          "args": [
            "node"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_set_bind_policy",
          "args": [
            "0"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"NUMA memory tuning in 'preferred' mode \"\n                                   \"only supports single node\")"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"NUMA memory tuning in 'preferred' mode \"\n                                   \"only supports single node\""
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodemask_isset",
          "args": [
            "&mask",
            "i"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_set_bind_policy",
          "args": [
            "0"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_set_membind",
          "args": [
            "&mask"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_set_bind_policy",
          "args": [
            "1"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodemask_set",
          "args": [
            "&mask",
            "bit"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"NUMA node %d is out of range\")",
            "bit"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapNextSetBit",
          "args": [
            "nodeset",
            "bit"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNextSetBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "986-1014",
          "snippet": "ssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodemask_zero",
          "args": [
            "&mask"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_max_node",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNumaNodesetIsAvailable",
          "args": [
            "nodeset"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaNodesetIsAvailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "993-1010",
          "snippet": "bool\nvirNumaNodesetIsAvailable(virBitmapPtr nodeset)\n{\n    ssize_t bit = -1;\n\n    if (!nodeset)\n        return true;\n\n    while ((bit = virBitmapNextSetBit(nodeset, bit)) >= 0) {\n        if (virNumaNodeIsAvailable(bit))\n            continue;\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"NUMA node %zd is unavailable\"), bit);\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaNodesetIsAvailable(virBitmapPtr nodeset)\n{\n    ssize_t bit = -1;\n\n    if (!nodeset)\n        return true;\n\n    while ((bit = virBitmapNextSetBit(nodeset, bit)) >= 0) {\n        if (virNumaNodeIsAvailable(bit))\n            continue;\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"NUMA node %zd is unavailable\"), bit);\n        return false;\n    }\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaSetupMemoryPolicy(virDomainNumatuneMemMode mode,\n                         virBitmapPtr nodeset)\n{\n    nodemask_t mask;\n    int node = -1;\n    int bit = 0;\n    size_t i;\n    int maxnode = 0;\n\n    if (!nodeset)\n        return 0;\n\n    if (!virNumaNodesetIsAvailable(nodeset))\n        return -1;\n\n    maxnode = numa_max_node();\n    maxnode = maxnode < NUMA_NUM_NODES ? maxnode : NUMA_NUM_NODES;\n\n    /* Convert nodemask to NUMA bitmask. */\n    nodemask_zero(&mask);\n    bit = -1;\n    while ((bit = virBitmapNextSetBit(nodeset, bit)) >= 0) {\n        if (bit > maxnode) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"NUMA node %d is out of range\"), bit);\n            return -1;\n        }\n        nodemask_set(&mask, bit);\n    }\n\n    switch (mode) {\n    case VIR_DOMAIN_NUMATUNE_MEM_STRICT:\n        numa_set_bind_policy(1);\n        numa_set_membind(&mask);\n        numa_set_bind_policy(0);\n        break;\n\n    case VIR_DOMAIN_NUMATUNE_MEM_PREFERRED:\n    {\n        int nnodes = 0;\n        for (i = 0; i < NUMA_NUM_NODES; i++) {\n            if (nodemask_isset(&mask, i)) {\n                node = i;\n                nnodes++;\n            }\n        }\n\n        if (nnodes != 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"NUMA memory tuning in 'preferred' mode \"\n                                   \"only supports single node\"));\n            return -1;\n        }\n\n        numa_set_bind_policy(0);\n        numa_set_preferred(node);\n    }\n    break;\n\n    case VIR_DOMAIN_NUMATUNE_MEM_INTERLEAVE:\n        numa_set_interleave_mask(&mask);\n        break;\n\n    case VIR_DOMAIN_NUMATUNE_MEM_LAST:\n        break;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNumaGetAutoPlacementAdvice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "80-87",
    "snippet": "char *\nvirNumaGetAutoPlacementAdvice(unsigned short vcpus G_GNUC_UNUSED,\n                              unsigned long long balloon G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                   _(\"numad is not available on this host\"));\n    return NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"numad is not available on this host\")"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"numad is not available on this host\""
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nchar *\nvirNumaGetAutoPlacementAdvice(unsigned short vcpus G_GNUC_UNUSED,\n                              unsigned long long balloon G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                   _(\"numad is not available on this host\"));\n    return NULL;\n}"
  },
  {
    "function_name": "virNumaGetAutoPlacementAdvice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
    "lines": "57-78",
    "snippet": "char *\nvirNumaGetAutoPlacementAdvice(unsigned short vcpus,\n                              unsigned long long balloon)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    char *output = NULL;\n\n    cmd = virCommandNewArgList(NUMAD, \"-w\", NULL);\n    virCommandAddArgFormat(cmd, \"%d:%llu\", vcpus,\n                           VIR_DIV_UP(balloon, 1024));\n\n    virCommandSetOutputBuffer(cmd, &output);\n\n    if (virCommandRun(cmd, NULL) < 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to query numad for the \"\n                         \"advisory nodeset\"));\n        VIR_FREE(output);\n    }\n\n    return output;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virbitmap.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virnuma.h\"",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "# include <numa.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "output"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Failed to query numad for the \"\n                         \"advisory nodeset\")"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to query numad for the \"\n                         \"advisory nodeset\""
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputBuffer",
          "args": [
            "cmd",
            "&output"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1869-1884",
          "snippet": "void\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%d:%llu\"",
            "vcpus",
            "VIR_DIV_UP(balloon, 1024)"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "balloon",
            "1024"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "NUMAD",
            "\"-w\"",
            "NULL"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nchar *\nvirNumaGetAutoPlacementAdvice(unsigned short vcpus,\n                              unsigned long long balloon)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    char *output = NULL;\n\n    cmd = virCommandNewArgList(NUMAD, \"-w\", NULL);\n    virCommandAddArgFormat(cmd, \"%d:%llu\", vcpus,\n                           VIR_DIV_UP(balloon, 1024));\n\n    virCommandSetOutputBuffer(cmd, &output);\n\n    if (virCommandRun(cmd, NULL) < 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to query numad for the \"\n                         \"advisory nodeset\"));\n        VIR_FREE(output);\n    }\n\n    return output;\n}"
  }
]