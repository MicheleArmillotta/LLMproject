[
  {
    "function_name": "prlsdkResizeImage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4862-4897",
    "snippet": "int prlsdkResizeImage(virDomainObjPtr dom, virDomainDiskDefPtr disk,\n                      unsigned long long newsize)\n{\n    int ret = -1;\n    PRL_RESULT pret;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_UINT32 emulatedType;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE prldisk = PRL_INVALID_HANDLE;\n\n    prldisk = prlsdkGetDisk(privdom->sdkdom, disk);\n    if (prldisk == PRL_INVALID_HANDLE)\n        goto cleanup;\n\n    pret = PrlVmDev_GetEmulatedType(prldisk, &emulatedType);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (emulatedType != PDT_USE_IMAGE_FILE &&\n        emulatedType != PDT_USE_FILE_SYSTEM) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Only disk image supported for resize\"));\n        goto cleanup;\n    }\n\n    job = PrlVmDev_ResizeImage(prldisk, newsize,\n                               PRIF_RESIZE_LAST_PARTITION);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n\n    PrlHandle_Free(prldisk);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);",
      "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "prldisk"
          ],
          "line": 4895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 4888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 4888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_ResizeImage",
          "args": [
            "prldisk",
            "newsize",
            "PRIF_RESIZE_LAST_PARTITION"
          ],
          "line": 4886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Only disk image supported for resize\")"
          ],
          "line": 4881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Only disk image supported for resize\""
          ],
          "line": 4882
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 4877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_GetEmulatedType",
          "args": [
            "prldisk",
            "&emulatedType"
          ],
          "line": 4876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetDisk",
          "args": [
            "privdom->sdkdom",
            "disk"
          ],
          "line": 4872
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3524-3569",
          "snippet": "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 num;\n    size_t i;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int bus;\n    char *dst = NULL;\n    PRL_DEVICE_TYPE devType;\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK)\n        devType = PDE_HARD_DISK;\n    else\n        devType = PDE_OPTICAL_DISK;\n\n    pret = PrlVmCfg_GetDevsCountByType(sdkdom, devType, &num);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < num; ++i) {\n        pret = PrlVmCfg_GetDevByType(sdkdom, devType, i, &sdkdisk);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (prlsdkGetDiskId(sdkdisk, &bus, &dst) < 0)\n            goto error;\n\n        if (disk->bus == bus && STREQ(disk->dst, dst)) {\n            VIR_FREE(dst);\n            return sdkdisk;\n        }\n\n        PrlHandle_Free(sdkdisk);\n        sdkdisk = PRL_INVALID_HANDLE;\n        VIR_FREE(dst);\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"No disk with bus '%s' and target '%s'\"),\n                   virDomainDiskBusTypeToString(disk->bus), disk->dst);\n    return PRL_INVALID_HANDLE;\n\n error:\n    VIR_FREE(dst);\n    PrlHandle_Free(sdkdisk);\n    return PRL_INVALID_HANDLE;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 num;\n    size_t i;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int bus;\n    char *dst = NULL;\n    PRL_DEVICE_TYPE devType;\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK)\n        devType = PDE_HARD_DISK;\n    else\n        devType = PDE_OPTICAL_DISK;\n\n    pret = PrlVmCfg_GetDevsCountByType(sdkdom, devType, &num);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < num; ++i) {\n        pret = PrlVmCfg_GetDevByType(sdkdom, devType, i, &sdkdisk);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (prlsdkGetDiskId(sdkdisk, &bus, &dst) < 0)\n            goto error;\n\n        if (disk->bus == bus && STREQ(disk->dst, dst)) {\n            VIR_FREE(dst);\n            return sdkdisk;\n        }\n\n        PrlHandle_Free(sdkdisk);\n        sdkdisk = PRL_INVALID_HANDLE;\n        VIR_FREE(dst);\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"No disk with bus '%s' and target '%s'\"),\n                   virDomainDiskBusTypeToString(disk->bus), disk->dst);\n    return PRL_INVALID_HANDLE;\n\n error:\n    VIR_FREE(dst);\n    PrlHandle_Free(sdkdisk);\n    return PRL_INVALID_HANDLE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nint prlsdkResizeImage(virDomainObjPtr dom, virDomainDiskDefPtr disk,\n                      unsigned long long newsize)\n{\n    int ret = -1;\n    PRL_RESULT pret;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_UINT32 emulatedType;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE prldisk = PRL_INVALID_HANDLE;\n\n    prldisk = prlsdkGetDisk(privdom->sdkdom, disk);\n    if (prldisk == PRL_INVALID_HANDLE)\n        goto cleanup;\n\n    pret = PrlVmDev_GetEmulatedType(prldisk, &emulatedType);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (emulatedType != PDT_USE_IMAGE_FILE &&\n        emulatedType != PDT_USE_FILE_SYSTEM) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Only disk image supported for resize\"));\n        goto cleanup;\n    }\n\n    job = PrlVmDev_ResizeImage(prldisk, newsize,\n                               PRIF_RESIZE_LAST_PARTITION);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n\n    PrlHandle_Free(prldisk);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkSetCpuCount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4842-4860",
    "snippet": "int prlsdkSetCpuCount(virDomainObjPtr dom, unsigned int count)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job;\n    PRL_RESULT pret;\n\n    job = PrlVm_BeginEdit(privdom->sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    pret = PrlVmCfg_SetCpuCount(privdom->sdkdom, count);\n    prlsdkCheckRetExit(pret, -1);\n\n    job = PrlVm_CommitEx(privdom->sdkdom, 0);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 4856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 4856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_CommitEx",
          "args": [
            "privdom->sdkdom",
            "0"
          ],
          "line": 4855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 4853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetCpuCount",
          "args": [
            "privdom->sdkdom",
            "count"
          ],
          "line": 4852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 4849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 4849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_BeginEdit",
          "args": [
            "privdom->sdkdom"
          ],
          "line": 4848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nint prlsdkSetCpuCount(virDomainObjPtr dom, unsigned int count)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job;\n    PRL_RESULT pret;\n\n    job = PrlVm_BeginEdit(privdom->sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    pret = PrlVmCfg_SetCpuCount(privdom->sdkdom, count);\n    prlsdkCheckRetExit(pret, -1);\n\n    job = PrlVm_CommitEx(privdom->sdkdom, 0);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkMigrate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4813-4840",
    "snippet": "int prlsdkMigrate(virDomainObjPtr dom, virURIPtr uri,\n                  const unsigned char *session_uuid,\n                  const char *dname,\n                  unsigned int flags)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n    PRL_UINT32 vzflags = PRLSDK_MIGRATION_FLAGS;\n\n    if (flags & VIR_MIGRATE_PAUSED)\n        vzflags |= PVMT_DONT_RESUME_VM;\n\n    prlsdkUUIDFormat(session_uuid, uuidstr);\n    job = PrlVm_MigrateWithRenameEx(privdom->sdkdom, uri->server,\n                                    uri->port, uuidstr,\n                                    dname == NULL ? \"\" : dname,\n                                    \"\",\n                                    vzflags,\n                                    0,\n                                    PRL_TRUE\n                                    );\n\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PRLSDK_MIGRATION_FLAGS (PSL_HIGH_SECURITY | PVMT_DONT_CREATE_DISK)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 4836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 4836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_MigrateWithRenameEx",
          "args": [
            "privdom->sdkdom",
            "uri->server",
            "uri->port",
            "uuidstr",
            "dname == NULL ? \"\" : dname",
            "\"\"",
            "vzflags",
            "0",
            "PRL_TRUE"
          ],
          "line": 4827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkUUIDFormat",
          "args": [
            "session_uuid",
            "uuidstr"
          ],
          "line": 4826
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "452-460",
          "snippet": "static void\nprlsdkUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    virUUIDFormat(uuid, uuidstr + 1);\n\n    uuidstr[0] = '{';\n    uuidstr[VIR_UUID_STRING_BUFLEN] = '}';\n    uuidstr[VIR_UUID_STRING_BUFLEN + 1] = '\\0';\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic void\nprlsdkUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    virUUIDFormat(uuid, uuidstr + 1);\n\n    uuidstr[0] = '{';\n    uuidstr[VIR_UUID_STRING_BUFLEN] = '}';\n    uuidstr[VIR_UUID_STRING_BUFLEN + 1] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define PRLSDK_MIGRATION_FLAGS (PSL_HIGH_SECURITY | PVMT_DONT_CREATE_DISK)\n\nint prlsdkMigrate(virDomainObjPtr dom, virURIPtr uri,\n                  const unsigned char *session_uuid,\n                  const char *dname,\n                  unsigned int flags)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n    PRL_UINT32 vzflags = PRLSDK_MIGRATION_FLAGS;\n\n    if (flags & VIR_MIGRATE_PAUSED)\n        vzflags |= PVMT_DONT_RESUME_VM;\n\n    prlsdkUUIDFormat(session_uuid, uuidstr);\n    job = PrlVm_MigrateWithRenameEx(privdom->sdkdom, uri->server,\n                                    uri->port, uuidstr,\n                                    dname == NULL ? \"\" : dname,\n                                    \"\",\n                                    vzflags,\n                                    0,\n                                    PRL_TRUE\n                                    );\n\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkSwitchToSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4788-4802",
    "snippet": "int prlsdkSwitchToSnapshot(virDomainObjPtr dom, const char *uuid, bool paused)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job;\n    PRL_UINT32 flags = 0;\n\n    if (paused)\n        flags |= PSSF_SKIP_RESUME;\n\n    job = PrlVm_SwitchToSnapshotEx(privdom->sdkdom, uuid, flags);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 4798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 4798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_SwitchToSnapshotEx",
          "args": [
            "privdom->sdkdom",
            "uuid",
            "flags"
          ],
          "line": 4797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nint prlsdkSwitchToSnapshot(virDomainObjPtr dom, const char *uuid, bool paused)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job;\n    PRL_UINT32 flags = 0;\n\n    if (paused)\n        flags |= PSSF_SKIP_RESUME;\n\n    job = PrlVm_SwitchToSnapshotEx(privdom->sdkdom, uuid, flags);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkDeleteSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4776-4786",
    "snippet": "int prlsdkDeleteSnapshot(virDomainObjPtr dom, const char *uuid, bool children)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job;\n\n    job = PrlVm_DeleteSnapshot(privdom->sdkdom, uuid, children);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 4782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 4782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_DeleteSnapshot",
          "args": [
            "privdom->sdkdom",
            "uuid",
            "children"
          ],
          "line": 4781
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nint prlsdkDeleteSnapshot(virDomainObjPtr dom, const char *uuid, bool children)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job;\n\n    job = PrlVm_DeleteSnapshot(privdom->sdkdom, uuid, children);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkCreateSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4763-4774",
    "snippet": "int prlsdkCreateSnapshot(virDomainObjPtr dom, const char *description)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job;\n\n    job = PrlVm_CreateSnapshot(privdom->sdkdom, \"\",\n                               description ? : \"\");\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 4770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 4770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_CreateSnapshot",
          "args": [
            "privdom->sdkdom",
            "\"\"",
            "description ? : \"\""
          ],
          "line": 4768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint prlsdkCreateSnapshot(virDomainObjPtr dom, const char *description)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job;\n\n    job = PrlVm_CreateSnapshot(privdom->sdkdom, \"\",\n                               description ? : \"\");\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkLoadSnapshots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4739-4761",
    "snippet": "virDomainSnapshotObjListPtr\nprlsdkLoadSnapshots(virDomainObjPtr dom)\n{\n    virDomainSnapshotObjListPtr ret = NULL;\n    PRL_HANDLE job;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    char *treexml = NULL;\n\n    job = PrlVm_GetSnapshotsTreeEx(privdom->sdkdom, PGST_WITHOUT_SCREENSHOTS);\n    if (PRL_FAILED(getDomainJobResult(job, dom, &result)))\n        goto cleanup;\n\n    if (!(treexml = prlsdkGetStringParamVar(PrlResult_GetParamAsString, result)))\n        goto cleanup;\n\n    ret = prlsdkParseSnapshotTree(treexml);\n cleanup:\n\n    PrlHandle_Free(result);\n    VIR_FREE(treexml);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "treexml"
          ],
          "line": 4759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "result"
          ],
          "line": 4758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkParseSnapshotTree",
          "args": [
            "treexml"
          ],
          "line": 4755
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkParseSnapshotTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "4609-4737",
          "snippet": "static virDomainSnapshotObjListPtr\nprlsdkParseSnapshotTree(const char *treexml)\n{\n    virDomainSnapshotObjListPtr ret = NULL;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    xmlNodePtr root;\n    xmlNodePtr *nodes = NULL;\n    virDomainSnapshotDefPtr def = NULL;\n    virDomainMomentObjPtr snapshot;\n    virDomainSnapshotObjListPtr snapshots = NULL;\n    char *xmlstr = NULL;\n    int n;\n    size_t i;\n\n    if (!(snapshots = virDomainSnapshotObjListNew()))\n        return NULL;\n\n    if (*treexml == '\\0')\n        return snapshots;\n\n    if (!(xml = virXMLParse(NULL, treexml, _(\"(snapshot_tree)\"))))\n        goto cleanup;\n\n    root = xmlDocGetRootElement(xml);\n    if (!virXMLNodeNameEqual(root, \"ParallelsSavedStates\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected root element: '%s'\"), root->name);\n        goto cleanup;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    ctxt->node = root;\n\n    if ((n = virXPathNodeSet(\"//SavedStateItem\", ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot extract snapshot nodes\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < n; i++) {\n        if (nodes[i]->parent == root)\n            continue;\n\n        if (VIR_ALLOC(def) < 0)\n            goto cleanup;\n\n        ctxt->node = nodes[i];\n\n        def->parent.name = virXPathString(\"string(./@guid)\", ctxt);\n        if (!def->parent.name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing 'guid' attribute\"));\n            goto cleanup;\n        }\n\n        def->parent.parent_name = virXPathString(\"string(../@guid)\", ctxt);\n\n        xmlstr = virXPathString(\"string(./DateTime)\", ctxt);\n        if (!xmlstr) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing 'DateTime' element\"));\n            goto cleanup;\n        }\n        if ((def->parent.creationTime = prlsdkParseDateTime(xmlstr)) < 0)\n            goto cleanup;\n        VIR_FREE(xmlstr);\n\n        def->parent.description = virXPathString(\"string(./Description)\", ctxt);\n\n        def->memory = VIR_DOMAIN_SNAPSHOT_LOCATION_NONE;\n        xmlstr = virXPathString(\"string(./@state)\", ctxt);\n        if (!xmlstr) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing 'state' attribute\"));\n            goto cleanup;\n        } else if (STREQ(xmlstr, \"poweron\")) {\n            def->state = VIR_DOMAIN_RUNNING;\n            def->memory = VIR_DOMAIN_SNAPSHOT_LOCATION_INTERNAL;\n        } else if (STREQ(xmlstr, \"pause\")) {\n            def->state = VIR_DOMAIN_PAUSED;\n            def->memory = VIR_DOMAIN_SNAPSHOT_LOCATION_INTERNAL;\n        } else if (STREQ(xmlstr, \"suspend\")) {\n            def->state = VIR_DOMAIN_SHUTOFF;\n        } else if (STREQ(xmlstr, \"poweroff\")) {\n            def->state = VIR_DOMAIN_SHUTOFF;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected snapshot state: %s\"), xmlstr);\n        }\n        VIR_FREE(xmlstr);\n\n        if (!(snapshot = virDomainSnapshotAssignDef(snapshots, def)))\n            goto cleanup;\n        def = NULL;\n\n        xmlstr = virXPathString(\"string(./@current)\", ctxt);\n        if (xmlstr && STREQ(\"yes\", xmlstr)) {\n            if (virDomainSnapshotGetCurrent(snapshots)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"too many current snapshots\"));\n                VIR_FREE(xmlstr);\n                goto cleanup;\n            }\n            virDomainSnapshotSetCurrent(snapshots, snapshot);\n        }\n        VIR_FREE(xmlstr);\n    }\n\n    if (virDomainSnapshotUpdateRelations(snapshots) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"snapshots have inconsistent relations\"));\n        goto cleanup;\n    }\n\n    ret = g_steal_pointer(&snapshots);\n\n cleanup:\n    virDomainSnapshotObjListFree(snapshots);\n    VIR_FREE(nodes);\n    VIR_FREE(xmlstr);\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(xml);\n    VIR_FREE(def);\n\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virDomainSnapshotObjListPtr\nprlsdkParseSnapshotTree(const char *treexml)\n{\n    virDomainSnapshotObjListPtr ret = NULL;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    xmlNodePtr root;\n    xmlNodePtr *nodes = NULL;\n    virDomainSnapshotDefPtr def = NULL;\n    virDomainMomentObjPtr snapshot;\n    virDomainSnapshotObjListPtr snapshots = NULL;\n    char *xmlstr = NULL;\n    int n;\n    size_t i;\n\n    if (!(snapshots = virDomainSnapshotObjListNew()))\n        return NULL;\n\n    if (*treexml == '\\0')\n        return snapshots;\n\n    if (!(xml = virXMLParse(NULL, treexml, _(\"(snapshot_tree)\"))))\n        goto cleanup;\n\n    root = xmlDocGetRootElement(xml);\n    if (!virXMLNodeNameEqual(root, \"ParallelsSavedStates\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected root element: '%s'\"), root->name);\n        goto cleanup;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    ctxt->node = root;\n\n    if ((n = virXPathNodeSet(\"//SavedStateItem\", ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot extract snapshot nodes\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < n; i++) {\n        if (nodes[i]->parent == root)\n            continue;\n\n        if (VIR_ALLOC(def) < 0)\n            goto cleanup;\n\n        ctxt->node = nodes[i];\n\n        def->parent.name = virXPathString(\"string(./@guid)\", ctxt);\n        if (!def->parent.name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing 'guid' attribute\"));\n            goto cleanup;\n        }\n\n        def->parent.parent_name = virXPathString(\"string(../@guid)\", ctxt);\n\n        xmlstr = virXPathString(\"string(./DateTime)\", ctxt);\n        if (!xmlstr) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing 'DateTime' element\"));\n            goto cleanup;\n        }\n        if ((def->parent.creationTime = prlsdkParseDateTime(xmlstr)) < 0)\n            goto cleanup;\n        VIR_FREE(xmlstr);\n\n        def->parent.description = virXPathString(\"string(./Description)\", ctxt);\n\n        def->memory = VIR_DOMAIN_SNAPSHOT_LOCATION_NONE;\n        xmlstr = virXPathString(\"string(./@state)\", ctxt);\n        if (!xmlstr) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing 'state' attribute\"));\n            goto cleanup;\n        } else if (STREQ(xmlstr, \"poweron\")) {\n            def->state = VIR_DOMAIN_RUNNING;\n            def->memory = VIR_DOMAIN_SNAPSHOT_LOCATION_INTERNAL;\n        } else if (STREQ(xmlstr, \"pause\")) {\n            def->state = VIR_DOMAIN_PAUSED;\n            def->memory = VIR_DOMAIN_SNAPSHOT_LOCATION_INTERNAL;\n        } else if (STREQ(xmlstr, \"suspend\")) {\n            def->state = VIR_DOMAIN_SHUTOFF;\n        } else if (STREQ(xmlstr, \"poweroff\")) {\n            def->state = VIR_DOMAIN_SHUTOFF;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected snapshot state: %s\"), xmlstr);\n        }\n        VIR_FREE(xmlstr);\n\n        if (!(snapshot = virDomainSnapshotAssignDef(snapshots, def)))\n            goto cleanup;\n        def = NULL;\n\n        xmlstr = virXPathString(\"string(./@current)\", ctxt);\n        if (xmlstr && STREQ(\"yes\", xmlstr)) {\n            if (virDomainSnapshotGetCurrent(snapshots)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"too many current snapshots\"));\n                VIR_FREE(xmlstr);\n                goto cleanup;\n            }\n            virDomainSnapshotSetCurrent(snapshots, snapshot);\n        }\n        VIR_FREE(xmlstr);\n    }\n\n    if (virDomainSnapshotUpdateRelations(snapshots) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"snapshots have inconsistent relations\"));\n        goto cleanup;\n    }\n\n    ret = g_steal_pointer(&snapshots);\n\n cleanup:\n    virDomainSnapshotObjListFree(snapshots);\n    VIR_FREE(nodes);\n    VIR_FREE(xmlstr);\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(xml);\n    VIR_FREE(def);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkGetStringParamVar",
          "args": [
            "PrlResult_GetParamAsString",
            "result"
          ],
          "line": 4752
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetStringParamVar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "299-320",
          "snippet": "static char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "getDomainJobResult(job, dom, &result)"
          ],
          "line": 4749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getDomainJobResult",
          "args": [
            "job",
            "dom",
            "&result"
          ],
          "line": 4749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_GetSnapshotsTreeEx",
          "args": [
            "privdom->sdkdom",
            "PGST_WITHOUT_SCREENSHOTS"
          ],
          "line": 4748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirDomainSnapshotObjListPtr\nprlsdkLoadSnapshots(virDomainObjPtr dom)\n{\n    virDomainSnapshotObjListPtr ret = NULL;\n    PRL_HANDLE job;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    char *treexml = NULL;\n\n    job = PrlVm_GetSnapshotsTreeEx(privdom->sdkdom, PGST_WITHOUT_SCREENSHOTS);\n    if (PRL_FAILED(getDomainJobResult(job, dom, &result)))\n        goto cleanup;\n\n    if (!(treexml = prlsdkGetStringParamVar(PrlResult_GetParamAsString, result)))\n        goto cleanup;\n\n    ret = prlsdkParseSnapshotTree(treexml);\n cleanup:\n\n    PrlHandle_Free(result);\n    VIR_FREE(treexml);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkParseSnapshotTree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4609-4737",
    "snippet": "static virDomainSnapshotObjListPtr\nprlsdkParseSnapshotTree(const char *treexml)\n{\n    virDomainSnapshotObjListPtr ret = NULL;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    xmlNodePtr root;\n    xmlNodePtr *nodes = NULL;\n    virDomainSnapshotDefPtr def = NULL;\n    virDomainMomentObjPtr snapshot;\n    virDomainSnapshotObjListPtr snapshots = NULL;\n    char *xmlstr = NULL;\n    int n;\n    size_t i;\n\n    if (!(snapshots = virDomainSnapshotObjListNew()))\n        return NULL;\n\n    if (*treexml == '\\0')\n        return snapshots;\n\n    if (!(xml = virXMLParse(NULL, treexml, _(\"(snapshot_tree)\"))))\n        goto cleanup;\n\n    root = xmlDocGetRootElement(xml);\n    if (!virXMLNodeNameEqual(root, \"ParallelsSavedStates\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected root element: '%s'\"), root->name);\n        goto cleanup;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    ctxt->node = root;\n\n    if ((n = virXPathNodeSet(\"//SavedStateItem\", ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot extract snapshot nodes\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < n; i++) {\n        if (nodes[i]->parent == root)\n            continue;\n\n        if (VIR_ALLOC(def) < 0)\n            goto cleanup;\n\n        ctxt->node = nodes[i];\n\n        def->parent.name = virXPathString(\"string(./@guid)\", ctxt);\n        if (!def->parent.name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing 'guid' attribute\"));\n            goto cleanup;\n        }\n\n        def->parent.parent_name = virXPathString(\"string(../@guid)\", ctxt);\n\n        xmlstr = virXPathString(\"string(./DateTime)\", ctxt);\n        if (!xmlstr) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing 'DateTime' element\"));\n            goto cleanup;\n        }\n        if ((def->parent.creationTime = prlsdkParseDateTime(xmlstr)) < 0)\n            goto cleanup;\n        VIR_FREE(xmlstr);\n\n        def->parent.description = virXPathString(\"string(./Description)\", ctxt);\n\n        def->memory = VIR_DOMAIN_SNAPSHOT_LOCATION_NONE;\n        xmlstr = virXPathString(\"string(./@state)\", ctxt);\n        if (!xmlstr) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing 'state' attribute\"));\n            goto cleanup;\n        } else if (STREQ(xmlstr, \"poweron\")) {\n            def->state = VIR_DOMAIN_RUNNING;\n            def->memory = VIR_DOMAIN_SNAPSHOT_LOCATION_INTERNAL;\n        } else if (STREQ(xmlstr, \"pause\")) {\n            def->state = VIR_DOMAIN_PAUSED;\n            def->memory = VIR_DOMAIN_SNAPSHOT_LOCATION_INTERNAL;\n        } else if (STREQ(xmlstr, \"suspend\")) {\n            def->state = VIR_DOMAIN_SHUTOFF;\n        } else if (STREQ(xmlstr, \"poweroff\")) {\n            def->state = VIR_DOMAIN_SHUTOFF;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected snapshot state: %s\"), xmlstr);\n        }\n        VIR_FREE(xmlstr);\n\n        if (!(snapshot = virDomainSnapshotAssignDef(snapshots, def)))\n            goto cleanup;\n        def = NULL;\n\n        xmlstr = virXPathString(\"string(./@current)\", ctxt);\n        if (xmlstr && STREQ(\"yes\", xmlstr)) {\n            if (virDomainSnapshotGetCurrent(snapshots)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"too many current snapshots\"));\n                VIR_FREE(xmlstr);\n                goto cleanup;\n            }\n            virDomainSnapshotSetCurrent(snapshots, snapshot);\n        }\n        VIR_FREE(xmlstr);\n    }\n\n    if (virDomainSnapshotUpdateRelations(snapshots) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"snapshots have inconsistent relations\"));\n        goto cleanup;\n    }\n\n    ret = g_steal_pointer(&snapshots);\n\n cleanup:\n    virDomainSnapshotObjListFree(snapshots);\n    VIR_FREE(nodes);\n    VIR_FREE(xmlstr);\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(xml);\n    VIR_FREE(def);\n\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 4734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xml"
          ],
          "line": 4733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "ctxt"
          ],
          "line": 4732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xmlstr"
          ],
          "line": 4731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 4730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotObjListFree",
          "args": [
            "snapshots"
          ],
          "line": 4729
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotObjListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainsnapshotobjlist.c",
          "lines": "99-106",
          "snippet": "void\nvirDomainSnapshotObjListFree(virDomainSnapshotObjListPtr snapshots)\n{\n    if (!snapshots)\n        return;\n    virDomainMomentObjListFree(snapshots->base);\n    VIR_FREE(snapshots);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainSnapshotObjListFree(virDomainSnapshotObjListPtr snapshots)\n{\n    if (!snapshots)\n        return;\n    virDomainMomentObjListFree(snapshots->base);\n    VIR_FREE(snapshots);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&snapshots"
          ],
          "line": 4726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"snapshots have inconsistent relations\")"
          ],
          "line": 4721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"snapshots have inconsistent relations\""
          ],
          "line": 4722
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotUpdateRelations",
          "args": [
            "snapshots"
          ],
          "line": 4720
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotUpdateRelations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainsnapshotobjlist.c",
          "lines": "239-243",
          "snippet": "int\nvirDomainSnapshotUpdateRelations(virDomainSnapshotObjListPtr snapshots)\n{\n    return virDomainMomentUpdateRelations(snapshots->base);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDomainSnapshotUpdateRelations(virDomainSnapshotObjListPtr snapshots)\n{\n    return virDomainMomentUpdateRelations(snapshots->base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xmlstr"
          ],
          "line": 4717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotSetCurrent",
          "args": [
            "snapshots",
            "snapshot"
          ],
          "line": 4715
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotSetCurrent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainsnapshotobjlist.c",
          "lines": "192-197",
          "snippet": "void\nvirDomainSnapshotSetCurrent(virDomainSnapshotObjListPtr snapshots,\n                            virDomainMomentObjPtr snapshot)\n{\n    virDomainMomentSetCurrent(snapshots->base, snapshot);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainSnapshotSetCurrent(virDomainSnapshotObjListPtr snapshots,\n                            virDomainMomentObjPtr snapshot)\n{\n    virDomainMomentSetCurrent(snapshots->base, snapshot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xmlstr"
          ],
          "line": 4712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"too many current snapshots\")"
          ],
          "line": 4710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotGetCurrent",
          "args": [
            "snapshots"
          ],
          "line": 4709
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotGetCurrentName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainsnapshotobjlist.c",
          "lines": "184-188",
          "snippet": "const char *\nvirDomainSnapshotGetCurrentName(virDomainSnapshotObjListPtr snapshots)\n{\n    return virDomainMomentGetCurrentName(snapshots->base);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nconst char *\nvirDomainSnapshotGetCurrentName(virDomainSnapshotObjListPtr snapshots)\n{\n    return virDomainMomentGetCurrentName(snapshots->base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "\"yes\"",
            "xmlstr"
          ],
          "line": 4708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./@current)\"",
            "ctxt"
          ],
          "line": 4707
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotAssignDef",
          "args": [
            "snapshots",
            "def"
          ],
          "line": 4703
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotAssignDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainsnapshotobjlist.c",
          "lines": "43-48",
          "snippet": "virDomainMomentObjPtr\nvirDomainSnapshotAssignDef(virDomainSnapshotObjListPtr snapshots,\n                           virDomainSnapshotDefPtr def)\n{\n    return virDomainMomentAssignDef(snapshots->base, &def->parent);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainMomentObjPtr\nvirDomainSnapshotAssignDef(virDomainSnapshotObjListPtr snapshots,\n                           virDomainSnapshotDefPtr def)\n{\n    return virDomainMomentAssignDef(snapshots->base, &def->parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xmlstr"
          ],
          "line": 4701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected snapshot state: %s\")",
            "xmlstr"
          ],
          "line": 4698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "xmlstr",
            "\"poweroff\""
          ],
          "line": 4695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "xmlstr",
            "\"suspend\""
          ],
          "line": 4693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "xmlstr",
            "\"pause\""
          ],
          "line": 4690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "xmlstr",
            "\"poweron\""
          ],
          "line": 4687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing 'state' attribute\")"
          ],
          "line": 4684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xmlstr"
          ],
          "line": 4677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkParseDateTime",
          "args": [
            "xmlstr"
          ],
          "line": 4675
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkParseDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "4579-4607",
          "snippet": "static long long\nprlsdkParseDateTime(const char *str)\n{\n    g_autoptr(GDateTime) then = NULL;\n    g_autoptr(GTimeZone) tz = g_time_zone_new_utc();\n    char *tmp;\n    int year, mon, mday, hour, min, sec;\n\n    /* Expect: YYYY-MM-DD HH:MM:SS (%d-%d-%dT%d:%d:%d)  eg 2010-11-28 14:29:01 */\n    if (/* year */\n        virStrToLong_i(str, &tmp, 10, &year) < 0 || *tmp != '-' ||\n        /* month */\n        virStrToLong_i(tmp+1, &tmp, 10, &mon) < 0 || *tmp != '-' ||\n        /* day */\n        virStrToLong_i(tmp+1, &tmp, 10, &mday) < 0 || *tmp != ' ' ||\n        /* hour */\n        virStrToLong_i(tmp+1, &tmp, 10, &hour) < 0 || *tmp != ':' ||\n        /* minute */\n        virStrToLong_i(tmp+1, &tmp, 10, &min) < 0 || *tmp != ':' ||\n        /* second */\n        virStrToLong_i(tmp+1, &tmp, 10, &sec) < 0 || *tmp != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected DateTime format: '%s'\"), str);\n        return -1;\n    }\n\n    then = g_date_time_new(tz, year, mon, mday, hour, min, sec);\n    return (long long)g_date_time_to_unix(then);\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic long long\nprlsdkParseDateTime(const char *str)\n{\n    g_autoptr(GDateTime) then = NULL;\n    g_autoptr(GTimeZone) tz = g_time_zone_new_utc();\n    char *tmp;\n    int year, mon, mday, hour, min, sec;\n\n    /* Expect: YYYY-MM-DD HH:MM:SS (%d-%d-%dT%d:%d:%d)  eg 2010-11-28 14:29:01 */\n    if (/* year */\n        virStrToLong_i(str, &tmp, 10, &year) < 0 || *tmp != '-' ||\n        /* month */\n        virStrToLong_i(tmp+1, &tmp, 10, &mon) < 0 || *tmp != '-' ||\n        /* day */\n        virStrToLong_i(tmp+1, &tmp, 10, &mday) < 0 || *tmp != ' ' ||\n        /* hour */\n        virStrToLong_i(tmp+1, &tmp, 10, &hour) < 0 || *tmp != ':' ||\n        /* minute */\n        virStrToLong_i(tmp+1, &tmp, 10, &min) < 0 || *tmp != ':' ||\n        /* second */\n        virStrToLong_i(tmp+1, &tmp, 10, &sec) < 0 || *tmp != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected DateTime format: '%s'\"), str);\n        return -1;\n    }\n\n    then = g_date_time_new(tz, year, mon, mday, hour, min, sec);\n    return (long long)g_date_time_to_unix(then);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing 'DateTime' element\")"
          ],
          "line": 4671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing 'guid' attribute\")"
          ],
          "line": 4662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def"
          ],
          "line": 4655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot extract snapshot nodes\")"
          ],
          "line": 4646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"//SavedStateItem\"",
            "ctxt",
            "&nodes"
          ],
          "line": 4645
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLXPathContextNew",
          "args": [
            "xml"
          ],
          "line": 4640
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLXPathContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "48-59",
          "snippet": "xmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected root element: '%s'\")",
            "root->name"
          ],
          "line": 4635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLNodeNameEqual",
          "args": [
            "root",
            "\"ParallelsSavedStates\""
          ],
          "line": 4634
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeNameEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1013-1018",
          "snippet": "bool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlDocGetRootElement",
          "args": [
            "xml"
          ],
          "line": 4633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLParse",
          "args": [
            "NULL",
            "treexml",
            "_(\"(snapshot_tree)\")"
          ],
          "line": 4630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotObjListNew",
          "args": [],
          "line": 4624
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotObjListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainsnapshotobjlist.c",
          "lines": "83-96",
          "snippet": "virDomainSnapshotObjListPtr\nvirDomainSnapshotObjListNew(void)\n{\n    virDomainSnapshotObjListPtr snapshots;\n\n    if (VIR_ALLOC(snapshots) < 0)\n        return NULL;\n    snapshots->base = virDomainMomentObjListNew();\n    if (!snapshots->base) {\n        VIR_FREE(snapshots);\n        return NULL;\n    }\n    return snapshots;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainSnapshotObjListPtr\nvirDomainSnapshotObjListNew(void)\n{\n    virDomainSnapshotObjListPtr snapshots;\n\n    if (VIR_ALLOC(snapshots) < 0)\n        return NULL;\n    snapshots->base = virDomainMomentObjListNew();\n    if (!snapshots->base) {\n        VIR_FREE(snapshots);\n        return NULL;\n    }\n    return snapshots;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virDomainSnapshotObjListPtr\nprlsdkParseSnapshotTree(const char *treexml)\n{\n    virDomainSnapshotObjListPtr ret = NULL;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    xmlNodePtr root;\n    xmlNodePtr *nodes = NULL;\n    virDomainSnapshotDefPtr def = NULL;\n    virDomainMomentObjPtr snapshot;\n    virDomainSnapshotObjListPtr snapshots = NULL;\n    char *xmlstr = NULL;\n    int n;\n    size_t i;\n\n    if (!(snapshots = virDomainSnapshotObjListNew()))\n        return NULL;\n\n    if (*treexml == '\\0')\n        return snapshots;\n\n    if (!(xml = virXMLParse(NULL, treexml, _(\"(snapshot_tree)\"))))\n        goto cleanup;\n\n    root = xmlDocGetRootElement(xml);\n    if (!virXMLNodeNameEqual(root, \"ParallelsSavedStates\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected root element: '%s'\"), root->name);\n        goto cleanup;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    ctxt->node = root;\n\n    if ((n = virXPathNodeSet(\"//SavedStateItem\", ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot extract snapshot nodes\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < n; i++) {\n        if (nodes[i]->parent == root)\n            continue;\n\n        if (VIR_ALLOC(def) < 0)\n            goto cleanup;\n\n        ctxt->node = nodes[i];\n\n        def->parent.name = virXPathString(\"string(./@guid)\", ctxt);\n        if (!def->parent.name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing 'guid' attribute\"));\n            goto cleanup;\n        }\n\n        def->parent.parent_name = virXPathString(\"string(../@guid)\", ctxt);\n\n        xmlstr = virXPathString(\"string(./DateTime)\", ctxt);\n        if (!xmlstr) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing 'DateTime' element\"));\n            goto cleanup;\n        }\n        if ((def->parent.creationTime = prlsdkParseDateTime(xmlstr)) < 0)\n            goto cleanup;\n        VIR_FREE(xmlstr);\n\n        def->parent.description = virXPathString(\"string(./Description)\", ctxt);\n\n        def->memory = VIR_DOMAIN_SNAPSHOT_LOCATION_NONE;\n        xmlstr = virXPathString(\"string(./@state)\", ctxt);\n        if (!xmlstr) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing 'state' attribute\"));\n            goto cleanup;\n        } else if (STREQ(xmlstr, \"poweron\")) {\n            def->state = VIR_DOMAIN_RUNNING;\n            def->memory = VIR_DOMAIN_SNAPSHOT_LOCATION_INTERNAL;\n        } else if (STREQ(xmlstr, \"pause\")) {\n            def->state = VIR_DOMAIN_PAUSED;\n            def->memory = VIR_DOMAIN_SNAPSHOT_LOCATION_INTERNAL;\n        } else if (STREQ(xmlstr, \"suspend\")) {\n            def->state = VIR_DOMAIN_SHUTOFF;\n        } else if (STREQ(xmlstr, \"poweroff\")) {\n            def->state = VIR_DOMAIN_SHUTOFF;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected snapshot state: %s\"), xmlstr);\n        }\n        VIR_FREE(xmlstr);\n\n        if (!(snapshot = virDomainSnapshotAssignDef(snapshots, def)))\n            goto cleanup;\n        def = NULL;\n\n        xmlstr = virXPathString(\"string(./@current)\", ctxt);\n        if (xmlstr && STREQ(\"yes\", xmlstr)) {\n            if (virDomainSnapshotGetCurrent(snapshots)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"too many current snapshots\"));\n                VIR_FREE(xmlstr);\n                goto cleanup;\n            }\n            virDomainSnapshotSetCurrent(snapshots, snapshot);\n        }\n        VIR_FREE(xmlstr);\n    }\n\n    if (virDomainSnapshotUpdateRelations(snapshots) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"snapshots have inconsistent relations\"));\n        goto cleanup;\n    }\n\n    ret = g_steal_pointer(&snapshots);\n\n cleanup:\n    virDomainSnapshotObjListFree(snapshots);\n    VIR_FREE(nodes);\n    VIR_FREE(xmlstr);\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(xml);\n    VIR_FREE(def);\n\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkParseDateTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4579-4607",
    "snippet": "static long long\nprlsdkParseDateTime(const char *str)\n{\n    g_autoptr(GDateTime) then = NULL;\n    g_autoptr(GTimeZone) tz = g_time_zone_new_utc();\n    char *tmp;\n    int year, mon, mday, hour, min, sec;\n\n    /* Expect: YYYY-MM-DD HH:MM:SS (%d-%d-%dT%d:%d:%d)  eg 2010-11-28 14:29:01 */\n    if (/* year */\n        virStrToLong_i(str, &tmp, 10, &year) < 0 || *tmp != '-' ||\n        /* month */\n        virStrToLong_i(tmp+1, &tmp, 10, &mon) < 0 || *tmp != '-' ||\n        /* day */\n        virStrToLong_i(tmp+1, &tmp, 10, &mday) < 0 || *tmp != ' ' ||\n        /* hour */\n        virStrToLong_i(tmp+1, &tmp, 10, &hour) < 0 || *tmp != ':' ||\n        /* minute */\n        virStrToLong_i(tmp+1, &tmp, 10, &min) < 0 || *tmp != ':' ||\n        /* second */\n        virStrToLong_i(tmp+1, &tmp, 10, &sec) < 0 || *tmp != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected DateTime format: '%s'\"), str);\n        return -1;\n    }\n\n    then = g_date_time_new(tz, year, mon, mday, hour, min, sec);\n    return (long long)g_date_time_to_unix(then);\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_date_time_to_unix",
          "args": [
            "then"
          ],
          "line": 4606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_date_time_new",
          "args": [
            "tz",
            "year",
            "mon",
            "mday",
            "hour",
            "min",
            "sec"
          ],
          "line": 4605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected DateTime format: '%s'\")",
            "str"
          ],
          "line": 4600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unexpected DateTime format: '%s'\""
          ],
          "line": 4601
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "tmp+1",
            "&tmp",
            "10",
            "&sec"
          ],
          "line": 4599
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_time_zone_new_utc",
          "args": [],
          "line": 4583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic long long\nprlsdkParseDateTime(const char *str)\n{\n    g_autoptr(GDateTime) then = NULL;\n    g_autoptr(GTimeZone) tz = g_time_zone_new_utc();\n    char *tmp;\n    int year, mon, mday, hour, min, sec;\n\n    /* Expect: YYYY-MM-DD HH:MM:SS (%d-%d-%dT%d:%d:%d)  eg 2010-11-28 14:29:01 */\n    if (/* year */\n        virStrToLong_i(str, &tmp, 10, &year) < 0 || *tmp != '-' ||\n        /* month */\n        virStrToLong_i(tmp+1, &tmp, 10, &mon) < 0 || *tmp != '-' ||\n        /* day */\n        virStrToLong_i(tmp+1, &tmp, 10, &mday) < 0 || *tmp != ' ' ||\n        /* hour */\n        virStrToLong_i(tmp+1, &tmp, 10, &hour) < 0 || *tmp != ':' ||\n        /* minute */\n        virStrToLong_i(tmp+1, &tmp, 10, &min) < 0 || *tmp != ':' ||\n        /* second */\n        virStrToLong_i(tmp+1, &tmp, 10, &sec) < 0 || *tmp != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected DateTime format: '%s'\"), str);\n        return -1;\n    }\n\n    then = g_date_time_new(tz, year, mon, mday, hour, min, sec);\n    return (long long)g_date_time_to_unix(then);\n}"
  },
  {
    "function_name": "prlsdkSetMemsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4559-4577",
    "snippet": "int prlsdkSetMemsize(virDomainObjPtr dom, unsigned int memsize)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job;\n    PRL_RESULT pret;\n\n    job = PrlVm_BeginEdit(privdom->sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    pret = PrlVmCfg_SetRamSize(privdom->sdkdom, memsize);\n    prlsdkCheckRetExit(pret, -1);\n\n    job = PrlVm_CommitEx(privdom->sdkdom, 0);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 4573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 4573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_CommitEx",
          "args": [
            "privdom->sdkdom",
            "0"
          ],
          "line": 4572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 4570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetRamSize",
          "args": [
            "privdom->sdkdom",
            "memsize"
          ],
          "line": 4569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 4566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 4566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_BeginEdit",
          "args": [
            "privdom->sdkdom"
          ],
          "line": 4565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nint prlsdkSetMemsize(virDomainObjPtr dom, unsigned int memsize)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job;\n    PRL_RESULT pret;\n\n    job = PrlVm_BeginEdit(privdom->sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    pret = PrlVmCfg_SetRamSize(privdom->sdkdom, memsize);\n    prlsdkCheckRetExit(pret, -1);\n\n    job = PrlVm_CommitEx(privdom->sdkdom, 0);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkGetMemoryStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4501-4556",
    "snippet": "int\nprlsdkGetMemoryStats(PRL_HANDLE sdkstats,\n                     virDomainMemoryStatPtr stats,\n                     unsigned int nr_stats)\n{\n    long long v = 0, t = 0, u = 0;\n    size_t i = 0;\n\n#define PRLSDK_GET_COUNTER(NAME, VALUE) \\\n    if (prlsdkExtractStatsParam(sdkstats, NAME, &VALUE) < 0) \\\n        return -1; \\\n\n#define PRLSDK_MEMORY_STAT_SET(TAG, VALUE) \\\n    if (i < nr_stats) { \\\n        stats[i].tag = (TAG); \\\n        stats[i].val = (VALUE); \\\n        i++; \\\n    }\n\n    i = 0;\n\n    // count to kb\n    PRLSDK_GET_COUNTER(\"guest.ram.swap_in\", v)\n    if (v != -1)\n        PRLSDK_MEMORY_STAT_SET(VIR_DOMAIN_MEMORY_STAT_SWAP_IN, v << 12)\n\n    PRLSDK_GET_COUNTER(\"guest.ram.swap_out\", v)\n    if (v != -1)\n        PRLSDK_MEMORY_STAT_SET(VIR_DOMAIN_MEMORY_STAT_SWAP_OUT, v << 12)\n\n    PRLSDK_GET_COUNTER(\"guest.ram.minor_fault\", v)\n    if (v != -1)\n        PRLSDK_MEMORY_STAT_SET(VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT, v)\n\n    PRLSDK_GET_COUNTER(\"guest.ram.major_fault\", v)\n    if (v != -1)\n        PRLSDK_MEMORY_STAT_SET(VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT, v)\n\n    PRLSDK_GET_COUNTER(\"guest.ram.total\", v)\n    if (v != -1)\n        PRLSDK_MEMORY_STAT_SET(VIR_DOMAIN_MEMORY_STAT_AVAILABLE, v << 10)\n\n    PRLSDK_GET_COUNTER(\"guest.ram.balloon_actual\", v)\n    if (v != -1)\n        PRLSDK_MEMORY_STAT_SET(VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON, v << 10)\n\n    PRLSDK_GET_COUNTER(\"guest.ram.usage\", u)\n    PRLSDK_GET_COUNTER(\"guest.ram.total\", t)\n    if (u != -1 && t != -1)\n        PRLSDK_MEMORY_STAT_SET(VIR_DOMAIN_MEMORY_STAT_UNUSED, (t - u) << 10)\n\n#undef PRLSDK_GET_COUNTER\n#undef PRLSDK_MEMORY_STAT_SET\n\n    return i;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRLSDK_MEMORY_STAT_SET",
          "args": [
            "VIR_DOMAIN_MEMORY_STAT_UNUSED",
            "(t - u) << 10"
          ],
          "line": 4550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_GET_COUNTER",
          "args": [
            "\"guest.ram.total\"",
            "t"
          ],
          "line": 4548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_GET_COUNTER",
          "args": [
            "\"guest.ram.usage\"",
            "u"
          ],
          "line": 4547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_MEMORY_STAT_SET",
          "args": [
            "VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON",
            "v << 10"
          ],
          "line": 4545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_GET_COUNTER",
          "args": [
            "\"guest.ram.balloon_actual\"",
            "v"
          ],
          "line": 4543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_MEMORY_STAT_SET",
          "args": [
            "VIR_DOMAIN_MEMORY_STAT_AVAILABLE",
            "v << 10"
          ],
          "line": 4541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_GET_COUNTER",
          "args": [
            "\"guest.ram.total\"",
            "v"
          ],
          "line": 4539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_MEMORY_STAT_SET",
          "args": [
            "VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT",
            "v"
          ],
          "line": 4537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_GET_COUNTER",
          "args": [
            "\"guest.ram.major_fault\"",
            "v"
          ],
          "line": 4535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_MEMORY_STAT_SET",
          "args": [
            "VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT",
            "v"
          ],
          "line": 4533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_GET_COUNTER",
          "args": [
            "\"guest.ram.minor_fault\"",
            "v"
          ],
          "line": 4531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_MEMORY_STAT_SET",
          "args": [
            "VIR_DOMAIN_MEMORY_STAT_SWAP_OUT",
            "v << 12"
          ],
          "line": 4529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_GET_COUNTER",
          "args": [
            "\"guest.ram.swap_out\"",
            "v"
          ],
          "line": 4527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_MEMORY_STAT_SET",
          "args": [
            "VIR_DOMAIN_MEMORY_STAT_SWAP_IN",
            "v << 12"
          ],
          "line": 4525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_GET_COUNTER",
          "args": [
            "\"guest.ram.swap_in\"",
            "v"
          ],
          "line": 4523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nprlsdkGetMemoryStats(PRL_HANDLE sdkstats,\n                     virDomainMemoryStatPtr stats,\n                     unsigned int nr_stats)\n{\n    long long v = 0, t = 0, u = 0;\n    size_t i = 0;\n\n#define PRLSDK_GET_COUNTER(NAME, VALUE) \\\n    if (prlsdkExtractStatsParam(sdkstats, NAME, &VALUE) < 0) \\\n        return -1; \\\n\n#define PRLSDK_MEMORY_STAT_SET(TAG, VALUE) \\\n    if (i < nr_stats) { \\\n        stats[i].tag = (TAG); \\\n        stats[i].val = (VALUE); \\\n        i++; \\\n    }\n\n    i = 0;\n\n    // count to kb\n    PRLSDK_GET_COUNTER(\"guest.ram.swap_in\", v)\n    if (v != -1)\n        PRLSDK_MEMORY_STAT_SET(VIR_DOMAIN_MEMORY_STAT_SWAP_IN, v << 12)\n\n    PRLSDK_GET_COUNTER(\"guest.ram.swap_out\", v)\n    if (v != -1)\n        PRLSDK_MEMORY_STAT_SET(VIR_DOMAIN_MEMORY_STAT_SWAP_OUT, v << 12)\n\n    PRLSDK_GET_COUNTER(\"guest.ram.minor_fault\", v)\n    if (v != -1)\n        PRLSDK_MEMORY_STAT_SET(VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT, v)\n\n    PRLSDK_GET_COUNTER(\"guest.ram.major_fault\", v)\n    if (v != -1)\n        PRLSDK_MEMORY_STAT_SET(VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT, v)\n\n    PRLSDK_GET_COUNTER(\"guest.ram.total\", v)\n    if (v != -1)\n        PRLSDK_MEMORY_STAT_SET(VIR_DOMAIN_MEMORY_STAT_AVAILABLE, v << 10)\n\n    PRLSDK_GET_COUNTER(\"guest.ram.balloon_actual\", v)\n    if (v != -1)\n        PRLSDK_MEMORY_STAT_SET(VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON, v << 10)\n\n    PRLSDK_GET_COUNTER(\"guest.ram.usage\", u)\n    PRLSDK_GET_COUNTER(\"guest.ram.total\", t)\n    if (u != -1 && t != -1)\n        PRLSDK_MEMORY_STAT_SET(VIR_DOMAIN_MEMORY_STAT_UNUSED, (t - u) << 10)\n\n#undef PRLSDK_GET_COUNTER\n#undef PRLSDK_MEMORY_STAT_SET\n\n    return i;\n}"
  },
  {
    "function_name": "prlsdkGetVcpuStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4483-4499",
    "snippet": "int\nprlsdkGetVcpuStats(PRL_HANDLE sdkstats, int idx, unsigned long long *vtime)\n{\n    char *name = NULL;\n    long long ptime = 0;\n    int ret = -1;\n\n    name = g_strdup_printf(\"guest.vcpu%u.time\", (unsigned int)idx);\n    if (prlsdkExtractStatsParam(sdkstats, name, &ptime) < 0)\n        goto cleanup;\n    *vtime = ptime == -1 ? 0 : ptime;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(name);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 4497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkExtractStatsParam",
          "args": [
            "sdkstats",
            "name",
            "&ptime"
          ],
          "line": 4491
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkExtractStatsParam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "4309-4335",
          "snippet": "static int\nprlsdkExtractStatsParam(PRL_HANDLE sdkstats, const char *name, long long *val)\n{\n    PRL_HANDLE param = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    PRL_INT64 pval = 0;\n    int ret = -1;\n\n    pret = PrlEvent_GetParamByName(sdkstats, name, &param);\n    if (pret == PRL_ERR_NO_DATA) {\n        *val = -1;\n        ret = 0;\n        goto cleanup;\n    } else if (PRL_FAILED(pret)) {\n        logPrlError(pret);\n        goto cleanup;\n    }\n    pret = PrlEvtPrm_ToInt64(param, &pval);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    *val = pval;\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(param);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkExtractStatsParam(PRL_HANDLE sdkstats, const char *name, long long *val)\n{\n    PRL_HANDLE param = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    PRL_INT64 pval = 0;\n    int ret = -1;\n\n    pret = PrlEvent_GetParamByName(sdkstats, name, &param);\n    if (pret == PRL_ERR_NO_DATA) {\n        *val = -1;\n        ret = 0;\n        goto cleanup;\n    } else if (PRL_FAILED(pret)) {\n        logPrlError(pret);\n        goto cleanup;\n    }\n    pret = PrlEvtPrm_ToInt64(param, &pval);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    *val = pval;\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(param);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"guest.vcpu%u.time\"",
            "(unsigned int)idx"
          ],
          "line": 4490
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nprlsdkGetVcpuStats(PRL_HANDLE sdkstats, int idx, unsigned long long *vtime)\n{\n    char *name = NULL;\n    long long ptime = 0;\n    int ret = -1;\n\n    name = g_strdup_printf(\"guest.vcpu%u.time\", (unsigned int)idx);\n    if (prlsdkExtractStatsParam(sdkstats, name, &ptime) < 0)\n        goto cleanup;\n    *vtime = ptime == -1 ? 0 : ptime;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(name);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkGetNetStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4436-4481",
    "snippet": "int\nprlsdkGetNetStats(PRL_HANDLE sdkstats, PRL_HANDLE sdkdom, const char *device,\n                  virDomainInterfaceStatsPtr stats)\n{\n    int ret = -1;\n    PRL_UINT32 net_index = -1;\n    char *name = NULL;\n    PRL_RESULT pret;\n    PRL_HANDLE net = PRL_INVALID_HANDLE;\n    virMacAddr mac;\n\n    if (virMacAddrParse(device, &mac) == 0)\n        net = prlsdkFindNetByMAC(sdkdom, &mac);\n    else\n        net = prlsdkFindNetByPath(sdkdom, device);\n\n    if (net == PRL_INVALID_HANDLE)\n       goto cleanup;\n\n    pret = PrlVmDev_GetIndex(net, &net_index);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n#define PRLSDK_GET_NET_COUNTER(VAL, NAME) \\\n    name = g_strdup_printf(\"net.nic%u.%s\", net_index, NAME); \\\n    if (prlsdkExtractStatsParam(sdkstats, name, &stats->VAL) < 0) \\\n        goto cleanup; \\\n    VIR_FREE(name);\n\n    PRLSDK_GET_NET_COUNTER(rx_bytes, \"bytes_in\")\n    PRLSDK_GET_NET_COUNTER(rx_packets, \"pkts_in\")\n    PRLSDK_GET_NET_COUNTER(tx_bytes, \"bytes_out\")\n    PRLSDK_GET_NET_COUNTER(tx_packets, \"pkts_out\")\n    stats->rx_errs = -1;\n    stats->rx_drop = -1;\n    stats->tx_errs = -1;\n    stats->tx_drop = -1;\n\n#undef PRLSDK_GET_NET_COUNTER\n    ret = 0;\n\n cleanup:\n    VIR_FREE(name);\n    PrlHandle_Free(net);\n\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);",
      "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "net"
          ],
          "line": 4478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 4477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_GET_NET_COUNTER",
          "args": [
            "tx_packets",
            "\"pkts_out\""
          ],
          "line": 4467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_GET_NET_COUNTER",
          "args": [
            "tx_bytes",
            "\"bytes_out\""
          ],
          "line": 4466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_GET_NET_COUNTER",
          "args": [
            "rx_packets",
            "\"pkts_in\""
          ],
          "line": 4465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRLSDK_GET_NET_COUNTER",
          "args": [
            "rx_bytes",
            "\"bytes_in\""
          ],
          "line": 4464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 4456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_GetIndex",
          "args": [
            "net",
            "&net_index"
          ],
          "line": 4455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkFindNetByPath",
          "args": [
            "sdkdom",
            "device"
          ],
          "line": 4450
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkFindNetByPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "4397-4434",
          "snippet": "static PRL_HANDLE\nprlsdkFindNetByPath(PRL_HANDLE sdkdom, const char *path)\n{\n    PRL_UINT32 count = 0;\n    PRL_RESULT pret;\n    size_t i;\n    char *name = NULL;\n    PRL_HANDLE net = PRL_INVALID_HANDLE;\n\n    pret = PrlVmCfg_GetNetAdaptersCount(sdkdom, &count);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < count; ++i) {\n        pret = PrlVmCfg_GetNetAdapter(sdkdom, i, &net);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (!(name = prlsdkGetStringParamVar(PrlVmDevNet_GetHostInterfaceName,\n                                             net)))\n            goto error;\n\n        if (STREQ(name, path))\n            break;\n\n        VIR_FREE(name);\n        PrlHandle_Free(net);\n        net = PRL_INVALID_HANDLE;\n    }\n\n    if (net == PRL_INVALID_HANDLE)\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"invalid path, '%s' is not a known interface\"), path);\n    return net;\n\n error:\n    VIR_FREE(name);\n    PrlHandle_Free(net);\n    return PRL_INVALID_HANDLE;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic PRL_HANDLE\nprlsdkFindNetByPath(PRL_HANDLE sdkdom, const char *path)\n{\n    PRL_UINT32 count = 0;\n    PRL_RESULT pret;\n    size_t i;\n    char *name = NULL;\n    PRL_HANDLE net = PRL_INVALID_HANDLE;\n\n    pret = PrlVmCfg_GetNetAdaptersCount(sdkdom, &count);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < count; ++i) {\n        pret = PrlVmCfg_GetNetAdapter(sdkdom, i, &net);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (!(name = prlsdkGetStringParamVar(PrlVmDevNet_GetHostInterfaceName,\n                                             net)))\n            goto error;\n\n        if (STREQ(name, path))\n            break;\n\n        VIR_FREE(name);\n        PrlHandle_Free(net);\n        net = PRL_INVALID_HANDLE;\n    }\n\n    if (net == PRL_INVALID_HANDLE)\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"invalid path, '%s' is not a known interface\"), path);\n    return net;\n\n error:\n    VIR_FREE(name);\n    PrlHandle_Free(net);\n    return PRL_INVALID_HANDLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkFindNetByMAC",
          "args": [
            "sdkdom",
            "&mac"
          ],
          "line": 4448
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkFindNetByMAC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3389-3426",
          "snippet": "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 adaptersCount;\n    PRL_UINT32 i;\n    PRL_HANDLE adapter = PRL_INVALID_HANDLE;\n    char adapterMac[PRL_MAC_STRING_BUFNAME];\n    char expectedMac[PRL_MAC_STRING_BUFNAME];\n    char virMac[VIR_MAC_STRING_BUFLEN];\n\n    prlsdkFormatMac(mac, expectedMac);\n\n    pret = PrlVmCfg_GetNetAdaptersCount(sdkdom, &adaptersCount);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < adaptersCount; ++i) {\n        pret = PrlVmCfg_GetNetAdapter(sdkdom, i, &adapter);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = prlsdkGetStringParamBuf(PrlVmDevNet_GetMacAddress,\n                                       adapter, adapterMac, sizeof(adapterMac));\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (STREQ(adapterMac, expectedMac))\n            return adapter;\n\n        PrlHandle_Free(adapter);\n        adapter = PRL_INVALID_HANDLE;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"No net with mac '%s'\"), virMacAddrFormat(mac, virMac));\n\n cleanup:\n    PrlHandle_Free(adapter);\n    return adapter;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PRL_MAC_STRING_BUFNAME  13"
          ],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define PRL_MAC_STRING_BUFNAME  13\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);\n\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 adaptersCount;\n    PRL_UINT32 i;\n    PRL_HANDLE adapter = PRL_INVALID_HANDLE;\n    char adapterMac[PRL_MAC_STRING_BUFNAME];\n    char expectedMac[PRL_MAC_STRING_BUFNAME];\n    char virMac[VIR_MAC_STRING_BUFLEN];\n\n    prlsdkFormatMac(mac, expectedMac);\n\n    pret = PrlVmCfg_GetNetAdaptersCount(sdkdom, &adaptersCount);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < adaptersCount; ++i) {\n        pret = PrlVmCfg_GetNetAdapter(sdkdom, i, &adapter);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = prlsdkGetStringParamBuf(PrlVmDevNet_GetMacAddress,\n                                       adapter, adapterMac, sizeof(adapterMac));\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (STREQ(adapterMac, expectedMac))\n            return adapter;\n\n        PrlHandle_Free(adapter);\n        adapter = PRL_INVALID_HANDLE;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"No net with mac '%s'\"), virMacAddrFormat(mac, virMac));\n\n cleanup:\n    PrlHandle_Free(adapter);\n    return adapter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrParse",
          "args": [
            "device",
            "&mac"
          ],
          "line": 4447
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "205-218",
          "snippet": "int\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);\n\nint\nprlsdkGetNetStats(PRL_HANDLE sdkstats, PRL_HANDLE sdkdom, const char *device,\n                  virDomainInterfaceStatsPtr stats)\n{\n    int ret = -1;\n    PRL_UINT32 net_index = -1;\n    char *name = NULL;\n    PRL_RESULT pret;\n    PRL_HANDLE net = PRL_INVALID_HANDLE;\n    virMacAddr mac;\n\n    if (virMacAddrParse(device, &mac) == 0)\n        net = prlsdkFindNetByMAC(sdkdom, &mac);\n    else\n        net = prlsdkFindNetByPath(sdkdom, device);\n\n    if (net == PRL_INVALID_HANDLE)\n       goto cleanup;\n\n    pret = PrlVmDev_GetIndex(net, &net_index);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n#define PRLSDK_GET_NET_COUNTER(VAL, NAME) \\\n    name = g_strdup_printf(\"net.nic%u.%s\", net_index, NAME); \\\n    if (prlsdkExtractStatsParam(sdkstats, name, &stats->VAL) < 0) \\\n        goto cleanup; \\\n    VIR_FREE(name);\n\n    PRLSDK_GET_NET_COUNTER(rx_bytes, \"bytes_in\")\n    PRLSDK_GET_NET_COUNTER(rx_packets, \"pkts_in\")\n    PRLSDK_GET_NET_COUNTER(tx_bytes, \"bytes_out\")\n    PRLSDK_GET_NET_COUNTER(tx_packets, \"pkts_out\")\n    stats->rx_errs = -1;\n    stats->rx_drop = -1;\n    stats->tx_errs = -1;\n    stats->tx_drop = -1;\n\n#undef PRLSDK_GET_NET_COUNTER\n    ret = 0;\n\n cleanup:\n    VIR_FREE(name);\n    PrlHandle_Free(net);\n\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkFindNetByPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4397-4434",
    "snippet": "static PRL_HANDLE\nprlsdkFindNetByPath(PRL_HANDLE sdkdom, const char *path)\n{\n    PRL_UINT32 count = 0;\n    PRL_RESULT pret;\n    size_t i;\n    char *name = NULL;\n    PRL_HANDLE net = PRL_INVALID_HANDLE;\n\n    pret = PrlVmCfg_GetNetAdaptersCount(sdkdom, &count);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < count; ++i) {\n        pret = PrlVmCfg_GetNetAdapter(sdkdom, i, &net);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (!(name = prlsdkGetStringParamVar(PrlVmDevNet_GetHostInterfaceName,\n                                             net)))\n            goto error;\n\n        if (STREQ(name, path))\n            break;\n\n        VIR_FREE(name);\n        PrlHandle_Free(net);\n        net = PRL_INVALID_HANDLE;\n    }\n\n    if (net == PRL_INVALID_HANDLE)\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"invalid path, '%s' is not a known interface\"), path);\n    return net;\n\n error:\n    VIR_FREE(name);\n    PrlHandle_Free(net);\n    return PRL_INVALID_HANDLE;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "net"
          ],
          "line": 4432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 4431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"invalid path, '%s' is not a known interface\")",
            "path"
          ],
          "line": 4426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid path, '%s' is not a known interface\""
          ],
          "line": 4427
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "net"
          ],
          "line": 4421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 4420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "path"
          ],
          "line": 4417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetStringParamVar",
          "args": [
            "PrlVmDevNet_GetHostInterfaceName",
            "net"
          ],
          "line": 4413
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetStringParamVar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "299-320",
          "snippet": "static char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 4411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetNetAdapter",
          "args": [
            "sdkdom",
            "i",
            "&net"
          ],
          "line": 4410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 4407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetNetAdaptersCount",
          "args": [
            "sdkdom",
            "&count"
          ],
          "line": 4406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic PRL_HANDLE\nprlsdkFindNetByPath(PRL_HANDLE sdkdom, const char *path)\n{\n    PRL_UINT32 count = 0;\n    PRL_RESULT pret;\n    size_t i;\n    char *name = NULL;\n    PRL_HANDLE net = PRL_INVALID_HANDLE;\n\n    pret = PrlVmCfg_GetNetAdaptersCount(sdkdom, &count);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < count; ++i) {\n        pret = PrlVmCfg_GetNetAdapter(sdkdom, i, &net);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (!(name = prlsdkGetStringParamVar(PrlVmDevNet_GetHostInterfaceName,\n                                             net)))\n            goto error;\n\n        if (STREQ(name, path))\n            break;\n\n        VIR_FREE(name);\n        PrlHandle_Free(net);\n        net = PRL_INVALID_HANDLE;\n    }\n\n    if (net == PRL_INVALID_HANDLE)\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"invalid path, '%s' is not a known interface\"), path);\n    return net;\n\n error:\n    VIR_FREE(name);\n    PrlHandle_Free(net);\n    return PRL_INVALID_HANDLE;\n}"
  },
  {
    "function_name": "prlsdkGetBlockStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4339-4394",
    "snippet": "int\nprlsdkGetBlockStats(PRL_HANDLE sdkstats,\n                    virDomainDiskDefPtr disk,\n                    virDomainBlockStatsPtr stats,\n                    bool isCt)\n{\n    virDomainDeviceDriveAddressPtr address;\n    int idx;\n    const char *prefix;\n    int ret = -1;\n    char *name = NULL;\n\n    address = &disk->info.addr.drive;\n\n    if (isCt) {\n        prefix = \"hdd\";\n        idx = address->unit;\n    } else {\n        switch (disk->bus) {\n        case VIR_DOMAIN_DISK_BUS_IDE:\n            prefix = \"ide\";\n            idx = address->bus * 2 + address->unit;\n            break;\n        case VIR_DOMAIN_DISK_BUS_SATA:\n            prefix = \"sata\";\n            idx = address->unit;\n            break;\n        case VIR_DOMAIN_DISK_BUS_SCSI:\n            prefix = \"scsi\";\n            idx = address->unit;\n            break;\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown disk bus: %X\"), disk->bus);\n            goto cleanup;\n        }\n    }\n\n\n#define PRLSDK_GET_STAT_PARAM(VAL, TYPE, NAME) \\\n    name = g_strdup_printf(\"devices.%s%d.%s\", prefix, idx, NAME); \\\n    if (prlsdkExtractStatsParam(sdkstats, name, &stats->VAL) < 0) \\\n        goto cleanup; \\\n    VIR_FREE(name);\n\n    PARALLELS_BLOCK_STATS_FOREACH(PRLSDK_GET_STAT_PARAM)\n\n#undef PRLSDK_GET_STAT_PARAM\n\n    ret = 0;\n\n cleanup:\n\n    VIR_FREE(name);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 4392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown disk bus: %X\")",
            "disk->bus"
          ],
          "line": 4371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown disk bus: %X\""
          ],
          "line": 4372
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nint\nprlsdkGetBlockStats(PRL_HANDLE sdkstats,\n                    virDomainDiskDefPtr disk,\n                    virDomainBlockStatsPtr stats,\n                    bool isCt)\n{\n    virDomainDeviceDriveAddressPtr address;\n    int idx;\n    const char *prefix;\n    int ret = -1;\n    char *name = NULL;\n\n    address = &disk->info.addr.drive;\n\n    if (isCt) {\n        prefix = \"hdd\";\n        idx = address->unit;\n    } else {\n        switch (disk->bus) {\n        case VIR_DOMAIN_DISK_BUS_IDE:\n            prefix = \"ide\";\n            idx = address->bus * 2 + address->unit;\n            break;\n        case VIR_DOMAIN_DISK_BUS_SATA:\n            prefix = \"sata\";\n            idx = address->unit;\n            break;\n        case VIR_DOMAIN_DISK_BUS_SCSI:\n            prefix = \"scsi\";\n            idx = address->unit;\n            break;\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown disk bus: %X\"), disk->bus);\n            goto cleanup;\n        }\n    }\n\n\n#define PRLSDK_GET_STAT_PARAM(VAL, TYPE, NAME) \\\n    name = g_strdup_printf(\"devices.%s%d.%s\", prefix, idx, NAME); \\\n    if (prlsdkExtractStatsParam(sdkstats, name, &stats->VAL) < 0) \\\n        goto cleanup; \\\n    VIR_FREE(name);\n\n    PARALLELS_BLOCK_STATS_FOREACH(PRLSDK_GET_STAT_PARAM)\n\n#undef PRLSDK_GET_STAT_PARAM\n\n    ret = 0;\n\n cleanup:\n\n    VIR_FREE(name);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkExtractStatsParam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4309-4335",
    "snippet": "static int\nprlsdkExtractStatsParam(PRL_HANDLE sdkstats, const char *name, long long *val)\n{\n    PRL_HANDLE param = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    PRL_INT64 pval = 0;\n    int ret = -1;\n\n    pret = PrlEvent_GetParamByName(sdkstats, name, &param);\n    if (pret == PRL_ERR_NO_DATA) {\n        *val = -1;\n        ret = 0;\n        goto cleanup;\n    } else if (PRL_FAILED(pret)) {\n        logPrlError(pret);\n        goto cleanup;\n    }\n    pret = PrlEvtPrm_ToInt64(param, &pval);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    *val = pval;\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(param);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "param"
          ],
          "line": 4333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 4327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlEvtPrm_ToInt64",
          "args": [
            "param",
            "&pval"
          ],
          "line": 4326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logPrlError",
          "args": [
            "pret"
          ],
          "line": 4323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "pret"
          ],
          "line": 4322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlEvent_GetParamByName",
          "args": [
            "sdkstats",
            "name",
            "&param"
          ],
          "line": 4317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkExtractStatsParam(PRL_HANDLE sdkstats, const char *name, long long *val)\n{\n    PRL_HANDLE param = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    PRL_INT64 pval = 0;\n    int ret = -1;\n\n    pret = PrlEvent_GetParamByName(sdkstats, name, &param);\n    if (pret == PRL_ERR_NO_DATA) {\n        *val = -1;\n        ret = 0;\n        goto cleanup;\n    } else if (PRL_FAILED(pret)) {\n        logPrlError(pret);\n        goto cleanup;\n    }\n    pret = PrlEvtPrm_ToInt64(param, &pval);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    *val = pval;\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(param);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkDomainManagedSaveRemove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4296-4307",
    "snippet": "int\nprlsdkDomainManagedSaveRemove(virDomainObjPtr dom)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job;\n\n    job = PrlVm_DropSuspendedState(privdom->sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 4303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 4303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_DropSuspendedState",
          "args": [
            "privdom->sdkdom"
          ],
          "line": 4302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nprlsdkDomainManagedSaveRemove(virDomainObjPtr dom)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job;\n\n    job = PrlVm_DropSuspendedState(privdom->sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkUnregisterDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4243-4294",
    "snippet": "int\nprlsdkUnregisterDomain(vzDriverPtr driver, virDomainObjPtr dom, unsigned int flags)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job;\n    virDomainSnapshotObjListPtr snapshots = NULL;\n    VIRTUAL_MACHINE_STATE domainState;\n    int ret = -1;\n    int num;\n\n    if (prlsdkGetDomainState(dom, privdom->sdkdom, &domainState) < 0)\n        return -1;\n\n    if (VMS_SUSPENDED == domainState &&\n        !(flags & VIR_DOMAIN_UNDEFINE_MANAGED_SAVE)) {\n\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Refusing to undefine while domain managed \"\n                         \"save image exists\"));\n        return -1;\n    }\n\n    if (!(snapshots = prlsdkLoadSnapshots(dom)))\n        return -1;\n\n    if ((num = virDomainSnapshotObjListNum(snapshots, NULL, 0)) < 0)\n        goto cleanup;\n\n    if (num > 0 && !(flags & VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"Refusing to undefine while snapshots exist\"));\n        goto cleanup;\n    }\n\n    if (prlsdkDetachDomainHardDisks(dom))\n        goto cleanup;\n\n    job = PrlVm_Delete(privdom->sdkdom, PRL_INVALID_HANDLE);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        goto cleanup;\n\n    prlsdkSendEvent(driver, dom, VIR_DOMAIN_EVENT_UNDEFINED,\n                    VIR_DOMAIN_EVENT_UNDEFINED_REMOVED);\n\n    virDomainObjListRemove(driver->domains, dom);\n\n    ret = 0;\n cleanup:\n\n    virDomainSnapshotObjListFree(snapshots);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainSnapshotObjListFree",
          "args": [
            "snapshots"
          ],
          "line": 4292
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotObjListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainsnapshotobjlist.c",
          "lines": "99-106",
          "snippet": "void\nvirDomainSnapshotObjListFree(virDomainSnapshotObjListPtr snapshots)\n{\n    if (!snapshots)\n        return;\n    virDomainMomentObjListFree(snapshots->base);\n    VIR_FREE(snapshots);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainSnapshotObjListFree(virDomainSnapshotObjListPtr snapshots)\n{\n    if (!snapshots)\n        return;\n    virDomainMomentObjListFree(snapshots->base);\n    VIR_FREE(snapshots);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListRemove",
          "args": [
            "driver->domains",
            "dom"
          ],
          "line": 4287
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "401-413",
          "snippet": "void\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkSendEvent",
          "args": [
            "driver",
            "dom",
            "VIR_DOMAIN_EVENT_UNDEFINED",
            "VIR_DOMAIN_EVENT_UNDEFINED_REMOVED"
          ],
          "line": 4284
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkSendEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2056-2068",
          "snippet": "static void\nprlsdkSendEvent(vzDriverPtr driver,\n                virDomainObjPtr dom,\n                virDomainEventType lvEventType,\n                int lvEventTypeDetails)\n{\n    virObjectEventPtr event;\n\n    event = virDomainEventLifecycleNewFromObj(dom,\n                                              lvEventType,\n                                              lvEventTypeDetails);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkSendEvent(vzDriverPtr driver,\n                virDomainObjPtr dom,\n                virDomainEventType lvEventType,\n                int lvEventTypeDetails)\n{\n    virObjectEventPtr event;\n\n    event = virDomainEventLifecycleNewFromObj(dom,\n                                              lvEventType,\n                                              lvEventTypeDetails);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 4281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 4281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_Delete",
          "args": [
            "privdom->sdkdom",
            "PRL_INVALID_HANDLE"
          ],
          "line": 4280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkDetachDomainHardDisks",
          "args": [
            "dom"
          ],
          "line": 4277
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkDetachDomainHardDisks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "4202-4241",
          "snippet": "static int\nprlsdkDetachDomainHardDisks(virDomainObjPtr dom)\n{\n    int ret = -1;\n    PRL_RESULT pret;\n    PRL_UINT32 hddCount;\n    PRL_UINT32 i;\n    PRL_HANDLE job;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    vzDomObjPtr pdom = dom->privateData;\n    PRL_HANDLE sdkdom = pdom->sdkdom;\n\n    job = PrlVm_BeginEdit(sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        goto cleanup;\n\n    pret = PrlVmCfg_GetHardDisksCount(sdkdom, &hddCount);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < hddCount; ++i) {\n        pret = PrlVmCfg_GetHardDisk(sdkdom, 0, &sdkdisk);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlVmDev_Remove(sdkdisk);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        PrlHandle_Free(sdkdisk);\n        sdkdisk = PRL_INVALID_HANDLE;\n    }\n\n    job = PrlVm_CommitEx(sdkdom, PVCF_DETACH_HDD_BUNDLE);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(sdkdisk);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkDetachDomainHardDisks(virDomainObjPtr dom)\n{\n    int ret = -1;\n    PRL_RESULT pret;\n    PRL_UINT32 hddCount;\n    PRL_UINT32 i;\n    PRL_HANDLE job;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    vzDomObjPtr pdom = dom->privateData;\n    PRL_HANDLE sdkdom = pdom->sdkdom;\n\n    job = PrlVm_BeginEdit(sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        goto cleanup;\n\n    pret = PrlVmCfg_GetHardDisksCount(sdkdom, &hddCount);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < hddCount; ++i) {\n        pret = PrlVmCfg_GetHardDisk(sdkdom, 0, &sdkdisk);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlVmDev_Remove(sdkdisk);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        PrlHandle_Free(sdkdisk);\n        sdkdisk = PRL_INVALID_HANDLE;\n    }\n\n    job = PrlVm_CommitEx(sdkdom, PVCF_DETACH_HDD_BUNDLE);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(sdkdisk);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Refusing to undefine while snapshots exist\")"
          ],
          "line": 4272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Refusing to undefine while snapshots exist\""
          ],
          "line": 4273
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotObjListNum",
          "args": [
            "snapshots",
            "NULL",
            "0"
          ],
          "line": 4268
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotObjListNum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainsnapshotobjlist.c",
          "lines": "158-164",
          "snippet": "int\nvirDomainSnapshotObjListNum(virDomainSnapshotObjListPtr snapshots,\n                            virDomainMomentObjPtr from,\n                            unsigned int flags)\n{\n    return virDomainSnapshotObjListGetNames(snapshots, from, NULL, 0, flags);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDomainSnapshotObjListNum(virDomainSnapshotObjListPtr snapshots,\n                            virDomainMomentObjPtr from,\n                            unsigned int flags)\n{\n    return virDomainSnapshotObjListGetNames(snapshots, from, NULL, 0, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkLoadSnapshots",
          "args": [
            "dom"
          ],
          "line": 4265
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkLoadSnapshots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "4739-4761",
          "snippet": "virDomainSnapshotObjListPtr\nprlsdkLoadSnapshots(virDomainObjPtr dom)\n{\n    virDomainSnapshotObjListPtr ret = NULL;\n    PRL_HANDLE job;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    char *treexml = NULL;\n\n    job = PrlVm_GetSnapshotsTreeEx(privdom->sdkdom, PGST_WITHOUT_SCREENSHOTS);\n    if (PRL_FAILED(getDomainJobResult(job, dom, &result)))\n        goto cleanup;\n\n    if (!(treexml = prlsdkGetStringParamVar(PrlResult_GetParamAsString, result)))\n        goto cleanup;\n\n    ret = prlsdkParseSnapshotTree(treexml);\n cleanup:\n\n    PrlHandle_Free(result);\n    VIR_FREE(treexml);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirDomainSnapshotObjListPtr\nprlsdkLoadSnapshots(virDomainObjPtr dom)\n{\n    virDomainSnapshotObjListPtr ret = NULL;\n    PRL_HANDLE job;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    char *treexml = NULL;\n\n    job = PrlVm_GetSnapshotsTreeEx(privdom->sdkdom, PGST_WITHOUT_SCREENSHOTS);\n    if (PRL_FAILED(getDomainJobResult(job, dom, &result)))\n        goto cleanup;\n\n    if (!(treexml = prlsdkGetStringParamVar(PrlResult_GetParamAsString, result)))\n        goto cleanup;\n\n    ret = prlsdkParseSnapshotTree(treexml);\n cleanup:\n\n    PrlHandle_Free(result);\n    VIR_FREE(treexml);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Refusing to undefine while domain managed \"\n                         \"save image exists\")"
          ],
          "line": 4259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetDomainState",
          "args": [
            "dom",
            "privdom->sdkdom",
            "&domainState"
          ],
          "line": 4253
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetDomainState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "519-545",
          "snippet": "static int\nprlsdkGetDomainState(virDomainObjPtr dom, PRL_HANDLE sdkdom, VIRTUAL_MACHINE_STATE_PTR vmState)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_HANDLE vmInfo = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    int ret = -1;\n\n    job = PrlVm_GetState(sdkdom);\n\n    if (PRL_FAILED(getDomainJobResult(job, dom, &result)))\n        goto cleanup;\n\n    pret = PrlResult_GetParamByIndex(result, 0, &vmInfo);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmInfo_GetState(vmInfo, vmState);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(vmInfo);\n    PrlHandle_Free(result);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkGetDomainState(virDomainObjPtr dom, PRL_HANDLE sdkdom, VIRTUAL_MACHINE_STATE_PTR vmState)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_HANDLE vmInfo = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    int ret = -1;\n\n    job = PrlVm_GetState(sdkdom);\n\n    if (PRL_FAILED(getDomainJobResult(job, dom, &result)))\n        goto cleanup;\n\n    pret = PrlResult_GetParamByIndex(result, 0, &vmInfo);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmInfo_GetState(vmInfo, vmState);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(vmInfo);\n    PrlHandle_Free(result);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nprlsdkUnregisterDomain(vzDriverPtr driver, virDomainObjPtr dom, unsigned int flags)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job;\n    virDomainSnapshotObjListPtr snapshots = NULL;\n    VIRTUAL_MACHINE_STATE domainState;\n    int ret = -1;\n    int num;\n\n    if (prlsdkGetDomainState(dom, privdom->sdkdom, &domainState) < 0)\n        return -1;\n\n    if (VMS_SUSPENDED == domainState &&\n        !(flags & VIR_DOMAIN_UNDEFINE_MANAGED_SAVE)) {\n\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Refusing to undefine while domain managed \"\n                         \"save image exists\"));\n        return -1;\n    }\n\n    if (!(snapshots = prlsdkLoadSnapshots(dom)))\n        return -1;\n\n    if ((num = virDomainSnapshotObjListNum(snapshots, NULL, 0)) < 0)\n        goto cleanup;\n\n    if (num > 0 && !(flags & VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"Refusing to undefine while snapshots exist\"));\n        goto cleanup;\n    }\n\n    if (prlsdkDetachDomainHardDisks(dom))\n        goto cleanup;\n\n    job = PrlVm_Delete(privdom->sdkdom, PRL_INVALID_HANDLE);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        goto cleanup;\n\n    prlsdkSendEvent(driver, dom, VIR_DOMAIN_EVENT_UNDEFINED,\n                    VIR_DOMAIN_EVENT_UNDEFINED_REMOVED);\n\n    virDomainObjListRemove(driver->domains, dom);\n\n    ret = 0;\n cleanup:\n\n    virDomainSnapshotObjListFree(snapshots);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkDetachDomainHardDisks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4202-4241",
    "snippet": "static int\nprlsdkDetachDomainHardDisks(virDomainObjPtr dom)\n{\n    int ret = -1;\n    PRL_RESULT pret;\n    PRL_UINT32 hddCount;\n    PRL_UINT32 i;\n    PRL_HANDLE job;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    vzDomObjPtr pdom = dom->privateData;\n    PRL_HANDLE sdkdom = pdom->sdkdom;\n\n    job = PrlVm_BeginEdit(sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        goto cleanup;\n\n    pret = PrlVmCfg_GetHardDisksCount(sdkdom, &hddCount);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < hddCount; ++i) {\n        pret = PrlVmCfg_GetHardDisk(sdkdom, 0, &sdkdisk);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlVmDev_Remove(sdkdisk);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        PrlHandle_Free(sdkdisk);\n        sdkdisk = PRL_INVALID_HANDLE;\n    }\n\n    job = PrlVm_CommitEx(sdkdom, PVCF_DETACH_HDD_BUNDLE);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(sdkdisk);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "sdkdisk"
          ],
          "line": 4239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 4233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 4233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_CommitEx",
          "args": [
            "sdkdom",
            "PVCF_DETACH_HDD_BUNDLE"
          ],
          "line": 4232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "sdkdisk"
          ],
          "line": 4228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 4226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_Remove",
          "args": [
            "sdkdisk"
          ],
          "line": 4225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 4223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetHardDisk",
          "args": [
            "sdkdom",
            "0",
            "&sdkdisk"
          ],
          "line": 4222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 4219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetHardDisksCount",
          "args": [
            "sdkdom",
            "&hddCount"
          ],
          "line": 4218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 4215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 4215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_BeginEdit",
          "args": [
            "sdkdom"
          ],
          "line": 4214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkDetachDomainHardDisks(virDomainObjPtr dom)\n{\n    int ret = -1;\n    PRL_RESULT pret;\n    PRL_UINT32 hddCount;\n    PRL_UINT32 i;\n    PRL_HANDLE job;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    vzDomObjPtr pdom = dom->privateData;\n    PRL_HANDLE sdkdom = pdom->sdkdom;\n\n    job = PrlVm_BeginEdit(sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        goto cleanup;\n\n    pret = PrlVmCfg_GetHardDisksCount(sdkdom, &hddCount);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < hddCount; ++i) {\n        pret = PrlVmCfg_GetHardDisk(sdkdom, 0, &sdkdisk);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlVmDev_Remove(sdkdisk);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        PrlHandle_Free(sdkdisk);\n        sdkdisk = PRL_INVALID_HANDLE;\n    }\n\n    job = PrlVm_CommitEx(sdkdom, PVCF_DETACH_HDD_BUNDLE);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(sdkdisk);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkCreateCt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4124-4193",
    "snippet": "int\nprlsdkCreateCt(virConnectPtr conn, virDomainDefPtr def)\n{\n    PRL_HANDLE sdkdom = PRL_INVALID_HANDLE;\n    PRL_GET_VM_CONFIG_PARAM_DATA confParam;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    PRL_UINT32 flags;\n    vzConnPtr privconn = conn->privateData;\n    vzDriverPtr driver = privconn->driver;\n    int ret = -1;\n    int useTemplate = 0;\n    size_t i;\n\n    for (i = 0; i < def->nfss; i++) {\n        if (useTemplate) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"Unsupported configuration\"));\n            return -1;\n        }\n        if (def->fss[i]->type == VIR_DOMAIN_FS_TYPE_TEMPLATE)\n            useTemplate = 1;\n        if (def->fss[i]->type == VIR_DOMAIN_FS_TYPE_VOLUME) {\n            if (virStorageTranslatePoolLocal(conn, def->fss[i]->src) < 0)\n                goto cleanup;\n        }\n\n    }\n\n    if (useTemplate && def->nfss > 1) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Unsupported configuration\"));\n        return -1;\n    }\n\n    confParam.nVmType = PVT_CT;\n    confParam.sConfigSample = \"vswap.1024MB\";\n    confParam.nOsVersion = 0;\n\n    job = PrlSrv_GetDefaultVmConfig(driver->server, &confParam, 0);\n    if (PRL_FAILED(getJobResult(job, &result)))\n        goto cleanup;\n\n    pret = PrlResult_GetParamByIndex(result, 0, &sdkdom);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (useTemplate) {\n        pret = PrlVmCfg_SetOsTemplate(sdkdom, def->fss[0]->src->path);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n    }\n\n    if (prlsdkDoApplyConfig(driver, NULL, sdkdom, def) < 0)\n        goto cleanup;\n\n    flags = PACF_NON_INTERACTIVE_MODE;\n    if (!useTemplate)\n        flags |= PRNVM_PRESERVE_DISK;\n    job = PrlVm_RegEx(sdkdom, \"\", flags);\n    if (PRL_FAILED(waitJob(job)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(sdkdom);\n    PrlHandle_Free(result);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "result"
          ],
          "line": 4191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "sdkdom"
          ],
          "line": 4190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitJob(job)"
          ],
          "line": 4184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitJob",
          "args": [
            "job"
          ],
          "line": 4184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_RegEx",
          "args": [
            "sdkdom",
            "\"\"",
            "flags"
          ],
          "line": 4183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkDoApplyConfig",
          "args": [
            "driver",
            "NULL",
            "sdkdom",
            "def"
          ],
          "line": 4177
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkDoApplyConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3894-4012",
          "snippet": "static int\nprlsdkDoApplyConfig(vzDriverPtr driver,\n                    virDomainObjPtr dom,\n                    PRL_HANDLE sdkdom,\n                    virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    size_t i;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n    char *mask = NULL;\n\n    if (prlsdkCheckUnsupportedParams(sdkdom, def) < 0)\n        return -1;\n\n    if (def->description) {\n        pret = PrlVmCfg_SetDescription(sdkdom, def->description);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    if (def->name) {\n        pret = PrlVmCfg_SetName(sdkdom, def->name);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    if (def->uuid) {\n        prlsdkUUIDFormat(def->uuid, uuidstr);\n\n        pret = PrlVmCfg_SetUuid(sdkdom, uuidstr);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    pret = PrlVmCfg_SetRamSize(sdkdom, virDomainDefGetMemoryTotal(def) >> 10);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_SetCpuCount(sdkdom, virDomainDefGetVcpus(def));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (!(mask = virBitmapFormat(def->cpumask)))\n        goto error;\n\n    pret = PrlVmCfg_SetCpuMask(sdkdom, mask);\n    prlsdkCheckRetGoto(pret, error);\n    VIR_FREE(mask);\n\n    switch ((int)def->os.arch) {\n    case VIR_ARCH_X86_64:\n        pret = PrlVmCfg_SetCpuMode(sdkdom, PCM_CPU_MODE_64);\n        break;\n    case VIR_ARCH_I686:\n        pret = PrlVmCfg_SetCpuMode(sdkdom, PCM_CPU_MODE_32);\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU mode: %s\"),\n                       virArchToString(def->os.arch));\n        goto error;\n    }\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkClearDevices(sdkdom) < 0)\n        goto error;\n\n    if (prlsdkRemoveBootDevices(sdkdom) < 0)\n        goto error;\n\n    for (i = 0; i < def->nnets; i++) {\n        if (prlsdkConfigureNet(driver, dom, sdkdom, def->nets[i],\n                               IS_CT(def), true) < 0)\n            goto error;\n    }\n\n    if (def->ngraphics > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver supports only VNC graphics\"));\n        goto error;\n    }\n\n    if (prlsdkApplyGraphicsParams(sdkdom,\n                                  def->ngraphics == 1 ? def->graphics[0] : NULL) < 0)\n        goto error;\n\n    if (prlsdkApplyVideoParams(sdkdom, def) < 0)\n        goto error;\n\n    for (i = 0; i < def->nserials; i++) {\n        if (prlsdkAddSerial(sdkdom, def->serials[i]) < 0)\n            goto error;\n    }\n\n    /* It is important that we add filesystems first and then disks as we rely\n     * on this information in prlsdkSetBootOrderCt */\n    for (i = 0; i < def->nfss; i++) {\n        if (prlsdkAddFS(sdkdom, def->fss[i]) < 0)\n            goto error;\n    }\n\n    /* filesystems first, disks go after them as we rely on this order in\n     * prlsdkSetBootOrderCt */\n    for (i = 0; i < def->ndisks; i++) {\n        if (prlsdkConfigureDisk(driver, sdkdom, def->disks[i],\n                                true) < 0)\n            goto error;\n    }\n\n    if (IS_CT(def)) {\n        if (prlsdkSetBootOrderCt(sdkdom, def) < 0)\n            goto error;\n    } else {\n        if (prlsdkSetBootOrderVm(sdkdom, def) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    VIR_FREE(mask);\n\n    return -1;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);",
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkDoApplyConfig(vzDriverPtr driver,\n                    virDomainObjPtr dom,\n                    PRL_HANDLE sdkdom,\n                    virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    size_t i;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n    char *mask = NULL;\n\n    if (prlsdkCheckUnsupportedParams(sdkdom, def) < 0)\n        return -1;\n\n    if (def->description) {\n        pret = PrlVmCfg_SetDescription(sdkdom, def->description);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    if (def->name) {\n        pret = PrlVmCfg_SetName(sdkdom, def->name);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    if (def->uuid) {\n        prlsdkUUIDFormat(def->uuid, uuidstr);\n\n        pret = PrlVmCfg_SetUuid(sdkdom, uuidstr);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    pret = PrlVmCfg_SetRamSize(sdkdom, virDomainDefGetMemoryTotal(def) >> 10);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_SetCpuCount(sdkdom, virDomainDefGetVcpus(def));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (!(mask = virBitmapFormat(def->cpumask)))\n        goto error;\n\n    pret = PrlVmCfg_SetCpuMask(sdkdom, mask);\n    prlsdkCheckRetGoto(pret, error);\n    VIR_FREE(mask);\n\n    switch ((int)def->os.arch) {\n    case VIR_ARCH_X86_64:\n        pret = PrlVmCfg_SetCpuMode(sdkdom, PCM_CPU_MODE_64);\n        break;\n    case VIR_ARCH_I686:\n        pret = PrlVmCfg_SetCpuMode(sdkdom, PCM_CPU_MODE_32);\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU mode: %s\"),\n                       virArchToString(def->os.arch));\n        goto error;\n    }\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkClearDevices(sdkdom) < 0)\n        goto error;\n\n    if (prlsdkRemoveBootDevices(sdkdom) < 0)\n        goto error;\n\n    for (i = 0; i < def->nnets; i++) {\n        if (prlsdkConfigureNet(driver, dom, sdkdom, def->nets[i],\n                               IS_CT(def), true) < 0)\n            goto error;\n    }\n\n    if (def->ngraphics > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver supports only VNC graphics\"));\n        goto error;\n    }\n\n    if (prlsdkApplyGraphicsParams(sdkdom,\n                                  def->ngraphics == 1 ? def->graphics[0] : NULL) < 0)\n        goto error;\n\n    if (prlsdkApplyVideoParams(sdkdom, def) < 0)\n        goto error;\n\n    for (i = 0; i < def->nserials; i++) {\n        if (prlsdkAddSerial(sdkdom, def->serials[i]) < 0)\n            goto error;\n    }\n\n    /* It is important that we add filesystems first and then disks as we rely\n     * on this information in prlsdkSetBootOrderCt */\n    for (i = 0; i < def->nfss; i++) {\n        if (prlsdkAddFS(sdkdom, def->fss[i]) < 0)\n            goto error;\n    }\n\n    /* filesystems first, disks go after them as we rely on this order in\n     * prlsdkSetBootOrderCt */\n    for (i = 0; i < def->ndisks; i++) {\n        if (prlsdkConfigureDisk(driver, sdkdom, def->disks[i],\n                                true) < 0)\n            goto error;\n    }\n\n    if (IS_CT(def)) {\n        if (prlsdkSetBootOrderCt(sdkdom, def) < 0)\n            goto error;\n    } else {\n        if (prlsdkSetBootOrderVm(sdkdom, def) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    VIR_FREE(mask);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 4173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetOsTemplate",
          "args": [
            "sdkdom",
            "def->fss[0]->src->path"
          ],
          "line": 4172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 4169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlResult_GetParamByIndex",
          "args": [
            "result",
            "0",
            "&sdkdom"
          ],
          "line": 4168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "getJobResult(job, &result)"
          ],
          "line": 4165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getJobResult",
          "args": [
            "job",
            "&result"
          ],
          "line": 4165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlSrv_GetDefaultVmConfig",
          "args": [
            "driver->server",
            "&confParam",
            "0"
          ],
          "line": 4164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Unsupported configuration\")"
          ],
          "line": 4155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported configuration\""
          ],
          "line": 4156
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageTranslatePoolLocal",
          "args": [
            "conn",
            "def->fss[i]->src"
          ],
          "line": 4148
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageTranslatePoolLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "4081-4121",
          "snippet": "static int\nvirStorageTranslatePoolLocal(virConnectPtr conn, virStorageSourcePtr src)\n{\n    virStoragePoolPtr pool = NULL;\n    virStorageVolPtr vol = NULL;\n    virStorageVolInfo info;\n    int ret = -1;\n\n    if (!(pool = virStoragePoolLookupByName(conn, src->srcpool->pool)))\n        return -1;\n    if (virStoragePoolIsActive(pool) != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"storage pool '%s' containing volume '%s' \"\n                         \"is not active\"), src->srcpool->pool,\n                       src->srcpool->volume);\n        goto cleanup;\n    }\n\n    if (!(vol = virStorageVolLookupByName(pool, src->srcpool->volume)))\n        goto cleanup;\n\n    if (virStorageVolGetInfo(vol, &info) < 0)\n        goto cleanup;\n\n    if (info.type != VIR_STORAGE_VOL_PLOOP) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported volume format '%s'\"),\n                       virStorageVolTypeToString(info.type));\n        goto cleanup;\n    }\n\n    if (!(src->path = virStorageVolGetPath(vol)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(pool);\n    virObjectUnref(vol);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvirStorageTranslatePoolLocal(virConnectPtr conn, virStorageSourcePtr src)\n{\n    virStoragePoolPtr pool = NULL;\n    virStorageVolPtr vol = NULL;\n    virStorageVolInfo info;\n    int ret = -1;\n\n    if (!(pool = virStoragePoolLookupByName(conn, src->srcpool->pool)))\n        return -1;\n    if (virStoragePoolIsActive(pool) != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"storage pool '%s' containing volume '%s' \"\n                         \"is not active\"), src->srcpool->pool,\n                       src->srcpool->volume);\n        goto cleanup;\n    }\n\n    if (!(vol = virStorageVolLookupByName(pool, src->srcpool->volume)))\n        goto cleanup;\n\n    if (virStorageVolGetInfo(vol, &info) < 0)\n        goto cleanup;\n\n    if (info.type != VIR_STORAGE_VOL_PLOOP) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported volume format '%s'\"),\n                       virStorageVolTypeToString(info.type));\n        goto cleanup;\n    }\n\n    if (!(src->path = virStorageVolGetPath(vol)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(pool);\n    virObjectUnref(vol);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Unsupported configuration\")"
          ],
          "line": 4141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nint\nprlsdkCreateCt(virConnectPtr conn, virDomainDefPtr def)\n{\n    PRL_HANDLE sdkdom = PRL_INVALID_HANDLE;\n    PRL_GET_VM_CONFIG_PARAM_DATA confParam;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    PRL_UINT32 flags;\n    vzConnPtr privconn = conn->privateData;\n    vzDriverPtr driver = privconn->driver;\n    int ret = -1;\n    int useTemplate = 0;\n    size_t i;\n\n    for (i = 0; i < def->nfss; i++) {\n        if (useTemplate) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"Unsupported configuration\"));\n            return -1;\n        }\n        if (def->fss[i]->type == VIR_DOMAIN_FS_TYPE_TEMPLATE)\n            useTemplate = 1;\n        if (def->fss[i]->type == VIR_DOMAIN_FS_TYPE_VOLUME) {\n            if (virStorageTranslatePoolLocal(conn, def->fss[i]->src) < 0)\n                goto cleanup;\n        }\n\n    }\n\n    if (useTemplate && def->nfss > 1) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Unsupported configuration\"));\n        return -1;\n    }\n\n    confParam.nVmType = PVT_CT;\n    confParam.sConfigSample = \"vswap.1024MB\";\n    confParam.nOsVersion = 0;\n\n    job = PrlSrv_GetDefaultVmConfig(driver->server, &confParam, 0);\n    if (PRL_FAILED(getJobResult(job, &result)))\n        goto cleanup;\n\n    pret = PrlResult_GetParamByIndex(result, 0, &sdkdom);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (useTemplate) {\n        pret = PrlVmCfg_SetOsTemplate(sdkdom, def->fss[0]->src->path);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n    }\n\n    if (prlsdkDoApplyConfig(driver, NULL, sdkdom, def) < 0)\n        goto cleanup;\n\n    flags = PACF_NON_INTERACTIVE_MODE;\n    if (!useTemplate)\n        flags |= PRNVM_PRESERVE_DISK;\n    job = PrlVm_RegEx(sdkdom, \"\", flags);\n    if (PRL_FAILED(waitJob(job)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(sdkdom);\n    PrlHandle_Free(result);\n    return ret;\n}"
  },
  {
    "function_name": "virStorageTranslatePoolLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4081-4121",
    "snippet": "static int\nvirStorageTranslatePoolLocal(virConnectPtr conn, virStorageSourcePtr src)\n{\n    virStoragePoolPtr pool = NULL;\n    virStorageVolPtr vol = NULL;\n    virStorageVolInfo info;\n    int ret = -1;\n\n    if (!(pool = virStoragePoolLookupByName(conn, src->srcpool->pool)))\n        return -1;\n    if (virStoragePoolIsActive(pool) != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"storage pool '%s' containing volume '%s' \"\n                         \"is not active\"), src->srcpool->pool,\n                       src->srcpool->volume);\n        goto cleanup;\n    }\n\n    if (!(vol = virStorageVolLookupByName(pool, src->srcpool->volume)))\n        goto cleanup;\n\n    if (virStorageVolGetInfo(vol, &info) < 0)\n        goto cleanup;\n\n    if (info.type != VIR_STORAGE_VOL_PLOOP) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported volume format '%s'\"),\n                       virStorageVolTypeToString(info.type));\n        goto cleanup;\n    }\n\n    if (!(src->path = virStorageVolGetPath(vol)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(pool);\n    virObjectUnref(vol);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "vol"
          ],
          "line": 4119
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageVolGetPath",
          "args": [
            "vol"
          ],
          "line": 4112
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageVolGetPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-storage.c",
          "lines": "2068-2092",
          "snippet": "char *\nvirStorageVolGetPath(virStorageVolPtr vol)\n{\n    virConnectPtr conn;\n    VIR_DEBUG(\"vol=%p\", vol);\n\n    virResetLastError();\n\n    virCheckStorageVolReturn(vol, NULL);\n    conn = vol->conn;\n\n    if (conn->storageDriver && conn->storageDriver->storageVolGetPath) {\n        char *ret;\n        ret = conn->storageDriver->storageVolGetPath(vol);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(vol->conn);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nchar *\nvirStorageVolGetPath(virStorageVolPtr vol)\n{\n    virConnectPtr conn;\n    VIR_DEBUG(\"vol=%p\", vol);\n\n    virResetLastError();\n\n    virCheckStorageVolReturn(vol, NULL);\n    conn = vol->conn;\n\n    if (conn->storageDriver && conn->storageDriver->storageVolGetPath) {\n        char *ret;\n        ret = conn->storageDriver->storageVolGetPath(vol);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(vol->conn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported volume format '%s'\")",
            "virStorageVolTypeToString(info.type)"
          ],
          "line": 4106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageVolTypeToString",
          "args": [
            "info.type"
          ],
          "line": 4108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported volume format '%s'\""
          ],
          "line": 4107
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageVolGetInfo",
          "args": [
            "vol",
            "&info"
          ],
          "line": 4102
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageVolGetInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-storage.c",
          "lines": "1933-1963",
          "snippet": "int\nvirStorageVolGetInfo(virStorageVolPtr vol,\n                     virStorageVolInfoPtr info)\n{\n    virConnectPtr conn;\n    VIR_DEBUG(\"vol=%p, info=%p\", vol, info);\n\n    virResetLastError();\n\n    if (info)\n        memset(info, 0, sizeof(*info));\n\n    virCheckStorageVolReturn(vol, -1);\n    virCheckNonNullArgGoto(info, error);\n\n    conn = vol->conn;\n\n    if (conn->storageDriver->storageVolGetInfo) {\n        int ret;\n        ret = conn->storageDriver->storageVolGetInfo(vol, info);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(vol->conn);\n    return -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStorageVolGetInfo(virStorageVolPtr vol,\n                     virStorageVolInfoPtr info)\n{\n    virConnectPtr conn;\n    VIR_DEBUG(\"vol=%p, info=%p\", vol, info);\n\n    virResetLastError();\n\n    if (info)\n        memset(info, 0, sizeof(*info));\n\n    virCheckStorageVolReturn(vol, -1);\n    virCheckNonNullArgGoto(info, error);\n\n    conn = vol->conn;\n\n    if (conn->storageDriver->storageVolGetInfo) {\n        int ret;\n        ret = conn->storageDriver->storageVolGetInfo(vol, info);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(vol->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageVolLookupByName",
          "args": [
            "pool",
            "src->srcpool->volume"
          ],
          "line": 4099
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageVolLookupByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-storage.c",
          "lines": "1326-1350",
          "snippet": "virStorageVolPtr\nvirStorageVolLookupByName(virStoragePoolPtr pool,\n                          const char *name)\n{\n    VIR_DEBUG(\"pool=%p, name=%s\", pool, NULLSTR(name));\n\n    virResetLastError();\n\n    virCheckStoragePoolReturn(pool, NULL);\n    virCheckNonNullArgGoto(name, error);\n\n    if (pool->conn->storageDriver && pool->conn->storageDriver->storageVolLookupByName) {\n        virStorageVolPtr ret;\n        ret = pool->conn->storageDriver->storageVolLookupByName(pool, name);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(pool->conn);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirStorageVolPtr\nvirStorageVolLookupByName(virStoragePoolPtr pool,\n                          const char *name)\n{\n    VIR_DEBUG(\"pool=%p, name=%s\", pool, NULLSTR(name));\n\n    virResetLastError();\n\n    virCheckStoragePoolReturn(pool, NULL);\n    virCheckNonNullArgGoto(name, error);\n\n    if (pool->conn->storageDriver && pool->conn->storageDriver->storageVolLookupByName) {\n        virStorageVolPtr ret;\n        ret = pool->conn->storageDriver->storageVolLookupByName(pool, name);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(pool->conn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"storage pool '%s' containing volume '%s' \"\n                         \"is not active\")",
            "src->srcpool->pool",
            "src->srcpool->volume"
          ],
          "line": 4092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolIsActive",
          "args": [
            "pool"
          ],
          "line": 4091
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-storage.c",
          "lines": "2178-2199",
          "snippet": "int\nvirStoragePoolIsActive(virStoragePoolPtr pool)\n{\n    VIR_DEBUG(\"pool=%p\", pool);\n\n    virResetLastError();\n\n    virCheckStoragePoolReturn(pool, -1);\n\n    if (pool->conn->storageDriver->storagePoolIsActive) {\n        int ret;\n        ret = pool->conn->storageDriver->storagePoolIsActive(pool);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(pool->conn);\n    return -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStoragePoolIsActive(virStoragePoolPtr pool)\n{\n    VIR_DEBUG(\"pool=%p\", pool);\n\n    virResetLastError();\n\n    virCheckStoragePoolReturn(pool, -1);\n\n    if (pool->conn->storageDriver->storagePoolIsActive) {\n        int ret;\n        ret = pool->conn->storageDriver->storagePoolIsActive(pool);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(pool->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolLookupByName",
          "args": [
            "conn",
            "src->srcpool->pool"
          ],
          "line": 4089
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolLookupByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-storage.c",
          "lines": "363-387",
          "snippet": "virStoragePoolPtr\nvirStoragePoolLookupByName(virConnectPtr conn,\n                           const char *name)\n{\n    VIR_DEBUG(\"conn=%p, name=%s\", conn, NULLSTR(name));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(name, error);\n\n    if (conn->storageDriver && conn->storageDriver->storagePoolLookupByName) {\n        virStoragePoolPtr ret;\n        ret = conn->storageDriver->storagePoolLookupByName(conn, name);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirStoragePoolPtr\nvirStoragePoolLookupByName(virConnectPtr conn,\n                           const char *name)\n{\n    VIR_DEBUG(\"conn=%p, name=%s\", conn, NULLSTR(name));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(name, error);\n\n    if (conn->storageDriver && conn->storageDriver->storagePoolLookupByName) {\n        virStoragePoolPtr ret;\n        ret = conn->storageDriver->storagePoolLookupByName(conn, name);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvirStorageTranslatePoolLocal(virConnectPtr conn, virStorageSourcePtr src)\n{\n    virStoragePoolPtr pool = NULL;\n    virStorageVolPtr vol = NULL;\n    virStorageVolInfo info;\n    int ret = -1;\n\n    if (!(pool = virStoragePoolLookupByName(conn, src->srcpool->pool)))\n        return -1;\n    if (virStoragePoolIsActive(pool) != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"storage pool '%s' containing volume '%s' \"\n                         \"is not active\"), src->srcpool->pool,\n                       src->srcpool->volume);\n        goto cleanup;\n    }\n\n    if (!(vol = virStorageVolLookupByName(pool, src->srcpool->volume)))\n        goto cleanup;\n\n    if (virStorageVolGetInfo(vol, &info) < 0)\n        goto cleanup;\n\n    if (info.type != VIR_STORAGE_VOL_PLOOP) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported volume format '%s'\"),\n                       virStorageVolTypeToString(info.type));\n        goto cleanup;\n    }\n\n    if (!(src->path = virStorageVolGetPath(vol)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(pool);\n    virObjectUnref(vol);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkCreateVm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4038-4079",
    "snippet": "int\nprlsdkCreateVm(vzDriverPtr driver, virDomainDefPtr def)\n{\n    PRL_HANDLE sdkdom = PRL_INVALID_HANDLE;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_HANDLE srvconf = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    int ret = -1;\n\n    pret = PrlSrv_CreateVm(driver->server, &sdkdom);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    job = PrlSrv_GetSrvConfig(driver->server);\n    if (PRL_FAILED(getJobResult(job, &result)))\n        goto cleanup;\n\n    pret = PrlResult_GetParamByIndex(result, 0, &srvconf);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmCfg_SetDefaultConfig(sdkdom, srvconf, PVS_GUEST_VER_LIN_REDHAT, 0);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmCfg_SetOfflineManagementEnabled(sdkdom, 0);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (prlsdkDoApplyConfig(driver, NULL, sdkdom, def) < 0)\n        goto cleanup;\n\n    job = PrlVm_Reg(sdkdom, \"\", 1);\n    if (PRL_FAILED(waitJob(job)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(sdkdom);\n    PrlHandle_Free(srvconf);\n    PrlHandle_Free(result);\n\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "result"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "srvconf"
          ],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "sdkdom"
          ],
          "line": 4074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitJob(job)"
          ],
          "line": 4068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitJob",
          "args": [
            "job"
          ],
          "line": 4068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_Reg",
          "args": [
            "sdkdom",
            "\"\"",
            "1"
          ],
          "line": 4067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkDoApplyConfig",
          "args": [
            "driver",
            "NULL",
            "sdkdom",
            "def"
          ],
          "line": 4064
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkDoApplyConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3894-4012",
          "snippet": "static int\nprlsdkDoApplyConfig(vzDriverPtr driver,\n                    virDomainObjPtr dom,\n                    PRL_HANDLE sdkdom,\n                    virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    size_t i;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n    char *mask = NULL;\n\n    if (prlsdkCheckUnsupportedParams(sdkdom, def) < 0)\n        return -1;\n\n    if (def->description) {\n        pret = PrlVmCfg_SetDescription(sdkdom, def->description);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    if (def->name) {\n        pret = PrlVmCfg_SetName(sdkdom, def->name);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    if (def->uuid) {\n        prlsdkUUIDFormat(def->uuid, uuidstr);\n\n        pret = PrlVmCfg_SetUuid(sdkdom, uuidstr);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    pret = PrlVmCfg_SetRamSize(sdkdom, virDomainDefGetMemoryTotal(def) >> 10);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_SetCpuCount(sdkdom, virDomainDefGetVcpus(def));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (!(mask = virBitmapFormat(def->cpumask)))\n        goto error;\n\n    pret = PrlVmCfg_SetCpuMask(sdkdom, mask);\n    prlsdkCheckRetGoto(pret, error);\n    VIR_FREE(mask);\n\n    switch ((int)def->os.arch) {\n    case VIR_ARCH_X86_64:\n        pret = PrlVmCfg_SetCpuMode(sdkdom, PCM_CPU_MODE_64);\n        break;\n    case VIR_ARCH_I686:\n        pret = PrlVmCfg_SetCpuMode(sdkdom, PCM_CPU_MODE_32);\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU mode: %s\"),\n                       virArchToString(def->os.arch));\n        goto error;\n    }\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkClearDevices(sdkdom) < 0)\n        goto error;\n\n    if (prlsdkRemoveBootDevices(sdkdom) < 0)\n        goto error;\n\n    for (i = 0; i < def->nnets; i++) {\n        if (prlsdkConfigureNet(driver, dom, sdkdom, def->nets[i],\n                               IS_CT(def), true) < 0)\n            goto error;\n    }\n\n    if (def->ngraphics > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver supports only VNC graphics\"));\n        goto error;\n    }\n\n    if (prlsdkApplyGraphicsParams(sdkdom,\n                                  def->ngraphics == 1 ? def->graphics[0] : NULL) < 0)\n        goto error;\n\n    if (prlsdkApplyVideoParams(sdkdom, def) < 0)\n        goto error;\n\n    for (i = 0; i < def->nserials; i++) {\n        if (prlsdkAddSerial(sdkdom, def->serials[i]) < 0)\n            goto error;\n    }\n\n    /* It is important that we add filesystems first and then disks as we rely\n     * on this information in prlsdkSetBootOrderCt */\n    for (i = 0; i < def->nfss; i++) {\n        if (prlsdkAddFS(sdkdom, def->fss[i]) < 0)\n            goto error;\n    }\n\n    /* filesystems first, disks go after them as we rely on this order in\n     * prlsdkSetBootOrderCt */\n    for (i = 0; i < def->ndisks; i++) {\n        if (prlsdkConfigureDisk(driver, sdkdom, def->disks[i],\n                                true) < 0)\n            goto error;\n    }\n\n    if (IS_CT(def)) {\n        if (prlsdkSetBootOrderCt(sdkdom, def) < 0)\n            goto error;\n    } else {\n        if (prlsdkSetBootOrderVm(sdkdom, def) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    VIR_FREE(mask);\n\n    return -1;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);",
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkDoApplyConfig(vzDriverPtr driver,\n                    virDomainObjPtr dom,\n                    PRL_HANDLE sdkdom,\n                    virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    size_t i;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n    char *mask = NULL;\n\n    if (prlsdkCheckUnsupportedParams(sdkdom, def) < 0)\n        return -1;\n\n    if (def->description) {\n        pret = PrlVmCfg_SetDescription(sdkdom, def->description);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    if (def->name) {\n        pret = PrlVmCfg_SetName(sdkdom, def->name);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    if (def->uuid) {\n        prlsdkUUIDFormat(def->uuid, uuidstr);\n\n        pret = PrlVmCfg_SetUuid(sdkdom, uuidstr);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    pret = PrlVmCfg_SetRamSize(sdkdom, virDomainDefGetMemoryTotal(def) >> 10);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_SetCpuCount(sdkdom, virDomainDefGetVcpus(def));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (!(mask = virBitmapFormat(def->cpumask)))\n        goto error;\n\n    pret = PrlVmCfg_SetCpuMask(sdkdom, mask);\n    prlsdkCheckRetGoto(pret, error);\n    VIR_FREE(mask);\n\n    switch ((int)def->os.arch) {\n    case VIR_ARCH_X86_64:\n        pret = PrlVmCfg_SetCpuMode(sdkdom, PCM_CPU_MODE_64);\n        break;\n    case VIR_ARCH_I686:\n        pret = PrlVmCfg_SetCpuMode(sdkdom, PCM_CPU_MODE_32);\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU mode: %s\"),\n                       virArchToString(def->os.arch));\n        goto error;\n    }\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkClearDevices(sdkdom) < 0)\n        goto error;\n\n    if (prlsdkRemoveBootDevices(sdkdom) < 0)\n        goto error;\n\n    for (i = 0; i < def->nnets; i++) {\n        if (prlsdkConfigureNet(driver, dom, sdkdom, def->nets[i],\n                               IS_CT(def), true) < 0)\n            goto error;\n    }\n\n    if (def->ngraphics > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver supports only VNC graphics\"));\n        goto error;\n    }\n\n    if (prlsdkApplyGraphicsParams(sdkdom,\n                                  def->ngraphics == 1 ? def->graphics[0] : NULL) < 0)\n        goto error;\n\n    if (prlsdkApplyVideoParams(sdkdom, def) < 0)\n        goto error;\n\n    for (i = 0; i < def->nserials; i++) {\n        if (prlsdkAddSerial(sdkdom, def->serials[i]) < 0)\n            goto error;\n    }\n\n    /* It is important that we add filesystems first and then disks as we rely\n     * on this information in prlsdkSetBootOrderCt */\n    for (i = 0; i < def->nfss; i++) {\n        if (prlsdkAddFS(sdkdom, def->fss[i]) < 0)\n            goto error;\n    }\n\n    /* filesystems first, disks go after them as we rely on this order in\n     * prlsdkSetBootOrderCt */\n    for (i = 0; i < def->ndisks; i++) {\n        if (prlsdkConfigureDisk(driver, sdkdom, def->disks[i],\n                                true) < 0)\n            goto error;\n    }\n\n    if (IS_CT(def)) {\n        if (prlsdkSetBootOrderCt(sdkdom, def) < 0)\n            goto error;\n    } else {\n        if (prlsdkSetBootOrderVm(sdkdom, def) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    VIR_FREE(mask);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 4062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetOfflineManagementEnabled",
          "args": [
            "sdkdom",
            "0"
          ],
          "line": 4061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 4059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetDefaultConfig",
          "args": [
            "sdkdom",
            "srvconf",
            "PVS_GUEST_VER_LIN_REDHAT",
            "0"
          ],
          "line": 4058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 4056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlResult_GetParamByIndex",
          "args": [
            "result",
            "0",
            "&srvconf"
          ],
          "line": 4055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "getJobResult(job, &result)"
          ],
          "line": 4052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getJobResult",
          "args": [
            "job",
            "&result"
          ],
          "line": 4052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlSrv_GetSrvConfig",
          "args": [
            "driver->server"
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 4049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlSrv_CreateVm",
          "args": [
            "driver->server",
            "&sdkdom"
          ],
          "line": 4048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nint\nprlsdkCreateVm(vzDriverPtr driver, virDomainDefPtr def)\n{\n    PRL_HANDLE sdkdom = PRL_INVALID_HANDLE;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_HANDLE srvconf = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    int ret = -1;\n\n    pret = PrlSrv_CreateVm(driver->server, &sdkdom);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    job = PrlSrv_GetSrvConfig(driver->server);\n    if (PRL_FAILED(getJobResult(job, &result)))\n        goto cleanup;\n\n    pret = PrlResult_GetParamByIndex(result, 0, &srvconf);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmCfg_SetDefaultConfig(sdkdom, srvconf, PVS_GUEST_VER_LIN_REDHAT, 0);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmCfg_SetOfflineManagementEnabled(sdkdom, 0);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (prlsdkDoApplyConfig(driver, NULL, sdkdom, def) < 0)\n        goto cleanup;\n\n    job = PrlVm_Reg(sdkdom, \"\", 1);\n    if (PRL_FAILED(waitJob(job)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(sdkdom);\n    PrlHandle_Free(srvconf);\n    PrlHandle_Free(result);\n\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkApplyConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "4014-4036",
    "snippet": "int\nprlsdkApplyConfig(vzDriverPtr driver,\n                  virDomainObjPtr dom,\n                  virDomainDefPtr new)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    int ret;\n\n    job = PrlVm_BeginEdit(privdom->sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    ret = prlsdkDoApplyConfig(driver, dom, privdom->sdkdom, new);\n\n    if (ret == 0) {\n        job = PrlVm_CommitEx(privdom->sdkdom, PVCF_DETACH_HDD_BUNDLE);\n        if (PRL_FAILED(waitDomainJob(job, dom)))\n            ret = -1;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 4031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 4031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_CommitEx",
          "args": [
            "privdom->sdkdom",
            "PVCF_DETACH_HDD_BUNDLE"
          ],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkDoApplyConfig",
          "args": [
            "driver",
            "dom",
            "privdom->sdkdom",
            "new"
          ],
          "line": 4027
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkDoApplyConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3894-4012",
          "snippet": "static int\nprlsdkDoApplyConfig(vzDriverPtr driver,\n                    virDomainObjPtr dom,\n                    PRL_HANDLE sdkdom,\n                    virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    size_t i;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n    char *mask = NULL;\n\n    if (prlsdkCheckUnsupportedParams(sdkdom, def) < 0)\n        return -1;\n\n    if (def->description) {\n        pret = PrlVmCfg_SetDescription(sdkdom, def->description);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    if (def->name) {\n        pret = PrlVmCfg_SetName(sdkdom, def->name);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    if (def->uuid) {\n        prlsdkUUIDFormat(def->uuid, uuidstr);\n\n        pret = PrlVmCfg_SetUuid(sdkdom, uuidstr);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    pret = PrlVmCfg_SetRamSize(sdkdom, virDomainDefGetMemoryTotal(def) >> 10);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_SetCpuCount(sdkdom, virDomainDefGetVcpus(def));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (!(mask = virBitmapFormat(def->cpumask)))\n        goto error;\n\n    pret = PrlVmCfg_SetCpuMask(sdkdom, mask);\n    prlsdkCheckRetGoto(pret, error);\n    VIR_FREE(mask);\n\n    switch ((int)def->os.arch) {\n    case VIR_ARCH_X86_64:\n        pret = PrlVmCfg_SetCpuMode(sdkdom, PCM_CPU_MODE_64);\n        break;\n    case VIR_ARCH_I686:\n        pret = PrlVmCfg_SetCpuMode(sdkdom, PCM_CPU_MODE_32);\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU mode: %s\"),\n                       virArchToString(def->os.arch));\n        goto error;\n    }\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkClearDevices(sdkdom) < 0)\n        goto error;\n\n    if (prlsdkRemoveBootDevices(sdkdom) < 0)\n        goto error;\n\n    for (i = 0; i < def->nnets; i++) {\n        if (prlsdkConfigureNet(driver, dom, sdkdom, def->nets[i],\n                               IS_CT(def), true) < 0)\n            goto error;\n    }\n\n    if (def->ngraphics > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver supports only VNC graphics\"));\n        goto error;\n    }\n\n    if (prlsdkApplyGraphicsParams(sdkdom,\n                                  def->ngraphics == 1 ? def->graphics[0] : NULL) < 0)\n        goto error;\n\n    if (prlsdkApplyVideoParams(sdkdom, def) < 0)\n        goto error;\n\n    for (i = 0; i < def->nserials; i++) {\n        if (prlsdkAddSerial(sdkdom, def->serials[i]) < 0)\n            goto error;\n    }\n\n    /* It is important that we add filesystems first and then disks as we rely\n     * on this information in prlsdkSetBootOrderCt */\n    for (i = 0; i < def->nfss; i++) {\n        if (prlsdkAddFS(sdkdom, def->fss[i]) < 0)\n            goto error;\n    }\n\n    /* filesystems first, disks go after them as we rely on this order in\n     * prlsdkSetBootOrderCt */\n    for (i = 0; i < def->ndisks; i++) {\n        if (prlsdkConfigureDisk(driver, sdkdom, def->disks[i],\n                                true) < 0)\n            goto error;\n    }\n\n    if (IS_CT(def)) {\n        if (prlsdkSetBootOrderCt(sdkdom, def) < 0)\n            goto error;\n    } else {\n        if (prlsdkSetBootOrderVm(sdkdom, def) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    VIR_FREE(mask);\n\n    return -1;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);",
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkDoApplyConfig(vzDriverPtr driver,\n                    virDomainObjPtr dom,\n                    PRL_HANDLE sdkdom,\n                    virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    size_t i;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n    char *mask = NULL;\n\n    if (prlsdkCheckUnsupportedParams(sdkdom, def) < 0)\n        return -1;\n\n    if (def->description) {\n        pret = PrlVmCfg_SetDescription(sdkdom, def->description);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    if (def->name) {\n        pret = PrlVmCfg_SetName(sdkdom, def->name);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    if (def->uuid) {\n        prlsdkUUIDFormat(def->uuid, uuidstr);\n\n        pret = PrlVmCfg_SetUuid(sdkdom, uuidstr);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    pret = PrlVmCfg_SetRamSize(sdkdom, virDomainDefGetMemoryTotal(def) >> 10);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_SetCpuCount(sdkdom, virDomainDefGetVcpus(def));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (!(mask = virBitmapFormat(def->cpumask)))\n        goto error;\n\n    pret = PrlVmCfg_SetCpuMask(sdkdom, mask);\n    prlsdkCheckRetGoto(pret, error);\n    VIR_FREE(mask);\n\n    switch ((int)def->os.arch) {\n    case VIR_ARCH_X86_64:\n        pret = PrlVmCfg_SetCpuMode(sdkdom, PCM_CPU_MODE_64);\n        break;\n    case VIR_ARCH_I686:\n        pret = PrlVmCfg_SetCpuMode(sdkdom, PCM_CPU_MODE_32);\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU mode: %s\"),\n                       virArchToString(def->os.arch));\n        goto error;\n    }\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkClearDevices(sdkdom) < 0)\n        goto error;\n\n    if (prlsdkRemoveBootDevices(sdkdom) < 0)\n        goto error;\n\n    for (i = 0; i < def->nnets; i++) {\n        if (prlsdkConfigureNet(driver, dom, sdkdom, def->nets[i],\n                               IS_CT(def), true) < 0)\n            goto error;\n    }\n\n    if (def->ngraphics > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver supports only VNC graphics\"));\n        goto error;\n    }\n\n    if (prlsdkApplyGraphicsParams(sdkdom,\n                                  def->ngraphics == 1 ? def->graphics[0] : NULL) < 0)\n        goto error;\n\n    if (prlsdkApplyVideoParams(sdkdom, def) < 0)\n        goto error;\n\n    for (i = 0; i < def->nserials; i++) {\n        if (prlsdkAddSerial(sdkdom, def->serials[i]) < 0)\n            goto error;\n    }\n\n    /* It is important that we add filesystems first and then disks as we rely\n     * on this information in prlsdkSetBootOrderCt */\n    for (i = 0; i < def->nfss; i++) {\n        if (prlsdkAddFS(sdkdom, def->fss[i]) < 0)\n            goto error;\n    }\n\n    /* filesystems first, disks go after them as we rely on this order in\n     * prlsdkSetBootOrderCt */\n    for (i = 0; i < def->ndisks; i++) {\n        if (prlsdkConfigureDisk(driver, sdkdom, def->disks[i],\n                                true) < 0)\n            goto error;\n    }\n\n    if (IS_CT(def)) {\n        if (prlsdkSetBootOrderCt(sdkdom, def) < 0)\n            goto error;\n    } else {\n        if (prlsdkSetBootOrderVm(sdkdom, def) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    VIR_FREE(mask);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 4024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 4024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_BeginEdit",
          "args": [
            "privdom->sdkdom"
          ],
          "line": 4023
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nprlsdkApplyConfig(vzDriverPtr driver,\n                  virDomainObjPtr dom,\n                  virDomainDefPtr new)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    int ret;\n\n    job = PrlVm_BeginEdit(privdom->sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    ret = prlsdkDoApplyConfig(driver, dom, privdom->sdkdom, new);\n\n    if (ret == 0) {\n        job = PrlVm_CommitEx(privdom->sdkdom, PVCF_DETACH_HDD_BUNDLE);\n        if (PRL_FAILED(waitDomainJob(job, dom)))\n            ret = -1;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkDoApplyConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "3894-4012",
    "snippet": "static int\nprlsdkDoApplyConfig(vzDriverPtr driver,\n                    virDomainObjPtr dom,\n                    PRL_HANDLE sdkdom,\n                    virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    size_t i;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n    char *mask = NULL;\n\n    if (prlsdkCheckUnsupportedParams(sdkdom, def) < 0)\n        return -1;\n\n    if (def->description) {\n        pret = PrlVmCfg_SetDescription(sdkdom, def->description);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    if (def->name) {\n        pret = PrlVmCfg_SetName(sdkdom, def->name);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    if (def->uuid) {\n        prlsdkUUIDFormat(def->uuid, uuidstr);\n\n        pret = PrlVmCfg_SetUuid(sdkdom, uuidstr);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    pret = PrlVmCfg_SetRamSize(sdkdom, virDomainDefGetMemoryTotal(def) >> 10);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_SetCpuCount(sdkdom, virDomainDefGetVcpus(def));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (!(mask = virBitmapFormat(def->cpumask)))\n        goto error;\n\n    pret = PrlVmCfg_SetCpuMask(sdkdom, mask);\n    prlsdkCheckRetGoto(pret, error);\n    VIR_FREE(mask);\n\n    switch ((int)def->os.arch) {\n    case VIR_ARCH_X86_64:\n        pret = PrlVmCfg_SetCpuMode(sdkdom, PCM_CPU_MODE_64);\n        break;\n    case VIR_ARCH_I686:\n        pret = PrlVmCfg_SetCpuMode(sdkdom, PCM_CPU_MODE_32);\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU mode: %s\"),\n                       virArchToString(def->os.arch));\n        goto error;\n    }\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkClearDevices(sdkdom) < 0)\n        goto error;\n\n    if (prlsdkRemoveBootDevices(sdkdom) < 0)\n        goto error;\n\n    for (i = 0; i < def->nnets; i++) {\n        if (prlsdkConfigureNet(driver, dom, sdkdom, def->nets[i],\n                               IS_CT(def), true) < 0)\n            goto error;\n    }\n\n    if (def->ngraphics > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver supports only VNC graphics\"));\n        goto error;\n    }\n\n    if (prlsdkApplyGraphicsParams(sdkdom,\n                                  def->ngraphics == 1 ? def->graphics[0] : NULL) < 0)\n        goto error;\n\n    if (prlsdkApplyVideoParams(sdkdom, def) < 0)\n        goto error;\n\n    for (i = 0; i < def->nserials; i++) {\n        if (prlsdkAddSerial(sdkdom, def->serials[i]) < 0)\n            goto error;\n    }\n\n    /* It is important that we add filesystems first and then disks as we rely\n     * on this information in prlsdkSetBootOrderCt */\n    for (i = 0; i < def->nfss; i++) {\n        if (prlsdkAddFS(sdkdom, def->fss[i]) < 0)\n            goto error;\n    }\n\n    /* filesystems first, disks go after them as we rely on this order in\n     * prlsdkSetBootOrderCt */\n    for (i = 0; i < def->ndisks; i++) {\n        if (prlsdkConfigureDisk(driver, sdkdom, def->disks[i],\n                                true) < 0)\n            goto error;\n    }\n\n    if (IS_CT(def)) {\n        if (prlsdkSetBootOrderCt(sdkdom, def) < 0)\n            goto error;\n    } else {\n        if (prlsdkSetBootOrderVm(sdkdom, def) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    VIR_FREE(mask);\n\n    return -1;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);",
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mask"
          ],
          "line": 4009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkSetBootOrderVm",
          "args": [
            "sdkdom",
            "def"
          ],
          "line": 4002
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkSetBootOrderVm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3834-3873",
          "snippet": "static int\nprlsdkSetBootOrderVm(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    size_t i;\n    int idx[VIR_DOMAIN_BOOT_LAST] = { 0 };\n    int bootIndex = 0;\n    PRL_RESULT pret;\n    PRL_UINT32 num;\n    int sdkType;\n    virDomainBootOrder virType;\n\n    for (i = 0; i < def->os.nBootDevs; ++i) {\n        virType = def->os.bootDevs[i];\n\n        switch ((int)virType) {\n        case VIR_DOMAIN_BOOT_CDROM:\n            sdkType = PDE_OPTICAL_DISK;\n            break;\n        case VIR_DOMAIN_BOOT_DISK:\n            sdkType = PDE_HARD_DISK;\n            break;\n        case VIR_DOMAIN_BOOT_NET:\n            sdkType = PDE_GENERIC_NETWORK_ADAPTER;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported boot device type: '%s'\"),\n                           virDomainBootTypeToString(virType));\n            return -1;\n        }\n\n        pret = PrlVmCfg_GetDevsCountByType(sdkdom, sdkType, &num);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = prlsdkAddDeviceToBootList(sdkdom, idx[virType]++, sdkType, bootIndex++);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkSetBootOrderVm(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    size_t i;\n    int idx[VIR_DOMAIN_BOOT_LAST] = { 0 };\n    int bootIndex = 0;\n    PRL_RESULT pret;\n    PRL_UINT32 num;\n    int sdkType;\n    virDomainBootOrder virType;\n\n    for (i = 0; i < def->os.nBootDevs; ++i) {\n        virType = def->os.bootDevs[i];\n\n        switch ((int)virType) {\n        case VIR_DOMAIN_BOOT_CDROM:\n            sdkType = PDE_OPTICAL_DISK;\n            break;\n        case VIR_DOMAIN_BOOT_DISK:\n            sdkType = PDE_HARD_DISK;\n            break;\n        case VIR_DOMAIN_BOOT_NET:\n            sdkType = PDE_GENERIC_NETWORK_ADAPTER;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported boot device type: '%s'\"),\n                           virDomainBootTypeToString(virType));\n            return -1;\n        }\n\n        pret = PrlVmCfg_GetDevsCountByType(sdkdom, sdkType, &num);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = prlsdkAddDeviceToBootList(sdkdom, idx[virType]++, sdkType, bootIndex++);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkSetBootOrderCt",
          "args": [
            "sdkdom",
            "def"
          ],
          "line": 3999
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkSetBootOrderCt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3800-3832",
          "snippet": "static int\nprlsdkSetBootOrderCt(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    size_t i;\n    PRL_HANDLE hdd = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    bool rootfs = false;\n    int ret = -1;\n\n    for (i = 0; i < def->nfss; i++) {\n\n        pret = prlsdkAddDeviceToBootList(sdkdom, i, PDE_HARD_DISK, i + 1);\n        prlsdkCheckRetExit(pret, -1);\n\n        if (STREQ(def->fss[i]->dst, \"/\"))\n            rootfs = true;\n    }\n\n    if (!rootfs) {\n        /* if we have root mounted we don't need to explicitly set boot order */\n        pret = PrlVmCfg_GetHardDisk(sdkdom, def->nfss, &hdd);\n        prlsdkCheckRetExit(pret, -1);\n\n        PrlVmDevHd_SetMountPoint(hdd, \"/\");\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(hdd);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkSetBootOrderCt(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    size_t i;\n    PRL_HANDLE hdd = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    bool rootfs = false;\n    int ret = -1;\n\n    for (i = 0; i < def->nfss; i++) {\n\n        pret = prlsdkAddDeviceToBootList(sdkdom, i, PDE_HARD_DISK, i + 1);\n        prlsdkCheckRetExit(pret, -1);\n\n        if (STREQ(def->fss[i]->dst, \"/\"))\n            rootfs = true;\n    }\n\n    if (!rootfs) {\n        /* if we have root mounted we don't need to explicitly set boot order */\n        pret = PrlVmCfg_GetHardDisk(sdkdom, def->nfss, &hdd);\n        prlsdkCheckRetExit(pret, -1);\n\n        PrlVmDevHd_SetMountPoint(hdd, \"/\");\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(hdd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "def"
          ],
          "line": 3998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkConfigureDisk",
          "args": [
            "driver",
            "sdkdom",
            "def->disks[i]",
            "true"
          ],
          "line": 3993
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConfigureDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3428-3522",
          "snippet": "static int prlsdkConfigureDisk(vzDriverPtr driver,\n                               PRL_HANDLE sdkdom,\n                               virDomainDiskDefPtr disk,\n                               bool create)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int ret = -1;\n    PRL_VM_DEV_EMULATION_TYPE emutype;\n    PRL_MASS_STORAGE_INTERFACE_TYPE sdkbus;\n    int idx;\n    virDomainDeviceDriveAddressPtr drive;\n    PRL_DEVICE_TYPE devType;\n    PRL_CLUSTERED_DEVICE_SUBTYPE scsiModel;\n    const char *path = disk->src->path ? : \"\";\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK)\n        devType = PDE_HARD_DISK;\n    else\n        devType = PDE_OPTICAL_DISK;\n\n    if (create) {\n        pret = PrlVmCfg_CreateVmDev(sdkdom, devType, &sdkdisk);\n        prlsdkCheckRetGoto(pret, cleanup);\n    } else {\n        sdkdisk = prlsdkGetDisk(sdkdom, disk);\n        if (sdkdisk == PRL_INVALID_HANDLE)\n            return -1;\n    }\n\n    pret = PrlVmDev_SetEnabled(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (disk->src->type == VIR_STORAGE_TYPE_FILE)\n        emutype = PDT_USE_IMAGE_FILE;\n    else\n        emutype = PDT_USE_REAL_DEVICE;\n\n    pret = PrlVmDev_SetEmulatedType(sdkdisk, emutype);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetSysName(sdkdisk, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetFriendlyName(sdkdisk, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    drive = &disk->info.addr.drive;\n\n    switch (disk->bus) {\n    case VIR_DOMAIN_DISK_BUS_IDE:\n        sdkbus = PMS_IDE_DEVICE;\n        idx = 2 * drive->bus + drive->unit;\n        break;\n    case VIR_DOMAIN_DISK_BUS_SCSI:\n        sdkbus = PMS_SCSI_DEVICE;\n        idx = drive->unit;\n        break;\n    case VIR_DOMAIN_DISK_BUS_SATA:\n        sdkbus = PMS_SATA_DEVICE;\n        idx = drive->unit;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified disk bus is not \"\n                         \"supported by vz driver.\"));\n        goto cleanup;\n    }\n\n    if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (vzGetDefaultSCSIModel(driver, &scsiModel) < 0)\n            goto cleanup;\n        pret = PrlVmDev_SetSubType(sdkdisk, scsiModel);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDev_SetIfaceType(sdkdisk, sdkbus);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetStackIndex(sdkdisk, idx);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (devType == PDE_HARD_DISK) {\n        pret = PrlVmDevHd_SetSerialNumber(sdkdisk, disk->serial);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    return 0;\n cleanup:\n    PrlHandle_Free(sdkdisk);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int prlsdkConfigureDisk(vzDriverPtr driver,\n                               PRL_HANDLE sdkdom,\n                               virDomainDiskDefPtr disk,\n                               bool create)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int ret = -1;\n    PRL_VM_DEV_EMULATION_TYPE emutype;\n    PRL_MASS_STORAGE_INTERFACE_TYPE sdkbus;\n    int idx;\n    virDomainDeviceDriveAddressPtr drive;\n    PRL_DEVICE_TYPE devType;\n    PRL_CLUSTERED_DEVICE_SUBTYPE scsiModel;\n    const char *path = disk->src->path ? : \"\";\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK)\n        devType = PDE_HARD_DISK;\n    else\n        devType = PDE_OPTICAL_DISK;\n\n    if (create) {\n        pret = PrlVmCfg_CreateVmDev(sdkdom, devType, &sdkdisk);\n        prlsdkCheckRetGoto(pret, cleanup);\n    } else {\n        sdkdisk = prlsdkGetDisk(sdkdom, disk);\n        if (sdkdisk == PRL_INVALID_HANDLE)\n            return -1;\n    }\n\n    pret = PrlVmDev_SetEnabled(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (disk->src->type == VIR_STORAGE_TYPE_FILE)\n        emutype = PDT_USE_IMAGE_FILE;\n    else\n        emutype = PDT_USE_REAL_DEVICE;\n\n    pret = PrlVmDev_SetEmulatedType(sdkdisk, emutype);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetSysName(sdkdisk, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetFriendlyName(sdkdisk, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    drive = &disk->info.addr.drive;\n\n    switch (disk->bus) {\n    case VIR_DOMAIN_DISK_BUS_IDE:\n        sdkbus = PMS_IDE_DEVICE;\n        idx = 2 * drive->bus + drive->unit;\n        break;\n    case VIR_DOMAIN_DISK_BUS_SCSI:\n        sdkbus = PMS_SCSI_DEVICE;\n        idx = drive->unit;\n        break;\n    case VIR_DOMAIN_DISK_BUS_SATA:\n        sdkbus = PMS_SATA_DEVICE;\n        idx = drive->unit;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified disk bus is not \"\n                         \"supported by vz driver.\"));\n        goto cleanup;\n    }\n\n    if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (vzGetDefaultSCSIModel(driver, &scsiModel) < 0)\n            goto cleanup;\n        pret = PrlVmDev_SetSubType(sdkdisk, scsiModel);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDev_SetIfaceType(sdkdisk, sdkbus);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetStackIndex(sdkdisk, idx);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (devType == PDE_HARD_DISK) {\n        pret = PrlVmDevHd_SetSerialNumber(sdkdisk, disk->serial);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    return 0;\n cleanup:\n    PrlHandle_Free(sdkdisk);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkAddFS",
          "args": [
            "sdkdom",
            "def->fss[i]"
          ],
          "line": 3986
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkAddFS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3747-3798",
          "snippet": "static int\nprlsdkAddFS(PRL_HANDLE sdkdom, virDomainFSDefPtr fs)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int ret = -1;\n    char *storage = NULL;\n\n    if (fs->type == VIR_DOMAIN_FS_TYPE_TEMPLATE)\n        return 0;\n\n    if (prlsdkCheckFSUnsupportedParams(fs) < 0)\n        return -1;\n\n    pret = PrlVmCfg_CreateVmDev(sdkdom, PDE_HARD_DISK, &sdkdisk);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (fs->type == VIR_DOMAIN_FS_TYPE_VOLUME) {\n        storage = g_strdup_printf(\"libvirt://localhost/%s/%s\",\n                                  fs->src->srcpool->pool, fs->src->srcpool->volume);\n        pret = PrlVmDevHd_SetStorageURL(sdkdisk, storage);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDev_SetEnabled(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetEmulatedType(sdkdisk, PDT_USE_IMAGE_FILE);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetSysName(sdkdisk, fs->src->path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetImagePath(sdkdisk, fs->src->path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetFriendlyName(sdkdisk, fs->src->path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevHd_SetMountPoint(sdkdisk, fs->dst);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(storage);\n    PrlHandle_Free(sdkdisk);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkAddFS(PRL_HANDLE sdkdom, virDomainFSDefPtr fs)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int ret = -1;\n    char *storage = NULL;\n\n    if (fs->type == VIR_DOMAIN_FS_TYPE_TEMPLATE)\n        return 0;\n\n    if (prlsdkCheckFSUnsupportedParams(fs) < 0)\n        return -1;\n\n    pret = PrlVmCfg_CreateVmDev(sdkdom, PDE_HARD_DISK, &sdkdisk);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (fs->type == VIR_DOMAIN_FS_TYPE_VOLUME) {\n        storage = g_strdup_printf(\"libvirt://localhost/%s/%s\",\n                                  fs->src->srcpool->pool, fs->src->srcpool->volume);\n        pret = PrlVmDevHd_SetStorageURL(sdkdisk, storage);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDev_SetEnabled(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetEmulatedType(sdkdisk, PDT_USE_IMAGE_FILE);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetSysName(sdkdisk, fs->src->path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetImagePath(sdkdisk, fs->src->path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetFriendlyName(sdkdisk, fs->src->path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevHd_SetMountPoint(sdkdisk, fs->dst);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(storage);\n    PrlHandle_Free(sdkdisk);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkAddSerial",
          "args": [
            "sdkdom",
            "def->serials[i]"
          ],
          "line": 3979
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkAddSerial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3076-3151",
          "snippet": "static int prlsdkAddSerial(PRL_HANDLE sdkdom, virDomainChrDefPtr chr)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdkchr = PRL_INVALID_HANDLE;\n    PRL_VM_DEV_EMULATION_TYPE emutype;\n    PRL_SERIAL_PORT_SOCKET_OPERATION_MODE socket_mode = PSP_SERIAL_SOCKET_SERVER;\n    char *path;\n    char *url = NULL;\n    int ret = -1;\n\n    if (prlsdkCheckSerialUnsupportedParams(chr) < 0)\n        return -1;\n\n    pret = PrlVmCfg_CreateVmDev(sdkdom, PDE_SERIAL_PORT, &sdkchr);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    switch (chr->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n        emutype = PDT_USE_REAL_DEVICE;\n        path = chr->source->data.file.path;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        emutype = PDT_USE_OUTPUT_FILE;\n        path = chr->source->data.file.path;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        emutype = PDT_USE_SERIAL_PORT_SOCKET_MODE;\n        path = chr->source->data.nix.path;\n        if (!chr->source->data.nix.listen)\n            socket_mode = PSP_SERIAL_SOCKET_CLIENT;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n        emutype = PDT_USE_TCP;\n        url = g_strdup_printf(\"%s:%s\", chr->source->data.tcp.host,\n                              chr->source->data.tcp.service);\n        if (!chr->source->data.tcp.listen)\n            socket_mode = PSP_SERIAL_SOCKET_CLIENT;\n        path = url;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n        emutype = PDT_USE_UDP;\n        url = g_strdup_printf(\"%s:%s\", chr->source->data.udp.bindHost,\n                              chr->source->data.udp.bindService);\n        path = url;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver doesn't support \"\n                         \"specified serial source type.\"));\n        goto cleanup;\n    }\n\n    pret = PrlVmDev_SetEmulatedType(sdkchr, emutype);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetSysName(sdkchr, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetFriendlyName(sdkchr, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevSerial_SetSocketMode(sdkchr, socket_mode);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetEnabled(sdkchr, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetIndex(sdkchr, chr->target.port);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n cleanup:\n    PrlHandle_Free(sdkchr);\n    VIR_FREE(url);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int prlsdkAddSerial(PRL_HANDLE sdkdom, virDomainChrDefPtr chr)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdkchr = PRL_INVALID_HANDLE;\n    PRL_VM_DEV_EMULATION_TYPE emutype;\n    PRL_SERIAL_PORT_SOCKET_OPERATION_MODE socket_mode = PSP_SERIAL_SOCKET_SERVER;\n    char *path;\n    char *url = NULL;\n    int ret = -1;\n\n    if (prlsdkCheckSerialUnsupportedParams(chr) < 0)\n        return -1;\n\n    pret = PrlVmCfg_CreateVmDev(sdkdom, PDE_SERIAL_PORT, &sdkchr);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    switch (chr->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n        emutype = PDT_USE_REAL_DEVICE;\n        path = chr->source->data.file.path;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        emutype = PDT_USE_OUTPUT_FILE;\n        path = chr->source->data.file.path;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        emutype = PDT_USE_SERIAL_PORT_SOCKET_MODE;\n        path = chr->source->data.nix.path;\n        if (!chr->source->data.nix.listen)\n            socket_mode = PSP_SERIAL_SOCKET_CLIENT;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n        emutype = PDT_USE_TCP;\n        url = g_strdup_printf(\"%s:%s\", chr->source->data.tcp.host,\n                              chr->source->data.tcp.service);\n        if (!chr->source->data.tcp.listen)\n            socket_mode = PSP_SERIAL_SOCKET_CLIENT;\n        path = url;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n        emutype = PDT_USE_UDP;\n        url = g_strdup_printf(\"%s:%s\", chr->source->data.udp.bindHost,\n                              chr->source->data.udp.bindService);\n        path = url;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver doesn't support \"\n                         \"specified serial source type.\"));\n        goto cleanup;\n    }\n\n    pret = PrlVmDev_SetEmulatedType(sdkchr, emutype);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetSysName(sdkchr, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetFriendlyName(sdkchr, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevSerial_SetSocketMode(sdkchr, socket_mode);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetEnabled(sdkchr, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetIndex(sdkchr, chr->target.port);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n cleanup:\n    PrlHandle_Free(sdkchr);\n    VIR_FREE(url);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkApplyVideoParams",
          "args": [
            "sdkdom",
            "def"
          ],
          "line": 3975
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkApplyVideoParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3055-3074",
          "snippet": "static int prlsdkApplyVideoParams(PRL_HANDLE sdkdom G_GNUC_UNUSED, virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n\n    if (def->nvideos == 0)\n        return 0;\n\n    if (IS_CT(def)) {\n        /* ignore video parameters */\n        return 0;\n    }\n\n    if (prlsdkCheckVideoUnsupportedParams(def))\n        return -1;\n\n    pret = PrlVmCfg_SetVideoRamSize(sdkdom, def->videos[0]->vram >> 10);\n    prlsdkCheckRetExit(pret, -1);\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int prlsdkApplyVideoParams(PRL_HANDLE sdkdom G_GNUC_UNUSED, virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n\n    if (def->nvideos == 0)\n        return 0;\n\n    if (IS_CT(def)) {\n        /* ignore video parameters */\n        return 0;\n    }\n\n    if (prlsdkCheckVideoUnsupportedParams(def))\n        return -1;\n\n    pret = PrlVmCfg_SetVideoRamSize(sdkdom, def->videos[0]->vram >> 10);\n    prlsdkCheckRetExit(pret, -1);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkApplyGraphicsParams",
          "args": [
            "sdkdom",
            "def->ngraphics == 1 ? def->graphics[0] : NULL"
          ],
          "line": 3971
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkApplyGraphicsParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3021-3053",
          "snippet": "static int prlsdkApplyGraphicsParams(PRL_HANDLE sdkdom,\n                                     virDomainGraphicsDefPtr gr)\n{\n    virDomainGraphicsListenDefPtr glisten;\n    PRL_RESULT pret;\n\n    if (!gr) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_DISABLED);\n        prlsdkCheckRetExit(pret, -1);\n        return 0;\n    }\n\n    pret = PrlVmCfg_SetVNCPassword(sdkdom, gr->data.vnc.auth.passwd ? : \"\");\n    prlsdkCheckRetExit(pret, -1);\n\n    if (gr->data.vnc.autoport) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_AUTO);\n        prlsdkCheckRetExit(pret, -1);\n    } else {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_MANUAL);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlVmCfg_SetVNCPort(sdkdom, gr->data.vnc.port);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    glisten = virDomainGraphicsGetListen(gr, 0);\n    pret = PrlVmCfg_SetVNCHostName(sdkdom, glisten && glisten->address ?\n                                           glisten->address : VIR_LOOPBACK_IPV4_ADDR);\n    prlsdkCheckRetExit(pret, -1);\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int prlsdkApplyGraphicsParams(PRL_HANDLE sdkdom,\n                                     virDomainGraphicsDefPtr gr)\n{\n    virDomainGraphicsListenDefPtr glisten;\n    PRL_RESULT pret;\n\n    if (!gr) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_DISABLED);\n        prlsdkCheckRetExit(pret, -1);\n        return 0;\n    }\n\n    pret = PrlVmCfg_SetVNCPassword(sdkdom, gr->data.vnc.auth.passwd ? : \"\");\n    prlsdkCheckRetExit(pret, -1);\n\n    if (gr->data.vnc.autoport) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_AUTO);\n        prlsdkCheckRetExit(pret, -1);\n    } else {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_MANUAL);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlVmCfg_SetVNCPort(sdkdom, gr->data.vnc.port);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    glisten = virDomainGraphicsGetListen(gr, 0);\n    pret = PrlVmCfg_SetVNCHostName(sdkdom, glisten && glisten->address ?\n                                           glisten->address : VIR_LOOPBACK_IPV4_ADDR);\n    prlsdkCheckRetExit(pret, -1);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"vz driver supports only VNC graphics\")"
          ],
          "line": 3966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"vz driver supports only VNC graphics\""
          ],
          "line": 3967
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkConfigureNet",
          "args": [
            "driver",
            "dom",
            "sdkdom",
            "def->nets[i]",
            "IS_CT(def)",
            "true"
          ],
          "line": 3960
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConfigureNet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3249-3387",
          "snippet": "static int prlsdkConfigureNet(vzDriverPtr driver G_GNUC_UNUSED,\n                              virDomainObjPtr dom G_GNUC_UNUSED,\n                              PRL_HANDLE sdkdom,\n                              virDomainNetDefPtr net,\n                              bool isCt, bool create)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdknet = PRL_INVALID_HANDLE;\n    PRL_HANDLE addrlist = PRL_INVALID_HANDLE;\n    size_t i;\n    int ret = -1;\n    char macstr[PRL_MAC_STRING_BUFNAME];\n    char *addrstr = NULL;\n    bool ipv6present = false;\n    bool ipv4present = false;\n\n    if (prlsdkCheckNetUnsupportedParams(net) < 0)\n        return -1;\n\n    if (create) {\n        pret = PrlVmCfg_CreateVmDev(sdkdom, PDE_GENERIC_NETWORK_ADAPTER, &sdknet);\n        prlsdkCheckRetGoto(pret, cleanup);\n    } else {\n        sdknet = prlsdkFindNetByMAC(sdkdom, &net->mac);\n        if (sdknet == PRL_INVALID_HANDLE)\n            return -1;\n    }\n\n    pret = PrlVmDev_SetEnabled(sdknet, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdknet, net->linkstate !=\n                                 VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN);\n\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (net->ifname) {\n        pret = PrlVmDevNet_SetHostInterfaceName(sdknet, net->ifname);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    prlsdkFormatMac(&net->mac, macstr);\n    pret = PrlVmDevNet_SetMacAddress(sdknet, macstr);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlApi_CreateStringsList(&addrlist);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < net->guestIP.nips; i++) {\n        char *tmpstr;\n\n        if (AF_INET == VIR_SOCKET_ADDR_FAMILY(&net->guestIP.ips[i]->address))\n            ipv4present = true;\n        else if (AF_INET6 == VIR_SOCKET_ADDR_FAMILY(&net->guestIP.ips[i]->address))\n            ipv6present = true;\n        else\n            continue;\n\n        if (!(tmpstr = virSocketAddrFormat(&net->guestIP.ips[i]->address)))\n            goto cleanup;\n\n        addrstr = g_strdup_printf(\"%s/%d\", tmpstr, net->guestIP.ips[i]->prefix);\n\n        VIR_FREE(tmpstr);\n        pret = PrlStrList_AddItem(addrlist, addrstr);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        VIR_FREE(addrstr);\n    }\n\n    if (ipv4present || ipv6present) {\n        pret = PrlVmDevNet_SetNetAddresses(sdknet, addrlist);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDevNet_SetConfigureWithDhcp(sdknet, !ipv4present);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevNet_SetConfigureWithDhcpIPv6(sdknet, !ipv6present);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevNet_SetAutoApply(sdknet, true);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (prlsdkConfigureGateways(sdknet, net))\n        goto cleanup;\n\n    if (isCt) {\n        if (net->model != VIR_DOMAIN_NET_MODEL_UNKNOWN)\n            VIR_WARN(\"Setting network adapter for containers is not \"\n                     \"supported by vz driver.\");\n    } else {\n        if (net->model == VIR_DOMAIN_NET_MODEL_RTL8139) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_RTL);\n        } else if (net->model == VIR_DOMAIN_NET_MODEL_E1000) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_E1000);\n        } else if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_VIRTIO);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Specified network adapter model is not \"\n                             \"supported by vz driver.\"));\n            goto cleanup;\n        }\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n        if (STREQ(net->data.network.name, PARALLELS_DOMAIN_ROUTED_NETWORK_NAME)) {\n            pret = PrlVmDev_SetEmulatedType(sdknet, PNA_ROUTED);\n            prlsdkCheckRetGoto(pret, cleanup);\n        } else {\n            pret = PrlVmDev_SetEmulatedType(sdknet, PNA_BRIDGED_NETWORK);\n            prlsdkCheckRetGoto(pret, cleanup);\n\n            pret = PrlVmDevNet_SetVirtualNetworkId(sdknet, net->data.network.name);\n            prlsdkCheckRetGoto(pret, cleanup);\n        }\n\n    } else if (net->type == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n\n        pret = PrlVmDev_SetEmulatedType(sdknet, PNA_BRIDGE);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlVmDevNet_SetVirtualNetworkId(sdknet, net->data.bridge.brname);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDevNet_SetPktFilterPreventMacSpoof(sdknet,\n                net->trustGuestRxFilters == VIR_TRISTATE_BOOL_YES);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(addrstr);\n    PrlHandle_Free(addrlist);\n    PrlHandle_Free(sdknet);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PRL_MAC_STRING_BUFNAME  13"
          ],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define PRL_MAC_STRING_BUFNAME  13\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);\n\nstatic int prlsdkConfigureNet(vzDriverPtr driver G_GNUC_UNUSED,\n                              virDomainObjPtr dom G_GNUC_UNUSED,\n                              PRL_HANDLE sdkdom,\n                              virDomainNetDefPtr net,\n                              bool isCt, bool create)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdknet = PRL_INVALID_HANDLE;\n    PRL_HANDLE addrlist = PRL_INVALID_HANDLE;\n    size_t i;\n    int ret = -1;\n    char macstr[PRL_MAC_STRING_BUFNAME];\n    char *addrstr = NULL;\n    bool ipv6present = false;\n    bool ipv4present = false;\n\n    if (prlsdkCheckNetUnsupportedParams(net) < 0)\n        return -1;\n\n    if (create) {\n        pret = PrlVmCfg_CreateVmDev(sdkdom, PDE_GENERIC_NETWORK_ADAPTER, &sdknet);\n        prlsdkCheckRetGoto(pret, cleanup);\n    } else {\n        sdknet = prlsdkFindNetByMAC(sdkdom, &net->mac);\n        if (sdknet == PRL_INVALID_HANDLE)\n            return -1;\n    }\n\n    pret = PrlVmDev_SetEnabled(sdknet, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdknet, net->linkstate !=\n                                 VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN);\n\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (net->ifname) {\n        pret = PrlVmDevNet_SetHostInterfaceName(sdknet, net->ifname);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    prlsdkFormatMac(&net->mac, macstr);\n    pret = PrlVmDevNet_SetMacAddress(sdknet, macstr);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlApi_CreateStringsList(&addrlist);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < net->guestIP.nips; i++) {\n        char *tmpstr;\n\n        if (AF_INET == VIR_SOCKET_ADDR_FAMILY(&net->guestIP.ips[i]->address))\n            ipv4present = true;\n        else if (AF_INET6 == VIR_SOCKET_ADDR_FAMILY(&net->guestIP.ips[i]->address))\n            ipv6present = true;\n        else\n            continue;\n\n        if (!(tmpstr = virSocketAddrFormat(&net->guestIP.ips[i]->address)))\n            goto cleanup;\n\n        addrstr = g_strdup_printf(\"%s/%d\", tmpstr, net->guestIP.ips[i]->prefix);\n\n        VIR_FREE(tmpstr);\n        pret = PrlStrList_AddItem(addrlist, addrstr);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        VIR_FREE(addrstr);\n    }\n\n    if (ipv4present || ipv6present) {\n        pret = PrlVmDevNet_SetNetAddresses(sdknet, addrlist);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDevNet_SetConfigureWithDhcp(sdknet, !ipv4present);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevNet_SetConfigureWithDhcpIPv6(sdknet, !ipv6present);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevNet_SetAutoApply(sdknet, true);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (prlsdkConfigureGateways(sdknet, net))\n        goto cleanup;\n\n    if (isCt) {\n        if (net->model != VIR_DOMAIN_NET_MODEL_UNKNOWN)\n            VIR_WARN(\"Setting network adapter for containers is not \"\n                     \"supported by vz driver.\");\n    } else {\n        if (net->model == VIR_DOMAIN_NET_MODEL_RTL8139) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_RTL);\n        } else if (net->model == VIR_DOMAIN_NET_MODEL_E1000) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_E1000);\n        } else if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_VIRTIO);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Specified network adapter model is not \"\n                             \"supported by vz driver.\"));\n            goto cleanup;\n        }\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n        if (STREQ(net->data.network.name, PARALLELS_DOMAIN_ROUTED_NETWORK_NAME)) {\n            pret = PrlVmDev_SetEmulatedType(sdknet, PNA_ROUTED);\n            prlsdkCheckRetGoto(pret, cleanup);\n        } else {\n            pret = PrlVmDev_SetEmulatedType(sdknet, PNA_BRIDGED_NETWORK);\n            prlsdkCheckRetGoto(pret, cleanup);\n\n            pret = PrlVmDevNet_SetVirtualNetworkId(sdknet, net->data.network.name);\n            prlsdkCheckRetGoto(pret, cleanup);\n        }\n\n    } else if (net->type == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n\n        pret = PrlVmDev_SetEmulatedType(sdknet, PNA_BRIDGE);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlVmDevNet_SetVirtualNetworkId(sdknet, net->data.bridge.brname);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDevNet_SetPktFilterPreventMacSpoof(sdknet,\n                net->trustGuestRxFilters == VIR_TRISTATE_BOOL_YES);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(addrstr);\n    PrlHandle_Free(addrlist);\n    PrlHandle_Free(sdknet);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "def"
          ],
          "line": 3961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkRemoveBootDevices",
          "args": [
            "sdkdom"
          ],
          "line": 3956
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkRemoveBootDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2716-2741",
          "snippet": "static int\nprlsdkRemoveBootDevices(PRL_HANDLE sdkdom)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 i, devCount;\n    PRL_HANDLE dev = PRL_INVALID_HANDLE;\n    PRL_DEVICE_TYPE devType;\n\n    pret = PrlVmCfg_GetBootDevCount(sdkdom, &devCount);\n    prlsdkCheckRetExit(pret, -1);\n\n    for (i = 0; i < devCount; i++) {\n\n        /* always get device by index 0, because device list resort after delete */\n        pret = PrlVmCfg_GetBootDev(sdkdom, 0, &dev);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlBootDev_GetType(dev, &devType);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlBootDev_Remove(dev);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkRemoveBootDevices(PRL_HANDLE sdkdom)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 i, devCount;\n    PRL_HANDLE dev = PRL_INVALID_HANDLE;\n    PRL_DEVICE_TYPE devType;\n\n    pret = PrlVmCfg_GetBootDevCount(sdkdom, &devCount);\n    prlsdkCheckRetExit(pret, -1);\n\n    for (i = 0; i < devCount; i++) {\n\n        /* always get device by index 0, because device list resort after delete */\n        pret = PrlVmCfg_GetBootDev(sdkdom, 0, &dev);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlBootDev_GetType(dev, &devType);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlBootDev_Remove(dev);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkClearDevices",
          "args": [
            "sdkdom"
          ],
          "line": 3953
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkClearDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2688-2714",
          "snippet": "static int prlsdkClearDevices(PRL_HANDLE sdkdom)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 n, i;\n    PRL_HANDLE devList;\n    PRL_HANDLE dev;\n    int ret = -1;\n\n    pret = PrlVmCfg_GetAllDevices(sdkdom, &devList);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlHndlList_GetItemsCount(devList, &n);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < n; i++) {\n        pret = PrlHndlList_GetItem(devList, i, &dev);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlVmDev_Remove(dev);\n        PrlHandle_Free(dev);\n    }\n\n    ret = 0;\n cleanup:\n    PrlHandle_Free(devList);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int prlsdkClearDevices(PRL_HANDLE sdkdom)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 n, i;\n    PRL_HANDLE devList;\n    PRL_HANDLE dev;\n    int ret = -1;\n\n    pret = PrlVmCfg_GetAllDevices(sdkdom, &devList);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlHndlList_GetItemsCount(devList, &n);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < n; i++) {\n        pret = PrlHndlList_GetItem(devList, i, &dev);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlVmDev_Remove(dev);\n        PrlHandle_Free(dev);\n    }\n\n    ret = 0;\n cleanup:\n    PrlHandle_Free(devList);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 3951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown CPU mode: %s\")",
            "virArchToString(def->os.arch)"
          ],
          "line": 3946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "def->os.arch"
          ],
          "line": 3948
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetCpuMode",
          "args": [
            "sdkdom",
            "PCM_CPU_MODE_32"
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetCpuMode",
          "args": [
            "sdkdom",
            "PCM_CPU_MODE_64"
          ],
          "line": 3940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mask"
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 3935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetCpuMask",
          "args": [
            "sdkdom",
            "mask"
          ],
          "line": 3934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFormat",
          "args": [
            "def->cpumask"
          ],
          "line": 3931
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "404-442",
          "snippet": "char *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetCpuCount",
          "args": [
            "sdkdom",
            "virDomainDefGetVcpus(def)"
          ],
          "line": 3928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetVcpus",
          "args": [
            "def"
          ],
          "line": 3928
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetVcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1912-1924",
          "snippet": "unsigned int\nvirDomainDefGetVcpus(const virDomainDef *def)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (def->vcpus[i]->online)\n            ret++;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int\nvirDomainDefGetVcpus(const virDomainDef *def)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (def->vcpus[i]->online)\n            ret++;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 3926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetRamSize",
          "args": [
            "sdkdom",
            "virDomainDefGetMemoryTotal(def) >> 10"
          ],
          "line": 3925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetMemoryTotal",
          "args": [
            "def"
          ],
          "line": 3925
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetMemoryTotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10946-10950",
          "snippet": "unsigned long long\nvirDomainDefGetMemoryTotal(const virDomainDef *def)\n{\n    return def->mem.total_memory;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned long long\nvirDomainDefGetMemoryTotal(const virDomainDef *def)\n{\n    return def->mem.total_memory;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 3922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetUuid",
          "args": [
            "sdkdom",
            "uuidstr"
          ],
          "line": 3921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkUUIDFormat",
          "args": [
            "def->uuid",
            "uuidstr"
          ],
          "line": 3919
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "452-460",
          "snippet": "static void\nprlsdkUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    virUUIDFormat(uuid, uuidstr + 1);\n\n    uuidstr[0] = '{';\n    uuidstr[VIR_UUID_STRING_BUFLEN] = '}';\n    uuidstr[VIR_UUID_STRING_BUFLEN + 1] = '\\0';\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic void\nprlsdkUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    virUUIDFormat(uuid, uuidstr + 1);\n\n    uuidstr[0] = '{';\n    uuidstr[VIR_UUID_STRING_BUFLEN] = '}';\n    uuidstr[VIR_UUID_STRING_BUFLEN + 1] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 3915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetName",
          "args": [
            "sdkdom",
            "def->name"
          ],
          "line": 3914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 3910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetDescription",
          "args": [
            "sdkdom",
            "def->description"
          ],
          "line": 3909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckUnsupportedParams",
          "args": [
            "sdkdom",
            "def"
          ],
          "line": 3905
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkCheckUnsupportedParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2466-2686",
          "snippet": "static int\nprlsdkCheckUnsupportedParams(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    size_t i;\n    PRL_VM_TYPE vmType;\n    PRL_RESULT pret;\n    virDomainNumatuneMemMode memMode;\n    int bus = IS_CT(def) ? VIR_DOMAIN_INPUT_BUS_PARALLELS :\n                           VIR_DOMAIN_INPUT_BUS_PS2;\n\n    if (def->title) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"titles are not supported by vz driver\"));\n        return -1;\n    }\n\n    if (def->blkio.ndevices > 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"blkio parameters are not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (virDomainDefGetMemoryTotal(def) != def->mem.cur_balloon) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing balloon parameters is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (virDomainDefGetMemoryTotal(def) % (1 << 10) != 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Memory size should be multiple of 1Mb.\"));\n        return -1;\n    }\n\n    if (def->mem.nhugepages ||\n        virMemoryLimitIsSet(def->mem.hard_limit) ||\n        virMemoryLimitIsSet(def->mem.soft_limit) ||\n        def->mem.min_guarantee ||\n        virMemoryLimitIsSet(def->mem.swap_hard_limit)) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Memory parameter is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"current vcpus must be equal to maxvcpus\"));\n        return -1;\n    }\n\n    if (def->placement_mode) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing cpu placement mode is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (def->cputune.shares ||\n        def->cputune.sharesSpecified ||\n        def->cputune.period ||\n        def->cputune.quota) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"cputune is not supported by vz driver\"));\n        return -1;\n    }\n\n    for (i = 0; i < virDomainDefGetVcpusMax(def); i++) {\n        virDomainVcpuDefPtr vcpu = virDomainDefGetVcpu(def, i);\n\n        if (vcpu->cpumask &&\n            !virBitmapEqual(def->cpumask, vcpu->cpumask)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"vcpupin cpumask differs from default cpumask\"));\n            return -1;\n        }\n    }\n\n\n    /*\n     * Though we don't support NUMA configuration at the moment\n     * virDomainDefPtr always contain non zero NUMA configuration\n     * So, just make sure this configuration does't differ from auto generated.\n     */\n    if ((virDomainNumatuneGetMode(def->numa, -1, &memMode) == 0 &&\n         memMode == VIR_DOMAIN_NUMATUNE_MEM_STRICT) ||\n        virDomainNumatuneHasPerNodeBinding(def->numa)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"numa parameters are not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (def->onReboot != VIR_DOMAIN_LIFECYCLE_ACTION_RESTART ||\n        def->onPoweroff != VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY ||\n        def->onCrash != VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"on_reboot, on_poweroff and on_crash parameters \"\n                         \"are not supported by vz driver\"));\n        return -1;\n    }\n\n    /* we fill only type and arch fields in vzLoadDomain for\n     * hvm type and also init for containers, so we can check that all\n     * other parameters are null and boot devices config is default */\n\n    if (def->os.machine != NULL || def->os.bootmenu != 0 ||\n        def->os.kernel != NULL || def->os.initrd != NULL ||\n        def->os.cmdline != NULL || def->os.root != NULL ||\n        def->os.loader != NULL || def->os.bootloader != NULL ||\n        def->os.bootloaderArgs != NULL || def->os.smbios_mode != 0 ||\n        def->os.bios.useserial != 0) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing OS parameters is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    pret = PrlVmCfg_GetVmType(sdkdom, &vmType);\n    if (PRL_FAILED(pret)) {\n        logPrlError(pret);\n        return -1;\n    }\n\n    if (!(vmType == PVT_VM && !IS_CT(def)) &&\n        !(vmType == PVT_CT && IS_CT(def))) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing OS type is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (!IS_CT(def)) {\n        if (def->os.init != NULL || def->os.initargv != NULL) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported OS parameters\"));\n            return -1;\n        }\n    } else {\n        if (def->os.nBootDevs != 0 ||\n            STRNEQ_NULLABLE(def->os.init, \"/sbin/init\") ||\n            (def->os.initargv != NULL && def->os.initargv[0] != NULL)) {\n\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported OS parameters\"));\n            return -1;\n        }\n    }\n\n    if (def->emulator) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing emulator is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    for (i = 0; i < VIR_DOMAIN_FEATURE_LAST; i++) {\n        if (def->features[i]) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"changing features is not supported \"\n                             \"by vz driver\"));\n            return -1;\n        }\n    }\n\n    if (def->clock.offset != VIR_DOMAIN_CLOCK_OFFSET_UTC ||\n        def->clock.ntimers != 0) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing clock parameters is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (!IS_CT(def) && def->nfss != 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Filesystems in VMs are not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (def->nsounds != 0 || def->nhostdevs != 0 ||\n        def->nredirdevs != 0 || def->nsmartcards != 0 ||\n        def->nparallels || def->nchannels != 0 ||\n        def->nleases != 0 || def->nhubs != 0) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing devices parameters is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    /* check we have only default input devices */\n    if (def->ngraphics > 0) {\n        if (def->ninputs != 2 ||\n            def->inputs[0]->bus != bus ||\n            def->inputs[1]->bus != bus ||\n            !((def->inputs[0]->type == VIR_DOMAIN_INPUT_TYPE_MOUSE &&\n               def->inputs[1]->type == VIR_DOMAIN_INPUT_TYPE_KBD) ||\n              (def->inputs[0]->type == VIR_DOMAIN_INPUT_TYPE_KBD &&\n               def->inputs[1]->type == VIR_DOMAIN_INPUT_TYPE_MOUSE))) {\n\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported input device configuration\"));\n            return -1;\n        }\n    } else if (def->ninputs != 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"input devices without vnc are not supported\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkCheckUnsupportedParams(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    size_t i;\n    PRL_VM_TYPE vmType;\n    PRL_RESULT pret;\n    virDomainNumatuneMemMode memMode;\n    int bus = IS_CT(def) ? VIR_DOMAIN_INPUT_BUS_PARALLELS :\n                           VIR_DOMAIN_INPUT_BUS_PS2;\n\n    if (def->title) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"titles are not supported by vz driver\"));\n        return -1;\n    }\n\n    if (def->blkio.ndevices > 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"blkio parameters are not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (virDomainDefGetMemoryTotal(def) != def->mem.cur_balloon) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing balloon parameters is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (virDomainDefGetMemoryTotal(def) % (1 << 10) != 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Memory size should be multiple of 1Mb.\"));\n        return -1;\n    }\n\n    if (def->mem.nhugepages ||\n        virMemoryLimitIsSet(def->mem.hard_limit) ||\n        virMemoryLimitIsSet(def->mem.soft_limit) ||\n        def->mem.min_guarantee ||\n        virMemoryLimitIsSet(def->mem.swap_hard_limit)) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Memory parameter is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"current vcpus must be equal to maxvcpus\"));\n        return -1;\n    }\n\n    if (def->placement_mode) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing cpu placement mode is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (def->cputune.shares ||\n        def->cputune.sharesSpecified ||\n        def->cputune.period ||\n        def->cputune.quota) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"cputune is not supported by vz driver\"));\n        return -1;\n    }\n\n    for (i = 0; i < virDomainDefGetVcpusMax(def); i++) {\n        virDomainVcpuDefPtr vcpu = virDomainDefGetVcpu(def, i);\n\n        if (vcpu->cpumask &&\n            !virBitmapEqual(def->cpumask, vcpu->cpumask)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"vcpupin cpumask differs from default cpumask\"));\n            return -1;\n        }\n    }\n\n\n    /*\n     * Though we don't support NUMA configuration at the moment\n     * virDomainDefPtr always contain non zero NUMA configuration\n     * So, just make sure this configuration does't differ from auto generated.\n     */\n    if ((virDomainNumatuneGetMode(def->numa, -1, &memMode) == 0 &&\n         memMode == VIR_DOMAIN_NUMATUNE_MEM_STRICT) ||\n        virDomainNumatuneHasPerNodeBinding(def->numa)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"numa parameters are not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (def->onReboot != VIR_DOMAIN_LIFECYCLE_ACTION_RESTART ||\n        def->onPoweroff != VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY ||\n        def->onCrash != VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"on_reboot, on_poweroff and on_crash parameters \"\n                         \"are not supported by vz driver\"));\n        return -1;\n    }\n\n    /* we fill only type and arch fields in vzLoadDomain for\n     * hvm type and also init for containers, so we can check that all\n     * other parameters are null and boot devices config is default */\n\n    if (def->os.machine != NULL || def->os.bootmenu != 0 ||\n        def->os.kernel != NULL || def->os.initrd != NULL ||\n        def->os.cmdline != NULL || def->os.root != NULL ||\n        def->os.loader != NULL || def->os.bootloader != NULL ||\n        def->os.bootloaderArgs != NULL || def->os.smbios_mode != 0 ||\n        def->os.bios.useserial != 0) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing OS parameters is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    pret = PrlVmCfg_GetVmType(sdkdom, &vmType);\n    if (PRL_FAILED(pret)) {\n        logPrlError(pret);\n        return -1;\n    }\n\n    if (!(vmType == PVT_VM && !IS_CT(def)) &&\n        !(vmType == PVT_CT && IS_CT(def))) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing OS type is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (!IS_CT(def)) {\n        if (def->os.init != NULL || def->os.initargv != NULL) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported OS parameters\"));\n            return -1;\n        }\n    } else {\n        if (def->os.nBootDevs != 0 ||\n            STRNEQ_NULLABLE(def->os.init, \"/sbin/init\") ||\n            (def->os.initargv != NULL && def->os.initargv[0] != NULL)) {\n\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported OS parameters\"));\n            return -1;\n        }\n    }\n\n    if (def->emulator) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing emulator is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    for (i = 0; i < VIR_DOMAIN_FEATURE_LAST; i++) {\n        if (def->features[i]) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"changing features is not supported \"\n                             \"by vz driver\"));\n            return -1;\n        }\n    }\n\n    if (def->clock.offset != VIR_DOMAIN_CLOCK_OFFSET_UTC ||\n        def->clock.ntimers != 0) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing clock parameters is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (!IS_CT(def) && def->nfss != 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Filesystems in VMs are not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (def->nsounds != 0 || def->nhostdevs != 0 ||\n        def->nredirdevs != 0 || def->nsmartcards != 0 ||\n        def->nparallels || def->nchannels != 0 ||\n        def->nleases != 0 || def->nhubs != 0) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing devices parameters is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    /* check we have only default input devices */\n    if (def->ngraphics > 0) {\n        if (def->ninputs != 2 ||\n            def->inputs[0]->bus != bus ||\n            def->inputs[1]->bus != bus ||\n            !((def->inputs[0]->type == VIR_DOMAIN_INPUT_TYPE_MOUSE &&\n               def->inputs[1]->type == VIR_DOMAIN_INPUT_TYPE_KBD) ||\n              (def->inputs[0]->type == VIR_DOMAIN_INPUT_TYPE_KBD &&\n               def->inputs[1]->type == VIR_DOMAIN_INPUT_TYPE_MOUSE))) {\n\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported input device configuration\"));\n            return -1;\n        }\n    } else if (def->ninputs != 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"input devices without vnc are not supported\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkDoApplyConfig(vzDriverPtr driver,\n                    virDomainObjPtr dom,\n                    PRL_HANDLE sdkdom,\n                    virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    size_t i;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n    char *mask = NULL;\n\n    if (prlsdkCheckUnsupportedParams(sdkdom, def) < 0)\n        return -1;\n\n    if (def->description) {\n        pret = PrlVmCfg_SetDescription(sdkdom, def->description);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    if (def->name) {\n        pret = PrlVmCfg_SetName(sdkdom, def->name);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    if (def->uuid) {\n        prlsdkUUIDFormat(def->uuid, uuidstr);\n\n        pret = PrlVmCfg_SetUuid(sdkdom, uuidstr);\n        prlsdkCheckRetGoto(pret, error);\n    }\n\n    pret = PrlVmCfg_SetRamSize(sdkdom, virDomainDefGetMemoryTotal(def) >> 10);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_SetCpuCount(sdkdom, virDomainDefGetVcpus(def));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (!(mask = virBitmapFormat(def->cpumask)))\n        goto error;\n\n    pret = PrlVmCfg_SetCpuMask(sdkdom, mask);\n    prlsdkCheckRetGoto(pret, error);\n    VIR_FREE(mask);\n\n    switch ((int)def->os.arch) {\n    case VIR_ARCH_X86_64:\n        pret = PrlVmCfg_SetCpuMode(sdkdom, PCM_CPU_MODE_64);\n        break;\n    case VIR_ARCH_I686:\n        pret = PrlVmCfg_SetCpuMode(sdkdom, PCM_CPU_MODE_32);\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU mode: %s\"),\n                       virArchToString(def->os.arch));\n        goto error;\n    }\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkClearDevices(sdkdom) < 0)\n        goto error;\n\n    if (prlsdkRemoveBootDevices(sdkdom) < 0)\n        goto error;\n\n    for (i = 0; i < def->nnets; i++) {\n        if (prlsdkConfigureNet(driver, dom, sdkdom, def->nets[i],\n                               IS_CT(def), true) < 0)\n            goto error;\n    }\n\n    if (def->ngraphics > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver supports only VNC graphics\"));\n        goto error;\n    }\n\n    if (prlsdkApplyGraphicsParams(sdkdom,\n                                  def->ngraphics == 1 ? def->graphics[0] : NULL) < 0)\n        goto error;\n\n    if (prlsdkApplyVideoParams(sdkdom, def) < 0)\n        goto error;\n\n    for (i = 0; i < def->nserials; i++) {\n        if (prlsdkAddSerial(sdkdom, def->serials[i]) < 0)\n            goto error;\n    }\n\n    /* It is important that we add filesystems first and then disks as we rely\n     * on this information in prlsdkSetBootOrderCt */\n    for (i = 0; i < def->nfss; i++) {\n        if (prlsdkAddFS(sdkdom, def->fss[i]) < 0)\n            goto error;\n    }\n\n    /* filesystems first, disks go after them as we rely on this order in\n     * prlsdkSetBootOrderCt */\n    for (i = 0; i < def->ndisks; i++) {\n        if (prlsdkConfigureDisk(driver, sdkdom, def->disks[i],\n                                true) < 0)\n            goto error;\n    }\n\n    if (IS_CT(def)) {\n        if (prlsdkSetBootOrderCt(sdkdom, def) < 0)\n            goto error;\n    } else {\n        if (prlsdkSetBootOrderVm(sdkdom, def) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    VIR_FREE(mask);\n\n    return -1;\n}"
  },
  {
    "function_name": "prlsdkDomainSetUserPassword",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "3875-3892",
    "snippet": "int\nprlsdkDomainSetUserPassword(virDomainObjPtr dom,\n                            const char *user,\n                            const char *password)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n\n    job = PrlVm_SetUserPasswd(privdom->sdkdom,\n                              user,\n                              password,\n                              0);\n\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 3888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 3888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_SetUserPasswd",
          "args": [
            "privdom->sdkdom",
            "user",
            "password",
            "0"
          ],
          "line": 3883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nprlsdkDomainSetUserPassword(virDomainObjPtr dom,\n                            const char *user,\n                            const char *password)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n\n    job = PrlVm_SetUserPasswd(privdom->sdkdom,\n                              user,\n                              password,\n                              0);\n\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkSetBootOrderVm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "3834-3873",
    "snippet": "static int\nprlsdkSetBootOrderVm(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    size_t i;\n    int idx[VIR_DOMAIN_BOOT_LAST] = { 0 };\n    int bootIndex = 0;\n    PRL_RESULT pret;\n    PRL_UINT32 num;\n    int sdkType;\n    virDomainBootOrder virType;\n\n    for (i = 0; i < def->os.nBootDevs; ++i) {\n        virType = def->os.bootDevs[i];\n\n        switch ((int)virType) {\n        case VIR_DOMAIN_BOOT_CDROM:\n            sdkType = PDE_OPTICAL_DISK;\n            break;\n        case VIR_DOMAIN_BOOT_DISK:\n            sdkType = PDE_HARD_DISK;\n            break;\n        case VIR_DOMAIN_BOOT_NET:\n            sdkType = PDE_GENERIC_NETWORK_ADAPTER;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported boot device type: '%s'\"),\n                           virDomainBootTypeToString(virType));\n            return -1;\n        }\n\n        pret = PrlVmCfg_GetDevsCountByType(sdkdom, sdkType, &num);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = prlsdkAddDeviceToBootList(sdkdom, idx[virType]++, sdkType, bootIndex++);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 3869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkAddDeviceToBootList",
          "args": [
            "sdkdom",
            "idx[virType]++",
            "sdkType",
            "bootIndex++"
          ],
          "line": 3868
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkAddDeviceToBootList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2743-2774",
          "snippet": "static int\nprlsdkAddDeviceToBootList(PRL_HANDLE sdkdom,\n                          PRL_UINT32 devIndex,\n                          PRL_DEVICE_TYPE devType,\n                          PRL_UINT32 bootSequence)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE bootDev = PRL_INVALID_HANDLE;\n\n    pret = PrlVmCfg_CreateBootDev(sdkdom, &bootDev);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetIndex(bootDev, devIndex);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetType(bootDev, devType);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetSequenceIndex(bootDev, bootSequence);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetInUse(bootDev, PRL_TRUE);\n    prlsdkCheckRetGoto(pret, error);\n\n    return 0;\n\n error:\n    if (bootDev != PRL_INVALID_HANDLE)\n        PrlBootDev_Remove(bootDev);\n\n    return -1;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkAddDeviceToBootList(PRL_HANDLE sdkdom,\n                          PRL_UINT32 devIndex,\n                          PRL_DEVICE_TYPE devType,\n                          PRL_UINT32 bootSequence)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE bootDev = PRL_INVALID_HANDLE;\n\n    pret = PrlVmCfg_CreateBootDev(sdkdom, &bootDev);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetIndex(bootDev, devIndex);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetType(bootDev, devType);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetSequenceIndex(bootDev, bootSequence);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetInUse(bootDev, PRL_TRUE);\n    prlsdkCheckRetGoto(pret, error);\n\n    return 0;\n\n error:\n    if (bootDev != PRL_INVALID_HANDLE)\n        PrlBootDev_Remove(bootDev);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 3866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetDevsCountByType",
          "args": [
            "sdkdom",
            "sdkType",
            "&num"
          ],
          "line": 3865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported boot device type: '%s'\")",
            "virDomainBootTypeToString(virType)"
          ],
          "line": 3859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainBootTypeToString",
          "args": [
            "virType"
          ],
          "line": 3861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported boot device type: '%s'\""
          ],
          "line": 3860
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkSetBootOrderVm(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    size_t i;\n    int idx[VIR_DOMAIN_BOOT_LAST] = { 0 };\n    int bootIndex = 0;\n    PRL_RESULT pret;\n    PRL_UINT32 num;\n    int sdkType;\n    virDomainBootOrder virType;\n\n    for (i = 0; i < def->os.nBootDevs; ++i) {\n        virType = def->os.bootDevs[i];\n\n        switch ((int)virType) {\n        case VIR_DOMAIN_BOOT_CDROM:\n            sdkType = PDE_OPTICAL_DISK;\n            break;\n        case VIR_DOMAIN_BOOT_DISK:\n            sdkType = PDE_HARD_DISK;\n            break;\n        case VIR_DOMAIN_BOOT_NET:\n            sdkType = PDE_GENERIC_NETWORK_ADAPTER;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported boot device type: '%s'\"),\n                           virDomainBootTypeToString(virType));\n            return -1;\n        }\n\n        pret = PrlVmCfg_GetDevsCountByType(sdkdom, sdkType, &num);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = prlsdkAddDeviceToBootList(sdkdom, idx[virType]++, sdkType, bootIndex++);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkSetBootOrderCt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "3800-3832",
    "snippet": "static int\nprlsdkSetBootOrderCt(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    size_t i;\n    PRL_HANDLE hdd = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    bool rootfs = false;\n    int ret = -1;\n\n    for (i = 0; i < def->nfss; i++) {\n\n        pret = prlsdkAddDeviceToBootList(sdkdom, i, PDE_HARD_DISK, i + 1);\n        prlsdkCheckRetExit(pret, -1);\n\n        if (STREQ(def->fss[i]->dst, \"/\"))\n            rootfs = true;\n    }\n\n    if (!rootfs) {\n        /* if we have root mounted we don't need to explicitly set boot order */\n        pret = PrlVmCfg_GetHardDisk(sdkdom, def->nfss, &hdd);\n        prlsdkCheckRetExit(pret, -1);\n\n        PrlVmDevHd_SetMountPoint(hdd, \"/\");\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(hdd);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "hdd"
          ],
          "line": 3830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevHd_SetMountPoint",
          "args": [
            "hdd",
            "\"/\""
          ],
          "line": 3823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 3821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetHardDisk",
          "args": [
            "sdkdom",
            "def->nfss",
            "&hdd"
          ],
          "line": 3820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->fss[i]->dst",
            "\"/\""
          ],
          "line": 3814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 3812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkAddDeviceToBootList",
          "args": [
            "sdkdom",
            "i",
            "PDE_HARD_DISK",
            "i + 1"
          ],
          "line": 3811
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkAddDeviceToBootList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2743-2774",
          "snippet": "static int\nprlsdkAddDeviceToBootList(PRL_HANDLE sdkdom,\n                          PRL_UINT32 devIndex,\n                          PRL_DEVICE_TYPE devType,\n                          PRL_UINT32 bootSequence)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE bootDev = PRL_INVALID_HANDLE;\n\n    pret = PrlVmCfg_CreateBootDev(sdkdom, &bootDev);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetIndex(bootDev, devIndex);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetType(bootDev, devType);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetSequenceIndex(bootDev, bootSequence);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetInUse(bootDev, PRL_TRUE);\n    prlsdkCheckRetGoto(pret, error);\n\n    return 0;\n\n error:\n    if (bootDev != PRL_INVALID_HANDLE)\n        PrlBootDev_Remove(bootDev);\n\n    return -1;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkAddDeviceToBootList(PRL_HANDLE sdkdom,\n                          PRL_UINT32 devIndex,\n                          PRL_DEVICE_TYPE devType,\n                          PRL_UINT32 bootSequence)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE bootDev = PRL_INVALID_HANDLE;\n\n    pret = PrlVmCfg_CreateBootDev(sdkdom, &bootDev);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetIndex(bootDev, devIndex);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetType(bootDev, devType);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetSequenceIndex(bootDev, bootSequence);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetInUse(bootDev, PRL_TRUE);\n    prlsdkCheckRetGoto(pret, error);\n\n    return 0;\n\n error:\n    if (bootDev != PRL_INVALID_HANDLE)\n        PrlBootDev_Remove(bootDev);\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkSetBootOrderCt(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    size_t i;\n    PRL_HANDLE hdd = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    bool rootfs = false;\n    int ret = -1;\n\n    for (i = 0; i < def->nfss; i++) {\n\n        pret = prlsdkAddDeviceToBootList(sdkdom, i, PDE_HARD_DISK, i + 1);\n        prlsdkCheckRetExit(pret, -1);\n\n        if (STREQ(def->fss[i]->dst, \"/\"))\n            rootfs = true;\n    }\n\n    if (!rootfs) {\n        /* if we have root mounted we don't need to explicitly set boot order */\n        pret = PrlVmCfg_GetHardDisk(sdkdom, def->nfss, &hdd);\n        prlsdkCheckRetExit(pret, -1);\n\n        PrlVmDevHd_SetMountPoint(hdd, \"/\");\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(hdd);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkAddFS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "3747-3798",
    "snippet": "static int\nprlsdkAddFS(PRL_HANDLE sdkdom, virDomainFSDefPtr fs)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int ret = -1;\n    char *storage = NULL;\n\n    if (fs->type == VIR_DOMAIN_FS_TYPE_TEMPLATE)\n        return 0;\n\n    if (prlsdkCheckFSUnsupportedParams(fs) < 0)\n        return -1;\n\n    pret = PrlVmCfg_CreateVmDev(sdkdom, PDE_HARD_DISK, &sdkdisk);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (fs->type == VIR_DOMAIN_FS_TYPE_VOLUME) {\n        storage = g_strdup_printf(\"libvirt://localhost/%s/%s\",\n                                  fs->src->srcpool->pool, fs->src->srcpool->volume);\n        pret = PrlVmDevHd_SetStorageURL(sdkdisk, storage);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDev_SetEnabled(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetEmulatedType(sdkdisk, PDT_USE_IMAGE_FILE);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetSysName(sdkdisk, fs->src->path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetImagePath(sdkdisk, fs->src->path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetFriendlyName(sdkdisk, fs->src->path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevHd_SetMountPoint(sdkdisk, fs->dst);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(storage);\n    PrlHandle_Free(sdkdisk);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "sdkdisk"
          ],
          "line": 3796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "storage"
          ],
          "line": 3795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevHd_SetMountPoint",
          "args": [
            "sdkdisk",
            "fs->dst"
          ],
          "line": 3789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetFriendlyName",
          "args": [
            "sdkdisk",
            "fs->src->path"
          ],
          "line": 3786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetImagePath",
          "args": [
            "sdkdisk",
            "fs->src->path"
          ],
          "line": 3783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetSysName",
          "args": [
            "sdkdisk",
            "fs->src->path"
          ],
          "line": 3780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetEmulatedType",
          "args": [
            "sdkdisk",
            "PDT_USE_IMAGE_FILE"
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetConnected",
          "args": [
            "sdkdisk",
            "1"
          ],
          "line": 3774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetEnabled",
          "args": [
            "sdkdisk",
            "1"
          ],
          "line": 3771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevHd_SetStorageURL",
          "args": [
            "sdkdisk",
            "storage"
          ],
          "line": 3767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"libvirt://localhost/%s/%s\"",
            "fs->src->srcpool->pool",
            "fs->src->srcpool->volume"
          ],
          "line": 3765
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_CreateVmDev",
          "args": [
            "sdkdom",
            "PDE_HARD_DISK",
            "&sdkdisk"
          ],
          "line": 3761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckFSUnsupportedParams",
          "args": [
            "fs"
          ],
          "line": 3758
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkCheckFSUnsupportedParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2966-3019",
          "snippet": "static int prlsdkCheckFSUnsupportedParams(virDomainFSDefPtr fs)\n{\n    if (fs->type != VIR_DOMAIN_FS_TYPE_FILE &&\n        fs->type != VIR_DOMAIN_FS_TYPE_VOLUME) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only file based or volume based filesystems \"\n                         \"are supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->fsdriver != VIR_DOMAIN_FS_DRIVER_TYPE_PLOOP) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only ploop fs driver is \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->accessmode != VIR_DOMAIN_FS_ACCESSMODE_PASSTHROUGH) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Changing fs access mode is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->wrpolicy != VIR_DOMAIN_FS_WRPOLICY_DEFAULT) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Changing fs write policy is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->format != VIR_STORAGE_FILE_PLOOP) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only ploop disk images are \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->readonly) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting readonly for filesystems is \"\n                         \"not supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->space_hard_limit || fs->space_soft_limit) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting fs quotas is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int prlsdkCheckFSUnsupportedParams(virDomainFSDefPtr fs)\n{\n    if (fs->type != VIR_DOMAIN_FS_TYPE_FILE &&\n        fs->type != VIR_DOMAIN_FS_TYPE_VOLUME) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only file based or volume based filesystems \"\n                         \"are supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->fsdriver != VIR_DOMAIN_FS_DRIVER_TYPE_PLOOP) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only ploop fs driver is \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->accessmode != VIR_DOMAIN_FS_ACCESSMODE_PASSTHROUGH) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Changing fs access mode is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->wrpolicy != VIR_DOMAIN_FS_WRPOLICY_DEFAULT) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Changing fs write policy is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->format != VIR_STORAGE_FILE_PLOOP) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only ploop disk images are \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->readonly) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting readonly for filesystems is \"\n                         \"not supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->space_hard_limit || fs->space_soft_limit) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting fs quotas is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkAddFS(PRL_HANDLE sdkdom, virDomainFSDefPtr fs)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int ret = -1;\n    char *storage = NULL;\n\n    if (fs->type == VIR_DOMAIN_FS_TYPE_TEMPLATE)\n        return 0;\n\n    if (prlsdkCheckFSUnsupportedParams(fs) < 0)\n        return -1;\n\n    pret = PrlVmCfg_CreateVmDev(sdkdom, PDE_HARD_DISK, &sdkdisk);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (fs->type == VIR_DOMAIN_FS_TYPE_VOLUME) {\n        storage = g_strdup_printf(\"libvirt://localhost/%s/%s\",\n                                  fs->src->srcpool->pool, fs->src->srcpool->volume);\n        pret = PrlVmDevHd_SetStorageURL(sdkdisk, storage);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDev_SetEnabled(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetEmulatedType(sdkdisk, PDT_USE_IMAGE_FILE);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetSysName(sdkdisk, fs->src->path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetImagePath(sdkdisk, fs->src->path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetFriendlyName(sdkdisk, fs->src->path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevHd_SetMountPoint(sdkdisk, fs->dst);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(storage);\n    PrlHandle_Free(sdkdisk);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkUpdateDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "3697-3745",
    "snippet": "int\nprlsdkUpdateDevice(vzDriverPtr driver,\n                   virDomainObjPtr dom,\n                   virDomainDeviceDefPtr dev)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n\n    job = PrlVm_BeginEdit(privdom->sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    switch (dev->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        if (prlsdkConfigureDisk(driver, privdom->sdkdom, dev->data.disk,\n                                false) < 0)\n            return -1;\n\n        break;\n    case VIR_DOMAIN_DEVICE_NET:\n        if (prlsdkConfigureNet(driver, dom, privdom->sdkdom, dev->data.net,\n                               IS_CT(dom->def), false) < 0)\n            return -1;\n\n        break;\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n        if (dom->def->ngraphics < 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"cannot find VNC graphics device\"));\n            return -1;\n        }\n\n        if (prlsdkApplyGraphicsParams(privdom->sdkdom, dev->data.graphics) < 0)\n            return -1;\n\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"updating device type '%s' is unsupported\"),\n                       virDomainDeviceTypeToString(dev->type));\n        return -1;\n    }\n\n    job = PrlVm_CommitEx(privdom->sdkdom, PVCF_DETACH_HDD_BUNDLE);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_CommitEx",
          "args": [
            "privdom->sdkdom",
            "PVCF_DETACH_HDD_BUNDLE"
          ],
          "line": 3740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"updating device type '%s' is unsupported\")",
            "virDomainDeviceTypeToString(dev->type)"
          ],
          "line": 3734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDeviceTypeToString",
          "args": [
            "dev->type"
          ],
          "line": 3736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"updating device type '%s' is unsupported\""
          ],
          "line": 3735
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkApplyGraphicsParams",
          "args": [
            "privdom->sdkdom",
            "dev->data.graphics"
          ],
          "line": 3729
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkApplyGraphicsParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3021-3053",
          "snippet": "static int prlsdkApplyGraphicsParams(PRL_HANDLE sdkdom,\n                                     virDomainGraphicsDefPtr gr)\n{\n    virDomainGraphicsListenDefPtr glisten;\n    PRL_RESULT pret;\n\n    if (!gr) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_DISABLED);\n        prlsdkCheckRetExit(pret, -1);\n        return 0;\n    }\n\n    pret = PrlVmCfg_SetVNCPassword(sdkdom, gr->data.vnc.auth.passwd ? : \"\");\n    prlsdkCheckRetExit(pret, -1);\n\n    if (gr->data.vnc.autoport) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_AUTO);\n        prlsdkCheckRetExit(pret, -1);\n    } else {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_MANUAL);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlVmCfg_SetVNCPort(sdkdom, gr->data.vnc.port);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    glisten = virDomainGraphicsGetListen(gr, 0);\n    pret = PrlVmCfg_SetVNCHostName(sdkdom, glisten && glisten->address ?\n                                           glisten->address : VIR_LOOPBACK_IPV4_ADDR);\n    prlsdkCheckRetExit(pret, -1);\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int prlsdkApplyGraphicsParams(PRL_HANDLE sdkdom,\n                                     virDomainGraphicsDefPtr gr)\n{\n    virDomainGraphicsListenDefPtr glisten;\n    PRL_RESULT pret;\n\n    if (!gr) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_DISABLED);\n        prlsdkCheckRetExit(pret, -1);\n        return 0;\n    }\n\n    pret = PrlVmCfg_SetVNCPassword(sdkdom, gr->data.vnc.auth.passwd ? : \"\");\n    prlsdkCheckRetExit(pret, -1);\n\n    if (gr->data.vnc.autoport) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_AUTO);\n        prlsdkCheckRetExit(pret, -1);\n    } else {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_MANUAL);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlVmCfg_SetVNCPort(sdkdom, gr->data.vnc.port);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    glisten = virDomainGraphicsGetListen(gr, 0);\n    pret = PrlVmCfg_SetVNCHostName(sdkdom, glisten && glisten->address ?\n                                           glisten->address : VIR_LOOPBACK_IPV4_ADDR);\n    prlsdkCheckRetExit(pret, -1);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"cannot find VNC graphics device\")"
          ],
          "line": 3724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkConfigureNet",
          "args": [
            "driver",
            "dom",
            "privdom->sdkdom",
            "dev->data.net",
            "IS_CT(dom->def)",
            "false"
          ],
          "line": 3717
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConfigureNet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3249-3387",
          "snippet": "static int prlsdkConfigureNet(vzDriverPtr driver G_GNUC_UNUSED,\n                              virDomainObjPtr dom G_GNUC_UNUSED,\n                              PRL_HANDLE sdkdom,\n                              virDomainNetDefPtr net,\n                              bool isCt, bool create)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdknet = PRL_INVALID_HANDLE;\n    PRL_HANDLE addrlist = PRL_INVALID_HANDLE;\n    size_t i;\n    int ret = -1;\n    char macstr[PRL_MAC_STRING_BUFNAME];\n    char *addrstr = NULL;\n    bool ipv6present = false;\n    bool ipv4present = false;\n\n    if (prlsdkCheckNetUnsupportedParams(net) < 0)\n        return -1;\n\n    if (create) {\n        pret = PrlVmCfg_CreateVmDev(sdkdom, PDE_GENERIC_NETWORK_ADAPTER, &sdknet);\n        prlsdkCheckRetGoto(pret, cleanup);\n    } else {\n        sdknet = prlsdkFindNetByMAC(sdkdom, &net->mac);\n        if (sdknet == PRL_INVALID_HANDLE)\n            return -1;\n    }\n\n    pret = PrlVmDev_SetEnabled(sdknet, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdknet, net->linkstate !=\n                                 VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN);\n\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (net->ifname) {\n        pret = PrlVmDevNet_SetHostInterfaceName(sdknet, net->ifname);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    prlsdkFormatMac(&net->mac, macstr);\n    pret = PrlVmDevNet_SetMacAddress(sdknet, macstr);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlApi_CreateStringsList(&addrlist);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < net->guestIP.nips; i++) {\n        char *tmpstr;\n\n        if (AF_INET == VIR_SOCKET_ADDR_FAMILY(&net->guestIP.ips[i]->address))\n            ipv4present = true;\n        else if (AF_INET6 == VIR_SOCKET_ADDR_FAMILY(&net->guestIP.ips[i]->address))\n            ipv6present = true;\n        else\n            continue;\n\n        if (!(tmpstr = virSocketAddrFormat(&net->guestIP.ips[i]->address)))\n            goto cleanup;\n\n        addrstr = g_strdup_printf(\"%s/%d\", tmpstr, net->guestIP.ips[i]->prefix);\n\n        VIR_FREE(tmpstr);\n        pret = PrlStrList_AddItem(addrlist, addrstr);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        VIR_FREE(addrstr);\n    }\n\n    if (ipv4present || ipv6present) {\n        pret = PrlVmDevNet_SetNetAddresses(sdknet, addrlist);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDevNet_SetConfigureWithDhcp(sdknet, !ipv4present);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevNet_SetConfigureWithDhcpIPv6(sdknet, !ipv6present);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevNet_SetAutoApply(sdknet, true);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (prlsdkConfigureGateways(sdknet, net))\n        goto cleanup;\n\n    if (isCt) {\n        if (net->model != VIR_DOMAIN_NET_MODEL_UNKNOWN)\n            VIR_WARN(\"Setting network adapter for containers is not \"\n                     \"supported by vz driver.\");\n    } else {\n        if (net->model == VIR_DOMAIN_NET_MODEL_RTL8139) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_RTL);\n        } else if (net->model == VIR_DOMAIN_NET_MODEL_E1000) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_E1000);\n        } else if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_VIRTIO);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Specified network adapter model is not \"\n                             \"supported by vz driver.\"));\n            goto cleanup;\n        }\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n        if (STREQ(net->data.network.name, PARALLELS_DOMAIN_ROUTED_NETWORK_NAME)) {\n            pret = PrlVmDev_SetEmulatedType(sdknet, PNA_ROUTED);\n            prlsdkCheckRetGoto(pret, cleanup);\n        } else {\n            pret = PrlVmDev_SetEmulatedType(sdknet, PNA_BRIDGED_NETWORK);\n            prlsdkCheckRetGoto(pret, cleanup);\n\n            pret = PrlVmDevNet_SetVirtualNetworkId(sdknet, net->data.network.name);\n            prlsdkCheckRetGoto(pret, cleanup);\n        }\n\n    } else if (net->type == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n\n        pret = PrlVmDev_SetEmulatedType(sdknet, PNA_BRIDGE);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlVmDevNet_SetVirtualNetworkId(sdknet, net->data.bridge.brname);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDevNet_SetPktFilterPreventMacSpoof(sdknet,\n                net->trustGuestRxFilters == VIR_TRISTATE_BOOL_YES);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(addrstr);\n    PrlHandle_Free(addrlist);\n    PrlHandle_Free(sdknet);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PRL_MAC_STRING_BUFNAME  13"
          ],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define PRL_MAC_STRING_BUFNAME  13\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);\n\nstatic int prlsdkConfigureNet(vzDriverPtr driver G_GNUC_UNUSED,\n                              virDomainObjPtr dom G_GNUC_UNUSED,\n                              PRL_HANDLE sdkdom,\n                              virDomainNetDefPtr net,\n                              bool isCt, bool create)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdknet = PRL_INVALID_HANDLE;\n    PRL_HANDLE addrlist = PRL_INVALID_HANDLE;\n    size_t i;\n    int ret = -1;\n    char macstr[PRL_MAC_STRING_BUFNAME];\n    char *addrstr = NULL;\n    bool ipv6present = false;\n    bool ipv4present = false;\n\n    if (prlsdkCheckNetUnsupportedParams(net) < 0)\n        return -1;\n\n    if (create) {\n        pret = PrlVmCfg_CreateVmDev(sdkdom, PDE_GENERIC_NETWORK_ADAPTER, &sdknet);\n        prlsdkCheckRetGoto(pret, cleanup);\n    } else {\n        sdknet = prlsdkFindNetByMAC(sdkdom, &net->mac);\n        if (sdknet == PRL_INVALID_HANDLE)\n            return -1;\n    }\n\n    pret = PrlVmDev_SetEnabled(sdknet, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdknet, net->linkstate !=\n                                 VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN);\n\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (net->ifname) {\n        pret = PrlVmDevNet_SetHostInterfaceName(sdknet, net->ifname);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    prlsdkFormatMac(&net->mac, macstr);\n    pret = PrlVmDevNet_SetMacAddress(sdknet, macstr);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlApi_CreateStringsList(&addrlist);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < net->guestIP.nips; i++) {\n        char *tmpstr;\n\n        if (AF_INET == VIR_SOCKET_ADDR_FAMILY(&net->guestIP.ips[i]->address))\n            ipv4present = true;\n        else if (AF_INET6 == VIR_SOCKET_ADDR_FAMILY(&net->guestIP.ips[i]->address))\n            ipv6present = true;\n        else\n            continue;\n\n        if (!(tmpstr = virSocketAddrFormat(&net->guestIP.ips[i]->address)))\n            goto cleanup;\n\n        addrstr = g_strdup_printf(\"%s/%d\", tmpstr, net->guestIP.ips[i]->prefix);\n\n        VIR_FREE(tmpstr);\n        pret = PrlStrList_AddItem(addrlist, addrstr);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        VIR_FREE(addrstr);\n    }\n\n    if (ipv4present || ipv6present) {\n        pret = PrlVmDevNet_SetNetAddresses(sdknet, addrlist);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDevNet_SetConfigureWithDhcp(sdknet, !ipv4present);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevNet_SetConfigureWithDhcpIPv6(sdknet, !ipv6present);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevNet_SetAutoApply(sdknet, true);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (prlsdkConfigureGateways(sdknet, net))\n        goto cleanup;\n\n    if (isCt) {\n        if (net->model != VIR_DOMAIN_NET_MODEL_UNKNOWN)\n            VIR_WARN(\"Setting network adapter for containers is not \"\n                     \"supported by vz driver.\");\n    } else {\n        if (net->model == VIR_DOMAIN_NET_MODEL_RTL8139) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_RTL);\n        } else if (net->model == VIR_DOMAIN_NET_MODEL_E1000) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_E1000);\n        } else if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_VIRTIO);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Specified network adapter model is not \"\n                             \"supported by vz driver.\"));\n            goto cleanup;\n        }\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n        if (STREQ(net->data.network.name, PARALLELS_DOMAIN_ROUTED_NETWORK_NAME)) {\n            pret = PrlVmDev_SetEmulatedType(sdknet, PNA_ROUTED);\n            prlsdkCheckRetGoto(pret, cleanup);\n        } else {\n            pret = PrlVmDev_SetEmulatedType(sdknet, PNA_BRIDGED_NETWORK);\n            prlsdkCheckRetGoto(pret, cleanup);\n\n            pret = PrlVmDevNet_SetVirtualNetworkId(sdknet, net->data.network.name);\n            prlsdkCheckRetGoto(pret, cleanup);\n        }\n\n    } else if (net->type == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n\n        pret = PrlVmDev_SetEmulatedType(sdknet, PNA_BRIDGE);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlVmDevNet_SetVirtualNetworkId(sdknet, net->data.bridge.brname);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDevNet_SetPktFilterPreventMacSpoof(sdknet,\n                net->trustGuestRxFilters == VIR_TRISTATE_BOOL_YES);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(addrstr);\n    PrlHandle_Free(addrlist);\n    PrlHandle_Free(sdknet);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "dom->def"
          ],
          "line": 3718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkConfigureDisk",
          "args": [
            "driver",
            "privdom->sdkdom",
            "dev->data.disk",
            "false"
          ],
          "line": 3711
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConfigureDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3428-3522",
          "snippet": "static int prlsdkConfigureDisk(vzDriverPtr driver,\n                               PRL_HANDLE sdkdom,\n                               virDomainDiskDefPtr disk,\n                               bool create)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int ret = -1;\n    PRL_VM_DEV_EMULATION_TYPE emutype;\n    PRL_MASS_STORAGE_INTERFACE_TYPE sdkbus;\n    int idx;\n    virDomainDeviceDriveAddressPtr drive;\n    PRL_DEVICE_TYPE devType;\n    PRL_CLUSTERED_DEVICE_SUBTYPE scsiModel;\n    const char *path = disk->src->path ? : \"\";\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK)\n        devType = PDE_HARD_DISK;\n    else\n        devType = PDE_OPTICAL_DISK;\n\n    if (create) {\n        pret = PrlVmCfg_CreateVmDev(sdkdom, devType, &sdkdisk);\n        prlsdkCheckRetGoto(pret, cleanup);\n    } else {\n        sdkdisk = prlsdkGetDisk(sdkdom, disk);\n        if (sdkdisk == PRL_INVALID_HANDLE)\n            return -1;\n    }\n\n    pret = PrlVmDev_SetEnabled(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (disk->src->type == VIR_STORAGE_TYPE_FILE)\n        emutype = PDT_USE_IMAGE_FILE;\n    else\n        emutype = PDT_USE_REAL_DEVICE;\n\n    pret = PrlVmDev_SetEmulatedType(sdkdisk, emutype);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetSysName(sdkdisk, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetFriendlyName(sdkdisk, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    drive = &disk->info.addr.drive;\n\n    switch (disk->bus) {\n    case VIR_DOMAIN_DISK_BUS_IDE:\n        sdkbus = PMS_IDE_DEVICE;\n        idx = 2 * drive->bus + drive->unit;\n        break;\n    case VIR_DOMAIN_DISK_BUS_SCSI:\n        sdkbus = PMS_SCSI_DEVICE;\n        idx = drive->unit;\n        break;\n    case VIR_DOMAIN_DISK_BUS_SATA:\n        sdkbus = PMS_SATA_DEVICE;\n        idx = drive->unit;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified disk bus is not \"\n                         \"supported by vz driver.\"));\n        goto cleanup;\n    }\n\n    if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (vzGetDefaultSCSIModel(driver, &scsiModel) < 0)\n            goto cleanup;\n        pret = PrlVmDev_SetSubType(sdkdisk, scsiModel);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDev_SetIfaceType(sdkdisk, sdkbus);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetStackIndex(sdkdisk, idx);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (devType == PDE_HARD_DISK) {\n        pret = PrlVmDevHd_SetSerialNumber(sdkdisk, disk->serial);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    return 0;\n cleanup:\n    PrlHandle_Free(sdkdisk);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int prlsdkConfigureDisk(vzDriverPtr driver,\n                               PRL_HANDLE sdkdom,\n                               virDomainDiskDefPtr disk,\n                               bool create)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int ret = -1;\n    PRL_VM_DEV_EMULATION_TYPE emutype;\n    PRL_MASS_STORAGE_INTERFACE_TYPE sdkbus;\n    int idx;\n    virDomainDeviceDriveAddressPtr drive;\n    PRL_DEVICE_TYPE devType;\n    PRL_CLUSTERED_DEVICE_SUBTYPE scsiModel;\n    const char *path = disk->src->path ? : \"\";\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK)\n        devType = PDE_HARD_DISK;\n    else\n        devType = PDE_OPTICAL_DISK;\n\n    if (create) {\n        pret = PrlVmCfg_CreateVmDev(sdkdom, devType, &sdkdisk);\n        prlsdkCheckRetGoto(pret, cleanup);\n    } else {\n        sdkdisk = prlsdkGetDisk(sdkdom, disk);\n        if (sdkdisk == PRL_INVALID_HANDLE)\n            return -1;\n    }\n\n    pret = PrlVmDev_SetEnabled(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (disk->src->type == VIR_STORAGE_TYPE_FILE)\n        emutype = PDT_USE_IMAGE_FILE;\n    else\n        emutype = PDT_USE_REAL_DEVICE;\n\n    pret = PrlVmDev_SetEmulatedType(sdkdisk, emutype);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetSysName(sdkdisk, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetFriendlyName(sdkdisk, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    drive = &disk->info.addr.drive;\n\n    switch (disk->bus) {\n    case VIR_DOMAIN_DISK_BUS_IDE:\n        sdkbus = PMS_IDE_DEVICE;\n        idx = 2 * drive->bus + drive->unit;\n        break;\n    case VIR_DOMAIN_DISK_BUS_SCSI:\n        sdkbus = PMS_SCSI_DEVICE;\n        idx = drive->unit;\n        break;\n    case VIR_DOMAIN_DISK_BUS_SATA:\n        sdkbus = PMS_SATA_DEVICE;\n        idx = drive->unit;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified disk bus is not \"\n                         \"supported by vz driver.\"));\n        goto cleanup;\n    }\n\n    if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (vzGetDefaultSCSIModel(driver, &scsiModel) < 0)\n            goto cleanup;\n        pret = PrlVmDev_SetSubType(sdkdisk, scsiModel);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDev_SetIfaceType(sdkdisk, sdkbus);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetStackIndex(sdkdisk, idx);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (devType == PDE_HARD_DISK) {\n        pret = PrlVmDevHd_SetSerialNumber(sdkdisk, disk->serial);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    return 0;\n cleanup:\n    PrlHandle_Free(sdkdisk);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 3706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 3706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_BeginEdit",
          "args": [
            "privdom->sdkdom"
          ],
          "line": 3705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nint\nprlsdkUpdateDevice(vzDriverPtr driver,\n                   virDomainObjPtr dom,\n                   virDomainDeviceDefPtr dev)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n\n    job = PrlVm_BeginEdit(privdom->sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    switch (dev->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        if (prlsdkConfigureDisk(driver, privdom->sdkdom, dev->data.disk,\n                                false) < 0)\n            return -1;\n\n        break;\n    case VIR_DOMAIN_DEVICE_NET:\n        if (prlsdkConfigureNet(driver, dom, privdom->sdkdom, dev->data.net,\n                               IS_CT(dom->def), false) < 0)\n            return -1;\n\n        break;\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n        if (dom->def->ngraphics < 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"cannot find VNC graphics device\"));\n            return -1;\n        }\n\n        if (prlsdkApplyGraphicsParams(privdom->sdkdom, dev->data.graphics) < 0)\n            return -1;\n\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"updating device type '%s' is unsupported\"),\n                       virDomainDeviceTypeToString(dev->type));\n        return -1;\n    }\n\n    job = PrlVm_CommitEx(privdom->sdkdom, PVCF_DETACH_HDD_BUNDLE);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkDetachDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "3627-3695",
    "snippet": "int\nprlsdkDetachDevice(vzDriverPtr driver G_GNUC_UNUSED,\n                   virDomainObjPtr dom,\n                   virDomainDeviceDefPtr dev)\n{\n    int ret = -1;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE sdkdev = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n\n    job = PrlVm_BeginEdit(privdom->sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        goto cleanup;\n\n    switch (dev->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        sdkdev = prlsdkGetDisk(privdom->sdkdom, dev->data.disk);\n        if (sdkdev == PRL_INVALID_HANDLE)\n            goto cleanup;\n\n        pret = PrlVmDev_Remove(sdkdev);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        break;\n    case VIR_DOMAIN_DEVICE_NET:\n        if (!IS_CT(dom->def)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"detaching network device from VM is unsupported\"));\n            goto cleanup;\n        }\n\n        sdkdev = prlsdkFindNetByMAC(privdom->sdkdom, &dev->data.net->mac);\n        if (sdkdev == PRL_INVALID_HANDLE)\n            goto cleanup;\n\n        pret = PrlVmDev_Remove(sdkdev);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        break;\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n        if (dom->def->ngraphics < 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"cannot find VNC graphics device\"));\n            goto cleanup;\n        }\n\n        if (prlsdkApplyGraphicsParams(privdom->sdkdom, NULL) < 0)\n            goto cleanup;\n\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"detaching device type '%s' is unsupported\"),\n                       virDomainDeviceTypeToString(dev->type));\n        goto cleanup;\n    }\n\n    job = PrlVm_CommitEx(privdom->sdkdom, PVCF_DETACH_HDD_BUNDLE);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n\n    PrlHandle_Free(sdkdev);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);",
      "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);",
      "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "sdkdev"
          ],
          "line": 3693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_CommitEx",
          "args": [
            "privdom->sdkdom",
            "PVCF_DETACH_HDD_BUNDLE"
          ],
          "line": 3685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"detaching device type '%s' is unsupported\")",
            "virDomainDeviceTypeToString(dev->type)"
          ],
          "line": 3679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDeviceTypeToString",
          "args": [
            "dev->type"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"detaching device type '%s' is unsupported\""
          ],
          "line": 3680
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkApplyGraphicsParams",
          "args": [
            "privdom->sdkdom",
            "NULL"
          ],
          "line": 3674
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkApplyGraphicsParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3021-3053",
          "snippet": "static int prlsdkApplyGraphicsParams(PRL_HANDLE sdkdom,\n                                     virDomainGraphicsDefPtr gr)\n{\n    virDomainGraphicsListenDefPtr glisten;\n    PRL_RESULT pret;\n\n    if (!gr) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_DISABLED);\n        prlsdkCheckRetExit(pret, -1);\n        return 0;\n    }\n\n    pret = PrlVmCfg_SetVNCPassword(sdkdom, gr->data.vnc.auth.passwd ? : \"\");\n    prlsdkCheckRetExit(pret, -1);\n\n    if (gr->data.vnc.autoport) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_AUTO);\n        prlsdkCheckRetExit(pret, -1);\n    } else {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_MANUAL);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlVmCfg_SetVNCPort(sdkdom, gr->data.vnc.port);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    glisten = virDomainGraphicsGetListen(gr, 0);\n    pret = PrlVmCfg_SetVNCHostName(sdkdom, glisten && glisten->address ?\n                                           glisten->address : VIR_LOOPBACK_IPV4_ADDR);\n    prlsdkCheckRetExit(pret, -1);\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int prlsdkApplyGraphicsParams(PRL_HANDLE sdkdom,\n                                     virDomainGraphicsDefPtr gr)\n{\n    virDomainGraphicsListenDefPtr glisten;\n    PRL_RESULT pret;\n\n    if (!gr) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_DISABLED);\n        prlsdkCheckRetExit(pret, -1);\n        return 0;\n    }\n\n    pret = PrlVmCfg_SetVNCPassword(sdkdom, gr->data.vnc.auth.passwd ? : \"\");\n    prlsdkCheckRetExit(pret, -1);\n\n    if (gr->data.vnc.autoport) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_AUTO);\n        prlsdkCheckRetExit(pret, -1);\n    } else {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_MANUAL);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlVmCfg_SetVNCPort(sdkdom, gr->data.vnc.port);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    glisten = virDomainGraphicsGetListen(gr, 0);\n    pret = PrlVmCfg_SetVNCHostName(sdkdom, glisten && glisten->address ?\n                                           glisten->address : VIR_LOOPBACK_IPV4_ADDR);\n    prlsdkCheckRetExit(pret, -1);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"cannot find VNC graphics device\")"
          ],
          "line": 3669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_Remove",
          "args": [
            "sdkdev"
          ],
          "line": 3663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkFindNetByMAC",
          "args": [
            "privdom->sdkdom",
            "&dev->data.net->mac"
          ],
          "line": 3659
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkFindNetByMAC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3389-3426",
          "snippet": "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 adaptersCount;\n    PRL_UINT32 i;\n    PRL_HANDLE adapter = PRL_INVALID_HANDLE;\n    char adapterMac[PRL_MAC_STRING_BUFNAME];\n    char expectedMac[PRL_MAC_STRING_BUFNAME];\n    char virMac[VIR_MAC_STRING_BUFLEN];\n\n    prlsdkFormatMac(mac, expectedMac);\n\n    pret = PrlVmCfg_GetNetAdaptersCount(sdkdom, &adaptersCount);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < adaptersCount; ++i) {\n        pret = PrlVmCfg_GetNetAdapter(sdkdom, i, &adapter);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = prlsdkGetStringParamBuf(PrlVmDevNet_GetMacAddress,\n                                       adapter, adapterMac, sizeof(adapterMac));\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (STREQ(adapterMac, expectedMac))\n            return adapter;\n\n        PrlHandle_Free(adapter);\n        adapter = PRL_INVALID_HANDLE;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"No net with mac '%s'\"), virMacAddrFormat(mac, virMac));\n\n cleanup:\n    PrlHandle_Free(adapter);\n    return adapter;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PRL_MAC_STRING_BUFNAME  13"
          ],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define PRL_MAC_STRING_BUFNAME  13\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);\n\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 adaptersCount;\n    PRL_UINT32 i;\n    PRL_HANDLE adapter = PRL_INVALID_HANDLE;\n    char adapterMac[PRL_MAC_STRING_BUFNAME];\n    char expectedMac[PRL_MAC_STRING_BUFNAME];\n    char virMac[VIR_MAC_STRING_BUFLEN];\n\n    prlsdkFormatMac(mac, expectedMac);\n\n    pret = PrlVmCfg_GetNetAdaptersCount(sdkdom, &adaptersCount);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < adaptersCount; ++i) {\n        pret = PrlVmCfg_GetNetAdapter(sdkdom, i, &adapter);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = prlsdkGetStringParamBuf(PrlVmDevNet_GetMacAddress,\n                                       adapter, adapterMac, sizeof(adapterMac));\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (STREQ(adapterMac, expectedMac))\n            return adapter;\n\n        PrlHandle_Free(adapter);\n        adapter = PRL_INVALID_HANDLE;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"No net with mac '%s'\"), virMacAddrFormat(mac, virMac));\n\n cleanup:\n    PrlHandle_Free(adapter);\n    return adapter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"detaching network device from VM is unsupported\")"
          ],
          "line": 3654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "dom->def"
          ],
          "line": 3653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_Remove",
          "args": [
            "sdkdev"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetDisk",
          "args": [
            "privdom->sdkdom",
            "dev->data.disk"
          ],
          "line": 3644
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3524-3569",
          "snippet": "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 num;\n    size_t i;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int bus;\n    char *dst = NULL;\n    PRL_DEVICE_TYPE devType;\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK)\n        devType = PDE_HARD_DISK;\n    else\n        devType = PDE_OPTICAL_DISK;\n\n    pret = PrlVmCfg_GetDevsCountByType(sdkdom, devType, &num);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < num; ++i) {\n        pret = PrlVmCfg_GetDevByType(sdkdom, devType, i, &sdkdisk);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (prlsdkGetDiskId(sdkdisk, &bus, &dst) < 0)\n            goto error;\n\n        if (disk->bus == bus && STREQ(disk->dst, dst)) {\n            VIR_FREE(dst);\n            return sdkdisk;\n        }\n\n        PrlHandle_Free(sdkdisk);\n        sdkdisk = PRL_INVALID_HANDLE;\n        VIR_FREE(dst);\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"No disk with bus '%s' and target '%s'\"),\n                   virDomainDiskBusTypeToString(disk->bus), disk->dst);\n    return PRL_INVALID_HANDLE;\n\n error:\n    VIR_FREE(dst);\n    PrlHandle_Free(sdkdisk);\n    return PRL_INVALID_HANDLE;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 num;\n    size_t i;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int bus;\n    char *dst = NULL;\n    PRL_DEVICE_TYPE devType;\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK)\n        devType = PDE_HARD_DISK;\n    else\n        devType = PDE_OPTICAL_DISK;\n\n    pret = PrlVmCfg_GetDevsCountByType(sdkdom, devType, &num);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < num; ++i) {\n        pret = PrlVmCfg_GetDevByType(sdkdom, devType, i, &sdkdisk);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (prlsdkGetDiskId(sdkdisk, &bus, &dst) < 0)\n            goto error;\n\n        if (disk->bus == bus && STREQ(disk->dst, dst)) {\n            VIR_FREE(dst);\n            return sdkdisk;\n        }\n\n        PrlHandle_Free(sdkdisk);\n        sdkdisk = PRL_INVALID_HANDLE;\n        VIR_FREE(dst);\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"No disk with bus '%s' and target '%s'\"),\n                   virDomainDiskBusTypeToString(disk->bus), disk->dst);\n    return PRL_INVALID_HANDLE;\n\n error:\n    VIR_FREE(dst);\n    PrlHandle_Free(sdkdisk);\n    return PRL_INVALID_HANDLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_BeginEdit",
          "args": [
            "privdom->sdkdom"
          ],
          "line": 3638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nint\nprlsdkDetachDevice(vzDriverPtr driver G_GNUC_UNUSED,\n                   virDomainObjPtr dom,\n                   virDomainDeviceDefPtr dev)\n{\n    int ret = -1;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE sdkdev = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n\n    job = PrlVm_BeginEdit(privdom->sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        goto cleanup;\n\n    switch (dev->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        sdkdev = prlsdkGetDisk(privdom->sdkdom, dev->data.disk);\n        if (sdkdev == PRL_INVALID_HANDLE)\n            goto cleanup;\n\n        pret = PrlVmDev_Remove(sdkdev);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        break;\n    case VIR_DOMAIN_DEVICE_NET:\n        if (!IS_CT(dom->def)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"detaching network device from VM is unsupported\"));\n            goto cleanup;\n        }\n\n        sdkdev = prlsdkFindNetByMAC(privdom->sdkdom, &dev->data.net->mac);\n        if (sdkdev == PRL_INVALID_HANDLE)\n            goto cleanup;\n\n        pret = PrlVmDev_Remove(sdkdev);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        break;\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n        if (dom->def->ngraphics < 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"cannot find VNC graphics device\"));\n            goto cleanup;\n        }\n\n        if (prlsdkApplyGraphicsParams(privdom->sdkdom, NULL) < 0)\n            goto cleanup;\n\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"detaching device type '%s' is unsupported\"),\n                       virDomainDeviceTypeToString(dev->type));\n        goto cleanup;\n    }\n\n    job = PrlVm_CommitEx(privdom->sdkdom, PVCF_DETACH_HDD_BUNDLE);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n\n    PrlHandle_Free(sdkdev);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkAttachDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "3571-3625",
    "snippet": "int\nprlsdkAttachDevice(vzDriverPtr driver,\n                   virDomainObjPtr dom,\n                   virDomainDeviceDefPtr dev)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n\n    job = PrlVm_BeginEdit(privdom->sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    switch (dev->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        if (prlsdkConfigureDisk(driver, privdom->sdkdom,\n                                dev->data.disk, true) < 0)\n            return -1;\n\n        break;\n    case VIR_DOMAIN_DEVICE_NET:\n        if (!IS_CT(dom->def)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"attaching network device to VM is unsupported\"));\n            return -1;\n        }\n\n        if (prlsdkConfigureNet(driver, dom, privdom->sdkdom, dev->data.net,\n                               IS_CT(dom->def), true) < 0)\n            return -1;\n\n        break;\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n        if (dom->def->ngraphics > 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"domain already has VNC graphics\"));\n            return -1;\n        }\n\n        if (prlsdkApplyGraphicsParams(privdom->sdkdom, dev->data.graphics) < 0)\n            return -1;\n\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"attaching device type '%s' is unsupported\"),\n                       virDomainDeviceTypeToString(dev->type));\n        return -1;\n    }\n\n    job = PrlVm_CommitEx(privdom->sdkdom, PVCF_DETACH_HDD_BUNDLE);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 3621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 3621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_CommitEx",
          "args": [
            "privdom->sdkdom",
            "PVCF_DETACH_HDD_BUNDLE"
          ],
          "line": 3620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"attaching device type '%s' is unsupported\")",
            "virDomainDeviceTypeToString(dev->type)"
          ],
          "line": 3614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDeviceTypeToString",
          "args": [
            "dev->type"
          ],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"attaching device type '%s' is unsupported\""
          ],
          "line": 3615
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkApplyGraphicsParams",
          "args": [
            "privdom->sdkdom",
            "dev->data.graphics"
          ],
          "line": 3609
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkApplyGraphicsParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3021-3053",
          "snippet": "static int prlsdkApplyGraphicsParams(PRL_HANDLE sdkdom,\n                                     virDomainGraphicsDefPtr gr)\n{\n    virDomainGraphicsListenDefPtr glisten;\n    PRL_RESULT pret;\n\n    if (!gr) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_DISABLED);\n        prlsdkCheckRetExit(pret, -1);\n        return 0;\n    }\n\n    pret = PrlVmCfg_SetVNCPassword(sdkdom, gr->data.vnc.auth.passwd ? : \"\");\n    prlsdkCheckRetExit(pret, -1);\n\n    if (gr->data.vnc.autoport) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_AUTO);\n        prlsdkCheckRetExit(pret, -1);\n    } else {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_MANUAL);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlVmCfg_SetVNCPort(sdkdom, gr->data.vnc.port);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    glisten = virDomainGraphicsGetListen(gr, 0);\n    pret = PrlVmCfg_SetVNCHostName(sdkdom, glisten && glisten->address ?\n                                           glisten->address : VIR_LOOPBACK_IPV4_ADDR);\n    prlsdkCheckRetExit(pret, -1);\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int prlsdkApplyGraphicsParams(PRL_HANDLE sdkdom,\n                                     virDomainGraphicsDefPtr gr)\n{\n    virDomainGraphicsListenDefPtr glisten;\n    PRL_RESULT pret;\n\n    if (!gr) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_DISABLED);\n        prlsdkCheckRetExit(pret, -1);\n        return 0;\n    }\n\n    pret = PrlVmCfg_SetVNCPassword(sdkdom, gr->data.vnc.auth.passwd ? : \"\");\n    prlsdkCheckRetExit(pret, -1);\n\n    if (gr->data.vnc.autoport) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_AUTO);\n        prlsdkCheckRetExit(pret, -1);\n    } else {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_MANUAL);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlVmCfg_SetVNCPort(sdkdom, gr->data.vnc.port);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    glisten = virDomainGraphicsGetListen(gr, 0);\n    pret = PrlVmCfg_SetVNCHostName(sdkdom, glisten && glisten->address ?\n                                           glisten->address : VIR_LOOPBACK_IPV4_ADDR);\n    prlsdkCheckRetExit(pret, -1);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"domain already has VNC graphics\")"
          ],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkConfigureNet",
          "args": [
            "driver",
            "dom",
            "privdom->sdkdom",
            "dev->data.net",
            "IS_CT(dom->def)",
            "true"
          ],
          "line": 3597
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConfigureNet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3249-3387",
          "snippet": "static int prlsdkConfigureNet(vzDriverPtr driver G_GNUC_UNUSED,\n                              virDomainObjPtr dom G_GNUC_UNUSED,\n                              PRL_HANDLE sdkdom,\n                              virDomainNetDefPtr net,\n                              bool isCt, bool create)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdknet = PRL_INVALID_HANDLE;\n    PRL_HANDLE addrlist = PRL_INVALID_HANDLE;\n    size_t i;\n    int ret = -1;\n    char macstr[PRL_MAC_STRING_BUFNAME];\n    char *addrstr = NULL;\n    bool ipv6present = false;\n    bool ipv4present = false;\n\n    if (prlsdkCheckNetUnsupportedParams(net) < 0)\n        return -1;\n\n    if (create) {\n        pret = PrlVmCfg_CreateVmDev(sdkdom, PDE_GENERIC_NETWORK_ADAPTER, &sdknet);\n        prlsdkCheckRetGoto(pret, cleanup);\n    } else {\n        sdknet = prlsdkFindNetByMAC(sdkdom, &net->mac);\n        if (sdknet == PRL_INVALID_HANDLE)\n            return -1;\n    }\n\n    pret = PrlVmDev_SetEnabled(sdknet, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdknet, net->linkstate !=\n                                 VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN);\n\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (net->ifname) {\n        pret = PrlVmDevNet_SetHostInterfaceName(sdknet, net->ifname);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    prlsdkFormatMac(&net->mac, macstr);\n    pret = PrlVmDevNet_SetMacAddress(sdknet, macstr);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlApi_CreateStringsList(&addrlist);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < net->guestIP.nips; i++) {\n        char *tmpstr;\n\n        if (AF_INET == VIR_SOCKET_ADDR_FAMILY(&net->guestIP.ips[i]->address))\n            ipv4present = true;\n        else if (AF_INET6 == VIR_SOCKET_ADDR_FAMILY(&net->guestIP.ips[i]->address))\n            ipv6present = true;\n        else\n            continue;\n\n        if (!(tmpstr = virSocketAddrFormat(&net->guestIP.ips[i]->address)))\n            goto cleanup;\n\n        addrstr = g_strdup_printf(\"%s/%d\", tmpstr, net->guestIP.ips[i]->prefix);\n\n        VIR_FREE(tmpstr);\n        pret = PrlStrList_AddItem(addrlist, addrstr);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        VIR_FREE(addrstr);\n    }\n\n    if (ipv4present || ipv6present) {\n        pret = PrlVmDevNet_SetNetAddresses(sdknet, addrlist);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDevNet_SetConfigureWithDhcp(sdknet, !ipv4present);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevNet_SetConfigureWithDhcpIPv6(sdknet, !ipv6present);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevNet_SetAutoApply(sdknet, true);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (prlsdkConfigureGateways(sdknet, net))\n        goto cleanup;\n\n    if (isCt) {\n        if (net->model != VIR_DOMAIN_NET_MODEL_UNKNOWN)\n            VIR_WARN(\"Setting network adapter for containers is not \"\n                     \"supported by vz driver.\");\n    } else {\n        if (net->model == VIR_DOMAIN_NET_MODEL_RTL8139) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_RTL);\n        } else if (net->model == VIR_DOMAIN_NET_MODEL_E1000) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_E1000);\n        } else if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_VIRTIO);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Specified network adapter model is not \"\n                             \"supported by vz driver.\"));\n            goto cleanup;\n        }\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n        if (STREQ(net->data.network.name, PARALLELS_DOMAIN_ROUTED_NETWORK_NAME)) {\n            pret = PrlVmDev_SetEmulatedType(sdknet, PNA_ROUTED);\n            prlsdkCheckRetGoto(pret, cleanup);\n        } else {\n            pret = PrlVmDev_SetEmulatedType(sdknet, PNA_BRIDGED_NETWORK);\n            prlsdkCheckRetGoto(pret, cleanup);\n\n            pret = PrlVmDevNet_SetVirtualNetworkId(sdknet, net->data.network.name);\n            prlsdkCheckRetGoto(pret, cleanup);\n        }\n\n    } else if (net->type == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n\n        pret = PrlVmDev_SetEmulatedType(sdknet, PNA_BRIDGE);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlVmDevNet_SetVirtualNetworkId(sdknet, net->data.bridge.brname);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDevNet_SetPktFilterPreventMacSpoof(sdknet,\n                net->trustGuestRxFilters == VIR_TRISTATE_BOOL_YES);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(addrstr);\n    PrlHandle_Free(addrlist);\n    PrlHandle_Free(sdknet);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PRL_MAC_STRING_BUFNAME  13"
          ],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define PRL_MAC_STRING_BUFNAME  13\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);\n\nstatic int prlsdkConfigureNet(vzDriverPtr driver G_GNUC_UNUSED,\n                              virDomainObjPtr dom G_GNUC_UNUSED,\n                              PRL_HANDLE sdkdom,\n                              virDomainNetDefPtr net,\n                              bool isCt, bool create)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdknet = PRL_INVALID_HANDLE;\n    PRL_HANDLE addrlist = PRL_INVALID_HANDLE;\n    size_t i;\n    int ret = -1;\n    char macstr[PRL_MAC_STRING_BUFNAME];\n    char *addrstr = NULL;\n    bool ipv6present = false;\n    bool ipv4present = false;\n\n    if (prlsdkCheckNetUnsupportedParams(net) < 0)\n        return -1;\n\n    if (create) {\n        pret = PrlVmCfg_CreateVmDev(sdkdom, PDE_GENERIC_NETWORK_ADAPTER, &sdknet);\n        prlsdkCheckRetGoto(pret, cleanup);\n    } else {\n        sdknet = prlsdkFindNetByMAC(sdkdom, &net->mac);\n        if (sdknet == PRL_INVALID_HANDLE)\n            return -1;\n    }\n\n    pret = PrlVmDev_SetEnabled(sdknet, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdknet, net->linkstate !=\n                                 VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN);\n\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (net->ifname) {\n        pret = PrlVmDevNet_SetHostInterfaceName(sdknet, net->ifname);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    prlsdkFormatMac(&net->mac, macstr);\n    pret = PrlVmDevNet_SetMacAddress(sdknet, macstr);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlApi_CreateStringsList(&addrlist);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < net->guestIP.nips; i++) {\n        char *tmpstr;\n\n        if (AF_INET == VIR_SOCKET_ADDR_FAMILY(&net->guestIP.ips[i]->address))\n            ipv4present = true;\n        else if (AF_INET6 == VIR_SOCKET_ADDR_FAMILY(&net->guestIP.ips[i]->address))\n            ipv6present = true;\n        else\n            continue;\n\n        if (!(tmpstr = virSocketAddrFormat(&net->guestIP.ips[i]->address)))\n            goto cleanup;\n\n        addrstr = g_strdup_printf(\"%s/%d\", tmpstr, net->guestIP.ips[i]->prefix);\n\n        VIR_FREE(tmpstr);\n        pret = PrlStrList_AddItem(addrlist, addrstr);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        VIR_FREE(addrstr);\n    }\n\n    if (ipv4present || ipv6present) {\n        pret = PrlVmDevNet_SetNetAddresses(sdknet, addrlist);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDevNet_SetConfigureWithDhcp(sdknet, !ipv4present);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevNet_SetConfigureWithDhcpIPv6(sdknet, !ipv6present);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevNet_SetAutoApply(sdknet, true);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (prlsdkConfigureGateways(sdknet, net))\n        goto cleanup;\n\n    if (isCt) {\n        if (net->model != VIR_DOMAIN_NET_MODEL_UNKNOWN)\n            VIR_WARN(\"Setting network adapter for containers is not \"\n                     \"supported by vz driver.\");\n    } else {\n        if (net->model == VIR_DOMAIN_NET_MODEL_RTL8139) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_RTL);\n        } else if (net->model == VIR_DOMAIN_NET_MODEL_E1000) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_E1000);\n        } else if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_VIRTIO);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Specified network adapter model is not \"\n                             \"supported by vz driver.\"));\n            goto cleanup;\n        }\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n        if (STREQ(net->data.network.name, PARALLELS_DOMAIN_ROUTED_NETWORK_NAME)) {\n            pret = PrlVmDev_SetEmulatedType(sdknet, PNA_ROUTED);\n            prlsdkCheckRetGoto(pret, cleanup);\n        } else {\n            pret = PrlVmDev_SetEmulatedType(sdknet, PNA_BRIDGED_NETWORK);\n            prlsdkCheckRetGoto(pret, cleanup);\n\n            pret = PrlVmDevNet_SetVirtualNetworkId(sdknet, net->data.network.name);\n            prlsdkCheckRetGoto(pret, cleanup);\n        }\n\n    } else if (net->type == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n\n        pret = PrlVmDev_SetEmulatedType(sdknet, PNA_BRIDGE);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlVmDevNet_SetVirtualNetworkId(sdknet, net->data.bridge.brname);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDevNet_SetPktFilterPreventMacSpoof(sdknet,\n                net->trustGuestRxFilters == VIR_TRISTATE_BOOL_YES);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(addrstr);\n    PrlHandle_Free(addrlist);\n    PrlHandle_Free(sdknet);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "dom->def"
          ],
          "line": 3598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"attaching network device to VM is unsupported\")"
          ],
          "line": 3592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "dom->def"
          ],
          "line": 3591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkConfigureDisk",
          "args": [
            "driver",
            "privdom->sdkdom",
            "dev->data.disk",
            "true"
          ],
          "line": 3585
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConfigureDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3428-3522",
          "snippet": "static int prlsdkConfigureDisk(vzDriverPtr driver,\n                               PRL_HANDLE sdkdom,\n                               virDomainDiskDefPtr disk,\n                               bool create)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int ret = -1;\n    PRL_VM_DEV_EMULATION_TYPE emutype;\n    PRL_MASS_STORAGE_INTERFACE_TYPE sdkbus;\n    int idx;\n    virDomainDeviceDriveAddressPtr drive;\n    PRL_DEVICE_TYPE devType;\n    PRL_CLUSTERED_DEVICE_SUBTYPE scsiModel;\n    const char *path = disk->src->path ? : \"\";\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK)\n        devType = PDE_HARD_DISK;\n    else\n        devType = PDE_OPTICAL_DISK;\n\n    if (create) {\n        pret = PrlVmCfg_CreateVmDev(sdkdom, devType, &sdkdisk);\n        prlsdkCheckRetGoto(pret, cleanup);\n    } else {\n        sdkdisk = prlsdkGetDisk(sdkdom, disk);\n        if (sdkdisk == PRL_INVALID_HANDLE)\n            return -1;\n    }\n\n    pret = PrlVmDev_SetEnabled(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (disk->src->type == VIR_STORAGE_TYPE_FILE)\n        emutype = PDT_USE_IMAGE_FILE;\n    else\n        emutype = PDT_USE_REAL_DEVICE;\n\n    pret = PrlVmDev_SetEmulatedType(sdkdisk, emutype);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetSysName(sdkdisk, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetFriendlyName(sdkdisk, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    drive = &disk->info.addr.drive;\n\n    switch (disk->bus) {\n    case VIR_DOMAIN_DISK_BUS_IDE:\n        sdkbus = PMS_IDE_DEVICE;\n        idx = 2 * drive->bus + drive->unit;\n        break;\n    case VIR_DOMAIN_DISK_BUS_SCSI:\n        sdkbus = PMS_SCSI_DEVICE;\n        idx = drive->unit;\n        break;\n    case VIR_DOMAIN_DISK_BUS_SATA:\n        sdkbus = PMS_SATA_DEVICE;\n        idx = drive->unit;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified disk bus is not \"\n                         \"supported by vz driver.\"));\n        goto cleanup;\n    }\n\n    if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (vzGetDefaultSCSIModel(driver, &scsiModel) < 0)\n            goto cleanup;\n        pret = PrlVmDev_SetSubType(sdkdisk, scsiModel);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDev_SetIfaceType(sdkdisk, sdkbus);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetStackIndex(sdkdisk, idx);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (devType == PDE_HARD_DISK) {\n        pret = PrlVmDevHd_SetSerialNumber(sdkdisk, disk->serial);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    return 0;\n cleanup:\n    PrlHandle_Free(sdkdisk);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int prlsdkConfigureDisk(vzDriverPtr driver,\n                               PRL_HANDLE sdkdom,\n                               virDomainDiskDefPtr disk,\n                               bool create)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int ret = -1;\n    PRL_VM_DEV_EMULATION_TYPE emutype;\n    PRL_MASS_STORAGE_INTERFACE_TYPE sdkbus;\n    int idx;\n    virDomainDeviceDriveAddressPtr drive;\n    PRL_DEVICE_TYPE devType;\n    PRL_CLUSTERED_DEVICE_SUBTYPE scsiModel;\n    const char *path = disk->src->path ? : \"\";\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK)\n        devType = PDE_HARD_DISK;\n    else\n        devType = PDE_OPTICAL_DISK;\n\n    if (create) {\n        pret = PrlVmCfg_CreateVmDev(sdkdom, devType, &sdkdisk);\n        prlsdkCheckRetGoto(pret, cleanup);\n    } else {\n        sdkdisk = prlsdkGetDisk(sdkdom, disk);\n        if (sdkdisk == PRL_INVALID_HANDLE)\n            return -1;\n    }\n\n    pret = PrlVmDev_SetEnabled(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (disk->src->type == VIR_STORAGE_TYPE_FILE)\n        emutype = PDT_USE_IMAGE_FILE;\n    else\n        emutype = PDT_USE_REAL_DEVICE;\n\n    pret = PrlVmDev_SetEmulatedType(sdkdisk, emutype);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetSysName(sdkdisk, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetFriendlyName(sdkdisk, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    drive = &disk->info.addr.drive;\n\n    switch (disk->bus) {\n    case VIR_DOMAIN_DISK_BUS_IDE:\n        sdkbus = PMS_IDE_DEVICE;\n        idx = 2 * drive->bus + drive->unit;\n        break;\n    case VIR_DOMAIN_DISK_BUS_SCSI:\n        sdkbus = PMS_SCSI_DEVICE;\n        idx = drive->unit;\n        break;\n    case VIR_DOMAIN_DISK_BUS_SATA:\n        sdkbus = PMS_SATA_DEVICE;\n        idx = drive->unit;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified disk bus is not \"\n                         \"supported by vz driver.\"));\n        goto cleanup;\n    }\n\n    if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (vzGetDefaultSCSIModel(driver, &scsiModel) < 0)\n            goto cleanup;\n        pret = PrlVmDev_SetSubType(sdkdisk, scsiModel);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDev_SetIfaceType(sdkdisk, sdkbus);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetStackIndex(sdkdisk, idx);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (devType == PDE_HARD_DISK) {\n        pret = PrlVmDevHd_SetSerialNumber(sdkdisk, disk->serial);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    return 0;\n cleanup:\n    PrlHandle_Free(sdkdisk);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitDomainJob(job, dom)"
          ],
          "line": 3580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 3580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_BeginEdit",
          "args": [
            "privdom->sdkdom"
          ],
          "line": 3579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nint\nprlsdkAttachDevice(vzDriverPtr driver,\n                   virDomainObjPtr dom,\n                   virDomainDeviceDefPtr dev)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n\n    job = PrlVm_BeginEdit(privdom->sdkdom);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    switch (dev->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        if (prlsdkConfigureDisk(driver, privdom->sdkdom,\n                                dev->data.disk, true) < 0)\n            return -1;\n\n        break;\n    case VIR_DOMAIN_DEVICE_NET:\n        if (!IS_CT(dom->def)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"attaching network device to VM is unsupported\"));\n            return -1;\n        }\n\n        if (prlsdkConfigureNet(driver, dom, privdom->sdkdom, dev->data.net,\n                               IS_CT(dom->def), true) < 0)\n            return -1;\n\n        break;\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n        if (dom->def->ngraphics > 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"domain already has VNC graphics\"));\n            return -1;\n        }\n\n        if (prlsdkApplyGraphicsParams(privdom->sdkdom, dev->data.graphics) < 0)\n            return -1;\n\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"attaching device type '%s' is unsupported\"),\n                       virDomainDeviceTypeToString(dev->type));\n        return -1;\n    }\n\n    job = PrlVm_CommitEx(privdom->sdkdom, PVCF_DETACH_HDD_BUNDLE);\n    if (PRL_FAILED(waitDomainJob(job, dom)))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkGetDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "3524-3569",
    "snippet": "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 num;\n    size_t i;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int bus;\n    char *dst = NULL;\n    PRL_DEVICE_TYPE devType;\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK)\n        devType = PDE_HARD_DISK;\n    else\n        devType = PDE_OPTICAL_DISK;\n\n    pret = PrlVmCfg_GetDevsCountByType(sdkdom, devType, &num);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < num; ++i) {\n        pret = PrlVmCfg_GetDevByType(sdkdom, devType, i, &sdkdisk);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (prlsdkGetDiskId(sdkdisk, &bus, &dst) < 0)\n            goto error;\n\n        if (disk->bus == bus && STREQ(disk->dst, dst)) {\n            VIR_FREE(dst);\n            return sdkdisk;\n        }\n\n        PrlHandle_Free(sdkdisk);\n        sdkdisk = PRL_INVALID_HANDLE;\n        VIR_FREE(dst);\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"No disk with bus '%s' and target '%s'\"),\n                   virDomainDiskBusTypeToString(disk->bus), disk->dst);\n    return PRL_INVALID_HANDLE;\n\n error:\n    VIR_FREE(dst);\n    PrlHandle_Free(sdkdisk);\n    return PRL_INVALID_HANDLE;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);",
      "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "sdkdisk"
          ],
          "line": 3567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dst"
          ],
          "line": 3566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"No disk with bus '%s' and target '%s'\")",
            "virDomainDiskBusTypeToString(disk->bus)",
            "disk->dst"
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskBusTypeToString",
          "args": [
            "disk->bus"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No disk with bus '%s' and target '%s'\""
          ],
          "line": 3561
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dst"
          ],
          "line": 3557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "sdkdisk"
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dst"
          ],
          "line": 3551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "disk->dst",
            "dst"
          ],
          "line": 3550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetDiskId",
          "args": [
            "sdkdisk",
            "&bus",
            "&dst"
          ],
          "line": 3547
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetDiskId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "607-643",
          "snippet": "static int\nprlsdkGetDiskId(PRL_HANDLE disk, int *bus, char **dst)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 pos, ifType;\n\n    pret = PrlVmDev_GetStackIndex(disk, &pos);\n    prlsdkCheckRetExit(pret, -1);\n\n    pret = PrlVmDev_GetIfaceType(disk, &ifType);\n    prlsdkCheckRetExit(pret, -1);\n\n    switch (ifType) {\n    case PMS_IDE_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_IDE;\n        *dst = virIndexToDiskName(pos, \"hd\");\n        break;\n    case PMS_SCSI_DEVICE:\n    case PMS_UNKNOWN_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_SCSI;\n        *dst = virIndexToDiskName(pos, \"sd\");\n        break;\n    case PMS_SATA_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_SATA;\n        *dst = virIndexToDiskName(pos, \"sd\");\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown disk bus: %X\"), ifType);\n        return -1;\n    }\n\n    if (NULL == *dst)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int\nprlsdkGetDiskId(PRL_HANDLE disk, int *bus, char **dst)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 pos, ifType;\n\n    pret = PrlVmDev_GetStackIndex(disk, &pos);\n    prlsdkCheckRetExit(pret, -1);\n\n    pret = PrlVmDev_GetIfaceType(disk, &ifType);\n    prlsdkCheckRetExit(pret, -1);\n\n    switch (ifType) {\n    case PMS_IDE_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_IDE;\n        *dst = virIndexToDiskName(pos, \"hd\");\n        break;\n    case PMS_SCSI_DEVICE:\n    case PMS_UNKNOWN_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_SCSI;\n        *dst = virIndexToDiskName(pos, \"sd\");\n        break;\n    case PMS_SATA_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_SATA;\n        *dst = virIndexToDiskName(pos, \"sd\");\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown disk bus: %X\"), ifType);\n        return -1;\n    }\n\n    if (NULL == *dst)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 3545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetDevByType",
          "args": [
            "sdkdom",
            "devType",
            "i",
            "&sdkdisk"
          ],
          "line": 3544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 3541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetDevsCountByType",
          "args": [
            "sdkdom",
            "devType",
            "&num"
          ],
          "line": 3540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 num;\n    size_t i;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int bus;\n    char *dst = NULL;\n    PRL_DEVICE_TYPE devType;\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK)\n        devType = PDE_HARD_DISK;\n    else\n        devType = PDE_OPTICAL_DISK;\n\n    pret = PrlVmCfg_GetDevsCountByType(sdkdom, devType, &num);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < num; ++i) {\n        pret = PrlVmCfg_GetDevByType(sdkdom, devType, i, &sdkdisk);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (prlsdkGetDiskId(sdkdisk, &bus, &dst) < 0)\n            goto error;\n\n        if (disk->bus == bus && STREQ(disk->dst, dst)) {\n            VIR_FREE(dst);\n            return sdkdisk;\n        }\n\n        PrlHandle_Free(sdkdisk);\n        sdkdisk = PRL_INVALID_HANDLE;\n        VIR_FREE(dst);\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"No disk with bus '%s' and target '%s'\"),\n                   virDomainDiskBusTypeToString(disk->bus), disk->dst);\n    return PRL_INVALID_HANDLE;\n\n error:\n    VIR_FREE(dst);\n    PrlHandle_Free(sdkdisk);\n    return PRL_INVALID_HANDLE;\n}"
  },
  {
    "function_name": "prlsdkConfigureDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "3428-3522",
    "snippet": "static int prlsdkConfigureDisk(vzDriverPtr driver,\n                               PRL_HANDLE sdkdom,\n                               virDomainDiskDefPtr disk,\n                               bool create)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int ret = -1;\n    PRL_VM_DEV_EMULATION_TYPE emutype;\n    PRL_MASS_STORAGE_INTERFACE_TYPE sdkbus;\n    int idx;\n    virDomainDeviceDriveAddressPtr drive;\n    PRL_DEVICE_TYPE devType;\n    PRL_CLUSTERED_DEVICE_SUBTYPE scsiModel;\n    const char *path = disk->src->path ? : \"\";\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK)\n        devType = PDE_HARD_DISK;\n    else\n        devType = PDE_OPTICAL_DISK;\n\n    if (create) {\n        pret = PrlVmCfg_CreateVmDev(sdkdom, devType, &sdkdisk);\n        prlsdkCheckRetGoto(pret, cleanup);\n    } else {\n        sdkdisk = prlsdkGetDisk(sdkdom, disk);\n        if (sdkdisk == PRL_INVALID_HANDLE)\n            return -1;\n    }\n\n    pret = PrlVmDev_SetEnabled(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (disk->src->type == VIR_STORAGE_TYPE_FILE)\n        emutype = PDT_USE_IMAGE_FILE;\n    else\n        emutype = PDT_USE_REAL_DEVICE;\n\n    pret = PrlVmDev_SetEmulatedType(sdkdisk, emutype);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetSysName(sdkdisk, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetFriendlyName(sdkdisk, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    drive = &disk->info.addr.drive;\n\n    switch (disk->bus) {\n    case VIR_DOMAIN_DISK_BUS_IDE:\n        sdkbus = PMS_IDE_DEVICE;\n        idx = 2 * drive->bus + drive->unit;\n        break;\n    case VIR_DOMAIN_DISK_BUS_SCSI:\n        sdkbus = PMS_SCSI_DEVICE;\n        idx = drive->unit;\n        break;\n    case VIR_DOMAIN_DISK_BUS_SATA:\n        sdkbus = PMS_SATA_DEVICE;\n        idx = drive->unit;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified disk bus is not \"\n                         \"supported by vz driver.\"));\n        goto cleanup;\n    }\n\n    if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (vzGetDefaultSCSIModel(driver, &scsiModel) < 0)\n            goto cleanup;\n        pret = PrlVmDev_SetSubType(sdkdisk, scsiModel);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDev_SetIfaceType(sdkdisk, sdkbus);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetStackIndex(sdkdisk, idx);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (devType == PDE_HARD_DISK) {\n        pret = PrlVmDevHd_SetSerialNumber(sdkdisk, disk->serial);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    return 0;\n cleanup:\n    PrlHandle_Free(sdkdisk);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);",
      "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "sdkdisk"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevHd_SetSerialNumber",
          "args": [
            "sdkdisk",
            "disk->serial"
          ],
          "line": 3514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetStackIndex",
          "args": [
            "sdkdisk",
            "idx"
          ],
          "line": 3510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetIfaceType",
          "args": [
            "sdkdisk",
            "sdkbus"
          ],
          "line": 3507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetSubType",
          "args": [
            "sdkdisk",
            "scsiModel"
          ],
          "line": 3503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vzGetDefaultSCSIModel",
          "args": [
            "driver",
            "&scsiModel"
          ],
          "line": 3501
        },
        "resolved": true,
        "details": {
          "function_name": "vzGetDefaultSCSIModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_utils.c",
          "lines": "471-489",
          "snippet": "int vzGetDefaultSCSIModel(vzDriverPtr driver,\n                          PRL_CLUSTERED_DEVICE_SUBTYPE *scsiModel)\n{\n    switch ((int)driver->vzCaps.scsiControllerModel) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI:\n        *scsiModel = PCD_VIRTIO_SCSI;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC:\n        *scsiModel = PCD_BUSLOGIC;\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown SCSI controller model %s\"),\n                       virDomainControllerModelSCSITypeToString(\n                           driver->vzCaps.scsiControllerModel));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virtime.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virstring.h\"",
            "#include \"vz_sdk.h\"",
            "#include \"vz_utils.h\"",
            "#include \"virjson.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virtime.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virstring.h\"\n#include \"vz_sdk.h\"\n#include \"vz_utils.h\"\n#include \"virjson.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint vzGetDefaultSCSIModel(vzDriverPtr driver,\n                          PRL_CLUSTERED_DEVICE_SUBTYPE *scsiModel)\n{\n    switch ((int)driver->vzCaps.scsiControllerModel) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI:\n        *scsiModel = PCD_VIRTIO_SCSI;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC:\n        *scsiModel = PCD_BUSLOGIC;\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown SCSI controller model %s\"),\n                       virDomainControllerModelSCSITypeToString(\n                           driver->vzCaps.scsiControllerModel));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Specified disk bus is not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Specified disk bus is not \"\n                         \"supported by vz driver.\""
          ],
          "line": 3495
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetFriendlyName",
          "args": [
            "sdkdisk",
            "path"
          ],
          "line": 3475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetSysName",
          "args": [
            "sdkdisk",
            "path"
          ],
          "line": 3472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetEmulatedType",
          "args": [
            "sdkdisk",
            "emutype"
          ],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetConnected",
          "args": [
            "sdkdisk",
            "1"
          ],
          "line": 3461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetEnabled",
          "args": [
            "sdkdisk",
            "1"
          ],
          "line": 3458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetDisk",
          "args": [
            "sdkdom",
            "disk"
          ],
          "line": 3453
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3524-3569",
          "snippet": "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 num;\n    size_t i;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int bus;\n    char *dst = NULL;\n    PRL_DEVICE_TYPE devType;\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK)\n        devType = PDE_HARD_DISK;\n    else\n        devType = PDE_OPTICAL_DISK;\n\n    pret = PrlVmCfg_GetDevsCountByType(sdkdom, devType, &num);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < num; ++i) {\n        pret = PrlVmCfg_GetDevByType(sdkdom, devType, i, &sdkdisk);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (prlsdkGetDiskId(sdkdisk, &bus, &dst) < 0)\n            goto error;\n\n        if (disk->bus == bus && STREQ(disk->dst, dst)) {\n            VIR_FREE(dst);\n            return sdkdisk;\n        }\n\n        PrlHandle_Free(sdkdisk);\n        sdkdisk = PRL_INVALID_HANDLE;\n        VIR_FREE(dst);\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"No disk with bus '%s' and target '%s'\"),\n                   virDomainDiskBusTypeToString(disk->bus), disk->dst);\n    return PRL_INVALID_HANDLE;\n\n error:\n    VIR_FREE(dst);\n    PrlHandle_Free(sdkdisk);\n    return PRL_INVALID_HANDLE;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 num;\n    size_t i;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int bus;\n    char *dst = NULL;\n    PRL_DEVICE_TYPE devType;\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK)\n        devType = PDE_HARD_DISK;\n    else\n        devType = PDE_OPTICAL_DISK;\n\n    pret = PrlVmCfg_GetDevsCountByType(sdkdom, devType, &num);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < num; ++i) {\n        pret = PrlVmCfg_GetDevByType(sdkdom, devType, i, &sdkdisk);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (prlsdkGetDiskId(sdkdisk, &bus, &dst) < 0)\n            goto error;\n\n        if (disk->bus == bus && STREQ(disk->dst, dst)) {\n            VIR_FREE(dst);\n            return sdkdisk;\n        }\n\n        PrlHandle_Free(sdkdisk);\n        sdkdisk = PRL_INVALID_HANDLE;\n        VIR_FREE(dst);\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"No disk with bus '%s' and target '%s'\"),\n                   virDomainDiskBusTypeToString(disk->bus), disk->dst);\n    return PRL_INVALID_HANDLE;\n\n error:\n    VIR_FREE(dst);\n    PrlHandle_Free(sdkdisk);\n    return PRL_INVALID_HANDLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_CreateVmDev",
          "args": [
            "sdkdom",
            "devType",
            "&sdkdisk"
          ],
          "line": 3450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int prlsdkConfigureDisk(vzDriverPtr driver,\n                               PRL_HANDLE sdkdom,\n                               virDomainDiskDefPtr disk,\n                               bool create)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdkdisk = PRL_INVALID_HANDLE;\n    int ret = -1;\n    PRL_VM_DEV_EMULATION_TYPE emutype;\n    PRL_MASS_STORAGE_INTERFACE_TYPE sdkbus;\n    int idx;\n    virDomainDeviceDriveAddressPtr drive;\n    PRL_DEVICE_TYPE devType;\n    PRL_CLUSTERED_DEVICE_SUBTYPE scsiModel;\n    const char *path = disk->src->path ? : \"\";\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK)\n        devType = PDE_HARD_DISK;\n    else\n        devType = PDE_OPTICAL_DISK;\n\n    if (create) {\n        pret = PrlVmCfg_CreateVmDev(sdkdom, devType, &sdkdisk);\n        prlsdkCheckRetGoto(pret, cleanup);\n    } else {\n        sdkdisk = prlsdkGetDisk(sdkdom, disk);\n        if (sdkdisk == PRL_INVALID_HANDLE)\n            return -1;\n    }\n\n    pret = PrlVmDev_SetEnabled(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdkdisk, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (disk->src->type == VIR_STORAGE_TYPE_FILE)\n        emutype = PDT_USE_IMAGE_FILE;\n    else\n        emutype = PDT_USE_REAL_DEVICE;\n\n    pret = PrlVmDev_SetEmulatedType(sdkdisk, emutype);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetSysName(sdkdisk, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetFriendlyName(sdkdisk, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    drive = &disk->info.addr.drive;\n\n    switch (disk->bus) {\n    case VIR_DOMAIN_DISK_BUS_IDE:\n        sdkbus = PMS_IDE_DEVICE;\n        idx = 2 * drive->bus + drive->unit;\n        break;\n    case VIR_DOMAIN_DISK_BUS_SCSI:\n        sdkbus = PMS_SCSI_DEVICE;\n        idx = drive->unit;\n        break;\n    case VIR_DOMAIN_DISK_BUS_SATA:\n        sdkbus = PMS_SATA_DEVICE;\n        idx = drive->unit;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified disk bus is not \"\n                         \"supported by vz driver.\"));\n        goto cleanup;\n    }\n\n    if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (vzGetDefaultSCSIModel(driver, &scsiModel) < 0)\n            goto cleanup;\n        pret = PrlVmDev_SetSubType(sdkdisk, scsiModel);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDev_SetIfaceType(sdkdisk, sdkbus);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetStackIndex(sdkdisk, idx);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (devType == PDE_HARD_DISK) {\n        pret = PrlVmDevHd_SetSerialNumber(sdkdisk, disk->serial);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    return 0;\n cleanup:\n    PrlHandle_Free(sdkdisk);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkFindNetByMAC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "3389-3426",
    "snippet": "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 adaptersCount;\n    PRL_UINT32 i;\n    PRL_HANDLE adapter = PRL_INVALID_HANDLE;\n    char adapterMac[PRL_MAC_STRING_BUFNAME];\n    char expectedMac[PRL_MAC_STRING_BUFNAME];\n    char virMac[VIR_MAC_STRING_BUFLEN];\n\n    prlsdkFormatMac(mac, expectedMac);\n\n    pret = PrlVmCfg_GetNetAdaptersCount(sdkdom, &adaptersCount);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < adaptersCount; ++i) {\n        pret = PrlVmCfg_GetNetAdapter(sdkdom, i, &adapter);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = prlsdkGetStringParamBuf(PrlVmDevNet_GetMacAddress,\n                                       adapter, adapterMac, sizeof(adapterMac));\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (STREQ(adapterMac, expectedMac))\n            return adapter;\n\n        PrlHandle_Free(adapter);\n        adapter = PRL_INVALID_HANDLE;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"No net with mac '%s'\"), virMacAddrFormat(mac, virMac));\n\n cleanup:\n    PrlHandle_Free(adapter);\n    return adapter;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PRL_MAC_STRING_BUFNAME  13"
    ],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);",
      "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "adapter"
          ],
          "line": 3424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"No net with mac '%s'\")",
            "virMacAddrFormat(mac, virMac)"
          ],
          "line": 3420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "mac",
            "virMac"
          ],
          "line": 3421
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No net with mac '%s'\""
          ],
          "line": 3421
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "adapter"
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "adapterMac",
            "expectedMac"
          ],
          "line": 3413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetStringParamBuf",
          "args": [
            "PrlVmDevNet_GetMacAddress",
            "adapter",
            "adapterMac",
            "sizeof(adapterMac)"
          ],
          "line": 3409
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetStringParamBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "322-328",
          "snippet": "static PRL_RESULT\nprlsdkGetStringParamBuf(prlsdkParamGetterType getter,\n                        PRL_HANDLE handle, char *buf, size_t size)\n{\n    PRL_UINT32 buflen = size;\n    return getter(handle, buf, &buflen);\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_RESULT\nprlsdkGetStringParamBuf(prlsdkParamGetterType getter,\n                        PRL_HANDLE handle, char *buf, size_t size)\n{\n    PRL_UINT32 buflen = size;\n    return getter(handle, buf, &buflen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetNetAdapter",
          "args": [
            "sdkdom",
            "i",
            "&adapter"
          ],
          "line": 3406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetNetAdaptersCount",
          "args": [
            "sdkdom",
            "&adaptersCount"
          ],
          "line": 3402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkFormatMac",
          "args": [
            "mac",
            "expectedMac"
          ],
          "line": 3400
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkFormatMac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3155-3163",
          "snippet": "static const char * prlsdkFormatMac(virMacAddrPtr mac, char *macstr)\n{\n    g_snprintf(macstr, PRL_MAC_STRING_BUFNAME,\n               \"%02X%02X%02X%02X%02X%02X\",\n               mac->addr[0], mac->addr[1], mac->addr[2],\n               mac->addr[3], mac->addr[4], mac->addr[5]);\n    macstr[PRL_MAC_STRING_BUFNAME - 1] = '\\0';\n    return macstr;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PRL_MAC_STRING_BUFNAME  13"
          ],
          "globals_used": [
            "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define PRL_MAC_STRING_BUFNAME  13\n\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);\n\nstatic const char * prlsdkFormatMac(virMacAddrPtr mac, char *macstr)\n{\n    g_snprintf(macstr, PRL_MAC_STRING_BUFNAME,\n               \"%02X%02X%02X%02X%02X%02X\",\n               mac->addr[0], mac->addr[1], mac->addr[2],\n               mac->addr[3], mac->addr[4], mac->addr[5]);\n    macstr[PRL_MAC_STRING_BUFNAME - 1] = '\\0';\n    return macstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define PRL_MAC_STRING_BUFNAME  13\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);\n\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 adaptersCount;\n    PRL_UINT32 i;\n    PRL_HANDLE adapter = PRL_INVALID_HANDLE;\n    char adapterMac[PRL_MAC_STRING_BUFNAME];\n    char expectedMac[PRL_MAC_STRING_BUFNAME];\n    char virMac[VIR_MAC_STRING_BUFLEN];\n\n    prlsdkFormatMac(mac, expectedMac);\n\n    pret = PrlVmCfg_GetNetAdaptersCount(sdkdom, &adaptersCount);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < adaptersCount; ++i) {\n        pret = PrlVmCfg_GetNetAdapter(sdkdom, i, &adapter);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = prlsdkGetStringParamBuf(PrlVmDevNet_GetMacAddress,\n                                       adapter, adapterMac, sizeof(adapterMac));\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (STREQ(adapterMac, expectedMac))\n            return adapter;\n\n        PrlHandle_Free(adapter);\n        adapter = PRL_INVALID_HANDLE;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"No net with mac '%s'\"), virMacAddrFormat(mac, virMac));\n\n cleanup:\n    PrlHandle_Free(adapter);\n    return adapter;\n}"
  },
  {
    "function_name": "prlsdkConfigureNet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "3249-3387",
    "snippet": "static int prlsdkConfigureNet(vzDriverPtr driver G_GNUC_UNUSED,\n                              virDomainObjPtr dom G_GNUC_UNUSED,\n                              PRL_HANDLE sdkdom,\n                              virDomainNetDefPtr net,\n                              bool isCt, bool create)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdknet = PRL_INVALID_HANDLE;\n    PRL_HANDLE addrlist = PRL_INVALID_HANDLE;\n    size_t i;\n    int ret = -1;\n    char macstr[PRL_MAC_STRING_BUFNAME];\n    char *addrstr = NULL;\n    bool ipv6present = false;\n    bool ipv4present = false;\n\n    if (prlsdkCheckNetUnsupportedParams(net) < 0)\n        return -1;\n\n    if (create) {\n        pret = PrlVmCfg_CreateVmDev(sdkdom, PDE_GENERIC_NETWORK_ADAPTER, &sdknet);\n        prlsdkCheckRetGoto(pret, cleanup);\n    } else {\n        sdknet = prlsdkFindNetByMAC(sdkdom, &net->mac);\n        if (sdknet == PRL_INVALID_HANDLE)\n            return -1;\n    }\n\n    pret = PrlVmDev_SetEnabled(sdknet, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdknet, net->linkstate !=\n                                 VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN);\n\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (net->ifname) {\n        pret = PrlVmDevNet_SetHostInterfaceName(sdknet, net->ifname);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    prlsdkFormatMac(&net->mac, macstr);\n    pret = PrlVmDevNet_SetMacAddress(sdknet, macstr);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlApi_CreateStringsList(&addrlist);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < net->guestIP.nips; i++) {\n        char *tmpstr;\n\n        if (AF_INET == VIR_SOCKET_ADDR_FAMILY(&net->guestIP.ips[i]->address))\n            ipv4present = true;\n        else if (AF_INET6 == VIR_SOCKET_ADDR_FAMILY(&net->guestIP.ips[i]->address))\n            ipv6present = true;\n        else\n            continue;\n\n        if (!(tmpstr = virSocketAddrFormat(&net->guestIP.ips[i]->address)))\n            goto cleanup;\n\n        addrstr = g_strdup_printf(\"%s/%d\", tmpstr, net->guestIP.ips[i]->prefix);\n\n        VIR_FREE(tmpstr);\n        pret = PrlStrList_AddItem(addrlist, addrstr);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        VIR_FREE(addrstr);\n    }\n\n    if (ipv4present || ipv6present) {\n        pret = PrlVmDevNet_SetNetAddresses(sdknet, addrlist);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDevNet_SetConfigureWithDhcp(sdknet, !ipv4present);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevNet_SetConfigureWithDhcpIPv6(sdknet, !ipv6present);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevNet_SetAutoApply(sdknet, true);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (prlsdkConfigureGateways(sdknet, net))\n        goto cleanup;\n\n    if (isCt) {\n        if (net->model != VIR_DOMAIN_NET_MODEL_UNKNOWN)\n            VIR_WARN(\"Setting network adapter for containers is not \"\n                     \"supported by vz driver.\");\n    } else {\n        if (net->model == VIR_DOMAIN_NET_MODEL_RTL8139) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_RTL);\n        } else if (net->model == VIR_DOMAIN_NET_MODEL_E1000) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_E1000);\n        } else if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_VIRTIO);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Specified network adapter model is not \"\n                             \"supported by vz driver.\"));\n            goto cleanup;\n        }\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n        if (STREQ(net->data.network.name, PARALLELS_DOMAIN_ROUTED_NETWORK_NAME)) {\n            pret = PrlVmDev_SetEmulatedType(sdknet, PNA_ROUTED);\n            prlsdkCheckRetGoto(pret, cleanup);\n        } else {\n            pret = PrlVmDev_SetEmulatedType(sdknet, PNA_BRIDGED_NETWORK);\n            prlsdkCheckRetGoto(pret, cleanup);\n\n            pret = PrlVmDevNet_SetVirtualNetworkId(sdknet, net->data.network.name);\n            prlsdkCheckRetGoto(pret, cleanup);\n        }\n\n    } else if (net->type == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n\n        pret = PrlVmDev_SetEmulatedType(sdknet, PNA_BRIDGE);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlVmDevNet_SetVirtualNetworkId(sdknet, net->data.bridge.brname);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDevNet_SetPktFilterPreventMacSpoof(sdknet,\n                net->trustGuestRxFilters == VIR_TRISTATE_BOOL_YES);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(addrstr);\n    PrlHandle_Free(addrlist);\n    PrlHandle_Free(sdknet);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PRL_MAC_STRING_BUFNAME  13"
    ],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);",
      "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "sdknet"
          ],
          "line": 3385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "addrlist"
          ],
          "line": 3384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addrstr"
          ],
          "line": 3383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevNet_SetPktFilterPreventMacSpoof",
          "args": [
            "sdknet",
            "net->trustGuestRxFilters == VIR_TRISTATE_BOOL_YES"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevNet_SetVirtualNetworkId",
          "args": [
            "sdknet",
            "net->data.bridge.brname"
          ],
          "line": 3373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetEmulatedType",
          "args": [
            "sdknet",
            "PNA_BRIDGE"
          ],
          "line": 3370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevNet_SetVirtualNetworkId",
          "args": [
            "sdknet",
            "net->data.network.name"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetEmulatedType",
          "args": [
            "sdknet",
            "PNA_BRIDGED_NETWORK"
          ],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetEmulatedType",
          "args": [
            "sdknet",
            "PNA_ROUTED"
          ],
          "line": 3358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "net->data.network.name",
            "PARALLELS_DOMAIN_ROUTED_NETWORK_NAME"
          ],
          "line": 3357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Specified network adapter model is not \"\n                             \"supported by vz driver.\")"
          ],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Specified network adapter model is not \"\n                             \"supported by vz driver.\""
          ],
          "line": 3349
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlVmDevNet_SetAdapterType",
          "args": [
            "sdknet",
            "PNT_VIRTIO"
          ],
          "line": 3346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevNet_SetAdapterType",
          "args": [
            "sdknet",
            "PNT_E1000"
          ],
          "line": 3344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevNet_SetAdapterType",
          "args": [
            "sdknet",
            "PNT_RTL"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Setting network adapter for containers is not \"\n                     \"supported by vz driver.\""
          ],
          "line": 3338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkConfigureGateways",
          "args": [
            "sdknet",
            "net"
          ],
          "line": 3333
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConfigureGateways",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3165-3247",
          "snippet": "static int prlsdkConfigureGateways(PRL_HANDLE sdknet, virDomainNetDefPtr net)\n{\n    int ret = -1;\n    size_t i;\n    virNetDevIPRoutePtr route4 = NULL, route6 = NULL;\n    char *gw4 = NULL, *gw6 = NULL;\n    PRL_RESULT pret;\n\n    for (i = 0; i < net->guestIP.nroutes; i++) {\n        virSocketAddrPtr addrdst, gateway;\n        virSocketAddr zero;\n\n        addrdst = virNetDevIPRouteGetAddress(net->guestIP.routes[i]);\n        gateway = virNetDevIPRouteGetGateway(net->guestIP.routes[i]);\n\n        ignore_value(virSocketAddrParse(&zero,\n                                (VIR_SOCKET_ADDR_IS_FAMILY(addrdst, AF_INET)\n                                 ? VIR_SOCKET_ADDR_IPV4_ALL\n                                 : VIR_SOCKET_ADDR_IPV6_ALL),\n                                VIR_SOCKET_ADDR_FAMILY(addrdst)));\n        /* virSocketAddrParse raises an error\n         * and we are not going to report it, reset it explicitly */\n        virResetLastError();\n\n        if (!virSocketAddrEqual(addrdst, &zero)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Support only default gateway\"));\n            return -1;\n        }\n\n        switch (VIR_SOCKET_ADDR_FAMILY(gateway)) {\n        case AF_INET:\n            if (route4) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Support only one IPv4 default gateway\"));\n                return -1;\n            }\n\n            route4 = net->guestIP.routes[i];\n\n            break;\n        case AF_INET6:\n            if (route6) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Support only one IPv6 default gateway\"));\n                return -1;\n            }\n\n            route6 = net->guestIP.routes[i];\n\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported address family %d \"\n                             \"Only IPv4 or IPv6 default gateway\"),\n                           VIR_SOCKET_ADDR_FAMILY(gateway));\n\n            return -1;\n        }\n    }\n\n    if (route4 &&\n        !(gw4 = virSocketAddrFormat(virNetDevIPRouteGetGateway(route4))))\n        goto cleanup;\n\n    pret = PrlVmDevNet_SetDefaultGateway(sdknet, gw4 ? : \"\");\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (route6 &&\n        !(gw6 = virSocketAddrFormat(virNetDevIPRouteGetGateway(route6))))\n        goto cleanup;\n\n    pret = PrlVmDevNet_SetDefaultGatewayIPv6(sdknet, gw6 ? : \"\");\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(gw4);\n    VIR_FREE(gw6);\n\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int prlsdkConfigureGateways(PRL_HANDLE sdknet, virDomainNetDefPtr net)\n{\n    int ret = -1;\n    size_t i;\n    virNetDevIPRoutePtr route4 = NULL, route6 = NULL;\n    char *gw4 = NULL, *gw6 = NULL;\n    PRL_RESULT pret;\n\n    for (i = 0; i < net->guestIP.nroutes; i++) {\n        virSocketAddrPtr addrdst, gateway;\n        virSocketAddr zero;\n\n        addrdst = virNetDevIPRouteGetAddress(net->guestIP.routes[i]);\n        gateway = virNetDevIPRouteGetGateway(net->guestIP.routes[i]);\n\n        ignore_value(virSocketAddrParse(&zero,\n                                (VIR_SOCKET_ADDR_IS_FAMILY(addrdst, AF_INET)\n                                 ? VIR_SOCKET_ADDR_IPV4_ALL\n                                 : VIR_SOCKET_ADDR_IPV6_ALL),\n                                VIR_SOCKET_ADDR_FAMILY(addrdst)));\n        /* virSocketAddrParse raises an error\n         * and we are not going to report it, reset it explicitly */\n        virResetLastError();\n\n        if (!virSocketAddrEqual(addrdst, &zero)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Support only default gateway\"));\n            return -1;\n        }\n\n        switch (VIR_SOCKET_ADDR_FAMILY(gateway)) {\n        case AF_INET:\n            if (route4) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Support only one IPv4 default gateway\"));\n                return -1;\n            }\n\n            route4 = net->guestIP.routes[i];\n\n            break;\n        case AF_INET6:\n            if (route6) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Support only one IPv6 default gateway\"));\n                return -1;\n            }\n\n            route6 = net->guestIP.routes[i];\n\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported address family %d \"\n                             \"Only IPv4 or IPv6 default gateway\"),\n                           VIR_SOCKET_ADDR_FAMILY(gateway));\n\n            return -1;\n        }\n    }\n\n    if (route4 &&\n        !(gw4 = virSocketAddrFormat(virNetDevIPRouteGetGateway(route4))))\n        goto cleanup;\n\n    pret = PrlVmDevNet_SetDefaultGateway(sdknet, gw4 ? : \"\");\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (route6 &&\n        !(gw6 = virSocketAddrFormat(virNetDevIPRouteGetGateway(route6))))\n        goto cleanup;\n\n    pret = PrlVmDevNet_SetDefaultGatewayIPv6(sdknet, gw6 ? : \"\");\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(gw4);\n    VIR_FREE(gw6);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevNet_SetAutoApply",
          "args": [
            "sdknet",
            "true"
          ],
          "line": 3330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevNet_SetConfigureWithDhcpIPv6",
          "args": [
            "sdknet",
            "!ipv6present"
          ],
          "line": 3327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevNet_SetConfigureWithDhcp",
          "args": [
            "sdknet",
            "!ipv4present"
          ],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevNet_SetNetAddresses",
          "args": [
            "sdknet",
            "addrlist"
          ],
          "line": 3320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addrstr"
          ],
          "line": 3316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlStrList_AddItem",
          "args": [
            "addrlist",
            "addrstr"
          ],
          "line": 3313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmpstr"
          ],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "&net->guestIP.ips[i]->address"
          ],
          "line": 3307
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "&net->guestIP.ips[i]->address"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "&net->guestIP.ips[i]->address"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlApi_CreateStringsList",
          "args": [
            "&addrlist"
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevNet_SetMacAddress",
          "args": [
            "sdknet",
            "macstr"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkFormatMac",
          "args": [
            "&net->mac",
            "macstr"
          ],
          "line": 3290
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkFormatMac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3155-3163",
          "snippet": "static const char * prlsdkFormatMac(virMacAddrPtr mac, char *macstr)\n{\n    g_snprintf(macstr, PRL_MAC_STRING_BUFNAME,\n               \"%02X%02X%02X%02X%02X%02X\",\n               mac->addr[0], mac->addr[1], mac->addr[2],\n               mac->addr[3], mac->addr[4], mac->addr[5]);\n    macstr[PRL_MAC_STRING_BUFNAME - 1] = '\\0';\n    return macstr;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PRL_MAC_STRING_BUFNAME  13"
          ],
          "globals_used": [
            "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define PRL_MAC_STRING_BUFNAME  13\n\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);\n\nstatic const char * prlsdkFormatMac(virMacAddrPtr mac, char *macstr)\n{\n    g_snprintf(macstr, PRL_MAC_STRING_BUFNAME,\n               \"%02X%02X%02X%02X%02X%02X\",\n               mac->addr[0], mac->addr[1], mac->addr[2],\n               mac->addr[3], mac->addr[4], mac->addr[5]);\n    macstr[PRL_MAC_STRING_BUFNAME - 1] = '\\0';\n    return macstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevNet_SetHostInterfaceName",
          "args": [
            "sdknet",
            "net->ifname"
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetConnected",
          "args": [
            "sdknet",
            "net->linkstate !=\n                                 VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN"
          ],
          "line": 3280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetEnabled",
          "args": [
            "sdknet",
            "1"
          ],
          "line": 3277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkFindNetByMAC",
          "args": [
            "sdkdom",
            "&net->mac"
          ],
          "line": 3272
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkFindNetByMAC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "3389-3426",
          "snippet": "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 adaptersCount;\n    PRL_UINT32 i;\n    PRL_HANDLE adapter = PRL_INVALID_HANDLE;\n    char adapterMac[PRL_MAC_STRING_BUFNAME];\n    char expectedMac[PRL_MAC_STRING_BUFNAME];\n    char virMac[VIR_MAC_STRING_BUFLEN];\n\n    prlsdkFormatMac(mac, expectedMac);\n\n    pret = PrlVmCfg_GetNetAdaptersCount(sdkdom, &adaptersCount);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < adaptersCount; ++i) {\n        pret = PrlVmCfg_GetNetAdapter(sdkdom, i, &adapter);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = prlsdkGetStringParamBuf(PrlVmDevNet_GetMacAddress,\n                                       adapter, adapterMac, sizeof(adapterMac));\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (STREQ(adapterMac, expectedMac))\n            return adapter;\n\n        PrlHandle_Free(adapter);\n        adapter = PRL_INVALID_HANDLE;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"No net with mac '%s'\"), virMacAddrFormat(mac, virMac));\n\n cleanup:\n    PrlHandle_Free(adapter);\n    return adapter;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PRL_MAC_STRING_BUFNAME  13"
          ],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define PRL_MAC_STRING_BUFNAME  13\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);\n\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 adaptersCount;\n    PRL_UINT32 i;\n    PRL_HANDLE adapter = PRL_INVALID_HANDLE;\n    char adapterMac[PRL_MAC_STRING_BUFNAME];\n    char expectedMac[PRL_MAC_STRING_BUFNAME];\n    char virMac[VIR_MAC_STRING_BUFLEN];\n\n    prlsdkFormatMac(mac, expectedMac);\n\n    pret = PrlVmCfg_GetNetAdaptersCount(sdkdom, &adaptersCount);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < adaptersCount; ++i) {\n        pret = PrlVmCfg_GetNetAdapter(sdkdom, i, &adapter);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = prlsdkGetStringParamBuf(PrlVmDevNet_GetMacAddress,\n                                       adapter, adapterMac, sizeof(adapterMac));\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (STREQ(adapterMac, expectedMac))\n            return adapter;\n\n        PrlHandle_Free(adapter);\n        adapter = PRL_INVALID_HANDLE;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"No net with mac '%s'\"), virMacAddrFormat(mac, virMac));\n\n cleanup:\n    PrlHandle_Free(adapter);\n    return adapter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_CreateVmDev",
          "args": [
            "sdkdom",
            "PDE_GENERIC_NETWORK_ADAPTER",
            "&sdknet"
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckNetUnsupportedParams",
          "args": [
            "net"
          ],
          "line": 3265
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkCheckNetUnsupportedParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2890-2964",
          "snippet": "static int prlsdkCheckNetUnsupportedParams(virDomainNetDefPtr net)\n{\n    if (net->type != VIR_DOMAIN_NET_TYPE_NETWORK &&\n        net->type != VIR_DOMAIN_NET_TYPE_BRIDGE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified network adapter type is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->backend.tap || net->backend.vhost) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Interface backend parameters are not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->data.network.portgroup) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Virtual network portgroups are not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->tune.sndbuf_specified) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting interface sndbuf is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->script) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting interface script is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->ifname_guest) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting guest interface name is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting device info for network devices is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->filter) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting network filter is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->bandwidth) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting network bandwidth is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->vlan.trunk) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting up vlans is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int prlsdkCheckNetUnsupportedParams(virDomainNetDefPtr net)\n{\n    if (net->type != VIR_DOMAIN_NET_TYPE_NETWORK &&\n        net->type != VIR_DOMAIN_NET_TYPE_BRIDGE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified network adapter type is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->backend.tap || net->backend.vhost) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Interface backend parameters are not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->data.network.portgroup) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Virtual network portgroups are not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->tune.sndbuf_specified) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting interface sndbuf is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->script) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting interface script is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->ifname_guest) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting guest interface name is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting device info for network devices is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->filter) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting network filter is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->bandwidth) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting network bandwidth is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->vlan.trunk) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting up vlans is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define PRL_MAC_STRING_BUFNAME  13\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);\n\nstatic int prlsdkConfigureNet(vzDriverPtr driver G_GNUC_UNUSED,\n                              virDomainObjPtr dom G_GNUC_UNUSED,\n                              PRL_HANDLE sdkdom,\n                              virDomainNetDefPtr net,\n                              bool isCt, bool create)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdknet = PRL_INVALID_HANDLE;\n    PRL_HANDLE addrlist = PRL_INVALID_HANDLE;\n    size_t i;\n    int ret = -1;\n    char macstr[PRL_MAC_STRING_BUFNAME];\n    char *addrstr = NULL;\n    bool ipv6present = false;\n    bool ipv4present = false;\n\n    if (prlsdkCheckNetUnsupportedParams(net) < 0)\n        return -1;\n\n    if (create) {\n        pret = PrlVmCfg_CreateVmDev(sdkdom, PDE_GENERIC_NETWORK_ADAPTER, &sdknet);\n        prlsdkCheckRetGoto(pret, cleanup);\n    } else {\n        sdknet = prlsdkFindNetByMAC(sdkdom, &net->mac);\n        if (sdknet == PRL_INVALID_HANDLE)\n            return -1;\n    }\n\n    pret = PrlVmDev_SetEnabled(sdknet, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetConnected(sdknet, net->linkstate !=\n                                 VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN);\n\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (net->ifname) {\n        pret = PrlVmDevNet_SetHostInterfaceName(sdknet, net->ifname);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    prlsdkFormatMac(&net->mac, macstr);\n    pret = PrlVmDevNet_SetMacAddress(sdknet, macstr);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlApi_CreateStringsList(&addrlist);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < net->guestIP.nips; i++) {\n        char *tmpstr;\n\n        if (AF_INET == VIR_SOCKET_ADDR_FAMILY(&net->guestIP.ips[i]->address))\n            ipv4present = true;\n        else if (AF_INET6 == VIR_SOCKET_ADDR_FAMILY(&net->guestIP.ips[i]->address))\n            ipv6present = true;\n        else\n            continue;\n\n        if (!(tmpstr = virSocketAddrFormat(&net->guestIP.ips[i]->address)))\n            goto cleanup;\n\n        addrstr = g_strdup_printf(\"%s/%d\", tmpstr, net->guestIP.ips[i]->prefix);\n\n        VIR_FREE(tmpstr);\n        pret = PrlStrList_AddItem(addrlist, addrstr);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        VIR_FREE(addrstr);\n    }\n\n    if (ipv4present || ipv6present) {\n        pret = PrlVmDevNet_SetNetAddresses(sdknet, addrlist);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDevNet_SetConfigureWithDhcp(sdknet, !ipv4present);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevNet_SetConfigureWithDhcpIPv6(sdknet, !ipv6present);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevNet_SetAutoApply(sdknet, true);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (prlsdkConfigureGateways(sdknet, net))\n        goto cleanup;\n\n    if (isCt) {\n        if (net->model != VIR_DOMAIN_NET_MODEL_UNKNOWN)\n            VIR_WARN(\"Setting network adapter for containers is not \"\n                     \"supported by vz driver.\");\n    } else {\n        if (net->model == VIR_DOMAIN_NET_MODEL_RTL8139) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_RTL);\n        } else if (net->model == VIR_DOMAIN_NET_MODEL_E1000) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_E1000);\n        } else if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO) {\n            pret = PrlVmDevNet_SetAdapterType(sdknet, PNT_VIRTIO);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Specified network adapter model is not \"\n                             \"supported by vz driver.\"));\n            goto cleanup;\n        }\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n        if (STREQ(net->data.network.name, PARALLELS_DOMAIN_ROUTED_NETWORK_NAME)) {\n            pret = PrlVmDev_SetEmulatedType(sdknet, PNA_ROUTED);\n            prlsdkCheckRetGoto(pret, cleanup);\n        } else {\n            pret = PrlVmDev_SetEmulatedType(sdknet, PNA_BRIDGED_NETWORK);\n            prlsdkCheckRetGoto(pret, cleanup);\n\n            pret = PrlVmDevNet_SetVirtualNetworkId(sdknet, net->data.network.name);\n            prlsdkCheckRetGoto(pret, cleanup);\n        }\n\n    } else if (net->type == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n\n        pret = PrlVmDev_SetEmulatedType(sdknet, PNA_BRIDGE);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlVmDevNet_SetVirtualNetworkId(sdknet, net->data.bridge.brname);\n        prlsdkCheckRetGoto(pret, cleanup);\n    }\n\n    pret = PrlVmDevNet_SetPktFilterPreventMacSpoof(sdknet,\n                net->trustGuestRxFilters == VIR_TRISTATE_BOOL_YES);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(addrstr);\n    PrlHandle_Free(addrlist);\n    PrlHandle_Free(sdknet);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkConfigureGateways",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "3165-3247",
    "snippet": "static int prlsdkConfigureGateways(PRL_HANDLE sdknet, virDomainNetDefPtr net)\n{\n    int ret = -1;\n    size_t i;\n    virNetDevIPRoutePtr route4 = NULL, route6 = NULL;\n    char *gw4 = NULL, *gw6 = NULL;\n    PRL_RESULT pret;\n\n    for (i = 0; i < net->guestIP.nroutes; i++) {\n        virSocketAddrPtr addrdst, gateway;\n        virSocketAddr zero;\n\n        addrdst = virNetDevIPRouteGetAddress(net->guestIP.routes[i]);\n        gateway = virNetDevIPRouteGetGateway(net->guestIP.routes[i]);\n\n        ignore_value(virSocketAddrParse(&zero,\n                                (VIR_SOCKET_ADDR_IS_FAMILY(addrdst, AF_INET)\n                                 ? VIR_SOCKET_ADDR_IPV4_ALL\n                                 : VIR_SOCKET_ADDR_IPV6_ALL),\n                                VIR_SOCKET_ADDR_FAMILY(addrdst)));\n        /* virSocketAddrParse raises an error\n         * and we are not going to report it, reset it explicitly */\n        virResetLastError();\n\n        if (!virSocketAddrEqual(addrdst, &zero)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Support only default gateway\"));\n            return -1;\n        }\n\n        switch (VIR_SOCKET_ADDR_FAMILY(gateway)) {\n        case AF_INET:\n            if (route4) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Support only one IPv4 default gateway\"));\n                return -1;\n            }\n\n            route4 = net->guestIP.routes[i];\n\n            break;\n        case AF_INET6:\n            if (route6) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Support only one IPv6 default gateway\"));\n                return -1;\n            }\n\n            route6 = net->guestIP.routes[i];\n\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported address family %d \"\n                             \"Only IPv4 or IPv6 default gateway\"),\n                           VIR_SOCKET_ADDR_FAMILY(gateway));\n\n            return -1;\n        }\n    }\n\n    if (route4 &&\n        !(gw4 = virSocketAddrFormat(virNetDevIPRouteGetGateway(route4))))\n        goto cleanup;\n\n    pret = PrlVmDevNet_SetDefaultGateway(sdknet, gw4 ? : \"\");\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (route6 &&\n        !(gw6 = virSocketAddrFormat(virNetDevIPRouteGetGateway(route6))))\n        goto cleanup;\n\n    pret = PrlVmDevNet_SetDefaultGatewayIPv6(sdknet, gw6 ? : \"\");\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(gw4);\n    VIR_FREE(gw6);\n\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "gw6"
          ],
          "line": 3244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "gw4"
          ],
          "line": 3243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevNet_SetDefaultGatewayIPv6",
          "args": [
            "sdknet",
            "gw6 ? : \"\""
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "virNetDevIPRouteGetGateway(route6)"
          ],
          "line": 3234
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteGetGateway",
          "args": [
            "route6"
          ],
          "line": 3234
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteGetGateway",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "1035-1041",
          "snippet": "virSocketAddrPtr\nvirNetDevIPRouteGetGateway(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->gateway;\n    return NULL;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nvirSocketAddrPtr\nvirNetDevIPRouteGetGateway(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->gateway;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevNet_SetDefaultGateway",
          "args": [
            "sdknet",
            "gw4 ? : \"\""
          ],
          "line": 3230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported address family %d \"\n                             \"Only IPv4 or IPv6 default gateway\")",
            "VIR_SOCKET_ADDR_FAMILY(gateway)"
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "gateway"
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported address family %d \"\n                             \"Only IPv4 or IPv6 default gateway\""
          ],
          "line": 3218
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Support only one IPv6 default gateway\")"
          ],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Support only one IPv4 default gateway\")"
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "gateway"
          ],
          "line": 3195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Support only default gateway\")"
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrEqual",
          "args": [
            "addrdst",
            "&zero"
          ],
          "line": 3189
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "359-378",
          "snippet": "bool\nvirSocketAddrEqual(const virSocketAddr *s1, const virSocketAddr *s2)\n{\n    if (s1->data.stor.ss_family != s2->data.stor.ss_family)\n        return false;\n\n    switch (s1->data.stor.ss_family) {\n    case AF_INET:\n        return (memcmp(&s1->data.inet4.sin_addr.s_addr,\n                       &s2->data.inet4.sin_addr.s_addr,\n                       sizeof(s1->data.inet4.sin_addr.s_addr)) == 0 &&\n                s1->data.inet4.sin_port == s2->data.inet4.sin_port);\n    case AF_INET6:\n        return (memcmp(&s1->data.inet6.sin6_addr.s6_addr,\n                       &s2->data.inet6.sin6_addr.s6_addr,\n                       sizeof(s1->data.inet6.sin6_addr.s6_addr)) == 0 &&\n                s1->data.inet6.sin6_port == s2->data.inet6.sin6_port);\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nbool\nvirSocketAddrEqual(const virSocketAddr *s1, const virSocketAddr *s2)\n{\n    if (s1->data.stor.ss_family != s2->data.stor.ss_family)\n        return false;\n\n    switch (s1->data.stor.ss_family) {\n    case AF_INET:\n        return (memcmp(&s1->data.inet4.sin_addr.s_addr,\n                       &s2->data.inet4.sin_addr.s_addr,\n                       sizeof(s1->data.inet4.sin_addr.s_addr)) == 0 &&\n                s1->data.inet4.sin_port == s2->data.inet4.sin_port);\n    case AF_INET6:\n        return (memcmp(&s1->data.inet6.sin6_addr.s6_addr,\n                       &s2->data.inet6.sin6_addr.s6_addr,\n                       sizeof(s1->data.inet6.sin6_addr.s6_addr)) == 0 &&\n                s1->data.inet6.sin6_port == s2->data.inet6.sin6_port);\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 3187
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virSocketAddrParse(&zero,\n                                (VIR_SOCKET_ADDR_IS_FAMILY(addrdst, AF_INET)\n                                 ? VIR_SOCKET_ADDR_IPV4_ALL\n                                 : VIR_SOCKET_ADDR_IPV6_ALL),\n                                VIR_SOCKET_ADDR_FAMILY(addrdst))"
          ],
          "line": 3180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrParse",
          "args": [
            "&zero",
            "(VIR_SOCKET_ADDR_IS_FAMILY(addrdst, AF_INET)\n                                 ? VIR_SOCKET_ADDR_IPV4_ALL\n                                 : VIR_SOCKET_ADDR_IPV6_ALL)",
            "VIR_SOCKET_ADDR_FAMILY(addrdst)"
          ],
          "line": 3180
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "135-158",
          "snippet": "int virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "addrdst"
          ],
          "line": 3184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "addrdst",
            "AF_INET"
          ],
          "line": 3181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteGetAddress",
          "args": [
            "net->guestIP.routes[i]"
          ],
          "line": 3177
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteGetAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "984-991",
          "snippet": "virSocketAddrPtr\nvirNetDevIPRouteGetAddress(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->address;\n\n    return NULL;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nvirSocketAddrPtr\nvirNetDevIPRouteGetAddress(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->address;\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int prlsdkConfigureGateways(PRL_HANDLE sdknet, virDomainNetDefPtr net)\n{\n    int ret = -1;\n    size_t i;\n    virNetDevIPRoutePtr route4 = NULL, route6 = NULL;\n    char *gw4 = NULL, *gw6 = NULL;\n    PRL_RESULT pret;\n\n    for (i = 0; i < net->guestIP.nroutes; i++) {\n        virSocketAddrPtr addrdst, gateway;\n        virSocketAddr zero;\n\n        addrdst = virNetDevIPRouteGetAddress(net->guestIP.routes[i]);\n        gateway = virNetDevIPRouteGetGateway(net->guestIP.routes[i]);\n\n        ignore_value(virSocketAddrParse(&zero,\n                                (VIR_SOCKET_ADDR_IS_FAMILY(addrdst, AF_INET)\n                                 ? VIR_SOCKET_ADDR_IPV4_ALL\n                                 : VIR_SOCKET_ADDR_IPV6_ALL),\n                                VIR_SOCKET_ADDR_FAMILY(addrdst)));\n        /* virSocketAddrParse raises an error\n         * and we are not going to report it, reset it explicitly */\n        virResetLastError();\n\n        if (!virSocketAddrEqual(addrdst, &zero)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Support only default gateway\"));\n            return -1;\n        }\n\n        switch (VIR_SOCKET_ADDR_FAMILY(gateway)) {\n        case AF_INET:\n            if (route4) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Support only one IPv4 default gateway\"));\n                return -1;\n            }\n\n            route4 = net->guestIP.routes[i];\n\n            break;\n        case AF_INET6:\n            if (route6) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Support only one IPv6 default gateway\"));\n                return -1;\n            }\n\n            route6 = net->guestIP.routes[i];\n\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported address family %d \"\n                             \"Only IPv4 or IPv6 default gateway\"),\n                           VIR_SOCKET_ADDR_FAMILY(gateway));\n\n            return -1;\n        }\n    }\n\n    if (route4 &&\n        !(gw4 = virSocketAddrFormat(virNetDevIPRouteGetGateway(route4))))\n        goto cleanup;\n\n    pret = PrlVmDevNet_SetDefaultGateway(sdknet, gw4 ? : \"\");\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (route6 &&\n        !(gw6 = virSocketAddrFormat(virNetDevIPRouteGetGateway(route6))))\n        goto cleanup;\n\n    pret = PrlVmDevNet_SetDefaultGatewayIPv6(sdknet, gw6 ? : \"\");\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(gw4);\n    VIR_FREE(gw6);\n\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkFormatMac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "3155-3163",
    "snippet": "static const char * prlsdkFormatMac(virMacAddrPtr mac, char *macstr)\n{\n    g_snprintf(macstr, PRL_MAC_STRING_BUFNAME,\n               \"%02X%02X%02X%02X%02X%02X\",\n               mac->addr[0], mac->addr[1], mac->addr[2],\n               mac->addr[3], mac->addr[4], mac->addr[5]);\n    macstr[PRL_MAC_STRING_BUFNAME - 1] = '\\0';\n    return macstr;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PRL_MAC_STRING_BUFNAME  13"
    ],
    "globals_used": [
      "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "macstr",
            "PRL_MAC_STRING_BUFNAME",
            "\"%02X%02X%02X%02X%02X%02X\"",
            "mac->addr[0]",
            "mac->addr[1]",
            "mac->addr[2]",
            "mac->addr[3]",
            "mac->addr[4]",
            "mac->addr[5]"
          ],
          "line": 3157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define PRL_MAC_STRING_BUFNAME  13\n\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);\n\nstatic const char * prlsdkFormatMac(virMacAddrPtr mac, char *macstr)\n{\n    g_snprintf(macstr, PRL_MAC_STRING_BUFNAME,\n               \"%02X%02X%02X%02X%02X%02X\",\n               mac->addr[0], mac->addr[1], mac->addr[2],\n               mac->addr[3], mac->addr[4], mac->addr[5]);\n    macstr[PRL_MAC_STRING_BUFNAME - 1] = '\\0';\n    return macstr;\n}"
  },
  {
    "function_name": "prlsdkAddSerial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "3076-3151",
    "snippet": "static int prlsdkAddSerial(PRL_HANDLE sdkdom, virDomainChrDefPtr chr)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdkchr = PRL_INVALID_HANDLE;\n    PRL_VM_DEV_EMULATION_TYPE emutype;\n    PRL_SERIAL_PORT_SOCKET_OPERATION_MODE socket_mode = PSP_SERIAL_SOCKET_SERVER;\n    char *path;\n    char *url = NULL;\n    int ret = -1;\n\n    if (prlsdkCheckSerialUnsupportedParams(chr) < 0)\n        return -1;\n\n    pret = PrlVmCfg_CreateVmDev(sdkdom, PDE_SERIAL_PORT, &sdkchr);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    switch (chr->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n        emutype = PDT_USE_REAL_DEVICE;\n        path = chr->source->data.file.path;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        emutype = PDT_USE_OUTPUT_FILE;\n        path = chr->source->data.file.path;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        emutype = PDT_USE_SERIAL_PORT_SOCKET_MODE;\n        path = chr->source->data.nix.path;\n        if (!chr->source->data.nix.listen)\n            socket_mode = PSP_SERIAL_SOCKET_CLIENT;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n        emutype = PDT_USE_TCP;\n        url = g_strdup_printf(\"%s:%s\", chr->source->data.tcp.host,\n                              chr->source->data.tcp.service);\n        if (!chr->source->data.tcp.listen)\n            socket_mode = PSP_SERIAL_SOCKET_CLIENT;\n        path = url;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n        emutype = PDT_USE_UDP;\n        url = g_strdup_printf(\"%s:%s\", chr->source->data.udp.bindHost,\n                              chr->source->data.udp.bindService);\n        path = url;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver doesn't support \"\n                         \"specified serial source type.\"));\n        goto cleanup;\n    }\n\n    pret = PrlVmDev_SetEmulatedType(sdkchr, emutype);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetSysName(sdkchr, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetFriendlyName(sdkchr, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevSerial_SetSocketMode(sdkchr, socket_mode);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetEnabled(sdkchr, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetIndex(sdkchr, chr->target.port);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n cleanup:\n    PrlHandle_Free(sdkchr);\n    VIR_FREE(url);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "url"
          ],
          "line": 3149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "sdkchr"
          ],
          "line": 3148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetIndex",
          "args": [
            "sdkchr",
            "chr->target.port"
          ],
          "line": 3143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetEnabled",
          "args": [
            "sdkchr",
            "1"
          ],
          "line": 3140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevSerial_SetSocketMode",
          "args": [
            "sdkchr",
            "socket_mode"
          ],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetFriendlyName",
          "args": [
            "sdkchr",
            "path"
          ],
          "line": 3134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetSysName",
          "args": [
            "sdkchr",
            "path"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_SetEmulatedType",
          "args": [
            "sdkchr",
            "emutype"
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"vz driver doesn't support \"\n                         \"specified serial source type.\")"
          ],
          "line": 3122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"vz driver doesn't support \"\n                         \"specified serial source type.\""
          ],
          "line": 3123
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 3090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_CreateVmDev",
          "args": [
            "sdkdom",
            "PDE_SERIAL_PORT",
            "&sdkchr"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckSerialUnsupportedParams",
          "args": [
            "chr"
          ],
          "line": 3086
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkCheckSerialUnsupportedParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2824-2888",
          "snippet": "static int prlsdkCheckSerialUnsupportedParams(virDomainChrDefPtr chr)\n{\n    if (chr->deviceType != VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified character device type is not supported \"\n                         \"by vz driver.\"));\n        return -1;\n    }\n\n    if (chr->targetType != VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_NONE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified character device target type is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (chr->source->type != VIR_DOMAIN_CHR_TYPE_DEV &&\n        chr->source->type != VIR_DOMAIN_CHR_TYPE_FILE &&\n        chr->source->type != VIR_DOMAIN_CHR_TYPE_UNIX &&\n        chr->source->type != VIR_DOMAIN_CHR_TYPE_TCP &&\n        chr->source->type != VIR_DOMAIN_CHR_TYPE_UDP) {\n\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified character device source type is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (chr->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting device info for character devices is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (chr->source->nseclabels > 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting security labels is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n   if (chr->source->type == VIR_DOMAIN_CHR_TYPE_TCP &&\n        chr->source->data.tcp.protocol != VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Protocol '%s' is not supported for \"\n                         \"tcp character device.\"),\n                       virDomainChrTcpProtocolTypeToString(chr->source->data.tcp.protocol));\n        return -1;\n    }\n\n    if (chr->source->type == VIR_DOMAIN_CHR_TYPE_UDP &&\n        (STRNEQ(chr->source->data.udp.bindHost,\n                chr->source->data.udp.connectHost) ||\n         STRNEQ(chr->source->data.udp.bindService,\n                chr->source->data.udp.connectService))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Different bind and connect parameters for \"\n                         \"udp character device is not supported.\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int prlsdkCheckSerialUnsupportedParams(virDomainChrDefPtr chr)\n{\n    if (chr->deviceType != VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified character device type is not supported \"\n                         \"by vz driver.\"));\n        return -1;\n    }\n\n    if (chr->targetType != VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_NONE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified character device target type is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (chr->source->type != VIR_DOMAIN_CHR_TYPE_DEV &&\n        chr->source->type != VIR_DOMAIN_CHR_TYPE_FILE &&\n        chr->source->type != VIR_DOMAIN_CHR_TYPE_UNIX &&\n        chr->source->type != VIR_DOMAIN_CHR_TYPE_TCP &&\n        chr->source->type != VIR_DOMAIN_CHR_TYPE_UDP) {\n\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified character device source type is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (chr->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting device info for character devices is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (chr->source->nseclabels > 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting security labels is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n   if (chr->source->type == VIR_DOMAIN_CHR_TYPE_TCP &&\n        chr->source->data.tcp.protocol != VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Protocol '%s' is not supported for \"\n                         \"tcp character device.\"),\n                       virDomainChrTcpProtocolTypeToString(chr->source->data.tcp.protocol));\n        return -1;\n    }\n\n    if (chr->source->type == VIR_DOMAIN_CHR_TYPE_UDP &&\n        (STRNEQ(chr->source->data.udp.bindHost,\n                chr->source->data.udp.connectHost) ||\n         STRNEQ(chr->source->data.udp.bindService,\n                chr->source->data.udp.connectService))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Different bind and connect parameters for \"\n                         \"udp character device is not supported.\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int prlsdkAddSerial(PRL_HANDLE sdkdom, virDomainChrDefPtr chr)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE sdkchr = PRL_INVALID_HANDLE;\n    PRL_VM_DEV_EMULATION_TYPE emutype;\n    PRL_SERIAL_PORT_SOCKET_OPERATION_MODE socket_mode = PSP_SERIAL_SOCKET_SERVER;\n    char *path;\n    char *url = NULL;\n    int ret = -1;\n\n    if (prlsdkCheckSerialUnsupportedParams(chr) < 0)\n        return -1;\n\n    pret = PrlVmCfg_CreateVmDev(sdkdom, PDE_SERIAL_PORT, &sdkchr);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    switch (chr->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n        emutype = PDT_USE_REAL_DEVICE;\n        path = chr->source->data.file.path;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        emutype = PDT_USE_OUTPUT_FILE;\n        path = chr->source->data.file.path;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        emutype = PDT_USE_SERIAL_PORT_SOCKET_MODE;\n        path = chr->source->data.nix.path;\n        if (!chr->source->data.nix.listen)\n            socket_mode = PSP_SERIAL_SOCKET_CLIENT;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n        emutype = PDT_USE_TCP;\n        url = g_strdup_printf(\"%s:%s\", chr->source->data.tcp.host,\n                              chr->source->data.tcp.service);\n        if (!chr->source->data.tcp.listen)\n            socket_mode = PSP_SERIAL_SOCKET_CLIENT;\n        path = url;\n        break;\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n        emutype = PDT_USE_UDP;\n        url = g_strdup_printf(\"%s:%s\", chr->source->data.udp.bindHost,\n                              chr->source->data.udp.bindService);\n        path = url;\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver doesn't support \"\n                         \"specified serial source type.\"));\n        goto cleanup;\n    }\n\n    pret = PrlVmDev_SetEmulatedType(sdkchr, emutype);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetSysName(sdkchr, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetFriendlyName(sdkchr, path);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDevSerial_SetSocketMode(sdkchr, socket_mode);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetEnabled(sdkchr, 1);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmDev_SetIndex(sdkchr, chr->target.port);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n cleanup:\n    PrlHandle_Free(sdkchr);\n    VIR_FREE(url);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkApplyVideoParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "3055-3074",
    "snippet": "static int prlsdkApplyVideoParams(PRL_HANDLE sdkdom G_GNUC_UNUSED, virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n\n    if (def->nvideos == 0)\n        return 0;\n\n    if (IS_CT(def)) {\n        /* ignore video parameters */\n        return 0;\n    }\n\n    if (prlsdkCheckVideoUnsupportedParams(def))\n        return -1;\n\n    pret = PrlVmCfg_SetVideoRamSize(sdkdom, def->videos[0]->vram >> 10);\n    prlsdkCheckRetExit(pret, -1);\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 3071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetVideoRamSize",
          "args": [
            "sdkdom",
            "def->videos[0]->vram >> 10"
          ],
          "line": 3070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckVideoUnsupportedParams",
          "args": [
            "def"
          ],
          "line": 3067
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkCheckVideoUnsupportedParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2776-2822",
          "snippet": "static int prlsdkCheckVideoUnsupportedParams(virDomainDefPtr def)\n{\n    virDomainVideoDefPtr v;\n\n    if (IS_CT(def)) {\n        if (def->nvideos == 0) {\n            return 0;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Video adapters are not supported \"\n                             \"int containers.\"));\n            return -1;\n        }\n    } else {\n        if (def->nvideos != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"vz driver supports \"\n                             \"only one video adapter.\"));\n            return -1;\n        }\n    }\n\n    v = def->videos[0];\n\n    if (v->type != VIR_DOMAIN_VIDEO_TYPE_VGA) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver supports \"\n                         \"only VGA video adapters.\"));\n        return -1;\n    }\n\n    if (v->heads != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver doesn't support \"\n                         \"multihead video adapters.\"));\n        return -1;\n    }\n\n    if (v->accel != NULL && (v->accel->accel2d || v->accel->accel3d)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver doesn't support \"\n                         \"setting video acceleration parameters.\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int prlsdkCheckVideoUnsupportedParams(virDomainDefPtr def)\n{\n    virDomainVideoDefPtr v;\n\n    if (IS_CT(def)) {\n        if (def->nvideos == 0) {\n            return 0;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Video adapters are not supported \"\n                             \"int containers.\"));\n            return -1;\n        }\n    } else {\n        if (def->nvideos != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"vz driver supports \"\n                             \"only one video adapter.\"));\n            return -1;\n        }\n    }\n\n    v = def->videos[0];\n\n    if (v->type != VIR_DOMAIN_VIDEO_TYPE_VGA) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver supports \"\n                         \"only VGA video adapters.\"));\n        return -1;\n    }\n\n    if (v->heads != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver doesn't support \"\n                         \"multihead video adapters.\"));\n        return -1;\n    }\n\n    if (v->accel != NULL && (v->accel->accel2d || v->accel->accel3d)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver doesn't support \"\n                         \"setting video acceleration parameters.\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "def"
          ],
          "line": 3062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int prlsdkApplyVideoParams(PRL_HANDLE sdkdom G_GNUC_UNUSED, virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n\n    if (def->nvideos == 0)\n        return 0;\n\n    if (IS_CT(def)) {\n        /* ignore video parameters */\n        return 0;\n    }\n\n    if (prlsdkCheckVideoUnsupportedParams(def))\n        return -1;\n\n    pret = PrlVmCfg_SetVideoRamSize(sdkdom, def->videos[0]->vram >> 10);\n    prlsdkCheckRetExit(pret, -1);\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkApplyGraphicsParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "3021-3053",
    "snippet": "static int prlsdkApplyGraphicsParams(PRL_HANDLE sdkdom,\n                                     virDomainGraphicsDefPtr gr)\n{\n    virDomainGraphicsListenDefPtr glisten;\n    PRL_RESULT pret;\n\n    if (!gr) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_DISABLED);\n        prlsdkCheckRetExit(pret, -1);\n        return 0;\n    }\n\n    pret = PrlVmCfg_SetVNCPassword(sdkdom, gr->data.vnc.auth.passwd ? : \"\");\n    prlsdkCheckRetExit(pret, -1);\n\n    if (gr->data.vnc.autoport) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_AUTO);\n        prlsdkCheckRetExit(pret, -1);\n    } else {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_MANUAL);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlVmCfg_SetVNCPort(sdkdom, gr->data.vnc.port);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    glisten = virDomainGraphicsGetListen(gr, 0);\n    pret = PrlVmCfg_SetVNCHostName(sdkdom, glisten && glisten->address ?\n                                           glisten->address : VIR_LOOPBACK_IPV4_ADDR);\n    prlsdkCheckRetExit(pret, -1);\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 3050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetVNCHostName",
          "args": [
            "sdkdom",
            "glisten && glisten->address ?\n                                           glisten->address : VIR_LOOPBACK_IPV4_ADDR"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsGetListen",
          "args": [
            "gr",
            "0"
          ],
          "line": 3047
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsGetListen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30357-30364",
          "snippet": "virDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 3044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetVNCPort",
          "args": [
            "sdkdom",
            "gr->data.vnc.port"
          ],
          "line": 3043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetVNCMode",
          "args": [
            "sdkdom",
            "PRD_MANUAL"
          ],
          "line": 3040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetVNCMode",
          "args": [
            "sdkdom",
            "PRD_AUTO"
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 3034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetVNCPassword",
          "args": [
            "sdkdom",
            "gr->data.vnc.auth.passwd ? : \"\""
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 3029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_SetVNCMode",
          "args": [
            "sdkdom",
            "PRD_DISABLED"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int prlsdkApplyGraphicsParams(PRL_HANDLE sdkdom,\n                                     virDomainGraphicsDefPtr gr)\n{\n    virDomainGraphicsListenDefPtr glisten;\n    PRL_RESULT pret;\n\n    if (!gr) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_DISABLED);\n        prlsdkCheckRetExit(pret, -1);\n        return 0;\n    }\n\n    pret = PrlVmCfg_SetVNCPassword(sdkdom, gr->data.vnc.auth.passwd ? : \"\");\n    prlsdkCheckRetExit(pret, -1);\n\n    if (gr->data.vnc.autoport) {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_AUTO);\n        prlsdkCheckRetExit(pret, -1);\n    } else {\n        pret = PrlVmCfg_SetVNCMode(sdkdom, PRD_MANUAL);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlVmCfg_SetVNCPort(sdkdom, gr->data.vnc.port);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    glisten = virDomainGraphicsGetListen(gr, 0);\n    pret = PrlVmCfg_SetVNCHostName(sdkdom, glisten && glisten->address ?\n                                           glisten->address : VIR_LOOPBACK_IPV4_ADDR);\n    prlsdkCheckRetExit(pret, -1);\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkCheckFSUnsupportedParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2966-3019",
    "snippet": "static int prlsdkCheckFSUnsupportedParams(virDomainFSDefPtr fs)\n{\n    if (fs->type != VIR_DOMAIN_FS_TYPE_FILE &&\n        fs->type != VIR_DOMAIN_FS_TYPE_VOLUME) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only file based or volume based filesystems \"\n                         \"are supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->fsdriver != VIR_DOMAIN_FS_DRIVER_TYPE_PLOOP) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only ploop fs driver is \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->accessmode != VIR_DOMAIN_FS_ACCESSMODE_PASSTHROUGH) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Changing fs access mode is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->wrpolicy != VIR_DOMAIN_FS_WRPOLICY_DEFAULT) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Changing fs write policy is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->format != VIR_STORAGE_FILE_PLOOP) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only ploop disk images are \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->readonly) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting readonly for filesystems is \"\n                         \"not supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->space_hard_limit || fs->space_soft_limit) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting fs quotas is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Setting fs quotas is not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Setting fs quotas is not \"\n                         \"supported by vz driver.\""
          ],
          "line": 3013
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Setting readonly for filesystems is \"\n                         \"not supported by vz driver.\")"
          ],
          "line": 3005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Only ploop disk images are \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Changing fs write policy is not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Changing fs access mode is not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Only ploop fs driver is \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Only file based or volume based filesystems \"\n                         \"are supported by vz driver.\")"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int prlsdkCheckFSUnsupportedParams(virDomainFSDefPtr fs)\n{\n    if (fs->type != VIR_DOMAIN_FS_TYPE_FILE &&\n        fs->type != VIR_DOMAIN_FS_TYPE_VOLUME) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only file based or volume based filesystems \"\n                         \"are supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->fsdriver != VIR_DOMAIN_FS_DRIVER_TYPE_PLOOP) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only ploop fs driver is \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->accessmode != VIR_DOMAIN_FS_ACCESSMODE_PASSTHROUGH) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Changing fs access mode is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->wrpolicy != VIR_DOMAIN_FS_WRPOLICY_DEFAULT) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Changing fs write policy is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->format != VIR_STORAGE_FILE_PLOOP) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only ploop disk images are \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->readonly) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting readonly for filesystems is \"\n                         \"not supported by vz driver.\"));\n        return -1;\n    }\n\n    if (fs->space_hard_limit || fs->space_soft_limit) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting fs quotas is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkCheckNetUnsupportedParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2890-2964",
    "snippet": "static int prlsdkCheckNetUnsupportedParams(virDomainNetDefPtr net)\n{\n    if (net->type != VIR_DOMAIN_NET_TYPE_NETWORK &&\n        net->type != VIR_DOMAIN_NET_TYPE_BRIDGE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified network adapter type is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->backend.tap || net->backend.vhost) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Interface backend parameters are not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->data.network.portgroup) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Virtual network portgroups are not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->tune.sndbuf_specified) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting interface sndbuf is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->script) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting interface script is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->ifname_guest) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting guest interface name is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting device info for network devices is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->filter) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting network filter is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->bandwidth) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting network bandwidth is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->vlan.trunk) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting up vlans is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Setting up vlans is not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Setting up vlans is not \"\n                         \"supported by vz driver.\""
          ],
          "line": 2958
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Setting network bandwidth is not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Setting network filter is not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Setting device info for network devices is not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Setting guest interface name is not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Setting interface script is not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Setting interface sndbuf is not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Virtual network portgroups are not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Interface backend parameters are not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Specified network adapter type is not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int prlsdkCheckNetUnsupportedParams(virDomainNetDefPtr net)\n{\n    if (net->type != VIR_DOMAIN_NET_TYPE_NETWORK &&\n        net->type != VIR_DOMAIN_NET_TYPE_BRIDGE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified network adapter type is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->backend.tap || net->backend.vhost) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Interface backend parameters are not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->data.network.portgroup) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Virtual network portgroups are not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->tune.sndbuf_specified) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting interface sndbuf is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->script) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting interface script is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->ifname_guest) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting guest interface name is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting device info for network devices is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->filter) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting network filter is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->bandwidth) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting network bandwidth is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (net->vlan.trunk) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting up vlans is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkCheckSerialUnsupportedParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2824-2888",
    "snippet": "static int prlsdkCheckSerialUnsupportedParams(virDomainChrDefPtr chr)\n{\n    if (chr->deviceType != VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified character device type is not supported \"\n                         \"by vz driver.\"));\n        return -1;\n    }\n\n    if (chr->targetType != VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_NONE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified character device target type is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (chr->source->type != VIR_DOMAIN_CHR_TYPE_DEV &&\n        chr->source->type != VIR_DOMAIN_CHR_TYPE_FILE &&\n        chr->source->type != VIR_DOMAIN_CHR_TYPE_UNIX &&\n        chr->source->type != VIR_DOMAIN_CHR_TYPE_TCP &&\n        chr->source->type != VIR_DOMAIN_CHR_TYPE_UDP) {\n\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified character device source type is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (chr->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting device info for character devices is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (chr->source->nseclabels > 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting security labels is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n   if (chr->source->type == VIR_DOMAIN_CHR_TYPE_TCP &&\n        chr->source->data.tcp.protocol != VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Protocol '%s' is not supported for \"\n                         \"tcp character device.\"),\n                       virDomainChrTcpProtocolTypeToString(chr->source->data.tcp.protocol));\n        return -1;\n    }\n\n    if (chr->source->type == VIR_DOMAIN_CHR_TYPE_UDP &&\n        (STRNEQ(chr->source->data.udp.bindHost,\n                chr->source->data.udp.connectHost) ||\n         STRNEQ(chr->source->data.udp.bindService,\n                chr->source->data.udp.connectService))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Different bind and connect parameters for \"\n                         \"udp character device is not supported.\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Different bind and connect parameters for \"\n                         \"udp character device is not supported.\")"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Different bind and connect parameters for \"\n                         \"udp character device is not supported.\""
          ],
          "line": 2882
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "chr->source->data.udp.bindService",
            "chr->source->data.udp.connectService"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "chr->source->data.udp.bindHost",
            "chr->source->data.udp.connectHost"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Protocol '%s' is not supported for \"\n                         \"tcp character device.\")",
            "virDomainChrTcpProtocolTypeToString(chr->source->data.tcp.protocol)"
          ],
          "line": 2869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrTcpProtocolTypeToString",
          "args": [
            "chr->source->data.tcp.protocol"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Setting security labels is not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Setting device info for character devices is not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Specified character device source type is not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Specified character device target type is not \"\n                         \"supported by vz driver.\")"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Specified character device type is not supported \"\n                         \"by vz driver.\")"
          ],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int prlsdkCheckSerialUnsupportedParams(virDomainChrDefPtr chr)\n{\n    if (chr->deviceType != VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified character device type is not supported \"\n                         \"by vz driver.\"));\n        return -1;\n    }\n\n    if (chr->targetType != VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_NONE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified character device target type is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (chr->source->type != VIR_DOMAIN_CHR_TYPE_DEV &&\n        chr->source->type != VIR_DOMAIN_CHR_TYPE_FILE &&\n        chr->source->type != VIR_DOMAIN_CHR_TYPE_UNIX &&\n        chr->source->type != VIR_DOMAIN_CHR_TYPE_TCP &&\n        chr->source->type != VIR_DOMAIN_CHR_TYPE_UDP) {\n\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Specified character device source type is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (chr->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting device info for character devices is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n    if (chr->source->nseclabels > 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Setting security labels is not \"\n                         \"supported by vz driver.\"));\n        return -1;\n    }\n\n   if (chr->source->type == VIR_DOMAIN_CHR_TYPE_TCP &&\n        chr->source->data.tcp.protocol != VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Protocol '%s' is not supported for \"\n                         \"tcp character device.\"),\n                       virDomainChrTcpProtocolTypeToString(chr->source->data.tcp.protocol));\n        return -1;\n    }\n\n    if (chr->source->type == VIR_DOMAIN_CHR_TYPE_UDP &&\n        (STRNEQ(chr->source->data.udp.bindHost,\n                chr->source->data.udp.connectHost) ||\n         STRNEQ(chr->source->data.udp.bindService,\n                chr->source->data.udp.connectService))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Different bind and connect parameters for \"\n                         \"udp character device is not supported.\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkCheckVideoUnsupportedParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2776-2822",
    "snippet": "static int prlsdkCheckVideoUnsupportedParams(virDomainDefPtr def)\n{\n    virDomainVideoDefPtr v;\n\n    if (IS_CT(def)) {\n        if (def->nvideos == 0) {\n            return 0;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Video adapters are not supported \"\n                             \"int containers.\"));\n            return -1;\n        }\n    } else {\n        if (def->nvideos != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"vz driver supports \"\n                             \"only one video adapter.\"));\n            return -1;\n        }\n    }\n\n    v = def->videos[0];\n\n    if (v->type != VIR_DOMAIN_VIDEO_TYPE_VGA) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver supports \"\n                         \"only VGA video adapters.\"));\n        return -1;\n    }\n\n    if (v->heads != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver doesn't support \"\n                         \"multihead video adapters.\"));\n        return -1;\n    }\n\n    if (v->accel != NULL && (v->accel->accel2d || v->accel->accel3d)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver doesn't support \"\n                         \"setting video acceleration parameters.\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"vz driver doesn't support \"\n                         \"setting video acceleration parameters.\")"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"vz driver doesn't support \"\n                         \"setting video acceleration parameters.\""
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"vz driver doesn't support \"\n                         \"multihead video adapters.\")"
          ],
          "line": 2808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"vz driver supports \"\n                         \"only VGA video adapters.\")"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"vz driver supports \"\n                             \"only one video adapter.\")"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Video adapters are not supported \"\n                             \"int containers.\")"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "def"
          ],
          "line": 2780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int prlsdkCheckVideoUnsupportedParams(virDomainDefPtr def)\n{\n    virDomainVideoDefPtr v;\n\n    if (IS_CT(def)) {\n        if (def->nvideos == 0) {\n            return 0;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Video adapters are not supported \"\n                             \"int containers.\"));\n            return -1;\n        }\n    } else {\n        if (def->nvideos != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"vz driver supports \"\n                             \"only one video adapter.\"));\n            return -1;\n        }\n    }\n\n    v = def->videos[0];\n\n    if (v->type != VIR_DOMAIN_VIDEO_TYPE_VGA) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver supports \"\n                         \"only VGA video adapters.\"));\n        return -1;\n    }\n\n    if (v->heads != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver doesn't support \"\n                         \"multihead video adapters.\"));\n        return -1;\n    }\n\n    if (v->accel != NULL && (v->accel->accel2d || v->accel->accel3d)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"vz driver doesn't support \"\n                         \"setting video acceleration parameters.\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkAddDeviceToBootList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2743-2774",
    "snippet": "static int\nprlsdkAddDeviceToBootList(PRL_HANDLE sdkdom,\n                          PRL_UINT32 devIndex,\n                          PRL_DEVICE_TYPE devType,\n                          PRL_UINT32 bootSequence)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE bootDev = PRL_INVALID_HANDLE;\n\n    pret = PrlVmCfg_CreateBootDev(sdkdom, &bootDev);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetIndex(bootDev, devIndex);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetType(bootDev, devType);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetSequenceIndex(bootDev, bootSequence);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetInUse(bootDev, PRL_TRUE);\n    prlsdkCheckRetGoto(pret, error);\n\n    return 0;\n\n error:\n    if (bootDev != PRL_INVALID_HANDLE)\n        PrlBootDev_Remove(bootDev);\n\n    return -1;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlBootDev_Remove",
          "args": [
            "bootDev"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlBootDev_SetInUse",
          "args": [
            "bootDev",
            "PRL_TRUE"
          ],
          "line": 2764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlBootDev_SetSequenceIndex",
          "args": [
            "bootDev",
            "bootSequence"
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlBootDev_SetType",
          "args": [
            "bootDev",
            "devType"
          ],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlBootDev_SetIndex",
          "args": [
            "bootDev",
            "devIndex"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_CreateBootDev",
          "args": [
            "sdkdom",
            "&bootDev"
          ],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkAddDeviceToBootList(PRL_HANDLE sdkdom,\n                          PRL_UINT32 devIndex,\n                          PRL_DEVICE_TYPE devType,\n                          PRL_UINT32 bootSequence)\n{\n    PRL_RESULT pret;\n    PRL_HANDLE bootDev = PRL_INVALID_HANDLE;\n\n    pret = PrlVmCfg_CreateBootDev(sdkdom, &bootDev);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetIndex(bootDev, devIndex);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetType(bootDev, devType);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetSequenceIndex(bootDev, bootSequence);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlBootDev_SetInUse(bootDev, PRL_TRUE);\n    prlsdkCheckRetGoto(pret, error);\n\n    return 0;\n\n error:\n    if (bootDev != PRL_INVALID_HANDLE)\n        PrlBootDev_Remove(bootDev);\n\n    return -1;\n}"
  },
  {
    "function_name": "prlsdkRemoveBootDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2716-2741",
    "snippet": "static int\nprlsdkRemoveBootDevices(PRL_HANDLE sdkdom)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 i, devCount;\n    PRL_HANDLE dev = PRL_INVALID_HANDLE;\n    PRL_DEVICE_TYPE devType;\n\n    pret = PrlVmCfg_GetBootDevCount(sdkdom, &devCount);\n    prlsdkCheckRetExit(pret, -1);\n\n    for (i = 0; i < devCount; i++) {\n\n        /* always get device by index 0, because device list resort after delete */\n        pret = PrlVmCfg_GetBootDev(sdkdom, 0, &dev);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlBootDev_GetType(dev, &devType);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlBootDev_Remove(dev);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlBootDev_Remove",
          "args": [
            "dev"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlBootDev_GetType",
          "args": [
            "dev",
            "&devType"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetBootDev",
          "args": [
            "sdkdom",
            "0",
            "&dev"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetBootDevCount",
          "args": [
            "sdkdom",
            "&devCount"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkRemoveBootDevices(PRL_HANDLE sdkdom)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 i, devCount;\n    PRL_HANDLE dev = PRL_INVALID_HANDLE;\n    PRL_DEVICE_TYPE devType;\n\n    pret = PrlVmCfg_GetBootDevCount(sdkdom, &devCount);\n    prlsdkCheckRetExit(pret, -1);\n\n    for (i = 0; i < devCount; i++) {\n\n        /* always get device by index 0, because device list resort after delete */\n        pret = PrlVmCfg_GetBootDev(sdkdom, 0, &dev);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlBootDev_GetType(dev, &devType);\n        prlsdkCheckRetExit(pret, -1);\n\n        pret = PrlBootDev_Remove(dev);\n        prlsdkCheckRetExit(pret, -1);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkClearDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2688-2714",
    "snippet": "static int prlsdkClearDevices(PRL_HANDLE sdkdom)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 n, i;\n    PRL_HANDLE devList;\n    PRL_HANDLE dev;\n    int ret = -1;\n\n    pret = PrlVmCfg_GetAllDevices(sdkdom, &devList);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlHndlList_GetItemsCount(devList, &n);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < n; i++) {\n        pret = PrlHndlList_GetItem(devList, i, &dev);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlVmDev_Remove(dev);\n        PrlHandle_Free(dev);\n    }\n\n    ret = 0;\n cleanup:\n    PrlHandle_Free(devList);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "devList"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "dev"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_Remove",
          "args": [
            "dev"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHndlList_GetItem",
          "args": [
            "devList",
            "i",
            "&dev"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHndlList_GetItemsCount",
          "args": [
            "devList",
            "&n"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 2697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetAllDevices",
          "args": [
            "sdkdom",
            "&devList"
          ],
          "line": 2696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int prlsdkClearDevices(PRL_HANDLE sdkdom)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 n, i;\n    PRL_HANDLE devList;\n    PRL_HANDLE dev;\n    int ret = -1;\n\n    pret = PrlVmCfg_GetAllDevices(sdkdom, &devList);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlHndlList_GetItemsCount(devList, &n);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < n; i++) {\n        pret = PrlHndlList_GetItem(devList, i, &dev);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlVmDev_Remove(dev);\n        PrlHandle_Free(dev);\n    }\n\n    ret = 0;\n cleanup:\n    PrlHandle_Free(devList);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkCheckUnsupportedParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2466-2686",
    "snippet": "static int\nprlsdkCheckUnsupportedParams(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    size_t i;\n    PRL_VM_TYPE vmType;\n    PRL_RESULT pret;\n    virDomainNumatuneMemMode memMode;\n    int bus = IS_CT(def) ? VIR_DOMAIN_INPUT_BUS_PARALLELS :\n                           VIR_DOMAIN_INPUT_BUS_PS2;\n\n    if (def->title) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"titles are not supported by vz driver\"));\n        return -1;\n    }\n\n    if (def->blkio.ndevices > 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"blkio parameters are not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (virDomainDefGetMemoryTotal(def) != def->mem.cur_balloon) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing balloon parameters is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (virDomainDefGetMemoryTotal(def) % (1 << 10) != 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Memory size should be multiple of 1Mb.\"));\n        return -1;\n    }\n\n    if (def->mem.nhugepages ||\n        virMemoryLimitIsSet(def->mem.hard_limit) ||\n        virMemoryLimitIsSet(def->mem.soft_limit) ||\n        def->mem.min_guarantee ||\n        virMemoryLimitIsSet(def->mem.swap_hard_limit)) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Memory parameter is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"current vcpus must be equal to maxvcpus\"));\n        return -1;\n    }\n\n    if (def->placement_mode) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing cpu placement mode is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (def->cputune.shares ||\n        def->cputune.sharesSpecified ||\n        def->cputune.period ||\n        def->cputune.quota) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"cputune is not supported by vz driver\"));\n        return -1;\n    }\n\n    for (i = 0; i < virDomainDefGetVcpusMax(def); i++) {\n        virDomainVcpuDefPtr vcpu = virDomainDefGetVcpu(def, i);\n\n        if (vcpu->cpumask &&\n            !virBitmapEqual(def->cpumask, vcpu->cpumask)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"vcpupin cpumask differs from default cpumask\"));\n            return -1;\n        }\n    }\n\n\n    /*\n     * Though we don't support NUMA configuration at the moment\n     * virDomainDefPtr always contain non zero NUMA configuration\n     * So, just make sure this configuration does't differ from auto generated.\n     */\n    if ((virDomainNumatuneGetMode(def->numa, -1, &memMode) == 0 &&\n         memMode == VIR_DOMAIN_NUMATUNE_MEM_STRICT) ||\n        virDomainNumatuneHasPerNodeBinding(def->numa)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"numa parameters are not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (def->onReboot != VIR_DOMAIN_LIFECYCLE_ACTION_RESTART ||\n        def->onPoweroff != VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY ||\n        def->onCrash != VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"on_reboot, on_poweroff and on_crash parameters \"\n                         \"are not supported by vz driver\"));\n        return -1;\n    }\n\n    /* we fill only type and arch fields in vzLoadDomain for\n     * hvm type and also init for containers, so we can check that all\n     * other parameters are null and boot devices config is default */\n\n    if (def->os.machine != NULL || def->os.bootmenu != 0 ||\n        def->os.kernel != NULL || def->os.initrd != NULL ||\n        def->os.cmdline != NULL || def->os.root != NULL ||\n        def->os.loader != NULL || def->os.bootloader != NULL ||\n        def->os.bootloaderArgs != NULL || def->os.smbios_mode != 0 ||\n        def->os.bios.useserial != 0) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing OS parameters is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    pret = PrlVmCfg_GetVmType(sdkdom, &vmType);\n    if (PRL_FAILED(pret)) {\n        logPrlError(pret);\n        return -1;\n    }\n\n    if (!(vmType == PVT_VM && !IS_CT(def)) &&\n        !(vmType == PVT_CT && IS_CT(def))) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing OS type is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (!IS_CT(def)) {\n        if (def->os.init != NULL || def->os.initargv != NULL) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported OS parameters\"));\n            return -1;\n        }\n    } else {\n        if (def->os.nBootDevs != 0 ||\n            STRNEQ_NULLABLE(def->os.init, \"/sbin/init\") ||\n            (def->os.initargv != NULL && def->os.initargv[0] != NULL)) {\n\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported OS parameters\"));\n            return -1;\n        }\n    }\n\n    if (def->emulator) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing emulator is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    for (i = 0; i < VIR_DOMAIN_FEATURE_LAST; i++) {\n        if (def->features[i]) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"changing features is not supported \"\n                             \"by vz driver\"));\n            return -1;\n        }\n    }\n\n    if (def->clock.offset != VIR_DOMAIN_CLOCK_OFFSET_UTC ||\n        def->clock.ntimers != 0) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing clock parameters is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (!IS_CT(def) && def->nfss != 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Filesystems in VMs are not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (def->nsounds != 0 || def->nhostdevs != 0 ||\n        def->nredirdevs != 0 || def->nsmartcards != 0 ||\n        def->nparallels || def->nchannels != 0 ||\n        def->nleases != 0 || def->nhubs != 0) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing devices parameters is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    /* check we have only default input devices */\n    if (def->ngraphics > 0) {\n        if (def->ninputs != 2 ||\n            def->inputs[0]->bus != bus ||\n            def->inputs[1]->bus != bus ||\n            !((def->inputs[0]->type == VIR_DOMAIN_INPUT_TYPE_MOUSE &&\n               def->inputs[1]->type == VIR_DOMAIN_INPUT_TYPE_KBD) ||\n              (def->inputs[0]->type == VIR_DOMAIN_INPUT_TYPE_KBD &&\n               def->inputs[1]->type == VIR_DOMAIN_INPUT_TYPE_MOUSE))) {\n\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported input device configuration\"));\n            return -1;\n        }\n    } else if (def->ninputs != 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"input devices without vnc are not supported\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"input devices without vnc are not supported\")"
          ],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"input devices without vnc are not supported\""
          ],
          "line": 2681
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unsupported input device configuration\")"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"changing devices parameters is not supported \"\n                         \"by vz driver\")"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Filesystems in VMs are not supported \"\n                         \"by vz driver\")"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "def"
          ],
          "line": 2647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"changing clock parameters is not supported \"\n                         \"by vz driver\")"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"changing features is not supported \"\n                             \"by vz driver\")"
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"changing emulator is not supported \"\n                         \"by vz driver\")"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unsupported OS parameters\")"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "def->os.init",
            "\"/sbin/init\""
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unsupported OS parameters\")"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "def"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"changing OS type is not supported \"\n                         \"by vz driver\")"
          ],
          "line": 2599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "def"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "def"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logPrlError",
          "args": [
            "pret"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "pret"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetVmType",
          "args": [
            "sdkdom",
            "&vmType"
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"changing OS parameters is not supported \"\n                         \"by vz driver\")"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"on_reboot, on_poweroff and on_crash parameters \"\n                         \"are not supported by vz driver\")"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"numa parameters are not supported \"\n                         \"by vz driver\")"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNumatuneHasPerNodeBinding",
          "args": [
            "def->numa"
          ],
          "line": 2556
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumatuneHasPerNodeBinding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "637-651",
          "snippet": "bool\nvirDomainNumatuneHasPerNodeBinding(virDomainNumaPtr numatune)\n{\n    size_t i = 0;\n\n    if (!numatune)\n        return false;\n\n    for (i = 0; i < numatune->nmem_nodes; i++) {\n        if (numatune->mem_nodes[i].nodeset)\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nbool\nvirDomainNumatuneHasPerNodeBinding(virDomainNumaPtr numatune)\n{\n    size_t i = 0;\n\n    if (!numatune)\n        return false;\n\n    for (i = 0; i < numatune->nmem_nodes; i++) {\n        if (numatune->mem_nodes[i].nodeset)\n            return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumatuneGetMode",
          "args": [
            "def->numa",
            "-1",
            "&memMode"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumatuneGetMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "389-409",
          "snippet": "int virDomainNumatuneGetMode(virDomainNumaPtr numatune,\n                             int cellid,\n                             virDomainNumatuneMemMode *mode)\n{\n    virDomainNumatuneMemMode tmp_mode;\n\n    if (!numatune)\n        return -1;\n\n    if (virDomainNumatuneNodeSpecified(numatune, cellid))\n        tmp_mode = numatune->mem_nodes[cellid].mode;\n    else if (numatune->memory.specified)\n        tmp_mode = numatune->memory.mode;\n    else\n        return -1;\n\n    if (mode)\n        *mode = tmp_mode;\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nint virDomainNumatuneGetMode(virDomainNumaPtr numatune,\n                             int cellid,\n                             virDomainNumatuneMemMode *mode)\n{\n    virDomainNumatuneMemMode tmp_mode;\n\n    if (!numatune)\n        return -1;\n\n    if (virDomainNumatuneNodeSpecified(numatune, cellid))\n        tmp_mode = numatune->mem_nodes[cellid].mode;\n    else if (numatune->memory.specified)\n        tmp_mode = numatune->memory.mode;\n    else\n        return -1;\n\n    if (mode)\n        *mode = tmp_mode;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"vcpupin cpumask differs from default cpumask\")"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapEqual",
          "args": [
            "def->cpumask",
            "vcpu->cpumask"
          ],
          "line": 2541
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "841-873",
          "snippet": "bool\nvirBitmapEqual(virBitmapPtr b1,\n               virBitmapPtr b2)\n{\n    virBitmapPtr tmp;\n    size_t i;\n\n    if (!b1 && !b2)\n        return true;\n\n    if (!b1 || !b2)\n        return false;\n\n    if (b1->nbits > b2->nbits) {\n        tmp = b1;\n        b1 = b2;\n        b2 = tmp;\n    }\n\n    /* Now b1 is the smaller one, if not equal */\n\n    for (i = 0; i < b1->map_len; i++) {\n        if (b1->map[i] != b2->map[i])\n            return false;\n    }\n\n    for (; i < b2->map_len; i++) {\n        if (b2->map[i])\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapEqual(virBitmapPtr b1,\n               virBitmapPtr b2)\n{\n    virBitmapPtr tmp;\n    size_t i;\n\n    if (!b1 && !b2)\n        return true;\n\n    if (!b1 || !b2)\n        return false;\n\n    if (b1->nbits > b2->nbits) {\n        tmp = b1;\n        b1 = b2;\n        b2 = tmp;\n    }\n\n    /* Now b1 is the smaller one, if not equal */\n\n    for (i = 0; i < b1->map_len; i++) {\n        if (b1->map[i] != b2->map[i])\n            return false;\n    }\n\n    for (; i < b2->map_len; i++) {\n        if (b2->map[i])\n            return false;\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetVcpu",
          "args": [
            "def",
            "i"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetVcpusTopology",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2066-2090",
          "snippet": "int\nvirDomainDefGetVcpusTopology(const virDomainDef *def,\n                             unsigned int *maxvcpus)\n{\n    unsigned long long tmp;\n\n    if (!def->cpu || def->cpu->sockets == 0)\n        return 1;\n\n    tmp = def->cpu->sockets;\n\n    /* multiplication of 32bit numbers fits into a 64bit variable */\n    if ((tmp *= def->cpu->dies) > UINT_MAX ||\n        (tmp *= def->cpu->cores) > UINT_MAX ||\n        (tmp *= def->cpu->threads) > UINT_MAX) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"cpu topology results in more than %u cpus\"), UINT_MAX);\n        return -1;\n    }\n\n    if (maxvcpus)\n        *maxvcpus = tmp;\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefGetVcpusTopology(const virDomainDef *def,\n                             unsigned int *maxvcpus)\n{\n    unsigned long long tmp;\n\n    if (!def->cpu || def->cpu->sockets == 0)\n        return 1;\n\n    tmp = def->cpu->sockets;\n\n    /* multiplication of 32bit numbers fits into a 64bit variable */\n    if ((tmp *= def->cpu->dies) > UINT_MAX ||\n        (tmp *= def->cpu->cores) > UINT_MAX ||\n        (tmp *= def->cpu->threads) > UINT_MAX) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"cpu topology results in more than %u cpus\"), UINT_MAX);\n        return -1;\n    }\n\n    if (maxvcpus)\n        *maxvcpus = tmp;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetVcpusMax",
          "args": [
            "def"
          ],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetVcpusMax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1882-1886",
          "snippet": "unsigned int\nvirDomainDefGetVcpusMax(const virDomainDef *def)\n{\n    return def->maxvcpus;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int\nvirDomainDefGetVcpusMax(const virDomainDef *def)\n{\n    return def->maxvcpus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"cputune is not supported by vz driver\")"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"changing cpu placement mode is not supported \"\n                         \"by vz driver\")"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"current vcpus must be equal to maxvcpus\")"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefHasVcpusOffline",
          "args": [
            "def"
          ],
          "line": 2514
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefHasVcpusOffline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1868-1879",
          "snippet": "bool\nvirDomainDefHasVcpusOffline(const virDomainDef *def)\n{\n    size_t i;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (!def->vcpus[i]->online)\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainDefHasVcpusOffline(const virDomainDef *def)\n{\n    size_t i;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (!def->vcpus[i]->online)\n            return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Memory parameter is not supported \"\n                         \"by vz driver\")"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMemoryLimitIsSet",
          "args": [
            "def->mem.swap_hard_limit"
          ],
          "line": 2506
        },
        "resolved": true,
        "details": {
          "function_name": "virMemoryLimitIsSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1628-1632",
          "snippet": "bool\nvirMemoryLimitIsSet(unsigned long long value)\n{\n    return value < VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirMemoryLimitIsSet(unsigned long long value)\n{\n    return value < VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Memory size should be multiple of 1Mb.\")"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetMemoryTotal",
          "args": [
            "def"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetMemoryTotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10946-10950",
          "snippet": "unsigned long long\nvirDomainDefGetMemoryTotal(const virDomainDef *def)\n{\n    return def->mem.total_memory;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned long long\nvirDomainDefGetMemoryTotal(const virDomainDef *def)\n{\n    return def->mem.total_memory;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"changing balloon parameters is not supported \"\n                         \"by vz driver\")"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"blkio parameters are not supported \"\n                         \"by vz driver\")"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"titles are not supported by vz driver\")"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "def"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkCheckUnsupportedParams(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    size_t i;\n    PRL_VM_TYPE vmType;\n    PRL_RESULT pret;\n    virDomainNumatuneMemMode memMode;\n    int bus = IS_CT(def) ? VIR_DOMAIN_INPUT_BUS_PARALLELS :\n                           VIR_DOMAIN_INPUT_BUS_PS2;\n\n    if (def->title) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"titles are not supported by vz driver\"));\n        return -1;\n    }\n\n    if (def->blkio.ndevices > 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"blkio parameters are not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (virDomainDefGetMemoryTotal(def) != def->mem.cur_balloon) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing balloon parameters is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (virDomainDefGetMemoryTotal(def) % (1 << 10) != 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Memory size should be multiple of 1Mb.\"));\n        return -1;\n    }\n\n    if (def->mem.nhugepages ||\n        virMemoryLimitIsSet(def->mem.hard_limit) ||\n        virMemoryLimitIsSet(def->mem.soft_limit) ||\n        def->mem.min_guarantee ||\n        virMemoryLimitIsSet(def->mem.swap_hard_limit)) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Memory parameter is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"current vcpus must be equal to maxvcpus\"));\n        return -1;\n    }\n\n    if (def->placement_mode) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing cpu placement mode is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (def->cputune.shares ||\n        def->cputune.sharesSpecified ||\n        def->cputune.period ||\n        def->cputune.quota) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"cputune is not supported by vz driver\"));\n        return -1;\n    }\n\n    for (i = 0; i < virDomainDefGetVcpusMax(def); i++) {\n        virDomainVcpuDefPtr vcpu = virDomainDefGetVcpu(def, i);\n\n        if (vcpu->cpumask &&\n            !virBitmapEqual(def->cpumask, vcpu->cpumask)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"vcpupin cpumask differs from default cpumask\"));\n            return -1;\n        }\n    }\n\n\n    /*\n     * Though we don't support NUMA configuration at the moment\n     * virDomainDefPtr always contain non zero NUMA configuration\n     * So, just make sure this configuration does't differ from auto generated.\n     */\n    if ((virDomainNumatuneGetMode(def->numa, -1, &memMode) == 0 &&\n         memMode == VIR_DOMAIN_NUMATUNE_MEM_STRICT) ||\n        virDomainNumatuneHasPerNodeBinding(def->numa)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"numa parameters are not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (def->onReboot != VIR_DOMAIN_LIFECYCLE_ACTION_RESTART ||\n        def->onPoweroff != VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY ||\n        def->onCrash != VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"on_reboot, on_poweroff and on_crash parameters \"\n                         \"are not supported by vz driver\"));\n        return -1;\n    }\n\n    /* we fill only type and arch fields in vzLoadDomain for\n     * hvm type and also init for containers, so we can check that all\n     * other parameters are null and boot devices config is default */\n\n    if (def->os.machine != NULL || def->os.bootmenu != 0 ||\n        def->os.kernel != NULL || def->os.initrd != NULL ||\n        def->os.cmdline != NULL || def->os.root != NULL ||\n        def->os.loader != NULL || def->os.bootloader != NULL ||\n        def->os.bootloaderArgs != NULL || def->os.smbios_mode != 0 ||\n        def->os.bios.useserial != 0) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing OS parameters is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    pret = PrlVmCfg_GetVmType(sdkdom, &vmType);\n    if (PRL_FAILED(pret)) {\n        logPrlError(pret);\n        return -1;\n    }\n\n    if (!(vmType == PVT_VM && !IS_CT(def)) &&\n        !(vmType == PVT_CT && IS_CT(def))) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing OS type is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (!IS_CT(def)) {\n        if (def->os.init != NULL || def->os.initargv != NULL) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported OS parameters\"));\n            return -1;\n        }\n    } else {\n        if (def->os.nBootDevs != 0 ||\n            STRNEQ_NULLABLE(def->os.init, \"/sbin/init\") ||\n            (def->os.initargv != NULL && def->os.initargv[0] != NULL)) {\n\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported OS parameters\"));\n            return -1;\n        }\n    }\n\n    if (def->emulator) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing emulator is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    for (i = 0; i < VIR_DOMAIN_FEATURE_LAST; i++) {\n        if (def->features[i]) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"changing features is not supported \"\n                             \"by vz driver\"));\n            return -1;\n        }\n    }\n\n    if (def->clock.offset != VIR_DOMAIN_CLOCK_OFFSET_UTC ||\n        def->clock.ntimers != 0) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing clock parameters is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (!IS_CT(def) && def->nfss != 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Filesystems in VMs are not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    if (def->nsounds != 0 || def->nhostdevs != 0 ||\n        def->nredirdevs != 0 || def->nsmartcards != 0 ||\n        def->nparallels || def->nchannels != 0 ||\n        def->nleases != 0 || def->nhubs != 0) {\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"changing devices parameters is not supported \"\n                         \"by vz driver\"));\n        return -1;\n    }\n\n    /* check we have only default input devices */\n    if (def->ngraphics > 0) {\n        if (def->ninputs != 2 ||\n            def->inputs[0]->bus != bus ||\n            def->inputs[1]->bus != bus ||\n            !((def->inputs[0]->type == VIR_DOMAIN_INPUT_TYPE_MOUSE &&\n               def->inputs[1]->type == VIR_DOMAIN_INPUT_TYPE_KBD) ||\n              (def->inputs[0]->type == VIR_DOMAIN_INPUT_TYPE_KBD &&\n               def->inputs[1]->type == VIR_DOMAIN_INPUT_TYPE_MOUSE))) {\n\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"unsupported input device configuration\"));\n            return -1;\n        }\n    } else if (def->ninputs != 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"input devices without vnc are not supported\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkConvertError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2446-2464",
    "snippet": "static void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "virerr",
            "\"%s\"",
            "_(\"Can't change domain state.\")"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Can't change domain state.\""
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}"
  },
  {
    "function_name": "prlsdkReset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2431-2444",
    "snippet": "int prlsdkReset(virDomainObjPtr dom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n\n    job = PrlVm_Reset(privdom->sdkdom);\n    if (PRL_FAILED(pret = waitDomainJob(job, dom))) {\n        prlsdkConvertError(pret);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prlsdkConvertError",
          "args": [
            "pret"
          ],
          "line": 2439
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConvertError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2446-2464",
          "snippet": "static void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "pret = waitDomainJob(job, dom)"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_Reset",
          "args": [
            "privdom->sdkdom"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nint prlsdkReset(virDomainObjPtr dom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n\n    job = PrlVm_Reset(privdom->sdkdom);\n    if (PRL_FAILED(pret = waitDomainJob(job, dom))) {\n        prlsdkConvertError(pret);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2416-2429",
    "snippet": "int prlsdkRestart(virDomainObjPtr dom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n\n    job = PrlVm_Restart(privdom->sdkdom);\n    if (PRL_FAILED(pret = waitDomainJob(job, dom))) {\n        prlsdkConvertError(pret);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prlsdkConvertError",
          "args": [
            "pret"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConvertError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2446-2464",
          "snippet": "static void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "pret = waitDomainJob(job, dom)"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_Restart",
          "args": [
            "privdom->sdkdom"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nint prlsdkRestart(virDomainObjPtr dom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n\n    job = PrlVm_Restart(privdom->sdkdom);\n    if (PRL_FAILED(pret = waitDomainJob(job, dom))) {\n        prlsdkConvertError(pret);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkSuspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2401-2414",
    "snippet": "int prlsdkSuspend(virDomainObjPtr dom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n\n    job = PrlVm_Suspend(privdom->sdkdom);\n    if (PRL_FAILED(pret = waitDomainJob(job, dom))) {\n        prlsdkConvertError(pret);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prlsdkConvertError",
          "args": [
            "pret"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConvertError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2446-2464",
          "snippet": "static void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "pret = waitDomainJob(job, dom)"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_Suspend",
          "args": [
            "privdom->sdkdom"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nint prlsdkSuspend(virDomainObjPtr dom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n\n    job = PrlVm_Suspend(privdom->sdkdom);\n    if (PRL_FAILED(pret = waitDomainJob(job, dom))) {\n        prlsdkConvertError(pret);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkResume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2386-2399",
    "snippet": "int prlsdkResume(virDomainObjPtr dom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n\n    job = PrlVm_Resume(privdom->sdkdom);\n    if (PRL_FAILED(pret = waitDomainJob(job, dom))) {\n        prlsdkConvertError(pret);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prlsdkConvertError",
          "args": [
            "pret"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConvertError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2446-2464",
          "snippet": "static void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "pret = waitDomainJob(job, dom)"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_Resume",
          "args": [
            "privdom->sdkdom"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nint prlsdkResume(virDomainObjPtr dom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n\n    job = PrlVm_Resume(privdom->sdkdom);\n    if (PRL_FAILED(pret = waitDomainJob(job, dom))) {\n        prlsdkConvertError(pret);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkPause",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2371-2384",
    "snippet": "int prlsdkPause(virDomainObjPtr dom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n\n    job = PrlVm_Pause(privdom->sdkdom, false);\n    if (PRL_FAILED(pret = waitDomainJob(job, dom))) {\n        prlsdkConvertError(pret);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prlsdkConvertError",
          "args": [
            "pret"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConvertError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2446-2464",
          "snippet": "static void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "pret = waitDomainJob(job, dom)"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_Pause",
          "args": [
            "privdom->sdkdom",
            "false"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nint prlsdkPause(virDomainObjPtr dom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n\n    job = PrlVm_Pause(privdom->sdkdom, false);\n    if (PRL_FAILED(pret = waitDomainJob(job, dom))) {\n        prlsdkConvertError(pret);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkStop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2356-2369",
    "snippet": "int prlsdkStop(virDomainObjPtr dom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n\n    job = PrlVm_StopEx(privdom->sdkdom, PSM_SHUTDOWN, 0);\n    if (PRL_FAILED(pret = waitDomainJob(job, dom))) {\n        prlsdkConvertError(pret);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prlsdkConvertError",
          "args": [
            "pret"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConvertError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2446-2464",
          "snippet": "static void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "pret = waitDomainJob(job, dom)"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_StopEx",
          "args": [
            "privdom->sdkdom",
            "PSM_SHUTDOWN",
            "0"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nint prlsdkStop(virDomainObjPtr dom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n\n    job = PrlVm_StopEx(privdom->sdkdom, PSM_SHUTDOWN, 0);\n    if (PRL_FAILED(pret = waitDomainJob(job, dom))) {\n        prlsdkConvertError(pret);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkKill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2341-2354",
    "snippet": "int prlsdkKill(virDomainObjPtr dom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n\n    job = PrlVm_StopEx(privdom->sdkdom, PSM_KILL, 0);\n    if (PRL_FAILED(pret = waitDomainJob(job, dom))) {\n        prlsdkConvertError(pret);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prlsdkConvertError",
          "args": [
            "pret"
          ],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConvertError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2446-2464",
          "snippet": "static void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "pret = waitDomainJob(job, dom)"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_StopEx",
          "args": [
            "privdom->sdkdom",
            "PSM_KILL",
            "0"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nint prlsdkKill(virDomainObjPtr dom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n\n    job = PrlVm_StopEx(privdom->sdkdom, PSM_KILL, 0);\n    if (PRL_FAILED(pret = waitDomainJob(job, dom))) {\n        prlsdkConvertError(pret);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2326-2339",
    "snippet": "int prlsdkStart(virDomainObjPtr dom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n\n    job = PrlVm_StartEx(privdom->sdkdom, PSM_VM_START, 0);\n    if (PRL_FAILED(pret = waitDomainJob(job, dom))) {\n        prlsdkConvertError(pret);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prlsdkConvertError",
          "args": [
            "pret"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConvertError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2446-2464",
          "snippet": "static void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret)\n{\n    virErrorNumber virerr;\n\n    switch (pret) {\n    case PRL_ERR_DISP_VM_IS_NOT_STARTED:\n    case PRL_ERR_DISP_VM_IS_NOT_STOPPED:\n    case PRL_ERR_INVALID_ACTION_REQUESTED:\n    case PRL_ERR_UNIMPLEMENTED:\n        virerr = VIR_ERR_OPERATION_INVALID;\n        break;\n    default:\n        virerr = VIR_ERR_OPERATION_FAILED;\n    }\n\n    virResetLastError();\n    virReportError(virerr, \"%s\", _(\"Can't change domain state.\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "pret = waitDomainJob(job, dom)"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_StartEx",
          "args": [
            "privdom->sdkdom",
            "PSM_VM_START",
            "0"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nint prlsdkStart(virDomainObjPtr dom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n\n    job = PrlVm_StartEx(privdom->sdkdom, PSM_VM_START, 0);\n    if (PRL_FAILED(pret = waitDomainJob(job, dom))) {\n        prlsdkConvertError(pret);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkEventsHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2259-2324",
    "snippet": "static PRL_RESULT\nprlsdkEventsHandler(PRL_HANDLE prlEvent, PRL_VOID_PTR opaque)\n{\n    vzDriverPtr driver = opaque;\n    PRL_RESULT pret = PRL_ERR_FAILURE;\n    PRL_HANDLE_TYPE handleType;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    PRL_EVENT_TYPE prlEventType;\n\n    pret = PrlHandle_GetType(prlEvent, &handleType);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    /* Currently, there is no need to handle anything but events */\n    if (handleType != PHT_EVENT)\n        goto cleanup;\n\n    if (driver == NULL)\n        goto cleanup;\n\n    pret = prlsdkGetStringParamBuf(PrlEvent_GetIssuerId,\n                                   prlEvent, uuidstr, sizeof(uuidstr));\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlEvent_GetType(prlEvent, &prlEventType);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (prlsdkUUIDParse(uuidstr, uuid) < 0) {\n        VIR_DEBUG(\"Skipping event type %d\", prlEventType);\n        goto cleanup;\n    }\n\n    switch ((int)prlEventType) {\n    case PET_DSP_EVT_VM_STATE_CHANGED:\n        prlsdkHandleVmStateEvent(driver, prlEvent, uuid);\n        break;\n    case PET_DSP_EVT_VM_CONFIG_CHANGED:\n        prlsdkHandleVmConfigEvent(driver, uuid);\n        break;\n    case PET_DSP_EVT_VM_CREATED:\n    case PET_DSP_EVT_VM_ADDED:\n        prlsdkHandleVmAddedEvent(driver, uuid);\n        break;\n    case PET_DSP_EVT_VM_DELETED:\n    case PET_DSP_EVT_VM_UNREGISTERED:\n        prlsdkHandleVmRemovedEvent(driver, uuid);\n        break;\n    case PET_DSP_EVT_VM_PERFSTATS:\n        prlsdkHandlePerfEvent(driver, prlEvent, uuid);\n        /* above function takes own of event */\n        prlEvent = PRL_INVALID_HANDLE;\n        break;\n    case PET_DSP_EVT_DISP_CONNECTION_CLOSED:\n        vzDestroyDriverConnection();\n        break;\n    case PET_DSP_EVT_VM_MIGRATE_PROGRESS_CHANGED:\n        prlsdkHandleMigrationProgress(driver, prlEvent, uuid);\n        break;\n    default:\n        VIR_DEBUG(\"Skipping event of type %d\", prlEventType);\n    }\n\n cleanup:\n    PrlHandle_Free(prlEvent);\n    return PRL_ERR_SUCCESS;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);",
      "static void\nprlsdkConvertError(PRL_RESULT pret);",
      "static PRL_RESULT\nprlsdkEventsHandler(PRL_HANDLE prlEvent, PRL_VOID_PTR opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "prlEvent"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Skipping event of type %d\"",
            "prlEventType"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkHandleMigrationProgress",
          "args": [
            "driver",
            "prlEvent",
            "uuid"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkHandleMigrationProgress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2231-2257",
          "snippet": "static void\nprlsdkHandleMigrationProgress(vzDriverPtr driver,\n                              PRL_HANDLE event,\n                              unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n    vzDomObjPtr privdom = NULL;\n    PRL_UINT32 progress;\n    PRL_HANDLE param = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n\n    if (!(dom = virDomainObjListFindByUUID(driver->domains, uuid)))\n        return;\n\n    pret = PrlEvent_GetParam(event, 0, &param);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlEvtPrm_ToUint32(param, &progress);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    privdom = dom->privateData;\n    privdom->job.progress = progress;\n\n cleanup:\n    PrlHandle_Free(param);\n    virDomainObjEndAPI(&dom);\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);",
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic void\nprlsdkHandleMigrationProgress(vzDriverPtr driver,\n                              PRL_HANDLE event,\n                              unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n    vzDomObjPtr privdom = NULL;\n    PRL_UINT32 progress;\n    PRL_HANDLE param = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n\n    if (!(dom = virDomainObjListFindByUUID(driver->domains, uuid)))\n        return;\n\n    pret = PrlEvent_GetParam(event, 0, &param);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlEvtPrm_ToUint32(param, &progress);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    privdom = dom->privateData;\n    privdom->job.progress = progress;\n\n cleanup:\n    PrlHandle_Free(param);\n    virDomainObjEndAPI(&dom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vzDestroyDriverConnection",
          "args": [],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "vzDestroyDriverConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_driver.c",
          "lines": "189-207",
          "snippet": "void\nvzDestroyDriverConnection(void)\n{\n    vzDriverPtr driver;\n    vzConnPtr privconn_list;\n\n    virMutexLock(&vz_driver_lock);\n    driver = g_steal_pointer(&vz_driver);\n    privconn_list = g_steal_pointer(&vz_conn_list);\n    virMutexUnlock(&vz_driver_lock);\n\n    while (privconn_list) {\n        vzConnPtr privconn = privconn_list;\n        privconn_list = privconn->next;\n        virConnectCloseCallbackDataCall(privconn->closeCallback,\n                                        VIR_CONNECT_CLOSE_REASON_EOF);\n    }\n    virObjectUnref(driver);\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"vz_utils.h\"",
            "#include \"vz_driver.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/time.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virMutex vz_driver_lock;",
            "static vzDriverPtr vz_driver;",
            "static vzConnPtr vz_conn_list;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"vz_utils.h\"\n#include \"vz_driver.h\"\n#include \"virutil.h\"\n#include \"viraccessapicheck.h\"\n#include \"virhostcpu.h\"\n#include \"virhostmem.h\"\n#include \"virtypedparam.h\"\n#include \"cpu/cpu.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <sys/statvfs.h>\n#include <sys/time.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virMutex vz_driver_lock;\nstatic vzDriverPtr vz_driver;\nstatic vzConnPtr vz_conn_list;\n\nvoid\nvzDestroyDriverConnection(void)\n{\n    vzDriverPtr driver;\n    vzConnPtr privconn_list;\n\n    virMutexLock(&vz_driver_lock);\n    driver = g_steal_pointer(&vz_driver);\n    privconn_list = g_steal_pointer(&vz_conn_list);\n    virMutexUnlock(&vz_driver_lock);\n\n    while (privconn_list) {\n        vzConnPtr privconn = privconn_list;\n        privconn_list = privconn->next;\n        virConnectCloseCallbackDataCall(privconn->closeCallback,\n                                        VIR_CONNECT_CLOSE_REASON_EOF);\n    }\n    virObjectUnref(driver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkHandlePerfEvent",
          "args": [
            "driver",
            "prlEvent",
            "uuid"
          ],
          "line": 2307
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkHandlePerfEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2211-2229",
          "snippet": "static void\nprlsdkHandlePerfEvent(vzDriverPtr driver,\n                      PRL_HANDLE event,\n                      unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n    vzDomObjPtr privdom = NULL;\n\n    if (!(dom = virDomainObjListFindByUUID(driver->domains, uuid))) {\n        PrlHandle_Free(event);\n        return;\n    }\n\n    privdom = dom->privateData;\n    PrlHandle_Free(privdom->stats);\n    privdom->stats = event;\n\n    virDomainObjEndAPI(&dom);\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic void\nprlsdkHandlePerfEvent(vzDriverPtr driver,\n                      PRL_HANDLE event,\n                      unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n    vzDomObjPtr privdom = NULL;\n\n    if (!(dom = virDomainObjListFindByUUID(driver->domains, uuid))) {\n        PrlHandle_Free(event);\n        return;\n    }\n\n    privdom = dom->privateData;\n    PrlHandle_Free(privdom->stats);\n    privdom->stats = event;\n\n    virDomainObjEndAPI(&dom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkHandleVmRemovedEvent",
          "args": [
            "driver",
            "uuid"
          ],
          "line": 2304
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkHandleVmRemovedEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2191-2209",
          "snippet": "static void\nprlsdkHandleVmRemovedEvent(vzDriverPtr driver,\n                           unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n\n    dom = virDomainObjListFindByUUID(driver->domains, uuid);\n    /* domain was removed from the list from the libvirt\n     * API function in current connection */\n    if (dom == NULL)\n        return;\n\n    prlsdkSendEvent(driver, dom, VIR_DOMAIN_EVENT_UNDEFINED,\n                    VIR_DOMAIN_EVENT_UNDEFINED_REMOVED);\n\n    virDomainObjListRemove(driver->domains, dom);\n    virDomainObjEndAPI(&dom);\n    return;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic void\nprlsdkHandleVmRemovedEvent(vzDriverPtr driver,\n                           unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n\n    dom = virDomainObjListFindByUUID(driver->domains, uuid);\n    /* domain was removed from the list from the libvirt\n     * API function in current connection */\n    if (dom == NULL)\n        return;\n\n    prlsdkSendEvent(driver, dom, VIR_DOMAIN_EVENT_UNDEFINED,\n                    VIR_DOMAIN_EVENT_UNDEFINED_REMOVED);\n\n    virDomainObjListRemove(driver->domains, dom);\n    virDomainObjEndAPI(&dom);\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkHandleVmAddedEvent",
          "args": [
            "driver",
            "uuid"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkHandleVmAddedEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2173-2189",
          "snippet": "static void\nprlsdkHandleVmAddedEvent(vzDriverPtr driver,\n                         unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n\n    if (!(dom = virDomainObjListFindByUUID(driver->domains, uuid)) &&\n        !(dom = prlsdkAddDomainByUUID(driver, uuid)))\n        goto cleanup;\n\n    prlsdkSendEvent(driver, dom, VIR_DOMAIN_EVENT_DEFINED,\n                    VIR_DOMAIN_EVENT_DEFINED_ADDED);\n\n cleanup:\n    virDomainObjEndAPI(&dom);\n    return;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic void\nprlsdkHandleVmAddedEvent(vzDriverPtr driver,\n                         unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n\n    if (!(dom = virDomainObjListFindByUUID(driver->domains, uuid)) &&\n        !(dom = prlsdkAddDomainByUUID(driver, uuid)))\n        goto cleanup;\n\n    prlsdkSendEvent(driver, dom, VIR_DOMAIN_EVENT_DEFINED,\n                    VIR_DOMAIN_EVENT_DEFINED_ADDED);\n\n cleanup:\n    virDomainObjEndAPI(&dom);\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkHandleVmConfigEvent",
          "args": [
            "driver",
            "uuid"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkHandleVmConfigEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2142-2171",
          "snippet": "static void\nprlsdkHandleVmConfigEvent(vzDriverPtr driver,\n                          unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n    bool job = false;\n\n    dom = virDomainObjListFindByUUID(driver->domains, uuid);\n    if (dom == NULL)\n        return;\n\n    if (vzDomainObjBeginJob(dom) < 0)\n        goto cleanup;\n    job = true;\n\n    if (dom->removing)\n        goto cleanup;\n\n    if (prlsdkUpdateDomain(driver, dom) < 0)\n        goto cleanup;\n\n    prlsdkSendEvent(driver, dom, VIR_DOMAIN_EVENT_DEFINED,\n                    VIR_DOMAIN_EVENT_DEFINED_UPDATED);\n\n cleanup:\n    if (job)\n        vzDomainObjEndJob(dom);\n    virDomainObjEndAPI(&dom);\n    return;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic void\nprlsdkHandleVmConfigEvent(vzDriverPtr driver,\n                          unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n    bool job = false;\n\n    dom = virDomainObjListFindByUUID(driver->domains, uuid);\n    if (dom == NULL)\n        return;\n\n    if (vzDomainObjBeginJob(dom) < 0)\n        goto cleanup;\n    job = true;\n\n    if (dom->removing)\n        goto cleanup;\n\n    if (prlsdkUpdateDomain(driver, dom) < 0)\n        goto cleanup;\n\n    prlsdkSendEvent(driver, dom, VIR_DOMAIN_EVENT_DEFINED,\n                    VIR_DOMAIN_EVENT_DEFINED_UPDATED);\n\n cleanup:\n    if (job)\n        vzDomainObjEndJob(dom);\n    virDomainObjEndAPI(&dom);\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkHandleVmStateEvent",
          "args": [
            "driver",
            "prlEvent",
            "uuid"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkHandleVmStateEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2103-2140",
          "snippet": "static void\nprlsdkHandleVmStateEvent(vzDriverPtr driver,\n                         PRL_HANDLE prlEvent,\n                         unsigned char *uuid)\n{\n    PRL_RESULT pret = PRL_ERR_FAILURE;\n    PRL_HANDLE eventParam = PRL_INVALID_HANDLE;\n    PRL_INT32 domainState;\n    virDomainObjPtr dom = NULL;\n    vzDomObjPtr pdom;\n    virDomainEventType lvEventType = 0;\n    int lvEventTypeDetails = 0;\n\n    dom = virDomainObjListFindByUUID(driver->domains, uuid);\n    if (dom == NULL)\n        return;\n\n    pret = PrlEvent_GetParamByName(prlEvent, \"vminfo_vm_state\", &eventParam);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlEvtPrm_ToInt32(eventParam, &domainState);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pdom = dom->privateData;\n\n    prlsdkConvertDomainState(domainState, pdom->id, dom);\n\n    prlsdkNewStateToEvent(domainState,\n                          &lvEventType,\n                          &lvEventTypeDetails);\n\n    prlsdkSendEvent(driver, dom, lvEventType, lvEventTypeDetails);\n\n cleanup:\n    PrlHandle_Free(eventParam);\n    virDomainObjEndAPI(&dom);\n    return;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);",
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic void\nprlsdkHandleVmStateEvent(vzDriverPtr driver,\n                         PRL_HANDLE prlEvent,\n                         unsigned char *uuid)\n{\n    PRL_RESULT pret = PRL_ERR_FAILURE;\n    PRL_HANDLE eventParam = PRL_INVALID_HANDLE;\n    PRL_INT32 domainState;\n    virDomainObjPtr dom = NULL;\n    vzDomObjPtr pdom;\n    virDomainEventType lvEventType = 0;\n    int lvEventTypeDetails = 0;\n\n    dom = virDomainObjListFindByUUID(driver->domains, uuid);\n    if (dom == NULL)\n        return;\n\n    pret = PrlEvent_GetParamByName(prlEvent, \"vminfo_vm_state\", &eventParam);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlEvtPrm_ToInt32(eventParam, &domainState);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pdom = dom->privateData;\n\n    prlsdkConvertDomainState(domainState, pdom->id, dom);\n\n    prlsdkNewStateToEvent(domainState,\n                          &lvEventType,\n                          &lvEventTypeDetails);\n\n    prlsdkSendEvent(driver, dom, lvEventType, lvEventTypeDetails);\n\n cleanup:\n    PrlHandle_Free(eventParam);\n    virDomainObjEndAPI(&dom);\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Skipping event type %d\"",
            "prlEventType"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkUUIDParse",
          "args": [
            "uuidstr",
            "uuid"
          ],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "496-517",
          "snippet": "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    char *tmp = NULL;\n    int ret = -1;\n\n    virCheckNonNullArgGoto(uuidstr, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    tmp = g_strdup(uuidstr);\n\n    tmp[strlen(tmp) - 1] = '\\0';\n\n    /* trim curly braces */\n    if (virUUIDParse(tmp + 1, uuid) < 0)\n        goto error;\n\n    ret = 0;\n error:\n    VIR_FREE(tmp);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    char *tmp = NULL;\n    int ret = -1;\n\n    virCheckNonNullArgGoto(uuidstr, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    tmp = g_strdup(uuidstr);\n\n    tmp[strlen(tmp) - 1] = '\\0';\n\n    /* trim curly braces */\n    if (virUUIDParse(tmp + 1, uuid) < 0)\n        goto error;\n\n    ret = 0;\n error:\n    VIR_FREE(tmp);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlEvent_GetType",
          "args": [
            "prlEvent",
            "&prlEventType"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetStringParamBuf",
          "args": [
            "PrlEvent_GetIssuerId",
            "prlEvent",
            "uuidstr",
            "sizeof(uuidstr)"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetStringParamBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "322-328",
          "snippet": "static PRL_RESULT\nprlsdkGetStringParamBuf(prlsdkParamGetterType getter,\n                        PRL_HANDLE handle, char *buf, size_t size)\n{\n    PRL_UINT32 buflen = size;\n    return getter(handle, buf, &buflen);\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_RESULT\nprlsdkGetStringParamBuf(prlsdkParamGetterType getter,\n                        PRL_HANDLE handle, char *buf, size_t size)\n{\n    PRL_UINT32 buflen = size;\n    return getter(handle, buf, &buflen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_GetType",
          "args": [
            "prlEvent",
            "&handleType"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_RESULT\nprlsdkEventsHandler(PRL_HANDLE prlEvent, PRL_VOID_PTR opaque);\n\nstatic PRL_RESULT\nprlsdkEventsHandler(PRL_HANDLE prlEvent, PRL_VOID_PTR opaque)\n{\n    vzDriverPtr driver = opaque;\n    PRL_RESULT pret = PRL_ERR_FAILURE;\n    PRL_HANDLE_TYPE handleType;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    PRL_EVENT_TYPE prlEventType;\n\n    pret = PrlHandle_GetType(prlEvent, &handleType);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    /* Currently, there is no need to handle anything but events */\n    if (handleType != PHT_EVENT)\n        goto cleanup;\n\n    if (driver == NULL)\n        goto cleanup;\n\n    pret = prlsdkGetStringParamBuf(PrlEvent_GetIssuerId,\n                                   prlEvent, uuidstr, sizeof(uuidstr));\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlEvent_GetType(prlEvent, &prlEventType);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (prlsdkUUIDParse(uuidstr, uuid) < 0) {\n        VIR_DEBUG(\"Skipping event type %d\", prlEventType);\n        goto cleanup;\n    }\n\n    switch ((int)prlEventType) {\n    case PET_DSP_EVT_VM_STATE_CHANGED:\n        prlsdkHandleVmStateEvent(driver, prlEvent, uuid);\n        break;\n    case PET_DSP_EVT_VM_CONFIG_CHANGED:\n        prlsdkHandleVmConfigEvent(driver, uuid);\n        break;\n    case PET_DSP_EVT_VM_CREATED:\n    case PET_DSP_EVT_VM_ADDED:\n        prlsdkHandleVmAddedEvent(driver, uuid);\n        break;\n    case PET_DSP_EVT_VM_DELETED:\n    case PET_DSP_EVT_VM_UNREGISTERED:\n        prlsdkHandleVmRemovedEvent(driver, uuid);\n        break;\n    case PET_DSP_EVT_VM_PERFSTATS:\n        prlsdkHandlePerfEvent(driver, prlEvent, uuid);\n        /* above function takes own of event */\n        prlEvent = PRL_INVALID_HANDLE;\n        break;\n    case PET_DSP_EVT_DISP_CONNECTION_CLOSED:\n        vzDestroyDriverConnection();\n        break;\n    case PET_DSP_EVT_VM_MIGRATE_PROGRESS_CHANGED:\n        prlsdkHandleMigrationProgress(driver, prlEvent, uuid);\n        break;\n    default:\n        VIR_DEBUG(\"Skipping event of type %d\", prlEventType);\n    }\n\n cleanup:\n    PrlHandle_Free(prlEvent);\n    return PRL_ERR_SUCCESS;\n}"
  },
  {
    "function_name": "prlsdkHandleMigrationProgress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2231-2257",
    "snippet": "static void\nprlsdkHandleMigrationProgress(vzDriverPtr driver,\n                              PRL_HANDLE event,\n                              unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n    vzDomObjPtr privdom = NULL;\n    PRL_UINT32 progress;\n    PRL_HANDLE param = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n\n    if (!(dom = virDomainObjListFindByUUID(driver->domains, uuid)))\n        return;\n\n    pret = PrlEvent_GetParam(event, 0, &param);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlEvtPrm_ToUint32(param, &progress);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    privdom = dom->privateData;\n    privdom->job.progress = progress;\n\n cleanup:\n    PrlHandle_Free(param);\n    virDomainObjEndAPI(&dom);\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);",
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&dom"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "param"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlEvtPrm_ToUint32",
          "args": [
            "param",
            "&progress"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlEvent_GetParam",
          "args": [
            "event",
            "0",
            "&param"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjListFindByUUID",
          "args": [
            "driver->domains",
            "uuid"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListFindByUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "162-179",
          "snippet": "virDomainObjPtr\nvirDomainObjListFindByUUID(virDomainObjListPtr doms,\n                           const unsigned char *uuid)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByUUIDLocked(doms, uuid);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virDomainObjListDispose(void *obj);\n\nvirDomainObjPtr\nvirDomainObjListFindByUUID(virDomainObjListPtr doms,\n                           const unsigned char *uuid)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByUUIDLocked(doms, uuid);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic void\nprlsdkHandleMigrationProgress(vzDriverPtr driver,\n                              PRL_HANDLE event,\n                              unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n    vzDomObjPtr privdom = NULL;\n    PRL_UINT32 progress;\n    PRL_HANDLE param = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n\n    if (!(dom = virDomainObjListFindByUUID(driver->domains, uuid)))\n        return;\n\n    pret = PrlEvent_GetParam(event, 0, &param);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlEvtPrm_ToUint32(param, &progress);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    privdom = dom->privateData;\n    privdom->job.progress = progress;\n\n cleanup:\n    PrlHandle_Free(param);\n    virDomainObjEndAPI(&dom);\n}"
  },
  {
    "function_name": "prlsdkHandlePerfEvent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2211-2229",
    "snippet": "static void\nprlsdkHandlePerfEvent(vzDriverPtr driver,\n                      PRL_HANDLE event,\n                      unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n    vzDomObjPtr privdom = NULL;\n\n    if (!(dom = virDomainObjListFindByUUID(driver->domains, uuid))) {\n        PrlHandle_Free(event);\n        return;\n    }\n\n    privdom = dom->privateData;\n    PrlHandle_Free(privdom->stats);\n    privdom->stats = event;\n\n    virDomainObjEndAPI(&dom);\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&dom"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "privdom->stats"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "event"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjListFindByUUID",
          "args": [
            "driver->domains",
            "uuid"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListFindByUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "162-179",
          "snippet": "virDomainObjPtr\nvirDomainObjListFindByUUID(virDomainObjListPtr doms,\n                           const unsigned char *uuid)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByUUIDLocked(doms, uuid);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virDomainObjListDispose(void *obj);\n\nvirDomainObjPtr\nvirDomainObjListFindByUUID(virDomainObjListPtr doms,\n                           const unsigned char *uuid)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByUUIDLocked(doms, uuid);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic void\nprlsdkHandlePerfEvent(vzDriverPtr driver,\n                      PRL_HANDLE event,\n                      unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n    vzDomObjPtr privdom = NULL;\n\n    if (!(dom = virDomainObjListFindByUUID(driver->domains, uuid))) {\n        PrlHandle_Free(event);\n        return;\n    }\n\n    privdom = dom->privateData;\n    PrlHandle_Free(privdom->stats);\n    privdom->stats = event;\n\n    virDomainObjEndAPI(&dom);\n}"
  },
  {
    "function_name": "prlsdkHandleVmRemovedEvent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2191-2209",
    "snippet": "static void\nprlsdkHandleVmRemovedEvent(vzDriverPtr driver,\n                           unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n\n    dom = virDomainObjListFindByUUID(driver->domains, uuid);\n    /* domain was removed from the list from the libvirt\n     * API function in current connection */\n    if (dom == NULL)\n        return;\n\n    prlsdkSendEvent(driver, dom, VIR_DOMAIN_EVENT_UNDEFINED,\n                    VIR_DOMAIN_EVENT_UNDEFINED_REMOVED);\n\n    virDomainObjListRemove(driver->domains, dom);\n    virDomainObjEndAPI(&dom);\n    return;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&dom"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListRemove",
          "args": [
            "driver->domains",
            "dom"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "401-413",
          "snippet": "void\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkSendEvent",
          "args": [
            "driver",
            "dom",
            "VIR_DOMAIN_EVENT_UNDEFINED",
            "VIR_DOMAIN_EVENT_UNDEFINED_REMOVED"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkSendEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2056-2068",
          "snippet": "static void\nprlsdkSendEvent(vzDriverPtr driver,\n                virDomainObjPtr dom,\n                virDomainEventType lvEventType,\n                int lvEventTypeDetails)\n{\n    virObjectEventPtr event;\n\n    event = virDomainEventLifecycleNewFromObj(dom,\n                                              lvEventType,\n                                              lvEventTypeDetails);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkSendEvent(vzDriverPtr driver,\n                virDomainObjPtr dom,\n                virDomainEventType lvEventType,\n                int lvEventTypeDetails)\n{\n    virObjectEventPtr event;\n\n    event = virDomainEventLifecycleNewFromObj(dom,\n                                              lvEventType,\n                                              lvEventTypeDetails);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListFindByUUID",
          "args": [
            "driver->domains",
            "uuid"
          ],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListFindByUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "162-179",
          "snippet": "virDomainObjPtr\nvirDomainObjListFindByUUID(virDomainObjListPtr doms,\n                           const unsigned char *uuid)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByUUIDLocked(doms, uuid);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virDomainObjListDispose(void *obj);\n\nvirDomainObjPtr\nvirDomainObjListFindByUUID(virDomainObjListPtr doms,\n                           const unsigned char *uuid)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByUUIDLocked(doms, uuid);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic void\nprlsdkHandleVmRemovedEvent(vzDriverPtr driver,\n                           unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n\n    dom = virDomainObjListFindByUUID(driver->domains, uuid);\n    /* domain was removed from the list from the libvirt\n     * API function in current connection */\n    if (dom == NULL)\n        return;\n\n    prlsdkSendEvent(driver, dom, VIR_DOMAIN_EVENT_UNDEFINED,\n                    VIR_DOMAIN_EVENT_UNDEFINED_REMOVED);\n\n    virDomainObjListRemove(driver->domains, dom);\n    virDomainObjEndAPI(&dom);\n    return;\n}"
  },
  {
    "function_name": "prlsdkHandleVmAddedEvent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2173-2189",
    "snippet": "static void\nprlsdkHandleVmAddedEvent(vzDriverPtr driver,\n                         unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n\n    if (!(dom = virDomainObjListFindByUUID(driver->domains, uuid)) &&\n        !(dom = prlsdkAddDomainByUUID(driver, uuid)))\n        goto cleanup;\n\n    prlsdkSendEvent(driver, dom, VIR_DOMAIN_EVENT_DEFINED,\n                    VIR_DOMAIN_EVENT_DEFINED_ADDED);\n\n cleanup:\n    virDomainObjEndAPI(&dom);\n    return;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&dom"
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkSendEvent",
          "args": [
            "driver",
            "dom",
            "VIR_DOMAIN_EVENT_DEFINED",
            "VIR_DOMAIN_EVENT_DEFINED_ADDED"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkSendEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2056-2068",
          "snippet": "static void\nprlsdkSendEvent(vzDriverPtr driver,\n                virDomainObjPtr dom,\n                virDomainEventType lvEventType,\n                int lvEventTypeDetails)\n{\n    virObjectEventPtr event;\n\n    event = virDomainEventLifecycleNewFromObj(dom,\n                                              lvEventType,\n                                              lvEventTypeDetails);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkSendEvent(vzDriverPtr driver,\n                virDomainObjPtr dom,\n                virDomainEventType lvEventType,\n                int lvEventTypeDetails)\n{\n    virObjectEventPtr event;\n\n    event = virDomainEventLifecycleNewFromObj(dom,\n                                              lvEventType,\n                                              lvEventTypeDetails);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkAddDomainByUUID",
          "args": [
            "driver",
            "uuid"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkAddDomainByUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2011-2025",
          "snippet": "virDomainObjPtr\nprlsdkAddDomainByUUID(vzDriverPtr driver, const unsigned char *uuid)\n{\n    PRL_HANDLE sdkdom;\n    virDomainObjPtr dom;\n\n    sdkdom = prlsdkSdkDomainLookupByUUID(driver, uuid);\n    if (sdkdom == PRL_INVALID_HANDLE)\n        return NULL;\n\n    dom = prlsdkLoadDomain(driver, sdkdom, NULL);\n\n    PrlHandle_Free(sdkdom);\n    return dom;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nvirDomainObjPtr\nprlsdkAddDomainByUUID(vzDriverPtr driver, const unsigned char *uuid)\n{\n    PRL_HANDLE sdkdom;\n    virDomainObjPtr dom;\n\n    sdkdom = prlsdkSdkDomainLookupByUUID(driver, uuid);\n    if (sdkdom == PRL_INVALID_HANDLE)\n        return NULL;\n\n    dom = prlsdkLoadDomain(driver, sdkdom, NULL);\n\n    PrlHandle_Free(sdkdom);\n    return dom;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListFindByUUID",
          "args": [
            "driver->domains",
            "uuid"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListFindByUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "162-179",
          "snippet": "virDomainObjPtr\nvirDomainObjListFindByUUID(virDomainObjListPtr doms,\n                           const unsigned char *uuid)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByUUIDLocked(doms, uuid);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virDomainObjListDispose(void *obj);\n\nvirDomainObjPtr\nvirDomainObjListFindByUUID(virDomainObjListPtr doms,\n                           const unsigned char *uuid)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByUUIDLocked(doms, uuid);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic void\nprlsdkHandleVmAddedEvent(vzDriverPtr driver,\n                         unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n\n    if (!(dom = virDomainObjListFindByUUID(driver->domains, uuid)) &&\n        !(dom = prlsdkAddDomainByUUID(driver, uuid)))\n        goto cleanup;\n\n    prlsdkSendEvent(driver, dom, VIR_DOMAIN_EVENT_DEFINED,\n                    VIR_DOMAIN_EVENT_DEFINED_ADDED);\n\n cleanup:\n    virDomainObjEndAPI(&dom);\n    return;\n}"
  },
  {
    "function_name": "prlsdkHandleVmConfigEvent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2142-2171",
    "snippet": "static void\nprlsdkHandleVmConfigEvent(vzDriverPtr driver,\n                          unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n    bool job = false;\n\n    dom = virDomainObjListFindByUUID(driver->domains, uuid);\n    if (dom == NULL)\n        return;\n\n    if (vzDomainObjBeginJob(dom) < 0)\n        goto cleanup;\n    job = true;\n\n    if (dom->removing)\n        goto cleanup;\n\n    if (prlsdkUpdateDomain(driver, dom) < 0)\n        goto cleanup;\n\n    prlsdkSendEvent(driver, dom, VIR_DOMAIN_EVENT_DEFINED,\n                    VIR_DOMAIN_EVENT_DEFINED_UPDATED);\n\n cleanup:\n    if (job)\n        vzDomainObjEndJob(dom);\n    virDomainObjEndAPI(&dom);\n    return;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&dom"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vzDomainObjEndJob",
          "args": [
            "dom"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "vzDomainObjEndJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_utils.c",
          "lines": "627-635",
          "snippet": "void\nvzDomainObjEndJob(virDomainObjPtr dom)\n{\n    vzDomObjPtr pdom = dom->privateData;\n\n    pdom->job.active = false;\n    pdom->job.cancelled = false;\n    virCondSignal(&pdom->job.cond);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virtime.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virstring.h\"",
            "#include \"vz_sdk.h\"",
            "#include \"vz_utils.h\"",
            "#include \"virjson.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virtime.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virstring.h\"\n#include \"vz_sdk.h\"\n#include \"vz_utils.h\"\n#include \"virjson.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvzDomainObjEndJob(virDomainObjPtr dom)\n{\n    vzDomObjPtr pdom = dom->privateData;\n\n    pdom->job.active = false;\n    pdom->job.cancelled = false;\n    virCondSignal(&pdom->job.cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkSendEvent",
          "args": [
            "driver",
            "dom",
            "VIR_DOMAIN_EVENT_DEFINED",
            "VIR_DOMAIN_EVENT_DEFINED_UPDATED"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkSendEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2056-2068",
          "snippet": "static void\nprlsdkSendEvent(vzDriverPtr driver,\n                virDomainObjPtr dom,\n                virDomainEventType lvEventType,\n                int lvEventTypeDetails)\n{\n    virObjectEventPtr event;\n\n    event = virDomainEventLifecycleNewFromObj(dom,\n                                              lvEventType,\n                                              lvEventTypeDetails);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkSendEvent(vzDriverPtr driver,\n                virDomainObjPtr dom,\n                virDomainEventType lvEventType,\n                int lvEventTypeDetails)\n{\n    virObjectEventPtr event;\n\n    event = virDomainEventLifecycleNewFromObj(dom,\n                                              lvEventType,\n                                              lvEventTypeDetails);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkUpdateDomain",
          "args": [
            "driver",
            "dom"
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkUpdateDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2043-2054",
          "snippet": "int\nprlsdkUpdateDomain(vzDriverPtr driver, virDomainObjPtr dom)\n{\n    PRL_HANDLE job;\n    vzDomObjPtr pdom = dom->privateData;\n\n    job = PrlVm_RefreshConfig(pdom->sdkdom);\n    if (waitDomainJob(job, dom))\n        return -1;\n\n    return prlsdkLoadDomain(driver, pdom->sdkdom, dom) ? 0 : -1;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nprlsdkUpdateDomain(vzDriverPtr driver, virDomainObjPtr dom)\n{\n    PRL_HANDLE job;\n    vzDomObjPtr pdom = dom->privateData;\n\n    job = PrlVm_RefreshConfig(pdom->sdkdom);\n    if (waitDomainJob(job, dom))\n        return -1;\n\n    return prlsdkLoadDomain(driver, pdom->sdkdom, dom) ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vzDomainObjBeginJob",
          "args": [
            "dom"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "vzDomainObjBeginJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_utils.c",
          "lines": "591-625",
          "snippet": "int\nvzDomainObjBeginJob(virDomainObjPtr dom)\n{\n    vzDomObjPtr pdom = dom->privateData;\n    unsigned long long now;\n    unsigned long long then;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n    then = now + VZ_JOB_WAIT_TIME;\n\n    while (pdom->job.active) {\n        if (virCondWaitUntil(&pdom->job.cond, &dom->parent.lock, then) < 0)\n            goto error;\n    }\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    pdom->job.active = true;\n    pdom->job.started = now;\n    pdom->job.elapsed = 0;\n    pdom->job.progress = 0;\n    pdom->job.hasProgress = false;\n    return 0;\n\n error:\n    if (errno == ETIMEDOUT)\n        virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                       \"%s\", _(\"cannot acquire state change lock\"));\n    else\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot acquire job mutex\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virtime.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virstring.h\"",
            "#include \"vz_sdk.h\"",
            "#include \"vz_utils.h\"",
            "#include \"virjson.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VZ_JOB_WAIT_TIME (1000 * 30)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virtime.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virstring.h\"\n#include \"vz_sdk.h\"\n#include \"vz_utils.h\"\n#include \"virjson.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define VZ_JOB_WAIT_TIME (1000 * 30)\n\nint\nvzDomainObjBeginJob(virDomainObjPtr dom)\n{\n    vzDomObjPtr pdom = dom->privateData;\n    unsigned long long now;\n    unsigned long long then;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n    then = now + VZ_JOB_WAIT_TIME;\n\n    while (pdom->job.active) {\n        if (virCondWaitUntil(&pdom->job.cond, &dom->parent.lock, then) < 0)\n            goto error;\n    }\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    pdom->job.active = true;\n    pdom->job.started = now;\n    pdom->job.elapsed = 0;\n    pdom->job.progress = 0;\n    pdom->job.hasProgress = false;\n    return 0;\n\n error:\n    if (errno == ETIMEDOUT)\n        virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                       \"%s\", _(\"cannot acquire state change lock\"));\n    else\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot acquire job mutex\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListFindByUUID",
          "args": [
            "driver->domains",
            "uuid"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListFindByUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "162-179",
          "snippet": "virDomainObjPtr\nvirDomainObjListFindByUUID(virDomainObjListPtr doms,\n                           const unsigned char *uuid)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByUUIDLocked(doms, uuid);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virDomainObjListDispose(void *obj);\n\nvirDomainObjPtr\nvirDomainObjListFindByUUID(virDomainObjListPtr doms,\n                           const unsigned char *uuid)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByUUIDLocked(doms, uuid);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic void\nprlsdkHandleVmConfigEvent(vzDriverPtr driver,\n                          unsigned char *uuid)\n{\n    virDomainObjPtr dom = NULL;\n    bool job = false;\n\n    dom = virDomainObjListFindByUUID(driver->domains, uuid);\n    if (dom == NULL)\n        return;\n\n    if (vzDomainObjBeginJob(dom) < 0)\n        goto cleanup;\n    job = true;\n\n    if (dom->removing)\n        goto cleanup;\n\n    if (prlsdkUpdateDomain(driver, dom) < 0)\n        goto cleanup;\n\n    prlsdkSendEvent(driver, dom, VIR_DOMAIN_EVENT_DEFINED,\n                    VIR_DOMAIN_EVENT_DEFINED_UPDATED);\n\n cleanup:\n    if (job)\n        vzDomainObjEndJob(dom);\n    virDomainObjEndAPI(&dom);\n    return;\n}"
  },
  {
    "function_name": "prlsdkHandleVmStateEvent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2103-2140",
    "snippet": "static void\nprlsdkHandleVmStateEvent(vzDriverPtr driver,\n                         PRL_HANDLE prlEvent,\n                         unsigned char *uuid)\n{\n    PRL_RESULT pret = PRL_ERR_FAILURE;\n    PRL_HANDLE eventParam = PRL_INVALID_HANDLE;\n    PRL_INT32 domainState;\n    virDomainObjPtr dom = NULL;\n    vzDomObjPtr pdom;\n    virDomainEventType lvEventType = 0;\n    int lvEventTypeDetails = 0;\n\n    dom = virDomainObjListFindByUUID(driver->domains, uuid);\n    if (dom == NULL)\n        return;\n\n    pret = PrlEvent_GetParamByName(prlEvent, \"vminfo_vm_state\", &eventParam);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlEvtPrm_ToInt32(eventParam, &domainState);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pdom = dom->privateData;\n\n    prlsdkConvertDomainState(domainState, pdom->id, dom);\n\n    prlsdkNewStateToEvent(domainState,\n                          &lvEventType,\n                          &lvEventTypeDetails);\n\n    prlsdkSendEvent(driver, dom, lvEventType, lvEventTypeDetails);\n\n cleanup:\n    PrlHandle_Free(eventParam);\n    virDomainObjEndAPI(&dom);\n    return;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);",
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&dom"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "eventParam"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkSendEvent",
          "args": [
            "driver",
            "dom",
            "lvEventType",
            "lvEventTypeDetails"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkSendEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2056-2068",
          "snippet": "static void\nprlsdkSendEvent(vzDriverPtr driver,\n                virDomainObjPtr dom,\n                virDomainEventType lvEventType,\n                int lvEventTypeDetails)\n{\n    virObjectEventPtr event;\n\n    event = virDomainEventLifecycleNewFromObj(dom,\n                                              lvEventType,\n                                              lvEventTypeDetails);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkSendEvent(vzDriverPtr driver,\n                virDomainObjPtr dom,\n                virDomainEventType lvEventType,\n                int lvEventTypeDetails)\n{\n    virObjectEventPtr event;\n\n    event = virDomainEventLifecycleNewFromObj(dom,\n                                              lvEventType,\n                                              lvEventTypeDetails);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkNewStateToEvent",
          "args": [
            "domainState",
            "&lvEventType",
            "&lvEventTypeDetails"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkNewStateToEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "2070-2101",
          "snippet": "static void\nprlsdkNewStateToEvent(VIRTUAL_MACHINE_STATE domainState,\n                      virDomainEventType *lvEventType,\n                      int *lvEventTypeDetails)\n{\n    /* We skip all intermediate states here, because\n     * libvirt doesn't have correspoding event types for\n     * them */\n    switch ((int)domainState) {\n    case VMS_STOPPED:\n    case VMS_MOUNTED:\n        *lvEventType = VIR_DOMAIN_EVENT_STOPPED;\n        *lvEventTypeDetails = VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN;\n        break;\n    case VMS_RUNNING:\n        *lvEventType = VIR_DOMAIN_EVENT_STARTED;\n        *lvEventTypeDetails = VIR_DOMAIN_EVENT_STARTED_BOOTED;\n        break;\n    case VMS_PAUSED:\n        *lvEventType = VIR_DOMAIN_EVENT_SUSPENDED;\n        *lvEventTypeDetails = VIR_DOMAIN_EVENT_SUSPENDED_PAUSED;\n        break;\n    case VMS_SUSPENDED:\n        *lvEventType = VIR_DOMAIN_EVENT_STOPPED;\n        *lvEventTypeDetails = VIR_DOMAIN_EVENT_STOPPED_SAVED;\n        break;\n    default:\n        VIR_DEBUG(\"Skip sending event about changing state to %X\",\n                  domainState);\n        break;\n    }\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkNewStateToEvent(VIRTUAL_MACHINE_STATE domainState,\n                      virDomainEventType *lvEventType,\n                      int *lvEventTypeDetails)\n{\n    /* We skip all intermediate states here, because\n     * libvirt doesn't have correspoding event types for\n     * them */\n    switch ((int)domainState) {\n    case VMS_STOPPED:\n    case VMS_MOUNTED:\n        *lvEventType = VIR_DOMAIN_EVENT_STOPPED;\n        *lvEventTypeDetails = VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN;\n        break;\n    case VMS_RUNNING:\n        *lvEventType = VIR_DOMAIN_EVENT_STARTED;\n        *lvEventTypeDetails = VIR_DOMAIN_EVENT_STARTED_BOOTED;\n        break;\n    case VMS_PAUSED:\n        *lvEventType = VIR_DOMAIN_EVENT_SUSPENDED;\n        *lvEventTypeDetails = VIR_DOMAIN_EVENT_SUSPENDED_PAUSED;\n        break;\n    case VMS_SUSPENDED:\n        *lvEventType = VIR_DOMAIN_EVENT_STOPPED;\n        *lvEventTypeDetails = VIR_DOMAIN_EVENT_STOPPED_SAVED;\n        break;\n    default:\n        VIR_DEBUG(\"Skip sending event about changing state to %X\",\n                  domainState);\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkConvertDomainState",
          "args": [
            "domainState",
            "pdom->id",
            "dom"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConvertDomainState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1376-1452",
          "snippet": "static void\nprlsdkConvertDomainState(VIRTUAL_MACHINE_STATE domainState,\n                         PRL_UINT32 envId,\n                         virDomainObjPtr dom)\n{\n    switch (domainState) {\n    case VMS_STOPPED:\n    case VMS_MOUNTED:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n        dom->def->id = -1;\n        break;\n    case VMS_STARTING:\n    case VMS_COMPACTING:\n    case VMS_RESETTING:\n    case VMS_PAUSING:\n    case VMS_RECONNECTING:\n    case VMS_RUNNING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_BOOTED);\n        dom->def->id = envId;\n        break;\n    case VMS_PAUSED:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_USER);\n        dom->def->id = envId;\n        break;\n    case VMS_SUSPENDED:\n    case VMS_DELETING_STATE:\n    case VMS_SUSPENDING_SYNC:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_SAVED);\n        dom->def->id = -1;\n        break;\n    case VMS_STOPPING:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTDOWN,\n                             VIR_DOMAIN_SHUTDOWN_USER);\n        dom->def->id = envId;\n        break;\n    case VMS_SNAPSHOTING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_SNAPSHOT);\n        dom->def->id = envId;\n        break;\n    case VMS_MIGRATING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_MIGRATION);\n        dom->def->id = envId;\n        break;\n    case VMS_SUSPENDING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_SAVE);\n        dom->def->id = envId;\n        break;\n    case VMS_RESTORING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_RESTORED);\n        dom->def->id = envId;\n        break;\n    case VMS_CONTINUING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_UNPAUSED);\n        dom->def->id = envId;\n        break;\n    case VMS_RESUMING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_RESTORED);\n        dom->def->id = envId;\n        break;\n    case VMS_UNKNOWN:\n    default:\n        virDomainObjSetState(dom, VIR_DOMAIN_NOSTATE,\n                             VIR_DOMAIN_NOSTATE_UNKNOWN);\n        dom->def->id = -1;\n        break;\n    }\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertDomainState(VIRTUAL_MACHINE_STATE domainState,\n                         PRL_UINT32 envId,\n                         virDomainObjPtr dom)\n{\n    switch (domainState) {\n    case VMS_STOPPED:\n    case VMS_MOUNTED:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n        dom->def->id = -1;\n        break;\n    case VMS_STARTING:\n    case VMS_COMPACTING:\n    case VMS_RESETTING:\n    case VMS_PAUSING:\n    case VMS_RECONNECTING:\n    case VMS_RUNNING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_BOOTED);\n        dom->def->id = envId;\n        break;\n    case VMS_PAUSED:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_USER);\n        dom->def->id = envId;\n        break;\n    case VMS_SUSPENDED:\n    case VMS_DELETING_STATE:\n    case VMS_SUSPENDING_SYNC:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_SAVED);\n        dom->def->id = -1;\n        break;\n    case VMS_STOPPING:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTDOWN,\n                             VIR_DOMAIN_SHUTDOWN_USER);\n        dom->def->id = envId;\n        break;\n    case VMS_SNAPSHOTING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_SNAPSHOT);\n        dom->def->id = envId;\n        break;\n    case VMS_MIGRATING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_MIGRATION);\n        dom->def->id = envId;\n        break;\n    case VMS_SUSPENDING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_SAVE);\n        dom->def->id = envId;\n        break;\n    case VMS_RESTORING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_RESTORED);\n        dom->def->id = envId;\n        break;\n    case VMS_CONTINUING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_UNPAUSED);\n        dom->def->id = envId;\n        break;\n    case VMS_RESUMING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_RESTORED);\n        dom->def->id = envId;\n        break;\n    case VMS_UNKNOWN:\n    default:\n        virDomainObjSetState(dom, VIR_DOMAIN_NOSTATE,\n                             VIR_DOMAIN_NOSTATE_UNKNOWN);\n        dom->def->id = -1;\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlEvtPrm_ToInt32",
          "args": [
            "eventParam",
            "&domainState"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlEvent_GetParamByName",
          "args": [
            "prlEvent",
            "\"vminfo_vm_state\"",
            "&eventParam"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjListFindByUUID",
          "args": [
            "driver->domains",
            "uuid"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListFindByUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "162-179",
          "snippet": "virDomainObjPtr\nvirDomainObjListFindByUUID(virDomainObjListPtr doms,\n                           const unsigned char *uuid)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByUUIDLocked(doms, uuid);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virDomainObjListDispose(void *obj);\n\nvirDomainObjPtr\nvirDomainObjListFindByUUID(virDomainObjListPtr doms,\n                           const unsigned char *uuid)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByUUIDLocked(doms, uuid);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic void\nprlsdkHandleVmStateEvent(vzDriverPtr driver,\n                         PRL_HANDLE prlEvent,\n                         unsigned char *uuid)\n{\n    PRL_RESULT pret = PRL_ERR_FAILURE;\n    PRL_HANDLE eventParam = PRL_INVALID_HANDLE;\n    PRL_INT32 domainState;\n    virDomainObjPtr dom = NULL;\n    vzDomObjPtr pdom;\n    virDomainEventType lvEventType = 0;\n    int lvEventTypeDetails = 0;\n\n    dom = virDomainObjListFindByUUID(driver->domains, uuid);\n    if (dom == NULL)\n        return;\n\n    pret = PrlEvent_GetParamByName(prlEvent, \"vminfo_vm_state\", &eventParam);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlEvtPrm_ToInt32(eventParam, &domainState);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pdom = dom->privateData;\n\n    prlsdkConvertDomainState(domainState, pdom->id, dom);\n\n    prlsdkNewStateToEvent(domainState,\n                          &lvEventType,\n                          &lvEventTypeDetails);\n\n    prlsdkSendEvent(driver, dom, lvEventType, lvEventTypeDetails);\n\n cleanup:\n    PrlHandle_Free(eventParam);\n    virDomainObjEndAPI(&dom);\n    return;\n}"
  },
  {
    "function_name": "prlsdkNewStateToEvent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2070-2101",
    "snippet": "static void\nprlsdkNewStateToEvent(VIRTUAL_MACHINE_STATE domainState,\n                      virDomainEventType *lvEventType,\n                      int *lvEventTypeDetails)\n{\n    /* We skip all intermediate states here, because\n     * libvirt doesn't have correspoding event types for\n     * them */\n    switch ((int)domainState) {\n    case VMS_STOPPED:\n    case VMS_MOUNTED:\n        *lvEventType = VIR_DOMAIN_EVENT_STOPPED;\n        *lvEventTypeDetails = VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN;\n        break;\n    case VMS_RUNNING:\n        *lvEventType = VIR_DOMAIN_EVENT_STARTED;\n        *lvEventTypeDetails = VIR_DOMAIN_EVENT_STARTED_BOOTED;\n        break;\n    case VMS_PAUSED:\n        *lvEventType = VIR_DOMAIN_EVENT_SUSPENDED;\n        *lvEventTypeDetails = VIR_DOMAIN_EVENT_SUSPENDED_PAUSED;\n        break;\n    case VMS_SUSPENDED:\n        *lvEventType = VIR_DOMAIN_EVENT_STOPPED;\n        *lvEventTypeDetails = VIR_DOMAIN_EVENT_STOPPED_SAVED;\n        break;\n    default:\n        VIR_DEBUG(\"Skip sending event about changing state to %X\",\n                  domainState);\n        break;\n    }\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Skip sending event about changing state to %X\"",
            "domainState"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkNewStateToEvent(VIRTUAL_MACHINE_STATE domainState,\n                      virDomainEventType *lvEventType,\n                      int *lvEventTypeDetails)\n{\n    /* We skip all intermediate states here, because\n     * libvirt doesn't have correspoding event types for\n     * them */\n    switch ((int)domainState) {\n    case VMS_STOPPED:\n    case VMS_MOUNTED:\n        *lvEventType = VIR_DOMAIN_EVENT_STOPPED;\n        *lvEventTypeDetails = VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN;\n        break;\n    case VMS_RUNNING:\n        *lvEventType = VIR_DOMAIN_EVENT_STARTED;\n        *lvEventTypeDetails = VIR_DOMAIN_EVENT_STARTED_BOOTED;\n        break;\n    case VMS_PAUSED:\n        *lvEventType = VIR_DOMAIN_EVENT_SUSPENDED;\n        *lvEventTypeDetails = VIR_DOMAIN_EVENT_SUSPENDED_PAUSED;\n        break;\n    case VMS_SUSPENDED:\n        *lvEventType = VIR_DOMAIN_EVENT_STOPPED;\n        *lvEventTypeDetails = VIR_DOMAIN_EVENT_STOPPED_SAVED;\n        break;\n    default:\n        VIR_DEBUG(\"Skip sending event about changing state to %X\",\n                  domainState);\n        break;\n    }\n}"
  },
  {
    "function_name": "prlsdkSendEvent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2056-2068",
    "snippet": "static void\nprlsdkSendEvent(vzDriverPtr driver,\n                virDomainObjPtr dom,\n                virDomainEventType lvEventType,\n                int lvEventTypeDetails)\n{\n    virObjectEventPtr event;\n\n    event = virDomainEventLifecycleNewFromObj(dom,\n                                              lvEventType,\n                                              lvEventTypeDetails);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->domainEventState",
            "event"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainEventLifecycleNewFromObj",
          "args": [
            "dom",
            "lvEventType",
            "lvEventTypeDetails"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainEventLifecycleNewFromObj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_event.c",
          "lines": "610-616",
          "snippet": "virObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainEventDispose(void *obj);",
            "static void virDomainEventLifecycleDispose(void *obj);",
            "static void virDomainEventRTCChangeDispose(void *obj);",
            "static void virDomainEventWatchdogDispose(void *obj);",
            "static void virDomainEventIOErrorDispose(void *obj);",
            "static void virDomainEventGraphicsDispose(void *obj);",
            "static void virDomainEventBlockJobDispose(void *obj);",
            "static void virDomainEventDiskChangeDispose(void *obj);",
            "static void virDomainEventTrayChangeDispose(void *obj);",
            "static void virDomainEventBalloonChangeDispose(void *obj);",
            "static void virDomainEventDeviceRemovedDispose(void *obj);",
            "static void virDomainEventPMDispose(void *obj);",
            "static void virDomainQemuMonitorEventDispose(void *obj);",
            "static void virDomainEventTunableDispose(void *obj);",
            "static void virDomainEventAgentLifecycleDispose(void *obj);",
            "static void virDomainEventDeviceAddedDispose(void *obj);",
            "static void virDomainEventMigrationIterationDispose(void *obj);",
            "static void virDomainEventJobCompletedDispose(void *obj);",
            "static void virDomainEventDeviceRemovalFailedDispose(void *obj);",
            "static void virDomainEventMetadataChangeDispose(void *obj);",
            "static void virDomainEventBlockThresholdDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virDomainEventDispose(void *obj);\nstatic void virDomainEventLifecycleDispose(void *obj);\nstatic void virDomainEventRTCChangeDispose(void *obj);\nstatic void virDomainEventWatchdogDispose(void *obj);\nstatic void virDomainEventIOErrorDispose(void *obj);\nstatic void virDomainEventGraphicsDispose(void *obj);\nstatic void virDomainEventBlockJobDispose(void *obj);\nstatic void virDomainEventDiskChangeDispose(void *obj);\nstatic void virDomainEventTrayChangeDispose(void *obj);\nstatic void virDomainEventBalloonChangeDispose(void *obj);\nstatic void virDomainEventDeviceRemovedDispose(void *obj);\nstatic void virDomainEventPMDispose(void *obj);\nstatic void virDomainQemuMonitorEventDispose(void *obj);\nstatic void virDomainEventTunableDispose(void *obj);\nstatic void virDomainEventAgentLifecycleDispose(void *obj);\nstatic void virDomainEventDeviceAddedDispose(void *obj);\nstatic void virDomainEventMigrationIterationDispose(void *obj);\nstatic void virDomainEventJobCompletedDispose(void *obj);\nstatic void virDomainEventDeviceRemovalFailedDispose(void *obj);\nstatic void virDomainEventMetadataChangeDispose(void *obj);\nstatic void virDomainEventBlockThresholdDispose(void *obj);\n\nvirObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkSendEvent(vzDriverPtr driver,\n                virDomainObjPtr dom,\n                virDomainEventType lvEventType,\n                int lvEventTypeDetails)\n{\n    virObjectEventPtr event;\n\n    event = virDomainEventLifecycleNewFromObj(dom,\n                                              lvEventType,\n                                              lvEventTypeDetails);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}"
  },
  {
    "function_name": "prlsdkUpdateDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2043-2054",
    "snippet": "int\nprlsdkUpdateDomain(vzDriverPtr driver, virDomainObjPtr dom)\n{\n    PRL_HANDLE job;\n    vzDomObjPtr pdom = dom->privateData;\n\n    job = PrlVm_RefreshConfig(pdom->sdkdom);\n    if (waitDomainJob(job, dom))\n        return -1;\n\n    return prlsdkLoadDomain(driver, pdom->sdkdom, dom) ? 0 : -1;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prlsdkLoadDomain",
          "args": [
            "driver",
            "pdom->sdkdom",
            "dom"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkLoadDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1826-1970",
          "snippet": "static virDomainObjPtr\nprlsdkLoadDomain(vzDriverPtr driver,\n                 PRL_HANDLE sdkdom,\n                 virDomainObjPtr dom)\n{\n    virDomainDefPtr def = NULL;\n    vzDomObjPtr pdom = NULL;\n    VIRTUAL_MACHINE_STATE domainState;\n\n    PRL_RESULT pret;\n    PRL_UINT32 ram;\n    PRL_UINT32 envId;\n    PRL_VM_AUTOSTART_OPTION autostart;\n    PRL_HANDLE job;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n\n    if (!(def = virDomainDefNew()))\n        goto error;\n\n    if (!(def->name = prlsdkGetStringParamVar(PrlVmCfg_GetName, sdkdom)))\n        goto error;\n\n    pret = prlsdkGetStringParamBuf(PrlVmCfg_GetUuid,\n                                   sdkdom, uuidstr, sizeof(uuidstr));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkUUIDParse(uuidstr, def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain UUID is malformed or empty\"));\n        goto error;\n    }\n\n    def->virtType = VIR_DOMAIN_VIRT_VZ;\n\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* get RAM parameters */\n    pret = PrlVmCfg_GetRamSize(sdkdom, &ram);\n    prlsdkCheckRetGoto(pret, error);\n    virDomainDefSetMemoryTotal(def, ram << 10); /* RAM size obtained in Mbytes,\n                                                     convert to Kbytes */\n    def->mem.cur_balloon = ram << 10;\n\n    if (prlsdkConvertCpuInfo(sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    if (prlsdkConvertCpuMode(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkConvertDomainType(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkAddVNCInfo(sdkdom, def) < 0)\n        goto error;\n\n    /* depends on prlsdkAddVNCInfo */\n    if (prlsdkAddDomainHardware(driver, sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    /* depends on prlsdkAddDomainHardware */\n    if (!IS_CT(def) && prlsdkConvertBootOrderVm(sdkdom, def) < 0)\n        goto error;\n\n    pret = PrlVmCfg_GetEnvId(sdkdom, &envId);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_GetAutoStart(sdkdom, &autostart);\n    prlsdkCheckRetGoto(pret, error);\n    if (autostart != PAO_VM_START_ON_LOAD &&\n        autostart != PAO_VM_START_MANUAL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown autostart mode: %X\"), autostart);\n        goto error;\n    }\n\n    if (prlsdkGetDomainState(dom, sdkdom, &domainState) < 0)\n        goto error;\n\n    if (!IS_CT(def) && virDomainDefAddImplicitDevices(def, driver->xmlopt) < 0)\n        goto error;\n\n    if (def->ngraphics > 0) {\n        int bus = IS_CT(def) ? VIR_DOMAIN_INPUT_BUS_PARALLELS :\n                               VIR_DOMAIN_INPUT_BUS_PS2;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_MOUSE,\n                                      bus) < 0)\n            goto error;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_KBD,\n                                      bus) < 0)\n            goto error;\n    }\n\n    if (!dom) {\n        virDomainObjPtr olddom = NULL;\n\n        job = PrlVm_SubscribeToPerfStats(sdkdom, NULL);\n        if (PRL_FAILED(waitJob(job)))\n            goto error;\n\n        virObjectLock(driver);\n        if (!(olddom = virDomainObjListFindByUUID(driver->domains, def->uuid)))\n            dom = virDomainObjListAdd(driver->domains, def, driver->xmlopt, 0, NULL);\n        virObjectUnlock(driver);\n\n        if (olddom) {\n            virDomainDefFree(def);\n            return olddom;\n        } else if (!dom) {\n            goto error;\n        }\n\n        pdom = dom->privateData;\n        pdom->sdkdom = sdkdom;\n        PrlHandle_AddRef(sdkdom);\n        dom->persistent = 1;\n    } else {\n        /* assign new virDomainDef without any checks\n         * we can't use virDomainObjAssignDef, because it checks\n         * for state and domain name */\n        virDomainDefFree(dom->def);\n        dom->def = def;\n    }\n\n    pdom = dom->privateData;\n    pdom->id = envId;\n\n    prlsdkConvertDomainState(domainState, envId, dom);\n\n    if (autostart == PAO_VM_START_ON_LOAD)\n        dom->autostart = 1;\n    else\n        dom->autostart = 0;\n\n    return dom;\n\n error:\n    virDomainDefFree(def);\n    return NULL;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);",
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic virDomainObjPtr\nprlsdkLoadDomain(vzDriverPtr driver,\n                 PRL_HANDLE sdkdom,\n                 virDomainObjPtr dom)\n{\n    virDomainDefPtr def = NULL;\n    vzDomObjPtr pdom = NULL;\n    VIRTUAL_MACHINE_STATE domainState;\n\n    PRL_RESULT pret;\n    PRL_UINT32 ram;\n    PRL_UINT32 envId;\n    PRL_VM_AUTOSTART_OPTION autostart;\n    PRL_HANDLE job;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n\n    if (!(def = virDomainDefNew()))\n        goto error;\n\n    if (!(def->name = prlsdkGetStringParamVar(PrlVmCfg_GetName, sdkdom)))\n        goto error;\n\n    pret = prlsdkGetStringParamBuf(PrlVmCfg_GetUuid,\n                                   sdkdom, uuidstr, sizeof(uuidstr));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkUUIDParse(uuidstr, def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain UUID is malformed or empty\"));\n        goto error;\n    }\n\n    def->virtType = VIR_DOMAIN_VIRT_VZ;\n\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* get RAM parameters */\n    pret = PrlVmCfg_GetRamSize(sdkdom, &ram);\n    prlsdkCheckRetGoto(pret, error);\n    virDomainDefSetMemoryTotal(def, ram << 10); /* RAM size obtained in Mbytes,\n                                                     convert to Kbytes */\n    def->mem.cur_balloon = ram << 10;\n\n    if (prlsdkConvertCpuInfo(sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    if (prlsdkConvertCpuMode(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkConvertDomainType(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkAddVNCInfo(sdkdom, def) < 0)\n        goto error;\n\n    /* depends on prlsdkAddVNCInfo */\n    if (prlsdkAddDomainHardware(driver, sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    /* depends on prlsdkAddDomainHardware */\n    if (!IS_CT(def) && prlsdkConvertBootOrderVm(sdkdom, def) < 0)\n        goto error;\n\n    pret = PrlVmCfg_GetEnvId(sdkdom, &envId);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_GetAutoStart(sdkdom, &autostart);\n    prlsdkCheckRetGoto(pret, error);\n    if (autostart != PAO_VM_START_ON_LOAD &&\n        autostart != PAO_VM_START_MANUAL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown autostart mode: %X\"), autostart);\n        goto error;\n    }\n\n    if (prlsdkGetDomainState(dom, sdkdom, &domainState) < 0)\n        goto error;\n\n    if (!IS_CT(def) && virDomainDefAddImplicitDevices(def, driver->xmlopt) < 0)\n        goto error;\n\n    if (def->ngraphics > 0) {\n        int bus = IS_CT(def) ? VIR_DOMAIN_INPUT_BUS_PARALLELS :\n                               VIR_DOMAIN_INPUT_BUS_PS2;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_MOUSE,\n                                      bus) < 0)\n            goto error;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_KBD,\n                                      bus) < 0)\n            goto error;\n    }\n\n    if (!dom) {\n        virDomainObjPtr olddom = NULL;\n\n        job = PrlVm_SubscribeToPerfStats(sdkdom, NULL);\n        if (PRL_FAILED(waitJob(job)))\n            goto error;\n\n        virObjectLock(driver);\n        if (!(olddom = virDomainObjListFindByUUID(driver->domains, def->uuid)))\n            dom = virDomainObjListAdd(driver->domains, def, driver->xmlopt, 0, NULL);\n        virObjectUnlock(driver);\n\n        if (olddom) {\n            virDomainDefFree(def);\n            return olddom;\n        } else if (!dom) {\n            goto error;\n        }\n\n        pdom = dom->privateData;\n        pdom->sdkdom = sdkdom;\n        PrlHandle_AddRef(sdkdom);\n        dom->persistent = 1;\n    } else {\n        /* assign new virDomainDef without any checks\n         * we can't use virDomainObjAssignDef, because it checks\n         * for state and domain name */\n        virDomainDefFree(dom->def);\n        dom->def = def;\n    }\n\n    pdom = dom->privateData;\n    pdom->id = envId;\n\n    prlsdkConvertDomainState(domainState, envId, dom);\n\n    if (autostart == PAO_VM_START_ON_LOAD)\n        dom->autostart = 1;\n    else\n        dom->autostart = 0;\n\n    return dom;\n\n error:\n    virDomainDefFree(def);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitDomainJob",
          "args": [
            "job",
            "dom"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_RefreshConfig",
          "args": [
            "pdom->sdkdom"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nprlsdkUpdateDomain(vzDriverPtr driver, virDomainObjPtr dom)\n{\n    PRL_HANDLE job;\n    vzDomObjPtr pdom = dom->privateData;\n\n    job = PrlVm_RefreshConfig(pdom->sdkdom);\n    if (waitDomainJob(job, dom))\n        return -1;\n\n    return prlsdkLoadDomain(driver, pdom->sdkdom, dom) ? 0 : -1;\n}"
  },
  {
    "function_name": "prlsdkAddDomainByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2027-2041",
    "snippet": "virDomainObjPtr\nprlsdkAddDomainByName(vzDriverPtr driver, const char *name)\n{\n    PRL_HANDLE sdkdom;\n    virDomainObjPtr dom;\n\n    sdkdom = prlsdkSdkDomainLookupByName(driver, name);\n    if (sdkdom == PRL_INVALID_HANDLE)\n        return NULL;\n\n    dom = prlsdkLoadDomain(driver, sdkdom, NULL);\n\n    PrlHandle_Free(sdkdom);\n    return dom;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "sdkdom"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkLoadDomain",
          "args": [
            "driver",
            "sdkdom",
            "NULL"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkLoadDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1826-1970",
          "snippet": "static virDomainObjPtr\nprlsdkLoadDomain(vzDriverPtr driver,\n                 PRL_HANDLE sdkdom,\n                 virDomainObjPtr dom)\n{\n    virDomainDefPtr def = NULL;\n    vzDomObjPtr pdom = NULL;\n    VIRTUAL_MACHINE_STATE domainState;\n\n    PRL_RESULT pret;\n    PRL_UINT32 ram;\n    PRL_UINT32 envId;\n    PRL_VM_AUTOSTART_OPTION autostart;\n    PRL_HANDLE job;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n\n    if (!(def = virDomainDefNew()))\n        goto error;\n\n    if (!(def->name = prlsdkGetStringParamVar(PrlVmCfg_GetName, sdkdom)))\n        goto error;\n\n    pret = prlsdkGetStringParamBuf(PrlVmCfg_GetUuid,\n                                   sdkdom, uuidstr, sizeof(uuidstr));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkUUIDParse(uuidstr, def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain UUID is malformed or empty\"));\n        goto error;\n    }\n\n    def->virtType = VIR_DOMAIN_VIRT_VZ;\n\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* get RAM parameters */\n    pret = PrlVmCfg_GetRamSize(sdkdom, &ram);\n    prlsdkCheckRetGoto(pret, error);\n    virDomainDefSetMemoryTotal(def, ram << 10); /* RAM size obtained in Mbytes,\n                                                     convert to Kbytes */\n    def->mem.cur_balloon = ram << 10;\n\n    if (prlsdkConvertCpuInfo(sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    if (prlsdkConvertCpuMode(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkConvertDomainType(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkAddVNCInfo(sdkdom, def) < 0)\n        goto error;\n\n    /* depends on prlsdkAddVNCInfo */\n    if (prlsdkAddDomainHardware(driver, sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    /* depends on prlsdkAddDomainHardware */\n    if (!IS_CT(def) && prlsdkConvertBootOrderVm(sdkdom, def) < 0)\n        goto error;\n\n    pret = PrlVmCfg_GetEnvId(sdkdom, &envId);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_GetAutoStart(sdkdom, &autostart);\n    prlsdkCheckRetGoto(pret, error);\n    if (autostart != PAO_VM_START_ON_LOAD &&\n        autostart != PAO_VM_START_MANUAL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown autostart mode: %X\"), autostart);\n        goto error;\n    }\n\n    if (prlsdkGetDomainState(dom, sdkdom, &domainState) < 0)\n        goto error;\n\n    if (!IS_CT(def) && virDomainDefAddImplicitDevices(def, driver->xmlopt) < 0)\n        goto error;\n\n    if (def->ngraphics > 0) {\n        int bus = IS_CT(def) ? VIR_DOMAIN_INPUT_BUS_PARALLELS :\n                               VIR_DOMAIN_INPUT_BUS_PS2;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_MOUSE,\n                                      bus) < 0)\n            goto error;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_KBD,\n                                      bus) < 0)\n            goto error;\n    }\n\n    if (!dom) {\n        virDomainObjPtr olddom = NULL;\n\n        job = PrlVm_SubscribeToPerfStats(sdkdom, NULL);\n        if (PRL_FAILED(waitJob(job)))\n            goto error;\n\n        virObjectLock(driver);\n        if (!(olddom = virDomainObjListFindByUUID(driver->domains, def->uuid)))\n            dom = virDomainObjListAdd(driver->domains, def, driver->xmlopt, 0, NULL);\n        virObjectUnlock(driver);\n\n        if (olddom) {\n            virDomainDefFree(def);\n            return olddom;\n        } else if (!dom) {\n            goto error;\n        }\n\n        pdom = dom->privateData;\n        pdom->sdkdom = sdkdom;\n        PrlHandle_AddRef(sdkdom);\n        dom->persistent = 1;\n    } else {\n        /* assign new virDomainDef without any checks\n         * we can't use virDomainObjAssignDef, because it checks\n         * for state and domain name */\n        virDomainDefFree(dom->def);\n        dom->def = def;\n    }\n\n    pdom = dom->privateData;\n    pdom->id = envId;\n\n    prlsdkConvertDomainState(domainState, envId, dom);\n\n    if (autostart == PAO_VM_START_ON_LOAD)\n        dom->autostart = 1;\n    else\n        dom->autostart = 0;\n\n    return dom;\n\n error:\n    virDomainDefFree(def);\n    return NULL;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);",
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic virDomainObjPtr\nprlsdkLoadDomain(vzDriverPtr driver,\n                 PRL_HANDLE sdkdom,\n                 virDomainObjPtr dom)\n{\n    virDomainDefPtr def = NULL;\n    vzDomObjPtr pdom = NULL;\n    VIRTUAL_MACHINE_STATE domainState;\n\n    PRL_RESULT pret;\n    PRL_UINT32 ram;\n    PRL_UINT32 envId;\n    PRL_VM_AUTOSTART_OPTION autostart;\n    PRL_HANDLE job;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n\n    if (!(def = virDomainDefNew()))\n        goto error;\n\n    if (!(def->name = prlsdkGetStringParamVar(PrlVmCfg_GetName, sdkdom)))\n        goto error;\n\n    pret = prlsdkGetStringParamBuf(PrlVmCfg_GetUuid,\n                                   sdkdom, uuidstr, sizeof(uuidstr));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkUUIDParse(uuidstr, def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain UUID is malformed or empty\"));\n        goto error;\n    }\n\n    def->virtType = VIR_DOMAIN_VIRT_VZ;\n\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* get RAM parameters */\n    pret = PrlVmCfg_GetRamSize(sdkdom, &ram);\n    prlsdkCheckRetGoto(pret, error);\n    virDomainDefSetMemoryTotal(def, ram << 10); /* RAM size obtained in Mbytes,\n                                                     convert to Kbytes */\n    def->mem.cur_balloon = ram << 10;\n\n    if (prlsdkConvertCpuInfo(sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    if (prlsdkConvertCpuMode(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkConvertDomainType(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkAddVNCInfo(sdkdom, def) < 0)\n        goto error;\n\n    /* depends on prlsdkAddVNCInfo */\n    if (prlsdkAddDomainHardware(driver, sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    /* depends on prlsdkAddDomainHardware */\n    if (!IS_CT(def) && prlsdkConvertBootOrderVm(sdkdom, def) < 0)\n        goto error;\n\n    pret = PrlVmCfg_GetEnvId(sdkdom, &envId);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_GetAutoStart(sdkdom, &autostart);\n    prlsdkCheckRetGoto(pret, error);\n    if (autostart != PAO_VM_START_ON_LOAD &&\n        autostart != PAO_VM_START_MANUAL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown autostart mode: %X\"), autostart);\n        goto error;\n    }\n\n    if (prlsdkGetDomainState(dom, sdkdom, &domainState) < 0)\n        goto error;\n\n    if (!IS_CT(def) && virDomainDefAddImplicitDevices(def, driver->xmlopt) < 0)\n        goto error;\n\n    if (def->ngraphics > 0) {\n        int bus = IS_CT(def) ? VIR_DOMAIN_INPUT_BUS_PARALLELS :\n                               VIR_DOMAIN_INPUT_BUS_PS2;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_MOUSE,\n                                      bus) < 0)\n            goto error;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_KBD,\n                                      bus) < 0)\n            goto error;\n    }\n\n    if (!dom) {\n        virDomainObjPtr olddom = NULL;\n\n        job = PrlVm_SubscribeToPerfStats(sdkdom, NULL);\n        if (PRL_FAILED(waitJob(job)))\n            goto error;\n\n        virObjectLock(driver);\n        if (!(olddom = virDomainObjListFindByUUID(driver->domains, def->uuid)))\n            dom = virDomainObjListAdd(driver->domains, def, driver->xmlopt, 0, NULL);\n        virObjectUnlock(driver);\n\n        if (olddom) {\n            virDomainDefFree(def);\n            return olddom;\n        } else if (!dom) {\n            goto error;\n        }\n\n        pdom = dom->privateData;\n        pdom->sdkdom = sdkdom;\n        PrlHandle_AddRef(sdkdom);\n        dom->persistent = 1;\n    } else {\n        /* assign new virDomainDef without any checks\n         * we can't use virDomainObjAssignDef, because it checks\n         * for state and domain name */\n        virDomainDefFree(dom->def);\n        dom->def = def;\n    }\n\n    pdom = dom->privateData;\n    pdom->id = envId;\n\n    prlsdkConvertDomainState(domainState, envId, dom);\n\n    if (autostart == PAO_VM_START_ON_LOAD)\n        dom->autostart = 1;\n    else\n        dom->autostart = 0;\n\n    return dom;\n\n error:\n    virDomainDefFree(def);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkSdkDomainLookupByName",
          "args": [
            "driver",
            "name"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkSdkDomainLookupByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "481-494",
          "snippet": "PRL_HANDLE\nprlsdkSdkDomainLookupByName(vzDriverPtr driver, const char *name)\n{\n    PRL_HANDLE sdkdom = PRL_INVALID_HANDLE;\n\n    if (prlsdkSdkDomainLookup(driver, name,\n                              PGVC_SEARCH_BY_NAME, &sdkdom) < 0) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching name '%s'\"), name);\n        return PRL_INVALID_HANDLE;\n    }\n\n    return sdkdom;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nPRL_HANDLE\nprlsdkSdkDomainLookupByName(vzDriverPtr driver, const char *name)\n{\n    PRL_HANDLE sdkdom = PRL_INVALID_HANDLE;\n\n    if (prlsdkSdkDomainLookup(driver, name,\n                              PGVC_SEARCH_BY_NAME, &sdkdom) < 0) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching name '%s'\"), name);\n        return PRL_INVALID_HANDLE;\n    }\n\n    return sdkdom;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirDomainObjPtr\nprlsdkAddDomainByName(vzDriverPtr driver, const char *name)\n{\n    PRL_HANDLE sdkdom;\n    virDomainObjPtr dom;\n\n    sdkdom = prlsdkSdkDomainLookupByName(driver, name);\n    if (sdkdom == PRL_INVALID_HANDLE)\n        return NULL;\n\n    dom = prlsdkLoadDomain(driver, sdkdom, NULL);\n\n    PrlHandle_Free(sdkdom);\n    return dom;\n}"
  },
  {
    "function_name": "prlsdkAddDomainByUUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "2011-2025",
    "snippet": "virDomainObjPtr\nprlsdkAddDomainByUUID(vzDriverPtr driver, const unsigned char *uuid)\n{\n    PRL_HANDLE sdkdom;\n    virDomainObjPtr dom;\n\n    sdkdom = prlsdkSdkDomainLookupByUUID(driver, uuid);\n    if (sdkdom == PRL_INVALID_HANDLE)\n        return NULL;\n\n    dom = prlsdkLoadDomain(driver, sdkdom, NULL);\n\n    PrlHandle_Free(sdkdom);\n    return dom;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "sdkdom"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkLoadDomain",
          "args": [
            "driver",
            "sdkdom",
            "NULL"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkLoadDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1826-1970",
          "snippet": "static virDomainObjPtr\nprlsdkLoadDomain(vzDriverPtr driver,\n                 PRL_HANDLE sdkdom,\n                 virDomainObjPtr dom)\n{\n    virDomainDefPtr def = NULL;\n    vzDomObjPtr pdom = NULL;\n    VIRTUAL_MACHINE_STATE domainState;\n\n    PRL_RESULT pret;\n    PRL_UINT32 ram;\n    PRL_UINT32 envId;\n    PRL_VM_AUTOSTART_OPTION autostart;\n    PRL_HANDLE job;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n\n    if (!(def = virDomainDefNew()))\n        goto error;\n\n    if (!(def->name = prlsdkGetStringParamVar(PrlVmCfg_GetName, sdkdom)))\n        goto error;\n\n    pret = prlsdkGetStringParamBuf(PrlVmCfg_GetUuid,\n                                   sdkdom, uuidstr, sizeof(uuidstr));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkUUIDParse(uuidstr, def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain UUID is malformed or empty\"));\n        goto error;\n    }\n\n    def->virtType = VIR_DOMAIN_VIRT_VZ;\n\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* get RAM parameters */\n    pret = PrlVmCfg_GetRamSize(sdkdom, &ram);\n    prlsdkCheckRetGoto(pret, error);\n    virDomainDefSetMemoryTotal(def, ram << 10); /* RAM size obtained in Mbytes,\n                                                     convert to Kbytes */\n    def->mem.cur_balloon = ram << 10;\n\n    if (prlsdkConvertCpuInfo(sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    if (prlsdkConvertCpuMode(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkConvertDomainType(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkAddVNCInfo(sdkdom, def) < 0)\n        goto error;\n\n    /* depends on prlsdkAddVNCInfo */\n    if (prlsdkAddDomainHardware(driver, sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    /* depends on prlsdkAddDomainHardware */\n    if (!IS_CT(def) && prlsdkConvertBootOrderVm(sdkdom, def) < 0)\n        goto error;\n\n    pret = PrlVmCfg_GetEnvId(sdkdom, &envId);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_GetAutoStart(sdkdom, &autostart);\n    prlsdkCheckRetGoto(pret, error);\n    if (autostart != PAO_VM_START_ON_LOAD &&\n        autostart != PAO_VM_START_MANUAL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown autostart mode: %X\"), autostart);\n        goto error;\n    }\n\n    if (prlsdkGetDomainState(dom, sdkdom, &domainState) < 0)\n        goto error;\n\n    if (!IS_CT(def) && virDomainDefAddImplicitDevices(def, driver->xmlopt) < 0)\n        goto error;\n\n    if (def->ngraphics > 0) {\n        int bus = IS_CT(def) ? VIR_DOMAIN_INPUT_BUS_PARALLELS :\n                               VIR_DOMAIN_INPUT_BUS_PS2;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_MOUSE,\n                                      bus) < 0)\n            goto error;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_KBD,\n                                      bus) < 0)\n            goto error;\n    }\n\n    if (!dom) {\n        virDomainObjPtr olddom = NULL;\n\n        job = PrlVm_SubscribeToPerfStats(sdkdom, NULL);\n        if (PRL_FAILED(waitJob(job)))\n            goto error;\n\n        virObjectLock(driver);\n        if (!(olddom = virDomainObjListFindByUUID(driver->domains, def->uuid)))\n            dom = virDomainObjListAdd(driver->domains, def, driver->xmlopt, 0, NULL);\n        virObjectUnlock(driver);\n\n        if (olddom) {\n            virDomainDefFree(def);\n            return olddom;\n        } else if (!dom) {\n            goto error;\n        }\n\n        pdom = dom->privateData;\n        pdom->sdkdom = sdkdom;\n        PrlHandle_AddRef(sdkdom);\n        dom->persistent = 1;\n    } else {\n        /* assign new virDomainDef without any checks\n         * we can't use virDomainObjAssignDef, because it checks\n         * for state and domain name */\n        virDomainDefFree(dom->def);\n        dom->def = def;\n    }\n\n    pdom = dom->privateData;\n    pdom->id = envId;\n\n    prlsdkConvertDomainState(domainState, envId, dom);\n\n    if (autostart == PAO_VM_START_ON_LOAD)\n        dom->autostart = 1;\n    else\n        dom->autostart = 0;\n\n    return dom;\n\n error:\n    virDomainDefFree(def);\n    return NULL;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);",
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic virDomainObjPtr\nprlsdkLoadDomain(vzDriverPtr driver,\n                 PRL_HANDLE sdkdom,\n                 virDomainObjPtr dom)\n{\n    virDomainDefPtr def = NULL;\n    vzDomObjPtr pdom = NULL;\n    VIRTUAL_MACHINE_STATE domainState;\n\n    PRL_RESULT pret;\n    PRL_UINT32 ram;\n    PRL_UINT32 envId;\n    PRL_VM_AUTOSTART_OPTION autostart;\n    PRL_HANDLE job;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n\n    if (!(def = virDomainDefNew()))\n        goto error;\n\n    if (!(def->name = prlsdkGetStringParamVar(PrlVmCfg_GetName, sdkdom)))\n        goto error;\n\n    pret = prlsdkGetStringParamBuf(PrlVmCfg_GetUuid,\n                                   sdkdom, uuidstr, sizeof(uuidstr));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkUUIDParse(uuidstr, def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain UUID is malformed or empty\"));\n        goto error;\n    }\n\n    def->virtType = VIR_DOMAIN_VIRT_VZ;\n\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* get RAM parameters */\n    pret = PrlVmCfg_GetRamSize(sdkdom, &ram);\n    prlsdkCheckRetGoto(pret, error);\n    virDomainDefSetMemoryTotal(def, ram << 10); /* RAM size obtained in Mbytes,\n                                                     convert to Kbytes */\n    def->mem.cur_balloon = ram << 10;\n\n    if (prlsdkConvertCpuInfo(sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    if (prlsdkConvertCpuMode(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkConvertDomainType(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkAddVNCInfo(sdkdom, def) < 0)\n        goto error;\n\n    /* depends on prlsdkAddVNCInfo */\n    if (prlsdkAddDomainHardware(driver, sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    /* depends on prlsdkAddDomainHardware */\n    if (!IS_CT(def) && prlsdkConvertBootOrderVm(sdkdom, def) < 0)\n        goto error;\n\n    pret = PrlVmCfg_GetEnvId(sdkdom, &envId);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_GetAutoStart(sdkdom, &autostart);\n    prlsdkCheckRetGoto(pret, error);\n    if (autostart != PAO_VM_START_ON_LOAD &&\n        autostart != PAO_VM_START_MANUAL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown autostart mode: %X\"), autostart);\n        goto error;\n    }\n\n    if (prlsdkGetDomainState(dom, sdkdom, &domainState) < 0)\n        goto error;\n\n    if (!IS_CT(def) && virDomainDefAddImplicitDevices(def, driver->xmlopt) < 0)\n        goto error;\n\n    if (def->ngraphics > 0) {\n        int bus = IS_CT(def) ? VIR_DOMAIN_INPUT_BUS_PARALLELS :\n                               VIR_DOMAIN_INPUT_BUS_PS2;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_MOUSE,\n                                      bus) < 0)\n            goto error;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_KBD,\n                                      bus) < 0)\n            goto error;\n    }\n\n    if (!dom) {\n        virDomainObjPtr olddom = NULL;\n\n        job = PrlVm_SubscribeToPerfStats(sdkdom, NULL);\n        if (PRL_FAILED(waitJob(job)))\n            goto error;\n\n        virObjectLock(driver);\n        if (!(olddom = virDomainObjListFindByUUID(driver->domains, def->uuid)))\n            dom = virDomainObjListAdd(driver->domains, def, driver->xmlopt, 0, NULL);\n        virObjectUnlock(driver);\n\n        if (olddom) {\n            virDomainDefFree(def);\n            return olddom;\n        } else if (!dom) {\n            goto error;\n        }\n\n        pdom = dom->privateData;\n        pdom->sdkdom = sdkdom;\n        PrlHandle_AddRef(sdkdom);\n        dom->persistent = 1;\n    } else {\n        /* assign new virDomainDef without any checks\n         * we can't use virDomainObjAssignDef, because it checks\n         * for state and domain name */\n        virDomainDefFree(dom->def);\n        dom->def = def;\n    }\n\n    pdom = dom->privateData;\n    pdom->id = envId;\n\n    prlsdkConvertDomainState(domainState, envId, dom);\n\n    if (autostart == PAO_VM_START_ON_LOAD)\n        dom->autostart = 1;\n    else\n        dom->autostart = 0;\n\n    return dom;\n\n error:\n    virDomainDefFree(def);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkSdkDomainLookupByUUID",
          "args": [
            "driver",
            "uuid"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkSdkDomainLookupByUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "462-479",
          "snippet": "static PRL_HANDLE\nprlsdkSdkDomainLookupByUUID(vzDriverPtr driver, const unsigned char *uuid)\n{\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n    PRL_HANDLE sdkdom = PRL_INVALID_HANDLE;\n\n    prlsdkUUIDFormat(uuid, uuidstr);\n\n    if (prlsdkSdkDomainLookup(driver, uuidstr,\n                              PGVC_SEARCH_BY_UUID, &sdkdom) < 0) {\n        virUUIDFormat(uuid, uuidstr);\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching uuid '%s'\"), uuidstr);\n        return PRL_INVALID_HANDLE;\n    }\n\n    return sdkdom;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic PRL_HANDLE\nprlsdkSdkDomainLookupByUUID(vzDriverPtr driver, const unsigned char *uuid)\n{\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n    PRL_HANDLE sdkdom = PRL_INVALID_HANDLE;\n\n    prlsdkUUIDFormat(uuid, uuidstr);\n\n    if (prlsdkSdkDomainLookup(driver, uuidstr,\n                              PGVC_SEARCH_BY_UUID, &sdkdom) < 0) {\n        virUUIDFormat(uuid, uuidstr);\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching uuid '%s'\"), uuidstr);\n        return PRL_INVALID_HANDLE;\n    }\n\n    return sdkdom;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nvirDomainObjPtr\nprlsdkAddDomainByUUID(vzDriverPtr driver, const unsigned char *uuid)\n{\n    PRL_HANDLE sdkdom;\n    virDomainObjPtr dom;\n\n    sdkdom = prlsdkSdkDomainLookupByUUID(driver, uuid);\n    if (sdkdom == PRL_INVALID_HANDLE)\n        return NULL;\n\n    dom = prlsdkLoadDomain(driver, sdkdom, NULL);\n\n    PrlHandle_Free(sdkdom);\n    return dom;\n}"
  },
  {
    "function_name": "prlsdkLoadDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "1972-2009",
    "snippet": "int\nprlsdkLoadDomains(vzDriverPtr driver)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result;\n    PRL_HANDLE sdkdom = PRL_INVALID_HANDLE;\n    PRL_UINT32 paramsCount;\n    PRL_RESULT pret;\n    size_t i = 0;\n    virDomainObjPtr dom;\n\n    job = PrlSrv_GetVmListEx(driver->server, PVTF_VM | PVTF_CT);\n\n    if (PRL_FAILED(getJobResult(job, &result)))\n        return -1;\n\n    pret = PrlResult_GetParamsCount(result, &paramsCount);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < paramsCount; i++) {\n        pret = PrlResult_GetParamByIndex(result, i, &sdkdom);\n        prlsdkCheckRetGoto(pret, error);\n\n        dom = prlsdkLoadDomain(driver, sdkdom, NULL);\n        virDomainObjEndAPI(&dom);\n\n        PrlHandle_Free(sdkdom);\n        sdkdom = PRL_INVALID_HANDLE;\n    }\n\n    PrlHandle_Free(result);\n    return 0;\n\n error:\n    PrlHandle_Free(sdkdom);\n    PrlHandle_Free(result);\n    return -1;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "result"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "sdkdom"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "result"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "sdkdom"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&dom"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkLoadDomain",
          "args": [
            "driver",
            "sdkdom",
            "NULL"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkLoadDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1826-1970",
          "snippet": "static virDomainObjPtr\nprlsdkLoadDomain(vzDriverPtr driver,\n                 PRL_HANDLE sdkdom,\n                 virDomainObjPtr dom)\n{\n    virDomainDefPtr def = NULL;\n    vzDomObjPtr pdom = NULL;\n    VIRTUAL_MACHINE_STATE domainState;\n\n    PRL_RESULT pret;\n    PRL_UINT32 ram;\n    PRL_UINT32 envId;\n    PRL_VM_AUTOSTART_OPTION autostart;\n    PRL_HANDLE job;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n\n    if (!(def = virDomainDefNew()))\n        goto error;\n\n    if (!(def->name = prlsdkGetStringParamVar(PrlVmCfg_GetName, sdkdom)))\n        goto error;\n\n    pret = prlsdkGetStringParamBuf(PrlVmCfg_GetUuid,\n                                   sdkdom, uuidstr, sizeof(uuidstr));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkUUIDParse(uuidstr, def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain UUID is malformed or empty\"));\n        goto error;\n    }\n\n    def->virtType = VIR_DOMAIN_VIRT_VZ;\n\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* get RAM parameters */\n    pret = PrlVmCfg_GetRamSize(sdkdom, &ram);\n    prlsdkCheckRetGoto(pret, error);\n    virDomainDefSetMemoryTotal(def, ram << 10); /* RAM size obtained in Mbytes,\n                                                     convert to Kbytes */\n    def->mem.cur_balloon = ram << 10;\n\n    if (prlsdkConvertCpuInfo(sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    if (prlsdkConvertCpuMode(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkConvertDomainType(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkAddVNCInfo(sdkdom, def) < 0)\n        goto error;\n\n    /* depends on prlsdkAddVNCInfo */\n    if (prlsdkAddDomainHardware(driver, sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    /* depends on prlsdkAddDomainHardware */\n    if (!IS_CT(def) && prlsdkConvertBootOrderVm(sdkdom, def) < 0)\n        goto error;\n\n    pret = PrlVmCfg_GetEnvId(sdkdom, &envId);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_GetAutoStart(sdkdom, &autostart);\n    prlsdkCheckRetGoto(pret, error);\n    if (autostart != PAO_VM_START_ON_LOAD &&\n        autostart != PAO_VM_START_MANUAL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown autostart mode: %X\"), autostart);\n        goto error;\n    }\n\n    if (prlsdkGetDomainState(dom, sdkdom, &domainState) < 0)\n        goto error;\n\n    if (!IS_CT(def) && virDomainDefAddImplicitDevices(def, driver->xmlopt) < 0)\n        goto error;\n\n    if (def->ngraphics > 0) {\n        int bus = IS_CT(def) ? VIR_DOMAIN_INPUT_BUS_PARALLELS :\n                               VIR_DOMAIN_INPUT_BUS_PS2;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_MOUSE,\n                                      bus) < 0)\n            goto error;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_KBD,\n                                      bus) < 0)\n            goto error;\n    }\n\n    if (!dom) {\n        virDomainObjPtr olddom = NULL;\n\n        job = PrlVm_SubscribeToPerfStats(sdkdom, NULL);\n        if (PRL_FAILED(waitJob(job)))\n            goto error;\n\n        virObjectLock(driver);\n        if (!(olddom = virDomainObjListFindByUUID(driver->domains, def->uuid)))\n            dom = virDomainObjListAdd(driver->domains, def, driver->xmlopt, 0, NULL);\n        virObjectUnlock(driver);\n\n        if (olddom) {\n            virDomainDefFree(def);\n            return olddom;\n        } else if (!dom) {\n            goto error;\n        }\n\n        pdom = dom->privateData;\n        pdom->sdkdom = sdkdom;\n        PrlHandle_AddRef(sdkdom);\n        dom->persistent = 1;\n    } else {\n        /* assign new virDomainDef without any checks\n         * we can't use virDomainObjAssignDef, because it checks\n         * for state and domain name */\n        virDomainDefFree(dom->def);\n        dom->def = def;\n    }\n\n    pdom = dom->privateData;\n    pdom->id = envId;\n\n    prlsdkConvertDomainState(domainState, envId, dom);\n\n    if (autostart == PAO_VM_START_ON_LOAD)\n        dom->autostart = 1;\n    else\n        dom->autostart = 0;\n\n    return dom;\n\n error:\n    virDomainDefFree(def);\n    return NULL;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);",
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic virDomainObjPtr\nprlsdkLoadDomain(vzDriverPtr driver,\n                 PRL_HANDLE sdkdom,\n                 virDomainObjPtr dom)\n{\n    virDomainDefPtr def = NULL;\n    vzDomObjPtr pdom = NULL;\n    VIRTUAL_MACHINE_STATE domainState;\n\n    PRL_RESULT pret;\n    PRL_UINT32 ram;\n    PRL_UINT32 envId;\n    PRL_VM_AUTOSTART_OPTION autostart;\n    PRL_HANDLE job;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n\n    if (!(def = virDomainDefNew()))\n        goto error;\n\n    if (!(def->name = prlsdkGetStringParamVar(PrlVmCfg_GetName, sdkdom)))\n        goto error;\n\n    pret = prlsdkGetStringParamBuf(PrlVmCfg_GetUuid,\n                                   sdkdom, uuidstr, sizeof(uuidstr));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkUUIDParse(uuidstr, def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain UUID is malformed or empty\"));\n        goto error;\n    }\n\n    def->virtType = VIR_DOMAIN_VIRT_VZ;\n\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* get RAM parameters */\n    pret = PrlVmCfg_GetRamSize(sdkdom, &ram);\n    prlsdkCheckRetGoto(pret, error);\n    virDomainDefSetMemoryTotal(def, ram << 10); /* RAM size obtained in Mbytes,\n                                                     convert to Kbytes */\n    def->mem.cur_balloon = ram << 10;\n\n    if (prlsdkConvertCpuInfo(sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    if (prlsdkConvertCpuMode(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkConvertDomainType(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkAddVNCInfo(sdkdom, def) < 0)\n        goto error;\n\n    /* depends on prlsdkAddVNCInfo */\n    if (prlsdkAddDomainHardware(driver, sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    /* depends on prlsdkAddDomainHardware */\n    if (!IS_CT(def) && prlsdkConvertBootOrderVm(sdkdom, def) < 0)\n        goto error;\n\n    pret = PrlVmCfg_GetEnvId(sdkdom, &envId);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_GetAutoStart(sdkdom, &autostart);\n    prlsdkCheckRetGoto(pret, error);\n    if (autostart != PAO_VM_START_ON_LOAD &&\n        autostart != PAO_VM_START_MANUAL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown autostart mode: %X\"), autostart);\n        goto error;\n    }\n\n    if (prlsdkGetDomainState(dom, sdkdom, &domainState) < 0)\n        goto error;\n\n    if (!IS_CT(def) && virDomainDefAddImplicitDevices(def, driver->xmlopt) < 0)\n        goto error;\n\n    if (def->ngraphics > 0) {\n        int bus = IS_CT(def) ? VIR_DOMAIN_INPUT_BUS_PARALLELS :\n                               VIR_DOMAIN_INPUT_BUS_PS2;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_MOUSE,\n                                      bus) < 0)\n            goto error;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_KBD,\n                                      bus) < 0)\n            goto error;\n    }\n\n    if (!dom) {\n        virDomainObjPtr olddom = NULL;\n\n        job = PrlVm_SubscribeToPerfStats(sdkdom, NULL);\n        if (PRL_FAILED(waitJob(job)))\n            goto error;\n\n        virObjectLock(driver);\n        if (!(olddom = virDomainObjListFindByUUID(driver->domains, def->uuid)))\n            dom = virDomainObjListAdd(driver->domains, def, driver->xmlopt, 0, NULL);\n        virObjectUnlock(driver);\n\n        if (olddom) {\n            virDomainDefFree(def);\n            return olddom;\n        } else if (!dom) {\n            goto error;\n        }\n\n        pdom = dom->privateData;\n        pdom->sdkdom = sdkdom;\n        PrlHandle_AddRef(sdkdom);\n        dom->persistent = 1;\n    } else {\n        /* assign new virDomainDef without any checks\n         * we can't use virDomainObjAssignDef, because it checks\n         * for state and domain name */\n        virDomainDefFree(dom->def);\n        dom->def = def;\n    }\n\n    pdom = dom->privateData;\n    pdom->id = envId;\n\n    prlsdkConvertDomainState(domainState, envId, dom);\n\n    if (autostart == PAO_VM_START_ON_LOAD)\n        dom->autostart = 1;\n    else\n        dom->autostart = 0;\n\n    return dom;\n\n error:\n    virDomainDefFree(def);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlResult_GetParamByIndex",
          "args": [
            "result",
            "i",
            "&sdkdom"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlResult_GetParamsCount",
          "args": [
            "result",
            "&paramsCount"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "getJobResult(job, &result)"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getJobResult",
          "args": [
            "job",
            "&result"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlSrv_GetVmListEx",
          "args": [
            "driver->server",
            "PVTF_VM | PVTF_CT"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nint\nprlsdkLoadDomains(vzDriverPtr driver)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result;\n    PRL_HANDLE sdkdom = PRL_INVALID_HANDLE;\n    PRL_UINT32 paramsCount;\n    PRL_RESULT pret;\n    size_t i = 0;\n    virDomainObjPtr dom;\n\n    job = PrlSrv_GetVmListEx(driver->server, PVTF_VM | PVTF_CT);\n\n    if (PRL_FAILED(getJobResult(job, &result)))\n        return -1;\n\n    pret = PrlResult_GetParamsCount(result, &paramsCount);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < paramsCount; i++) {\n        pret = PrlResult_GetParamByIndex(result, i, &sdkdom);\n        prlsdkCheckRetGoto(pret, error);\n\n        dom = prlsdkLoadDomain(driver, sdkdom, NULL);\n        virDomainObjEndAPI(&dom);\n\n        PrlHandle_Free(sdkdom);\n        sdkdom = PRL_INVALID_HANDLE;\n    }\n\n    PrlHandle_Free(result);\n    return 0;\n\n error:\n    PrlHandle_Free(sdkdom);\n    PrlHandle_Free(result);\n    return -1;\n}"
  },
  {
    "function_name": "prlsdkLoadDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "1826-1970",
    "snippet": "static virDomainObjPtr\nprlsdkLoadDomain(vzDriverPtr driver,\n                 PRL_HANDLE sdkdom,\n                 virDomainObjPtr dom)\n{\n    virDomainDefPtr def = NULL;\n    vzDomObjPtr pdom = NULL;\n    VIRTUAL_MACHINE_STATE domainState;\n\n    PRL_RESULT pret;\n    PRL_UINT32 ram;\n    PRL_UINT32 envId;\n    PRL_VM_AUTOSTART_OPTION autostart;\n    PRL_HANDLE job;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n\n    if (!(def = virDomainDefNew()))\n        goto error;\n\n    if (!(def->name = prlsdkGetStringParamVar(PrlVmCfg_GetName, sdkdom)))\n        goto error;\n\n    pret = prlsdkGetStringParamBuf(PrlVmCfg_GetUuid,\n                                   sdkdom, uuidstr, sizeof(uuidstr));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkUUIDParse(uuidstr, def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain UUID is malformed or empty\"));\n        goto error;\n    }\n\n    def->virtType = VIR_DOMAIN_VIRT_VZ;\n\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* get RAM parameters */\n    pret = PrlVmCfg_GetRamSize(sdkdom, &ram);\n    prlsdkCheckRetGoto(pret, error);\n    virDomainDefSetMemoryTotal(def, ram << 10); /* RAM size obtained in Mbytes,\n                                                     convert to Kbytes */\n    def->mem.cur_balloon = ram << 10;\n\n    if (prlsdkConvertCpuInfo(sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    if (prlsdkConvertCpuMode(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkConvertDomainType(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkAddVNCInfo(sdkdom, def) < 0)\n        goto error;\n\n    /* depends on prlsdkAddVNCInfo */\n    if (prlsdkAddDomainHardware(driver, sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    /* depends on prlsdkAddDomainHardware */\n    if (!IS_CT(def) && prlsdkConvertBootOrderVm(sdkdom, def) < 0)\n        goto error;\n\n    pret = PrlVmCfg_GetEnvId(sdkdom, &envId);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_GetAutoStart(sdkdom, &autostart);\n    prlsdkCheckRetGoto(pret, error);\n    if (autostart != PAO_VM_START_ON_LOAD &&\n        autostart != PAO_VM_START_MANUAL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown autostart mode: %X\"), autostart);\n        goto error;\n    }\n\n    if (prlsdkGetDomainState(dom, sdkdom, &domainState) < 0)\n        goto error;\n\n    if (!IS_CT(def) && virDomainDefAddImplicitDevices(def, driver->xmlopt) < 0)\n        goto error;\n\n    if (def->ngraphics > 0) {\n        int bus = IS_CT(def) ? VIR_DOMAIN_INPUT_BUS_PARALLELS :\n                               VIR_DOMAIN_INPUT_BUS_PS2;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_MOUSE,\n                                      bus) < 0)\n            goto error;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_KBD,\n                                      bus) < 0)\n            goto error;\n    }\n\n    if (!dom) {\n        virDomainObjPtr olddom = NULL;\n\n        job = PrlVm_SubscribeToPerfStats(sdkdom, NULL);\n        if (PRL_FAILED(waitJob(job)))\n            goto error;\n\n        virObjectLock(driver);\n        if (!(olddom = virDomainObjListFindByUUID(driver->domains, def->uuid)))\n            dom = virDomainObjListAdd(driver->domains, def, driver->xmlopt, 0, NULL);\n        virObjectUnlock(driver);\n\n        if (olddom) {\n            virDomainDefFree(def);\n            return olddom;\n        } else if (!dom) {\n            goto error;\n        }\n\n        pdom = dom->privateData;\n        pdom->sdkdom = sdkdom;\n        PrlHandle_AddRef(sdkdom);\n        dom->persistent = 1;\n    } else {\n        /* assign new virDomainDef without any checks\n         * we can't use virDomainObjAssignDef, because it checks\n         * for state and domain name */\n        virDomainDefFree(dom->def);\n        dom->def = def;\n    }\n\n    pdom = dom->privateData;\n    pdom->id = envId;\n\n    prlsdkConvertDomainState(domainState, envId, dom);\n\n    if (autostart == PAO_VM_START_ON_LOAD)\n        dom->autostart = 1;\n    else\n        dom->autostart = 0;\n\n    return dom;\n\n error:\n    virDomainDefFree(def);\n    return NULL;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);",
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "def"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkConvertDomainState",
          "args": [
            "domainState",
            "envId",
            "dom"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConvertDomainState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1376-1452",
          "snippet": "static void\nprlsdkConvertDomainState(VIRTUAL_MACHINE_STATE domainState,\n                         PRL_UINT32 envId,\n                         virDomainObjPtr dom)\n{\n    switch (domainState) {\n    case VMS_STOPPED:\n    case VMS_MOUNTED:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n        dom->def->id = -1;\n        break;\n    case VMS_STARTING:\n    case VMS_COMPACTING:\n    case VMS_RESETTING:\n    case VMS_PAUSING:\n    case VMS_RECONNECTING:\n    case VMS_RUNNING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_BOOTED);\n        dom->def->id = envId;\n        break;\n    case VMS_PAUSED:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_USER);\n        dom->def->id = envId;\n        break;\n    case VMS_SUSPENDED:\n    case VMS_DELETING_STATE:\n    case VMS_SUSPENDING_SYNC:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_SAVED);\n        dom->def->id = -1;\n        break;\n    case VMS_STOPPING:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTDOWN,\n                             VIR_DOMAIN_SHUTDOWN_USER);\n        dom->def->id = envId;\n        break;\n    case VMS_SNAPSHOTING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_SNAPSHOT);\n        dom->def->id = envId;\n        break;\n    case VMS_MIGRATING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_MIGRATION);\n        dom->def->id = envId;\n        break;\n    case VMS_SUSPENDING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_SAVE);\n        dom->def->id = envId;\n        break;\n    case VMS_RESTORING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_RESTORED);\n        dom->def->id = envId;\n        break;\n    case VMS_CONTINUING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_UNPAUSED);\n        dom->def->id = envId;\n        break;\n    case VMS_RESUMING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_RESTORED);\n        dom->def->id = envId;\n        break;\n    case VMS_UNKNOWN:\n    default:\n        virDomainObjSetState(dom, VIR_DOMAIN_NOSTATE,\n                             VIR_DOMAIN_NOSTATE_UNKNOWN);\n        dom->def->id = -1;\n        break;\n    }\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertDomainState(VIRTUAL_MACHINE_STATE domainState,\n                         PRL_UINT32 envId,\n                         virDomainObjPtr dom)\n{\n    switch (domainState) {\n    case VMS_STOPPED:\n    case VMS_MOUNTED:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n        dom->def->id = -1;\n        break;\n    case VMS_STARTING:\n    case VMS_COMPACTING:\n    case VMS_RESETTING:\n    case VMS_PAUSING:\n    case VMS_RECONNECTING:\n    case VMS_RUNNING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_BOOTED);\n        dom->def->id = envId;\n        break;\n    case VMS_PAUSED:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_USER);\n        dom->def->id = envId;\n        break;\n    case VMS_SUSPENDED:\n    case VMS_DELETING_STATE:\n    case VMS_SUSPENDING_SYNC:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_SAVED);\n        dom->def->id = -1;\n        break;\n    case VMS_STOPPING:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTDOWN,\n                             VIR_DOMAIN_SHUTDOWN_USER);\n        dom->def->id = envId;\n        break;\n    case VMS_SNAPSHOTING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_SNAPSHOT);\n        dom->def->id = envId;\n        break;\n    case VMS_MIGRATING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_MIGRATION);\n        dom->def->id = envId;\n        break;\n    case VMS_SUSPENDING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_SAVE);\n        dom->def->id = envId;\n        break;\n    case VMS_RESTORING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_RESTORED);\n        dom->def->id = envId;\n        break;\n    case VMS_CONTINUING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_UNPAUSED);\n        dom->def->id = envId;\n        break;\n    case VMS_RESUMING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_RESTORED);\n        dom->def->id = envId;\n        break;\n    case VMS_UNKNOWN:\n    default:\n        virDomainObjSetState(dom, VIR_DOMAIN_NOSTATE,\n                             VIR_DOMAIN_NOSTATE_UNKNOWN);\n        dom->def->id = -1;\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlHandle_AddRef",
          "args": [
            "sdkdom"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListAdd",
          "args": [
            "driver->domains",
            "def",
            "driver->xmlopt",
            "0",
            "NULL"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "354-366",
          "snippet": "virDomainObjPtr virDomainObjListAdd(virDomainObjListPtr doms,\n                                    virDomainDefPtr def,\n                                    virDomainXMLOptionPtr xmlopt,\n                                    unsigned int flags,\n                                    virDomainDefPtr *oldDef)\n{\n    virDomainObjPtr ret;\n\n    virObjectRWLockWrite(doms);\n    ret = virDomainObjListAddLocked(doms, def, xmlopt, flags, oldDef);\n    virObjectRWUnlock(doms);\n    return ret;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainObjPtr virDomainObjListAdd(virDomainObjListPtr doms,\n                                    virDomainDefPtr def,\n                                    virDomainXMLOptionPtr xmlopt,\n                                    unsigned int flags,\n                                    virDomainDefPtr *oldDef)\n{\n    virDomainObjPtr ret;\n\n    virObjectRWLockWrite(doms);\n    ret = virDomainObjListAddLocked(doms, def, xmlopt, flags, oldDef);\n    virObjectRWUnlock(doms);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListFindByUUID",
          "args": [
            "driver->domains",
            "def->uuid"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListFindByUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "162-179",
          "snippet": "virDomainObjPtr\nvirDomainObjListFindByUUID(virDomainObjListPtr doms,\n                           const unsigned char *uuid)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByUUIDLocked(doms, uuid);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virDomainObjListDispose(void *obj);\n\nvirDomainObjPtr\nvirDomainObjListFindByUUID(virDomainObjListPtr doms,\n                           const unsigned char *uuid)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByUUIDLocked(doms, uuid);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "waitJob(job)"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitJob",
          "args": [
            "job"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_SubscribeToPerfStats",
          "args": [
            "sdkdom",
            "NULL"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefMaybeAddInput",
          "args": [
            "def",
            "VIR_DOMAIN_INPUT_TYPE_KBD",
            "bus"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefMaybeAddInput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "19027-19053",
          "snippet": "int\nvirDomainDefMaybeAddInput(virDomainDefPtr def,\n                          int type,\n                          int bus)\n{\n    size_t i;\n    virDomainInputDefPtr input;\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (def->inputs[i]->type == type &&\n            def->inputs[i]->bus == bus)\n            return 0;\n    }\n\n    if (VIR_ALLOC(input) < 0)\n        return -1;\n\n    input->type = type;\n    input->bus = bus;\n\n    if (VIR_APPEND_ELEMENT(def->inputs, def->ninputs, input) < 0) {\n        VIR_FREE(input);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefMaybeAddInput(virDomainDefPtr def,\n                          int type,\n                          int bus)\n{\n    size_t i;\n    virDomainInputDefPtr input;\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (def->inputs[i]->type == type &&\n            def->inputs[i]->bus == bus)\n            return 0;\n    }\n\n    if (VIR_ALLOC(input) < 0)\n        return -1;\n\n    input->type = type;\n    input->bus = bus;\n\n    if (VIR_APPEND_ELEMENT(def->inputs, def->ninputs, input) < 0) {\n        VIR_FREE(input);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "def"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefAddImplicitDevices",
          "args": [
            "def",
            "driver->xmlopt"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefAddImplicitDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "24314-24327",
          "snippet": "int\nvirDomainDefAddImplicitDevices(virDomainDefPtr def, virDomainXMLOptionPtr xmlopt)\n{\n    if (virDomainDefAddConsoleCompat(def) < 0)\n        return -1;\n\n    if (virDomainDefAddImplicitControllers(def) < 0)\n        return -1;\n\n    if (virDomainDefAddImplicitVideo(def, xmlopt) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefAddImplicitDevices(virDomainDefPtr def, virDomainXMLOptionPtr xmlopt)\n{\n    if (virDomainDefAddConsoleCompat(def) < 0)\n        return -1;\n\n    if (virDomainDefAddImplicitControllers(def) < 0)\n        return -1;\n\n    if (virDomainDefAddImplicitVideo(def, xmlopt) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "def"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetDomainState",
          "args": [
            "dom",
            "sdkdom",
            "&domainState"
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetDomainState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "519-545",
          "snippet": "static int\nprlsdkGetDomainState(virDomainObjPtr dom, PRL_HANDLE sdkdom, VIRTUAL_MACHINE_STATE_PTR vmState)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_HANDLE vmInfo = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    int ret = -1;\n\n    job = PrlVm_GetState(sdkdom);\n\n    if (PRL_FAILED(getDomainJobResult(job, dom, &result)))\n        goto cleanup;\n\n    pret = PrlResult_GetParamByIndex(result, 0, &vmInfo);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmInfo_GetState(vmInfo, vmState);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(vmInfo);\n    PrlHandle_Free(result);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkGetDomainState(virDomainObjPtr dom, PRL_HANDLE sdkdom, VIRTUAL_MACHINE_STATE_PTR vmState)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_HANDLE vmInfo = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    int ret = -1;\n\n    job = PrlVm_GetState(sdkdom);\n\n    if (PRL_FAILED(getDomainJobResult(job, dom, &result)))\n        goto cleanup;\n\n    pret = PrlResult_GetParamByIndex(result, 0, &vmInfo);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmInfo_GetState(vmInfo, vmState);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(vmInfo);\n    PrlHandle_Free(result);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown autostart mode: %X\")",
            "autostart"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown autostart mode: %X\""
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetAutoStart",
          "args": [
            "sdkdom",
            "&autostart"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetEnvId",
          "args": [
            "sdkdom",
            "&envId"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkConvertBootOrderVm",
          "args": [
            "sdkdom",
            "def"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConvertBootOrderVm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1731-1818",
          "snippet": "static int\nprlsdkConvertBootOrderVm(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    int ret = -1;\n    PRL_RESULT pret;\n    PRL_UINT32 bootNum;\n    PRL_HANDLE bootDev = PRL_INVALID_HANDLE;\n    PRL_BOOL inUse;\n    PRL_DEVICE_TYPE sdkType;\n    virDomainBootOrder type;\n    PRL_UINT32 prevBootIndex = 0, bootIndex, sdkIndex;\n    int bootUsage[VIR_DOMAIN_BOOT_LAST] = { 0 };\n    size_t i;\n\n    pret = PrlVmCfg_GetBootDevCount(sdkdom, &bootNum);\n    prlsdkCheckRetExit(pret, -1);\n\n    def->os.nBootDevs = 0;\n\n    if (bootNum > VIR_DOMAIN_MAX_BOOT_DEVS) {\n        bootNum = VIR_DOMAIN_MAX_BOOT_DEVS;\n        VIR_WARN(\"Too many boot devices\");\n    }\n\n    for (i = 0; i < bootNum; ++i) {\n        pret = PrlVmCfg_GetBootDev(sdkdom, i, &bootDev);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlBootDev_IsInUse(bootDev, &inUse);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (!inUse)\n            continue;\n\n        pret = PrlBootDev_GetSequenceIndex(bootDev, &bootIndex);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        /* bootIndex is started from 1 */\n        if (bootIndex <= prevBootIndex) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Unsupported boot order configuration\"));\n            goto cleanup;\n        }\n        prevBootIndex = bootIndex;\n\n        pret = PrlBootDev_GetType(bootDev, &sdkType);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (sdkType == PDE_FLOPPY_DISK) {\n            VIR_WARN(\"Skipping floppy from boot order.\");\n            continue;\n        }\n\n        switch ((int)sdkType) {\n        case PDE_OPTICAL_DISK:\n            type = VIR_DOMAIN_BOOT_CDROM;\n            break;\n        case PDE_HARD_DISK:\n            type = VIR_DOMAIN_BOOT_DISK;\n            break;\n        case PDE_GENERIC_NETWORK_ADAPTER:\n            type = VIR_DOMAIN_BOOT_NET;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unexpected boot device type %i\"), sdkType);\n            goto cleanup;\n        }\n\n        pret = PrlBootDev_GetIndex(bootDev, &sdkIndex);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (prlsdkBootOrderCheck(sdkdom, sdkType, sdkIndex, def, bootUsage[type]) < 0)\n            goto cleanup;\n\n        bootUsage[type]++;\n        def->os.bootDevs[def->os.nBootDevs++] = type;\n\n        PrlHandle_Free(bootDev);\n        bootDev = PRL_INVALID_HANDLE;\n    }\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(bootDev);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkConvertBootOrderVm(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    int ret = -1;\n    PRL_RESULT pret;\n    PRL_UINT32 bootNum;\n    PRL_HANDLE bootDev = PRL_INVALID_HANDLE;\n    PRL_BOOL inUse;\n    PRL_DEVICE_TYPE sdkType;\n    virDomainBootOrder type;\n    PRL_UINT32 prevBootIndex = 0, bootIndex, sdkIndex;\n    int bootUsage[VIR_DOMAIN_BOOT_LAST] = { 0 };\n    size_t i;\n\n    pret = PrlVmCfg_GetBootDevCount(sdkdom, &bootNum);\n    prlsdkCheckRetExit(pret, -1);\n\n    def->os.nBootDevs = 0;\n\n    if (bootNum > VIR_DOMAIN_MAX_BOOT_DEVS) {\n        bootNum = VIR_DOMAIN_MAX_BOOT_DEVS;\n        VIR_WARN(\"Too many boot devices\");\n    }\n\n    for (i = 0; i < bootNum; ++i) {\n        pret = PrlVmCfg_GetBootDev(sdkdom, i, &bootDev);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlBootDev_IsInUse(bootDev, &inUse);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (!inUse)\n            continue;\n\n        pret = PrlBootDev_GetSequenceIndex(bootDev, &bootIndex);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        /* bootIndex is started from 1 */\n        if (bootIndex <= prevBootIndex) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Unsupported boot order configuration\"));\n            goto cleanup;\n        }\n        prevBootIndex = bootIndex;\n\n        pret = PrlBootDev_GetType(bootDev, &sdkType);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (sdkType == PDE_FLOPPY_DISK) {\n            VIR_WARN(\"Skipping floppy from boot order.\");\n            continue;\n        }\n\n        switch ((int)sdkType) {\n        case PDE_OPTICAL_DISK:\n            type = VIR_DOMAIN_BOOT_CDROM;\n            break;\n        case PDE_HARD_DISK:\n            type = VIR_DOMAIN_BOOT_DISK;\n            break;\n        case PDE_GENERIC_NETWORK_ADAPTER:\n            type = VIR_DOMAIN_BOOT_NET;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unexpected boot device type %i\"), sdkType);\n            goto cleanup;\n        }\n\n        pret = PrlBootDev_GetIndex(bootDev, &sdkIndex);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (prlsdkBootOrderCheck(sdkdom, sdkType, sdkIndex, def, bootUsage[type]) < 0)\n            goto cleanup;\n\n        bootUsage[type]++;\n        def->os.bootDevs[def->os.nBootDevs++] = type;\n\n        PrlHandle_Free(bootDev);\n        bootDev = PRL_INVALID_HANDLE;\n    }\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(bootDev);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "def"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkAddDomainHardware",
          "args": [
            "driver",
            "sdkdom",
            "def",
            "driver->xmlopt"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkAddDomainHardware",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1289-1318",
          "snippet": "static int\nprlsdkAddDomainHardware(vzDriverPtr driver,\n                        PRL_HANDLE sdkdom,\n                        virDomainDefPtr def,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    if (IS_CT(def)) {\n        if (prlsdkAddDomainVideoInfoCt(def, xmlopt) < 0)\n            return -1;\n    } else {\n        if (prlsdkAddDomainVideoInfoVm(sdkdom, def) < 0)\n            return -1;\n    }\n\n    if (prlsdkAddDomainHardDisksInfo(driver, sdkdom, def) < 0)\n        return -1;\n\n    if (prlsdkAddDomainOpticalDisksInfo(driver, sdkdom, def) < 0)\n        return -1;\n\n    if (prlsdkAddDomainNetInfo(sdkdom, def) < 0)\n        return -1;\n\n    if (prlsdkAddSerialInfo(sdkdom,\n                            &def->serials,\n                            &def->nserials) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkAddDomainHardware(vzDriverPtr driver,\n                        PRL_HANDLE sdkdom,\n                        virDomainDefPtr def,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    if (IS_CT(def)) {\n        if (prlsdkAddDomainVideoInfoCt(def, xmlopt) < 0)\n            return -1;\n    } else {\n        if (prlsdkAddDomainVideoInfoVm(sdkdom, def) < 0)\n            return -1;\n    }\n\n    if (prlsdkAddDomainHardDisksInfo(driver, sdkdom, def) < 0)\n        return -1;\n\n    if (prlsdkAddDomainOpticalDisksInfo(driver, sdkdom, def) < 0)\n        return -1;\n\n    if (prlsdkAddDomainNetInfo(sdkdom, def) < 0)\n        return -1;\n\n    if (prlsdkAddSerialInfo(sdkdom,\n                            &def->serials,\n                            &def->nserials) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkAddVNCInfo",
          "args": [
            "sdkdom",
            "def"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkAddVNCInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1321-1374",
          "snippet": "static int\nprlsdkAddVNCInfo(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    virDomainGraphicsDefPtr gr = NULL;\n    PRL_VM_REMOTE_DISPLAY_MODE vncMode;\n    PRL_UINT32 port;\n    PRL_RESULT pret;\n    char *passwd = NULL;\n\n    pret = PrlVmCfg_GetVNCMode(sdkdom, &vncMode);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (vncMode == PRD_DISABLED)\n        return 0;\n\n    if (VIR_ALLOC(gr) < 0)\n        goto error;\n\n    if (!(passwd = prlsdkGetStringParamVar(PrlVmCfg_GetVNCPassword, sdkdom)))\n        goto error;\n\n    if (*passwd != '\\0') {\n        gr->data.vnc.auth.passwd = passwd;\n        passwd = NULL;\n    }\n\n    pret = PrlVmCfg_GetVNCPort(sdkdom, &port);\n    prlsdkCheckRetGoto(pret, error);\n\n    gr->data.vnc.autoport = (vncMode == PRD_AUTO);\n    gr->type = VIR_DOMAIN_GRAPHICS_TYPE_VNC;\n    gr->data.vnc.port = port;\n\n    if (VIR_ALLOC(gr->listens) < 0)\n        goto error;\n\n    gr->nListens = 1;\n\n    if (!(gr->listens[0].address = prlsdkGetStringParamVar(PrlVmCfg_GetVNCHostName,\n                                                           sdkdom)))\n        goto error;\n\n    gr->listens[0].type = VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS;\n\n    if (VIR_APPEND_ELEMENT(def->graphics, def->ngraphics, gr) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDomainGraphicsDefFree(gr);\n    VIR_FREE(passwd);\n    return -1;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkAddVNCInfo(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    virDomainGraphicsDefPtr gr = NULL;\n    PRL_VM_REMOTE_DISPLAY_MODE vncMode;\n    PRL_UINT32 port;\n    PRL_RESULT pret;\n    char *passwd = NULL;\n\n    pret = PrlVmCfg_GetVNCMode(sdkdom, &vncMode);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (vncMode == PRD_DISABLED)\n        return 0;\n\n    if (VIR_ALLOC(gr) < 0)\n        goto error;\n\n    if (!(passwd = prlsdkGetStringParamVar(PrlVmCfg_GetVNCPassword, sdkdom)))\n        goto error;\n\n    if (*passwd != '\\0') {\n        gr->data.vnc.auth.passwd = passwd;\n        passwd = NULL;\n    }\n\n    pret = PrlVmCfg_GetVNCPort(sdkdom, &port);\n    prlsdkCheckRetGoto(pret, error);\n\n    gr->data.vnc.autoport = (vncMode == PRD_AUTO);\n    gr->type = VIR_DOMAIN_GRAPHICS_TYPE_VNC;\n    gr->data.vnc.port = port;\n\n    if (VIR_ALLOC(gr->listens) < 0)\n        goto error;\n\n    gr->nListens = 1;\n\n    if (!(gr->listens[0].address = prlsdkGetStringParamVar(PrlVmCfg_GetVNCHostName,\n                                                           sdkdom)))\n        goto error;\n\n    gr->listens[0].type = VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS;\n\n    if (VIR_APPEND_ELEMENT(def->graphics, def->ngraphics, gr) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDomainGraphicsDefFree(gr);\n    VIR_FREE(passwd);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkConvertDomainType",
          "args": [
            "sdkdom",
            "def"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConvertDomainType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1495-1519",
          "snippet": "static int\nprlsdkConvertDomainType(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    PRL_VM_TYPE domainType;\n    PRL_RESULT pret;\n\n    pret = PrlVmCfg_GetVmType(sdkdom, &domainType);\n    prlsdkCheckRetExit(pret, -1);\n\n    switch (domainType) {\n    case PVT_VM:\n        def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n        break;\n    case PVT_CT:\n        def->os.type = VIR_DOMAIN_OSTYPE_EXE;\n        def->os.init = g_strdup(\"/sbin/init\");\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown domain type: %X\"), domainType);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkConvertDomainType(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    PRL_VM_TYPE domainType;\n    PRL_RESULT pret;\n\n    pret = PrlVmCfg_GetVmType(sdkdom, &domainType);\n    prlsdkCheckRetExit(pret, -1);\n\n    switch (domainType) {\n    case PVT_VM:\n        def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n        break;\n    case PVT_CT:\n        def->os.type = VIR_DOMAIN_OSTYPE_EXE;\n        def->os.init = g_strdup(\"/sbin/init\");\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown domain type: %X\"), domainType);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkConvertCpuMode",
          "args": [
            "sdkdom",
            "def"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConvertCpuMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1521-1544",
          "snippet": "static int\nprlsdkConvertCpuMode(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    PRL_CPU_MODE cpuMode;\n\n    pret = PrlVmCfg_GetCpuMode(sdkdom, &cpuMode);\n    prlsdkCheckRetExit(pret, -1);\n\n    switch (cpuMode) {\n    case PCM_CPU_MODE_32:\n        def->os.arch = VIR_ARCH_I686;\n        break;\n    case PCM_CPU_MODE_64:\n        def->os.arch = VIR_ARCH_X86_64;\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU mode: %X\"), cpuMode);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkConvertCpuMode(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    PRL_CPU_MODE cpuMode;\n\n    pret = PrlVmCfg_GetCpuMode(sdkdom, &cpuMode);\n    prlsdkCheckRetExit(pret, -1);\n\n    switch (cpuMode) {\n    case PCM_CPU_MODE_32:\n        def->os.arch = VIR_ARCH_I686;\n        break;\n    case PCM_CPU_MODE_64:\n        def->os.arch = VIR_ARCH_X86_64;\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU mode: %X\"), cpuMode);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkConvertCpuInfo",
          "args": [
            "sdkdom",
            "def",
            "driver->xmlopt"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkConvertCpuInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1454-1493",
          "snippet": "static int\nprlsdkConvertCpuInfo(PRL_HANDLE sdkdom,\n                     virDomainDefPtr def,\n                     virDomainXMLOptionPtr xmlopt)\n{\n    g_autofree char *buf = NULL;\n    int hostcpus;\n    PRL_UINT32 cpuCount;\n    PRL_RESULT pret;\n\n    if ((hostcpus = virHostCPUGetCount()) < 0)\n        return -1;\n\n    /* get number of CPUs */\n    pret = PrlVmCfg_GetCpuCount(sdkdom, &cpuCount);\n    prlsdkCheckRetExit(pret, -1);\n\n    if (cpuCount > hostcpus)\n        cpuCount = hostcpus;\n\n    if (virDomainDefSetVcpusMax(def, cpuCount, xmlopt) < 0)\n        return -1;\n\n    if (virDomainDefSetVcpus(def, cpuCount) < 0)\n        return -1;\n\n    if (!(buf = prlsdkGetStringParamVar(PrlVmCfg_GetCpuMask, sdkdom)))\n        return -1;\n\n    if (strlen(buf) == 0) {\n        if (!(def->cpumask = virBitmapNew(hostcpus)))\n            return -1;\n        virBitmapSetAll(def->cpumask);\n    } else {\n        if (virBitmapParse(buf, &def->cpumask, hostcpus) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkConvertCpuInfo(PRL_HANDLE sdkdom,\n                     virDomainDefPtr def,\n                     virDomainXMLOptionPtr xmlopt)\n{\n    g_autofree char *buf = NULL;\n    int hostcpus;\n    PRL_UINT32 cpuCount;\n    PRL_RESULT pret;\n\n    if ((hostcpus = virHostCPUGetCount()) < 0)\n        return -1;\n\n    /* get number of CPUs */\n    pret = PrlVmCfg_GetCpuCount(sdkdom, &cpuCount);\n    prlsdkCheckRetExit(pret, -1);\n\n    if (cpuCount > hostcpus)\n        cpuCount = hostcpus;\n\n    if (virDomainDefSetVcpusMax(def, cpuCount, xmlopt) < 0)\n        return -1;\n\n    if (virDomainDefSetVcpus(def, cpuCount) < 0)\n        return -1;\n\n    if (!(buf = prlsdkGetStringParamVar(PrlVmCfg_GetCpuMask, sdkdom)))\n        return -1;\n\n    if (strlen(buf) == 0) {\n        if (!(def->cpumask = virBitmapNew(hostcpus)))\n            return -1;\n        virBitmapSetAll(def->cpumask);\n    } else {\n        if (virBitmapParse(buf, &def->cpumask, hostcpus) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSetMemoryTotal",
          "args": [
            "def",
            "ram << 10"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetMemoryTotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10931-10936",
          "snippet": "void\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetRamSize",
          "args": [
            "sdkdom",
            "&ram"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Domain UUID is malformed or empty\")"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkUUIDParse",
          "args": [
            "uuidstr",
            "def->uuid"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "496-517",
          "snippet": "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    char *tmp = NULL;\n    int ret = -1;\n\n    virCheckNonNullArgGoto(uuidstr, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    tmp = g_strdup(uuidstr);\n\n    tmp[strlen(tmp) - 1] = '\\0';\n\n    /* trim curly braces */\n    if (virUUIDParse(tmp + 1, uuid) < 0)\n        goto error;\n\n    ret = 0;\n error:\n    VIR_FREE(tmp);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    char *tmp = NULL;\n    int ret = -1;\n\n    virCheckNonNullArgGoto(uuidstr, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    tmp = g_strdup(uuidstr);\n\n    tmp[strlen(tmp) - 1] = '\\0';\n\n    /* trim curly braces */\n    if (virUUIDParse(tmp + 1, uuid) < 0)\n        goto error;\n\n    ret = 0;\n error:\n    VIR_FREE(tmp);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetStringParamBuf",
          "args": [
            "PrlVmCfg_GetUuid",
            "sdkdom",
            "uuidstr",
            "sizeof(uuidstr)"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetStringParamBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "322-328",
          "snippet": "static PRL_RESULT\nprlsdkGetStringParamBuf(prlsdkParamGetterType getter,\n                        PRL_HANDLE handle, char *buf, size_t size)\n{\n    PRL_UINT32 buflen = size;\n    return getter(handle, buf, &buflen);\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_RESULT\nprlsdkGetStringParamBuf(prlsdkParamGetterType getter,\n                        PRL_HANDLE handle, char *buf, size_t size)\n{\n    PRL_UINT32 buflen = size;\n    return getter(handle, buf, &buflen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkGetStringParamVar",
          "args": [
            "PrlVmCfg_GetName",
            "sdkdom"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetStringParamVar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "299-320",
          "snippet": "static char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefNew",
          "args": [],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3574-3594",
          "snippet": "virDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic virDomainObjPtr\nprlsdkLoadDomain(vzDriverPtr driver,\n                 PRL_HANDLE sdkdom,\n                 virDomainObjPtr dom)\n{\n    virDomainDefPtr def = NULL;\n    vzDomObjPtr pdom = NULL;\n    VIRTUAL_MACHINE_STATE domainState;\n\n    PRL_RESULT pret;\n    PRL_UINT32 ram;\n    PRL_UINT32 envId;\n    PRL_VM_AUTOSTART_OPTION autostart;\n    PRL_HANDLE job;\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n\n    if (!(def = virDomainDefNew()))\n        goto error;\n\n    if (!(def->name = prlsdkGetStringParamVar(PrlVmCfg_GetName, sdkdom)))\n        goto error;\n\n    pret = prlsdkGetStringParamBuf(PrlVmCfg_GetUuid,\n                                   sdkdom, uuidstr, sizeof(uuidstr));\n    prlsdkCheckRetGoto(pret, error);\n\n    if (prlsdkUUIDParse(uuidstr, def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain UUID is malformed or empty\"));\n        goto error;\n    }\n\n    def->virtType = VIR_DOMAIN_VIRT_VZ;\n\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* get RAM parameters */\n    pret = PrlVmCfg_GetRamSize(sdkdom, &ram);\n    prlsdkCheckRetGoto(pret, error);\n    virDomainDefSetMemoryTotal(def, ram << 10); /* RAM size obtained in Mbytes,\n                                                     convert to Kbytes */\n    def->mem.cur_balloon = ram << 10;\n\n    if (prlsdkConvertCpuInfo(sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    if (prlsdkConvertCpuMode(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkConvertDomainType(sdkdom, def) < 0)\n        goto error;\n\n    if (prlsdkAddVNCInfo(sdkdom, def) < 0)\n        goto error;\n\n    /* depends on prlsdkAddVNCInfo */\n    if (prlsdkAddDomainHardware(driver, sdkdom, def, driver->xmlopt) < 0)\n        goto error;\n\n    /* depends on prlsdkAddDomainHardware */\n    if (!IS_CT(def) && prlsdkConvertBootOrderVm(sdkdom, def) < 0)\n        goto error;\n\n    pret = PrlVmCfg_GetEnvId(sdkdom, &envId);\n    prlsdkCheckRetGoto(pret, error);\n\n    pret = PrlVmCfg_GetAutoStart(sdkdom, &autostart);\n    prlsdkCheckRetGoto(pret, error);\n    if (autostart != PAO_VM_START_ON_LOAD &&\n        autostart != PAO_VM_START_MANUAL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown autostart mode: %X\"), autostart);\n        goto error;\n    }\n\n    if (prlsdkGetDomainState(dom, sdkdom, &domainState) < 0)\n        goto error;\n\n    if (!IS_CT(def) && virDomainDefAddImplicitDevices(def, driver->xmlopt) < 0)\n        goto error;\n\n    if (def->ngraphics > 0) {\n        int bus = IS_CT(def) ? VIR_DOMAIN_INPUT_BUS_PARALLELS :\n                               VIR_DOMAIN_INPUT_BUS_PS2;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_MOUSE,\n                                      bus) < 0)\n            goto error;\n\n        if (virDomainDefMaybeAddInput(def,\n                                      VIR_DOMAIN_INPUT_TYPE_KBD,\n                                      bus) < 0)\n            goto error;\n    }\n\n    if (!dom) {\n        virDomainObjPtr olddom = NULL;\n\n        job = PrlVm_SubscribeToPerfStats(sdkdom, NULL);\n        if (PRL_FAILED(waitJob(job)))\n            goto error;\n\n        virObjectLock(driver);\n        if (!(olddom = virDomainObjListFindByUUID(driver->domains, def->uuid)))\n            dom = virDomainObjListAdd(driver->domains, def, driver->xmlopt, 0, NULL);\n        virObjectUnlock(driver);\n\n        if (olddom) {\n            virDomainDefFree(def);\n            return olddom;\n        } else if (!dom) {\n            goto error;\n        }\n\n        pdom = dom->privateData;\n        pdom->sdkdom = sdkdom;\n        PrlHandle_AddRef(sdkdom);\n        dom->persistent = 1;\n    } else {\n        /* assign new virDomainDef without any checks\n         * we can't use virDomainObjAssignDef, because it checks\n         * for state and domain name */\n        virDomainDefFree(dom->def);\n        dom->def = def;\n    }\n\n    pdom = dom->privateData;\n    pdom->id = envId;\n\n    prlsdkConvertDomainState(domainState, envId, dom);\n\n    if (autostart == PAO_VM_START_ON_LOAD)\n        dom->autostart = 1;\n    else\n        dom->autostart = 0;\n\n    return dom;\n\n error:\n    virDomainDefFree(def);\n    return NULL;\n}"
  },
  {
    "function_name": "prlsdkConvertBootOrderVm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "1731-1818",
    "snippet": "static int\nprlsdkConvertBootOrderVm(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    int ret = -1;\n    PRL_RESULT pret;\n    PRL_UINT32 bootNum;\n    PRL_HANDLE bootDev = PRL_INVALID_HANDLE;\n    PRL_BOOL inUse;\n    PRL_DEVICE_TYPE sdkType;\n    virDomainBootOrder type;\n    PRL_UINT32 prevBootIndex = 0, bootIndex, sdkIndex;\n    int bootUsage[VIR_DOMAIN_BOOT_LAST] = { 0 };\n    size_t i;\n\n    pret = PrlVmCfg_GetBootDevCount(sdkdom, &bootNum);\n    prlsdkCheckRetExit(pret, -1);\n\n    def->os.nBootDevs = 0;\n\n    if (bootNum > VIR_DOMAIN_MAX_BOOT_DEVS) {\n        bootNum = VIR_DOMAIN_MAX_BOOT_DEVS;\n        VIR_WARN(\"Too many boot devices\");\n    }\n\n    for (i = 0; i < bootNum; ++i) {\n        pret = PrlVmCfg_GetBootDev(sdkdom, i, &bootDev);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlBootDev_IsInUse(bootDev, &inUse);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (!inUse)\n            continue;\n\n        pret = PrlBootDev_GetSequenceIndex(bootDev, &bootIndex);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        /* bootIndex is started from 1 */\n        if (bootIndex <= prevBootIndex) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Unsupported boot order configuration\"));\n            goto cleanup;\n        }\n        prevBootIndex = bootIndex;\n\n        pret = PrlBootDev_GetType(bootDev, &sdkType);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (sdkType == PDE_FLOPPY_DISK) {\n            VIR_WARN(\"Skipping floppy from boot order.\");\n            continue;\n        }\n\n        switch ((int)sdkType) {\n        case PDE_OPTICAL_DISK:\n            type = VIR_DOMAIN_BOOT_CDROM;\n            break;\n        case PDE_HARD_DISK:\n            type = VIR_DOMAIN_BOOT_DISK;\n            break;\n        case PDE_GENERIC_NETWORK_ADAPTER:\n            type = VIR_DOMAIN_BOOT_NET;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unexpected boot device type %i\"), sdkType);\n            goto cleanup;\n        }\n\n        pret = PrlBootDev_GetIndex(bootDev, &sdkIndex);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (prlsdkBootOrderCheck(sdkdom, sdkType, sdkIndex, def, bootUsage[type]) < 0)\n            goto cleanup;\n\n        bootUsage[type]++;\n        def->os.bootDevs[def->os.nBootDevs++] = type;\n\n        PrlHandle_Free(bootDev);\n        bootDev = PRL_INVALID_HANDLE;\n    }\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(bootDev);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "bootDev"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "bootDev"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkBootOrderCheck",
          "args": [
            "sdkdom",
            "sdkType",
            "sdkIndex",
            "def",
            "bootUsage[type]"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkBootOrderCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1649-1729",
          "snippet": "static int\nprlsdkBootOrderCheck(PRL_HANDLE sdkdom, PRL_DEVICE_TYPE sdkType, int sdkIndex,\n                     virDomainDefPtr def, int bootIndex)\n{\n    char *sdkName = NULL;\n    PRL_HANDLE dev = PRL_INVALID_HANDLE;\n    virDomainDiskDefPtr disk;\n    virDomainDiskDevice device;\n    int bus;\n    char *dst = NULL;\n    int ret = -1;\n\n    dev = prlsdkGetDevByDevIndex(sdkdom, sdkType, sdkIndex);\n    if (dev == PRL_INVALID_HANDLE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Can't find boot device of type: %d, device index: %d\"),\n                       sdkType, sdkIndex);\n        return -1;\n    }\n\n    switch ((int)sdkType) {\n    case PDE_OPTICAL_DISK:\n    case PDE_HARD_DISK:\n        switch ((int)sdkType) {\n        case PDE_OPTICAL_DISK:\n            device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n            break;\n        case PDE_HARD_DISK:\n            device = VIR_DOMAIN_DISK_DEVICE_DISK;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported disk type %d\"), sdkType);\n            goto cleanup;\n        }\n\n        if (!(disk = virFindDiskBootIndex(def, device, bootIndex))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Can't find boot device of type: %s, index: %d\"),\n                           virDomainDiskDeviceTypeToString(device), bootIndex);\n            goto cleanup;\n        }\n\n        if (prlsdkGetDiskId(dev, &bus, &dst) < 0)\n            goto cleanup;\n\n        if (!(bus == disk->bus && STREQ(disk->dst, dst)))\n            VIR_WARN(\"Unrepresentable boot order configuration\");\n\n        break;\n    case PDE_GENERIC_NETWORK_ADAPTER:\n        if (!(sdkName = prlsdkGetStringParamVar(PrlVmDevNet_GetHostInterfaceName,\n                                                dev)))\n            goto cleanup;\n\n        if (bootIndex >= def->nnets) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Can't find network boot device for index: %d\"),\n                           bootIndex);\n            goto cleanup;\n        }\n\n        if (STRNEQ(sdkName, def->nets[bootIndex]->ifname))\n            VIR_WARN(\"Unrepresentable boot order configuration\");\n\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unexpected device type %d\"), sdkType);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n\n    VIR_FREE(sdkName);\n    PrlHandle_Free(dev);\n    VIR_FREE(dst);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int\nprlsdkBootOrderCheck(PRL_HANDLE sdkdom, PRL_DEVICE_TYPE sdkType, int sdkIndex,\n                     virDomainDefPtr def, int bootIndex)\n{\n    char *sdkName = NULL;\n    PRL_HANDLE dev = PRL_INVALID_HANDLE;\n    virDomainDiskDefPtr disk;\n    virDomainDiskDevice device;\n    int bus;\n    char *dst = NULL;\n    int ret = -1;\n\n    dev = prlsdkGetDevByDevIndex(sdkdom, sdkType, sdkIndex);\n    if (dev == PRL_INVALID_HANDLE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Can't find boot device of type: %d, device index: %d\"),\n                       sdkType, sdkIndex);\n        return -1;\n    }\n\n    switch ((int)sdkType) {\n    case PDE_OPTICAL_DISK:\n    case PDE_HARD_DISK:\n        switch ((int)sdkType) {\n        case PDE_OPTICAL_DISK:\n            device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n            break;\n        case PDE_HARD_DISK:\n            device = VIR_DOMAIN_DISK_DEVICE_DISK;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported disk type %d\"), sdkType);\n            goto cleanup;\n        }\n\n        if (!(disk = virFindDiskBootIndex(def, device, bootIndex))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Can't find boot device of type: %s, index: %d\"),\n                           virDomainDiskDeviceTypeToString(device), bootIndex);\n            goto cleanup;\n        }\n\n        if (prlsdkGetDiskId(dev, &bus, &dst) < 0)\n            goto cleanup;\n\n        if (!(bus == disk->bus && STREQ(disk->dst, dst)))\n            VIR_WARN(\"Unrepresentable boot order configuration\");\n\n        break;\n    case PDE_GENERIC_NETWORK_ADAPTER:\n        if (!(sdkName = prlsdkGetStringParamVar(PrlVmDevNet_GetHostInterfaceName,\n                                                dev)))\n            goto cleanup;\n\n        if (bootIndex >= def->nnets) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Can't find network boot device for index: %d\"),\n                           bootIndex);\n            goto cleanup;\n        }\n\n        if (STRNEQ(sdkName, def->nets[bootIndex]->ifname))\n            VIR_WARN(\"Unrepresentable boot order configuration\");\n\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unexpected device type %d\"), sdkType);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n\n    VIR_FREE(sdkName);\n    PrlHandle_Free(dev);\n    VIR_FREE(dst);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlBootDev_GetIndex",
          "args": [
            "bootDev",
            "&sdkIndex"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unexpected boot device type %i\")",
            "sdkType"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected boot device type %i\""
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Skipping floppy from boot order.\""
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlBootDev_GetType",
          "args": [
            "bootDev",
            "&sdkType"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Unsupported boot order configuration\")"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlBootDev_GetSequenceIndex",
          "args": [
            "bootDev",
            "&bootIndex"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlBootDev_IsInUse",
          "args": [
            "bootDev",
            "&inUse"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetBootDev",
          "args": [
            "sdkdom",
            "i",
            "&bootDev"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Too many boot devices\""
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetBootDevCount",
          "args": [
            "sdkdom",
            "&bootNum"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkConvertBootOrderVm(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    int ret = -1;\n    PRL_RESULT pret;\n    PRL_UINT32 bootNum;\n    PRL_HANDLE bootDev = PRL_INVALID_HANDLE;\n    PRL_BOOL inUse;\n    PRL_DEVICE_TYPE sdkType;\n    virDomainBootOrder type;\n    PRL_UINT32 prevBootIndex = 0, bootIndex, sdkIndex;\n    int bootUsage[VIR_DOMAIN_BOOT_LAST] = { 0 };\n    size_t i;\n\n    pret = PrlVmCfg_GetBootDevCount(sdkdom, &bootNum);\n    prlsdkCheckRetExit(pret, -1);\n\n    def->os.nBootDevs = 0;\n\n    if (bootNum > VIR_DOMAIN_MAX_BOOT_DEVS) {\n        bootNum = VIR_DOMAIN_MAX_BOOT_DEVS;\n        VIR_WARN(\"Too many boot devices\");\n    }\n\n    for (i = 0; i < bootNum; ++i) {\n        pret = PrlVmCfg_GetBootDev(sdkdom, i, &bootDev);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlBootDev_IsInUse(bootDev, &inUse);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (!inUse)\n            continue;\n\n        pret = PrlBootDev_GetSequenceIndex(bootDev, &bootIndex);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        /* bootIndex is started from 1 */\n        if (bootIndex <= prevBootIndex) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Unsupported boot order configuration\"));\n            goto cleanup;\n        }\n        prevBootIndex = bootIndex;\n\n        pret = PrlBootDev_GetType(bootDev, &sdkType);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (sdkType == PDE_FLOPPY_DISK) {\n            VIR_WARN(\"Skipping floppy from boot order.\");\n            continue;\n        }\n\n        switch ((int)sdkType) {\n        case PDE_OPTICAL_DISK:\n            type = VIR_DOMAIN_BOOT_CDROM;\n            break;\n        case PDE_HARD_DISK:\n            type = VIR_DOMAIN_BOOT_DISK;\n            break;\n        case PDE_GENERIC_NETWORK_ADAPTER:\n            type = VIR_DOMAIN_BOOT_NET;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unexpected boot device type %i\"), sdkType);\n            goto cleanup;\n        }\n\n        pret = PrlBootDev_GetIndex(bootDev, &sdkIndex);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (prlsdkBootOrderCheck(sdkdom, sdkType, sdkIndex, def, bootUsage[type]) < 0)\n            goto cleanup;\n\n        bootUsage[type]++;\n        def->os.bootDevs[def->os.nBootDevs++] = type;\n\n        PrlHandle_Free(bootDev);\n        bootDev = PRL_INVALID_HANDLE;\n    }\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(bootDev);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkBootOrderCheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "1649-1729",
    "snippet": "static int\nprlsdkBootOrderCheck(PRL_HANDLE sdkdom, PRL_DEVICE_TYPE sdkType, int sdkIndex,\n                     virDomainDefPtr def, int bootIndex)\n{\n    char *sdkName = NULL;\n    PRL_HANDLE dev = PRL_INVALID_HANDLE;\n    virDomainDiskDefPtr disk;\n    virDomainDiskDevice device;\n    int bus;\n    char *dst = NULL;\n    int ret = -1;\n\n    dev = prlsdkGetDevByDevIndex(sdkdom, sdkType, sdkIndex);\n    if (dev == PRL_INVALID_HANDLE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Can't find boot device of type: %d, device index: %d\"),\n                       sdkType, sdkIndex);\n        return -1;\n    }\n\n    switch ((int)sdkType) {\n    case PDE_OPTICAL_DISK:\n    case PDE_HARD_DISK:\n        switch ((int)sdkType) {\n        case PDE_OPTICAL_DISK:\n            device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n            break;\n        case PDE_HARD_DISK:\n            device = VIR_DOMAIN_DISK_DEVICE_DISK;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported disk type %d\"), sdkType);\n            goto cleanup;\n        }\n\n        if (!(disk = virFindDiskBootIndex(def, device, bootIndex))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Can't find boot device of type: %s, index: %d\"),\n                           virDomainDiskDeviceTypeToString(device), bootIndex);\n            goto cleanup;\n        }\n\n        if (prlsdkGetDiskId(dev, &bus, &dst) < 0)\n            goto cleanup;\n\n        if (!(bus == disk->bus && STREQ(disk->dst, dst)))\n            VIR_WARN(\"Unrepresentable boot order configuration\");\n\n        break;\n    case PDE_GENERIC_NETWORK_ADAPTER:\n        if (!(sdkName = prlsdkGetStringParamVar(PrlVmDevNet_GetHostInterfaceName,\n                                                dev)))\n            goto cleanup;\n\n        if (bootIndex >= def->nnets) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Can't find network boot device for index: %d\"),\n                           bootIndex);\n            goto cleanup;\n        }\n\n        if (STRNEQ(sdkName, def->nets[bootIndex]->ifname))\n            VIR_WARN(\"Unrepresentable boot order configuration\");\n\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unexpected device type %d\"), sdkType);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n\n    VIR_FREE(sdkName);\n    PrlHandle_Free(dev);\n    VIR_FREE(dst);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dst"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "dev"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sdkName"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unexpected device type %d\")",
            "sdkType"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected device type %d\""
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unrepresentable boot order configuration\""
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "sdkName",
            "def->nets[bootIndex]->ifname"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Can't find network boot device for index: %d\")",
            "bootIndex"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetStringParamVar",
          "args": [
            "PrlVmDevNet_GetHostInterfaceName",
            "dev"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetStringParamVar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "299-320",
          "snippet": "static char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unrepresentable boot order configuration\""
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "disk->dst",
            "dst"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetDiskId",
          "args": [
            "dev",
            "&bus",
            "&dst"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetDiskId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "607-643",
          "snippet": "static int\nprlsdkGetDiskId(PRL_HANDLE disk, int *bus, char **dst)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 pos, ifType;\n\n    pret = PrlVmDev_GetStackIndex(disk, &pos);\n    prlsdkCheckRetExit(pret, -1);\n\n    pret = PrlVmDev_GetIfaceType(disk, &ifType);\n    prlsdkCheckRetExit(pret, -1);\n\n    switch (ifType) {\n    case PMS_IDE_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_IDE;\n        *dst = virIndexToDiskName(pos, \"hd\");\n        break;\n    case PMS_SCSI_DEVICE:\n    case PMS_UNKNOWN_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_SCSI;\n        *dst = virIndexToDiskName(pos, \"sd\");\n        break;\n    case PMS_SATA_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_SATA;\n        *dst = virIndexToDiskName(pos, \"sd\");\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown disk bus: %X\"), ifType);\n        return -1;\n    }\n\n    if (NULL == *dst)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int\nprlsdkGetDiskId(PRL_HANDLE disk, int *bus, char **dst)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 pos, ifType;\n\n    pret = PrlVmDev_GetStackIndex(disk, &pos);\n    prlsdkCheckRetExit(pret, -1);\n\n    pret = PrlVmDev_GetIfaceType(disk, &ifType);\n    prlsdkCheckRetExit(pret, -1);\n\n    switch (ifType) {\n    case PMS_IDE_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_IDE;\n        *dst = virIndexToDiskName(pos, \"hd\");\n        break;\n    case PMS_SCSI_DEVICE:\n    case PMS_UNKNOWN_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_SCSI;\n        *dst = virIndexToDiskName(pos, \"sd\");\n        break;\n    case PMS_SATA_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_SATA;\n        *dst = virIndexToDiskName(pos, \"sd\");\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown disk bus: %X\"), ifType);\n        return -1;\n    }\n\n    if (NULL == *dst)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Can't find boot device of type: %s, index: %d\")",
            "virDomainDiskDeviceTypeToString(device)",
            "bootIndex"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskDeviceTypeToString",
          "args": [
            "device"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFindDiskBootIndex",
          "args": [
            "def",
            "device",
            "bootIndex"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "virFindDiskBootIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1578-1593",
          "snippet": "static virDomainDiskDefPtr\nvirFindDiskBootIndex(virDomainDefPtr def, virDomainDiskDevice type, int index)\n{\n    size_t i;\n    int c = 0;\n\n    for (i = 0; i < def->ndisks; ++i) {\n        if (def->disks[i]->device != type)\n            continue;\n        if (c == index)\n            return def->disks[i];\n        ++c;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virDomainDiskDefPtr\nvirFindDiskBootIndex(virDomainDefPtr def, virDomainDiskDevice type, int index)\n{\n    size_t i;\n    int c = 0;\n\n    for (i = 0; i < def->ndisks; ++i) {\n        if (def->disks[i]->device != type)\n            continue;\n        if (c == index)\n            return def->disks[i];\n        ++c;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported disk type %d\")",
            "sdkType"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Can't find boot device of type: %d, device index: %d\")",
            "sdkType",
            "sdkIndex"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetDevByDevIndex",
          "args": [
            "sdkdom",
            "sdkType",
            "sdkIndex"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetDevByDevIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1546-1576",
          "snippet": "static PRL_HANDLE\nprlsdkGetDevByDevIndex(PRL_HANDLE sdkdom, PRL_DEVICE_TYPE type, PRL_UINT32 devIndex)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 index, num;\n    PRL_HANDLE dev = PRL_INVALID_HANDLE;\n    size_t i;\n\n    pret = PrlVmCfg_GetDevsCountByType(sdkdom, type, &num);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < num; ++i) {\n        pret = PrlVmCfg_GetDevByType(sdkdom, type, i, &dev);\n        prlsdkCheckRetGoto(pret, error);\n\n        pret = PrlVmDev_GetIndex(dev, &index);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (index == devIndex)\n            break;\n\n        PrlHandle_Free(dev);\n        dev = PRL_INVALID_HANDLE;\n    }\n\n    return dev;\n\n error:\n    PrlHandle_Free(dev);\n    return PRL_INVALID_HANDLE;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic PRL_HANDLE\nprlsdkGetDevByDevIndex(PRL_HANDLE sdkdom, PRL_DEVICE_TYPE type, PRL_UINT32 devIndex)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 index, num;\n    PRL_HANDLE dev = PRL_INVALID_HANDLE;\n    size_t i;\n\n    pret = PrlVmCfg_GetDevsCountByType(sdkdom, type, &num);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < num; ++i) {\n        pret = PrlVmCfg_GetDevByType(sdkdom, type, i, &dev);\n        prlsdkCheckRetGoto(pret, error);\n\n        pret = PrlVmDev_GetIndex(dev, &index);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (index == devIndex)\n            break;\n\n        PrlHandle_Free(dev);\n        dev = PRL_INVALID_HANDLE;\n    }\n\n    return dev;\n\n error:\n    PrlHandle_Free(dev);\n    return PRL_INVALID_HANDLE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int\nprlsdkBootOrderCheck(PRL_HANDLE sdkdom, PRL_DEVICE_TYPE sdkType, int sdkIndex,\n                     virDomainDefPtr def, int bootIndex)\n{\n    char *sdkName = NULL;\n    PRL_HANDLE dev = PRL_INVALID_HANDLE;\n    virDomainDiskDefPtr disk;\n    virDomainDiskDevice device;\n    int bus;\n    char *dst = NULL;\n    int ret = -1;\n\n    dev = prlsdkGetDevByDevIndex(sdkdom, sdkType, sdkIndex);\n    if (dev == PRL_INVALID_HANDLE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Can't find boot device of type: %d, device index: %d\"),\n                       sdkType, sdkIndex);\n        return -1;\n    }\n\n    switch ((int)sdkType) {\n    case PDE_OPTICAL_DISK:\n    case PDE_HARD_DISK:\n        switch ((int)sdkType) {\n        case PDE_OPTICAL_DISK:\n            device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n            break;\n        case PDE_HARD_DISK:\n            device = VIR_DOMAIN_DISK_DEVICE_DISK;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported disk type %d\"), sdkType);\n            goto cleanup;\n        }\n\n        if (!(disk = virFindDiskBootIndex(def, device, bootIndex))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Can't find boot device of type: %s, index: %d\"),\n                           virDomainDiskDeviceTypeToString(device), bootIndex);\n            goto cleanup;\n        }\n\n        if (prlsdkGetDiskId(dev, &bus, &dst) < 0)\n            goto cleanup;\n\n        if (!(bus == disk->bus && STREQ(disk->dst, dst)))\n            VIR_WARN(\"Unrepresentable boot order configuration\");\n\n        break;\n    case PDE_GENERIC_NETWORK_ADAPTER:\n        if (!(sdkName = prlsdkGetStringParamVar(PrlVmDevNet_GetHostInterfaceName,\n                                                dev)))\n            goto cleanup;\n\n        if (bootIndex >= def->nnets) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Can't find network boot device for index: %d\"),\n                           bootIndex);\n            goto cleanup;\n        }\n\n        if (STRNEQ(sdkName, def->nets[bootIndex]->ifname))\n            VIR_WARN(\"Unrepresentable boot order configuration\");\n\n        break;\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unexpected device type %d\"), sdkType);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n\n    VIR_FREE(sdkName);\n    PrlHandle_Free(dev);\n    VIR_FREE(dst);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkInBootList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "1595-1648",
    "snippet": "static bool\nprlsdkInBootList(PRL_HANDLE sdkdom,\n                 PRL_HANDLE sdktargetdev)\n{\n    bool ret = false;\n    PRL_RESULT pret;\n    PRL_UINT32 bootNum;\n    PRL_HANDLE bootDev = PRL_INVALID_HANDLE;\n    PRL_BOOL inUse;\n    PRL_DEVICE_TYPE sdkType, targetType;\n    PRL_UINT32 sdkIndex, targetIndex;\n    size_t i;\n\n    pret = PrlVmDev_GetType(sdktargetdev, &targetType);\n    prlsdkCheckRetExit(pret, false);\n\n    pret = PrlVmDev_GetIndex(sdktargetdev, &targetIndex);\n    prlsdkCheckRetExit(pret, false);\n\n    pret = PrlVmCfg_GetBootDevCount(sdkdom, &bootNum);\n    prlsdkCheckRetExit(pret, false);\n\n    for (i = 0; i < bootNum; ++i) {\n        pret = PrlVmCfg_GetBootDev(sdkdom, i, &bootDev);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlBootDev_IsInUse(bootDev, &inUse);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (!inUse) {\n            PrlHandle_Free(bootDev);\n            bootDev = PRL_INVALID_HANDLE;\n            continue;\n        }\n\n        pret = PrlBootDev_GetType(bootDev, &sdkType);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlBootDev_GetIndex(bootDev, &sdkIndex);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        PrlHandle_Free(bootDev);\n        bootDev = PRL_INVALID_HANDLE;\n\n        if (sdkIndex == targetIndex && sdkType == targetType) {\n            ret = true;\n            break;\n        }\n    }\n\n cleanup:\n    PrlHandle_Free(bootDev);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);",
      "static bool\nprlsdkInBootList(PRL_HANDLE sdkdom,\n                 PRL_HANDLE sdktargetdev);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "bootDev"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "bootDev"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlBootDev_GetIndex",
          "args": [
            "bootDev",
            "&sdkIndex"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlBootDev_GetType",
          "args": [
            "bootDev",
            "&sdkType"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "bootDev"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlBootDev_IsInUse",
          "args": [
            "bootDev",
            "&inUse"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetBootDev",
          "args": [
            "sdkdom",
            "i",
            "&bootDev"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "false"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetBootDevCount",
          "args": [
            "sdkdom",
            "&bootNum"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "false"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_GetIndex",
          "args": [
            "sdktargetdev",
            "&targetIndex"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "false"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_GetType",
          "args": [
            "sdktargetdev",
            "&targetType"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic bool\nprlsdkInBootList(PRL_HANDLE sdkdom,\n                 PRL_HANDLE sdktargetdev);\n\nstatic bool\nprlsdkInBootList(PRL_HANDLE sdkdom,\n                 PRL_HANDLE sdktargetdev)\n{\n    bool ret = false;\n    PRL_RESULT pret;\n    PRL_UINT32 bootNum;\n    PRL_HANDLE bootDev = PRL_INVALID_HANDLE;\n    PRL_BOOL inUse;\n    PRL_DEVICE_TYPE sdkType, targetType;\n    PRL_UINT32 sdkIndex, targetIndex;\n    size_t i;\n\n    pret = PrlVmDev_GetType(sdktargetdev, &targetType);\n    prlsdkCheckRetExit(pret, false);\n\n    pret = PrlVmDev_GetIndex(sdktargetdev, &targetIndex);\n    prlsdkCheckRetExit(pret, false);\n\n    pret = PrlVmCfg_GetBootDevCount(sdkdom, &bootNum);\n    prlsdkCheckRetExit(pret, false);\n\n    for (i = 0; i < bootNum; ++i) {\n        pret = PrlVmCfg_GetBootDev(sdkdom, i, &bootDev);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlBootDev_IsInUse(bootDev, &inUse);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (!inUse) {\n            PrlHandle_Free(bootDev);\n            bootDev = PRL_INVALID_HANDLE;\n            continue;\n        }\n\n        pret = PrlBootDev_GetType(bootDev, &sdkType);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlBootDev_GetIndex(bootDev, &sdkIndex);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        PrlHandle_Free(bootDev);\n        bootDev = PRL_INVALID_HANDLE;\n\n        if (sdkIndex == targetIndex && sdkType == targetType) {\n            ret = true;\n            break;\n        }\n    }\n\n cleanup:\n    PrlHandle_Free(bootDev);\n    return ret;\n}"
  },
  {
    "function_name": "virFindDiskBootIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "1578-1593",
    "snippet": "static virDomainDiskDefPtr\nvirFindDiskBootIndex(virDomainDefPtr def, virDomainDiskDevice type, int index)\n{\n    size_t i;\n    int c = 0;\n\n    for (i = 0; i < def->ndisks; ++i) {\n        if (def->disks[i]->device != type)\n            continue;\n        if (c == index)\n            return def->disks[i];\n        ++c;\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virDomainDiskDefPtr\nvirFindDiskBootIndex(virDomainDefPtr def, virDomainDiskDevice type, int index)\n{\n    size_t i;\n    int c = 0;\n\n    for (i = 0; i < def->ndisks; ++i) {\n        if (def->disks[i]->device != type)\n            continue;\n        if (c == index)\n            return def->disks[i];\n        ++c;\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "prlsdkGetDevByDevIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "1546-1576",
    "snippet": "static PRL_HANDLE\nprlsdkGetDevByDevIndex(PRL_HANDLE sdkdom, PRL_DEVICE_TYPE type, PRL_UINT32 devIndex)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 index, num;\n    PRL_HANDLE dev = PRL_INVALID_HANDLE;\n    size_t i;\n\n    pret = PrlVmCfg_GetDevsCountByType(sdkdom, type, &num);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < num; ++i) {\n        pret = PrlVmCfg_GetDevByType(sdkdom, type, i, &dev);\n        prlsdkCheckRetGoto(pret, error);\n\n        pret = PrlVmDev_GetIndex(dev, &index);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (index == devIndex)\n            break;\n\n        PrlHandle_Free(dev);\n        dev = PRL_INVALID_HANDLE;\n    }\n\n    return dev;\n\n error:\n    PrlHandle_Free(dev);\n    return PRL_INVALID_HANDLE;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "dev"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "dev"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_GetIndex",
          "args": [
            "dev",
            "&index"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetDevByType",
          "args": [
            "sdkdom",
            "type",
            "i",
            "&dev"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetDevsCountByType",
          "args": [
            "sdkdom",
            "type",
            "&num"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic PRL_HANDLE\nprlsdkGetDevByDevIndex(PRL_HANDLE sdkdom, PRL_DEVICE_TYPE type, PRL_UINT32 devIndex)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 index, num;\n    PRL_HANDLE dev = PRL_INVALID_HANDLE;\n    size_t i;\n\n    pret = PrlVmCfg_GetDevsCountByType(sdkdom, type, &num);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < num; ++i) {\n        pret = PrlVmCfg_GetDevByType(sdkdom, type, i, &dev);\n        prlsdkCheckRetGoto(pret, error);\n\n        pret = PrlVmDev_GetIndex(dev, &index);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (index == devIndex)\n            break;\n\n        PrlHandle_Free(dev);\n        dev = PRL_INVALID_HANDLE;\n    }\n\n    return dev;\n\n error:\n    PrlHandle_Free(dev);\n    return PRL_INVALID_HANDLE;\n}"
  },
  {
    "function_name": "prlsdkConvertCpuMode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "1521-1544",
    "snippet": "static int\nprlsdkConvertCpuMode(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    PRL_CPU_MODE cpuMode;\n\n    pret = PrlVmCfg_GetCpuMode(sdkdom, &cpuMode);\n    prlsdkCheckRetExit(pret, -1);\n\n    switch (cpuMode) {\n    case PCM_CPU_MODE_32:\n        def->os.arch = VIR_ARCH_I686;\n        break;\n    case PCM_CPU_MODE_64:\n        def->os.arch = VIR_ARCH_X86_64;\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU mode: %X\"), cpuMode);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown CPU mode: %X\")",
            "cpuMode"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown CPU mode: %X\""
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetCpuMode",
          "args": [
            "sdkdom",
            "&cpuMode"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkConvertCpuMode(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    PRL_CPU_MODE cpuMode;\n\n    pret = PrlVmCfg_GetCpuMode(sdkdom, &cpuMode);\n    prlsdkCheckRetExit(pret, -1);\n\n    switch (cpuMode) {\n    case PCM_CPU_MODE_32:\n        def->os.arch = VIR_ARCH_I686;\n        break;\n    case PCM_CPU_MODE_64:\n        def->os.arch = VIR_ARCH_X86_64;\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU mode: %X\"), cpuMode);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkConvertDomainType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "1495-1519",
    "snippet": "static int\nprlsdkConvertDomainType(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    PRL_VM_TYPE domainType;\n    PRL_RESULT pret;\n\n    pret = PrlVmCfg_GetVmType(sdkdom, &domainType);\n    prlsdkCheckRetExit(pret, -1);\n\n    switch (domainType) {\n    case PVT_VM:\n        def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n        break;\n    case PVT_CT:\n        def->os.type = VIR_DOMAIN_OSTYPE_EXE;\n        def->os.init = g_strdup(\"/sbin/init\");\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown domain type: %X\"), domainType);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown domain type: %X\")",
            "domainType"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown domain type: %X\""
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetVmType",
          "args": [
            "sdkdom",
            "&domainType"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkConvertDomainType(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    PRL_VM_TYPE domainType;\n    PRL_RESULT pret;\n\n    pret = PrlVmCfg_GetVmType(sdkdom, &domainType);\n    prlsdkCheckRetExit(pret, -1);\n\n    switch (domainType) {\n    case PVT_VM:\n        def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n        break;\n    case PVT_CT:\n        def->os.type = VIR_DOMAIN_OSTYPE_EXE;\n        def->os.init = g_strdup(\"/sbin/init\");\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown domain type: %X\"), domainType);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkConvertCpuInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "1454-1493",
    "snippet": "static int\nprlsdkConvertCpuInfo(PRL_HANDLE sdkdom,\n                     virDomainDefPtr def,\n                     virDomainXMLOptionPtr xmlopt)\n{\n    g_autofree char *buf = NULL;\n    int hostcpus;\n    PRL_UINT32 cpuCount;\n    PRL_RESULT pret;\n\n    if ((hostcpus = virHostCPUGetCount()) < 0)\n        return -1;\n\n    /* get number of CPUs */\n    pret = PrlVmCfg_GetCpuCount(sdkdom, &cpuCount);\n    prlsdkCheckRetExit(pret, -1);\n\n    if (cpuCount > hostcpus)\n        cpuCount = hostcpus;\n\n    if (virDomainDefSetVcpusMax(def, cpuCount, xmlopt) < 0)\n        return -1;\n\n    if (virDomainDefSetVcpus(def, cpuCount) < 0)\n        return -1;\n\n    if (!(buf = prlsdkGetStringParamVar(PrlVmCfg_GetCpuMask, sdkdom)))\n        return -1;\n\n    if (strlen(buf) == 0) {\n        if (!(def->cpumask = virBitmapNew(hostcpus)))\n            return -1;\n        virBitmapSetAll(def->cpumask);\n    } else {\n        if (virBitmapParse(buf, &def->cpumask, hostcpus) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapParse",
          "args": [
            "buf",
            "&def->cpumask",
            "hostcpus"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "581-587",
          "snippet": "int\nvirBitmapParse(const char *str,\n               virBitmapPtr *bitmap,\n               size_t bitmapSize)\n{\n    return virBitmapParseSeparator(str, '\\0', bitmap, bitmapSize);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapParse(const char *str,\n               virBitmapPtr *bitmap,\n               size_t bitmapSize)\n{\n    return virBitmapParseSeparator(str, '\\0', bitmap, bitmapSize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapSetAll",
          "args": [
            "def->cpumask"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "895-906",
          "snippet": "void virBitmapSetAll(virBitmapPtr bitmap)\n{\n    int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n    memset(bitmap->map, 0xff,\n           bitmap->map_len * (VIR_BITMAP_BITS_PER_UNIT / CHAR_BIT));\n\n    /* Ensure tail bits are clear.  */\n    if (tail)\n        bitmap->map[bitmap->map_len - 1] &=\n            -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nvoid virBitmapSetAll(virBitmapPtr bitmap)\n{\n    int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n    memset(bitmap->map, 0xff,\n           bitmap->map_len * (VIR_BITMAP_BITS_PER_UNIT / CHAR_BIT));\n\n    /* Ensure tail bits are clear.  */\n    if (tail)\n        bitmap->map[bitmap->map_len - 1] &=\n            -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "hostcpus"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetStringParamVar",
          "args": [
            "PrlVmCfg_GetCpuMask",
            "sdkdom"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetStringParamVar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "299-320",
          "snippet": "static char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSetVcpus",
          "args": [
            "def",
            "cpuCount"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetVcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1889-1909",
          "snippet": "int\nvirDomainDefSetVcpus(virDomainDefPtr def,\n                     unsigned int vcpus)\n{\n    size_t i;\n\n    if (vcpus > def->maxvcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"maximum vCPU count must not be less than current \"\n                         \"vCPU count\"));\n        return -1;\n    }\n\n    for (i = 0; i < vcpus; i++)\n        def->vcpus[i]->online = true;\n\n    for (i = vcpus; i < def->maxvcpus; i++)\n        def->vcpus[i]->online = false;\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefSetVcpus(virDomainDefPtr def,\n                     unsigned int vcpus)\n{\n    size_t i;\n\n    if (vcpus > def->maxvcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"maximum vCPU count must not be less than current \"\n                         \"vCPU count\"));\n        return -1;\n    }\n\n    for (i = 0; i < vcpus; i++)\n        def->vcpus[i]->online = true;\n\n    for (i = vcpus; i < def->maxvcpus; i++)\n        def->vcpus[i]->online = false;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSetVcpusMax",
          "args": [
            "def",
            "cpuCount",
            "xmlopt"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetVcpusMax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1838-1865",
          "snippet": "int\nvirDomainDefSetVcpusMax(virDomainDefPtr def,\n                        unsigned int maxvcpus,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    size_t oldmax = def->maxvcpus;\n    size_t i;\n\n    if (def->maxvcpus == maxvcpus)\n        return 0;\n\n    if (def->maxvcpus < maxvcpus) {\n        if (VIR_EXPAND_N(def->vcpus, def->maxvcpus, maxvcpus - def->maxvcpus) < 0)\n            return -1;\n\n        for (i = oldmax; i < def->maxvcpus; i++) {\n            if (!(def->vcpus[i] = virDomainVcpuDefNew(xmlopt)))\n                return -1;\n        }\n    } else {\n        for (i = maxvcpus; i < def->maxvcpus; i++)\n            virDomainVcpuDefFree(def->vcpus[i]);\n\n        VIR_SHRINK_N(def->vcpus, def->maxvcpus, def->maxvcpus - maxvcpus);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefSetVcpusMax(virDomainDefPtr def,\n                        unsigned int maxvcpus,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    size_t oldmax = def->maxvcpus;\n    size_t i;\n\n    if (def->maxvcpus == maxvcpus)\n        return 0;\n\n    if (def->maxvcpus < maxvcpus) {\n        if (VIR_EXPAND_N(def->vcpus, def->maxvcpus, maxvcpus - def->maxvcpus) < 0)\n            return -1;\n\n        for (i = oldmax; i < def->maxvcpus; i++) {\n            if (!(def->vcpus[i] = virDomainVcpuDefNew(xmlopt)))\n                return -1;\n        }\n    } else {\n        for (i = maxvcpus; i < def->maxvcpus; i++)\n            virDomainVcpuDefFree(def->vcpus[i]);\n\n        VIR_SHRINK_N(def->vcpus, def->maxvcpus, def->maxvcpus - maxvcpus);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetCpuCount",
          "args": [
            "sdkdom",
            "&cpuCount"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostCPUGetCount",
          "args": [],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "1030-1042",
          "snippet": "int\nvirHostCPUGetCount(void)\n{\n#if defined(__linux__)\n    return virHostCPUParseCountLinux();\n#elif defined(__FreeBSD__) || defined(__APPLE__)\n    return virHostCPUGetCountAppleFreeBSD();\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"host cpu counting not implemented on this platform\"));\n    return -1;\n#endif\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUGetCount(void)\n{\n#if defined(__linux__)\n    return virHostCPUParseCountLinux();\n#elif defined(__FreeBSD__) || defined(__APPLE__)\n    return virHostCPUGetCountAppleFreeBSD();\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"host cpu counting not implemented on this platform\"));\n    return -1;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkConvertCpuInfo(PRL_HANDLE sdkdom,\n                     virDomainDefPtr def,\n                     virDomainXMLOptionPtr xmlopt)\n{\n    g_autofree char *buf = NULL;\n    int hostcpus;\n    PRL_UINT32 cpuCount;\n    PRL_RESULT pret;\n\n    if ((hostcpus = virHostCPUGetCount()) < 0)\n        return -1;\n\n    /* get number of CPUs */\n    pret = PrlVmCfg_GetCpuCount(sdkdom, &cpuCount);\n    prlsdkCheckRetExit(pret, -1);\n\n    if (cpuCount > hostcpus)\n        cpuCount = hostcpus;\n\n    if (virDomainDefSetVcpusMax(def, cpuCount, xmlopt) < 0)\n        return -1;\n\n    if (virDomainDefSetVcpus(def, cpuCount) < 0)\n        return -1;\n\n    if (!(buf = prlsdkGetStringParamVar(PrlVmCfg_GetCpuMask, sdkdom)))\n        return -1;\n\n    if (strlen(buf) == 0) {\n        if (!(def->cpumask = virBitmapNew(hostcpus)))\n            return -1;\n        virBitmapSetAll(def->cpumask);\n    } else {\n        if (virBitmapParse(buf, &def->cpumask, hostcpus) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkConvertDomainState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "1376-1452",
    "snippet": "static void\nprlsdkConvertDomainState(VIRTUAL_MACHINE_STATE domainState,\n                         PRL_UINT32 envId,\n                         virDomainObjPtr dom)\n{\n    switch (domainState) {\n    case VMS_STOPPED:\n    case VMS_MOUNTED:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n        dom->def->id = -1;\n        break;\n    case VMS_STARTING:\n    case VMS_COMPACTING:\n    case VMS_RESETTING:\n    case VMS_PAUSING:\n    case VMS_RECONNECTING:\n    case VMS_RUNNING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_BOOTED);\n        dom->def->id = envId;\n        break;\n    case VMS_PAUSED:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_USER);\n        dom->def->id = envId;\n        break;\n    case VMS_SUSPENDED:\n    case VMS_DELETING_STATE:\n    case VMS_SUSPENDING_SYNC:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_SAVED);\n        dom->def->id = -1;\n        break;\n    case VMS_STOPPING:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTDOWN,\n                             VIR_DOMAIN_SHUTDOWN_USER);\n        dom->def->id = envId;\n        break;\n    case VMS_SNAPSHOTING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_SNAPSHOT);\n        dom->def->id = envId;\n        break;\n    case VMS_MIGRATING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_MIGRATION);\n        dom->def->id = envId;\n        break;\n    case VMS_SUSPENDING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_SAVE);\n        dom->def->id = envId;\n        break;\n    case VMS_RESTORING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_RESTORED);\n        dom->def->id = envId;\n        break;\n    case VMS_CONTINUING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_UNPAUSED);\n        dom->def->id = envId;\n        break;\n    case VMS_RESUMING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_RESTORED);\n        dom->def->id = envId;\n        break;\n    case VMS_UNKNOWN:\n    default:\n        virDomainObjSetState(dom, VIR_DOMAIN_NOSTATE,\n                             VIR_DOMAIN_NOSTATE_UNKNOWN);\n        dom->def->id = -1;\n        break;\n    }\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "dom",
            "VIR_DOMAIN_NOSTATE",
            "VIR_DOMAIN_NOSTATE_UNKNOWN"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertDomainState(VIRTUAL_MACHINE_STATE domainState,\n                         PRL_UINT32 envId,\n                         virDomainObjPtr dom)\n{\n    switch (domainState) {\n    case VMS_STOPPED:\n    case VMS_MOUNTED:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n        dom->def->id = -1;\n        break;\n    case VMS_STARTING:\n    case VMS_COMPACTING:\n    case VMS_RESETTING:\n    case VMS_PAUSING:\n    case VMS_RECONNECTING:\n    case VMS_RUNNING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_BOOTED);\n        dom->def->id = envId;\n        break;\n    case VMS_PAUSED:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_USER);\n        dom->def->id = envId;\n        break;\n    case VMS_SUSPENDED:\n    case VMS_DELETING_STATE:\n    case VMS_SUSPENDING_SYNC:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_SAVED);\n        dom->def->id = -1;\n        break;\n    case VMS_STOPPING:\n        virDomainObjSetState(dom, VIR_DOMAIN_SHUTDOWN,\n                             VIR_DOMAIN_SHUTDOWN_USER);\n        dom->def->id = envId;\n        break;\n    case VMS_SNAPSHOTING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_SNAPSHOT);\n        dom->def->id = envId;\n        break;\n    case VMS_MIGRATING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_MIGRATION);\n        dom->def->id = envId;\n        break;\n    case VMS_SUSPENDING:\n        virDomainObjSetState(dom, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_SAVE);\n        dom->def->id = envId;\n        break;\n    case VMS_RESTORING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_RESTORED);\n        dom->def->id = envId;\n        break;\n    case VMS_CONTINUING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_UNPAUSED);\n        dom->def->id = envId;\n        break;\n    case VMS_RESUMING:\n        virDomainObjSetState(dom, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_RESTORED);\n        dom->def->id = envId;\n        break;\n    case VMS_UNKNOWN:\n    default:\n        virDomainObjSetState(dom, VIR_DOMAIN_NOSTATE,\n                             VIR_DOMAIN_NOSTATE_UNKNOWN);\n        dom->def->id = -1;\n        break;\n    }\n}"
  },
  {
    "function_name": "prlsdkAddVNCInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "1321-1374",
    "snippet": "static int\nprlsdkAddVNCInfo(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    virDomainGraphicsDefPtr gr = NULL;\n    PRL_VM_REMOTE_DISPLAY_MODE vncMode;\n    PRL_UINT32 port;\n    PRL_RESULT pret;\n    char *passwd = NULL;\n\n    pret = PrlVmCfg_GetVNCMode(sdkdom, &vncMode);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (vncMode == PRD_DISABLED)\n        return 0;\n\n    if (VIR_ALLOC(gr) < 0)\n        goto error;\n\n    if (!(passwd = prlsdkGetStringParamVar(PrlVmCfg_GetVNCPassword, sdkdom)))\n        goto error;\n\n    if (*passwd != '\\0') {\n        gr->data.vnc.auth.passwd = passwd;\n        passwd = NULL;\n    }\n\n    pret = PrlVmCfg_GetVNCPort(sdkdom, &port);\n    prlsdkCheckRetGoto(pret, error);\n\n    gr->data.vnc.autoport = (vncMode == PRD_AUTO);\n    gr->type = VIR_DOMAIN_GRAPHICS_TYPE_VNC;\n    gr->data.vnc.port = port;\n\n    if (VIR_ALLOC(gr->listens) < 0)\n        goto error;\n\n    gr->nListens = 1;\n\n    if (!(gr->listens[0].address = prlsdkGetStringParamVar(PrlVmCfg_GetVNCHostName,\n                                                           sdkdom)))\n        goto error;\n\n    gr->listens[0].type = VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS;\n\n    if (VIR_APPEND_ELEMENT(def->graphics, def->ngraphics, gr) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDomainGraphicsDefFree(gr);\n    VIR_FREE(passwd);\n    return -1;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "passwd"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsDefFree",
          "args": [
            "gr"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1719-1764",
          "snippet": "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    switch (def->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        VIR_FREE(def->data.vnc.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.vnc.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n        VIR_FREE(def->data.sdl.display);\n        VIR_FREE(def->data.sdl.xauth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n        VIR_FREE(def->data.desktop.display);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        VIR_FREE(def->data.spice.rendernode);\n        VIR_FREE(def->data.spice.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.spice.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        VIR_FREE(def->data.egl_headless.rendernode);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    for (i = 0; i < def->nListens; i++)\n        virDomainGraphicsListenDefClear(&def->listens[i]);\n    VIR_FREE(def->listens);\n\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    switch (def->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        VIR_FREE(def->data.vnc.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.vnc.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n        VIR_FREE(def->data.sdl.display);\n        VIR_FREE(def->data.sdl.xauth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n        VIR_FREE(def->data.desktop.display);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        VIR_FREE(def->data.spice.rendernode);\n        VIR_FREE(def->data.spice.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.spice.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        VIR_FREE(def->data.egl_headless.rendernode);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    for (i = 0; i < def->nListens; i++)\n        virDomainGraphicsListenDefClear(&def->listens[i]);\n    VIR_FREE(def->listens);\n\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->graphics",
            "def->ngraphics",
            "gr"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetStringParamVar",
          "args": [
            "PrlVmCfg_GetVNCHostName",
            "sdkdom"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetStringParamVar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "299-320",
          "snippet": "static char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "gr->listens"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetVNCPort",
          "args": [
            "sdkdom",
            "&port"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "gr"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetVNCMode",
          "args": [
            "sdkdom",
            "&vncMode"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkAddVNCInfo(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    virDomainGraphicsDefPtr gr = NULL;\n    PRL_VM_REMOTE_DISPLAY_MODE vncMode;\n    PRL_UINT32 port;\n    PRL_RESULT pret;\n    char *passwd = NULL;\n\n    pret = PrlVmCfg_GetVNCMode(sdkdom, &vncMode);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (vncMode == PRD_DISABLED)\n        return 0;\n\n    if (VIR_ALLOC(gr) < 0)\n        goto error;\n\n    if (!(passwd = prlsdkGetStringParamVar(PrlVmCfg_GetVNCPassword, sdkdom)))\n        goto error;\n\n    if (*passwd != '\\0') {\n        gr->data.vnc.auth.passwd = passwd;\n        passwd = NULL;\n    }\n\n    pret = PrlVmCfg_GetVNCPort(sdkdom, &port);\n    prlsdkCheckRetGoto(pret, error);\n\n    gr->data.vnc.autoport = (vncMode == PRD_AUTO);\n    gr->type = VIR_DOMAIN_GRAPHICS_TYPE_VNC;\n    gr->data.vnc.port = port;\n\n    if (VIR_ALLOC(gr->listens) < 0)\n        goto error;\n\n    gr->nListens = 1;\n\n    if (!(gr->listens[0].address = prlsdkGetStringParamVar(PrlVmCfg_GetVNCHostName,\n                                                           sdkdom)))\n        goto error;\n\n    gr->listens[0].type = VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS;\n\n    if (VIR_APPEND_ELEMENT(def->graphics, def->ngraphics, gr) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDomainGraphicsDefFree(gr);\n    VIR_FREE(passwd);\n    return -1;\n}"
  },
  {
    "function_name": "prlsdkAddDomainHardware",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "1289-1318",
    "snippet": "static int\nprlsdkAddDomainHardware(vzDriverPtr driver,\n                        PRL_HANDLE sdkdom,\n                        virDomainDefPtr def,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    if (IS_CT(def)) {\n        if (prlsdkAddDomainVideoInfoCt(def, xmlopt) < 0)\n            return -1;\n    } else {\n        if (prlsdkAddDomainVideoInfoVm(sdkdom, def) < 0)\n            return -1;\n    }\n\n    if (prlsdkAddDomainHardDisksInfo(driver, sdkdom, def) < 0)\n        return -1;\n\n    if (prlsdkAddDomainOpticalDisksInfo(driver, sdkdom, def) < 0)\n        return -1;\n\n    if (prlsdkAddDomainNetInfo(sdkdom, def) < 0)\n        return -1;\n\n    if (prlsdkAddSerialInfo(sdkdom,\n                            &def->serials,\n                            &def->nserials) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prlsdkAddSerialInfo",
          "args": [
            "sdkdom",
            "&def->serials",
            "&def->nserials"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkAddSerialInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1250-1286",
          "snippet": "static int\nprlsdkAddSerialInfo(PRL_HANDLE sdkdom,\n                    virDomainChrDefPtr **serials,\n                    size_t *nserials)\n{\n    PRL_RESULT ret;\n    PRL_HANDLE serialPort;\n    PRL_UINT32 serialPortsCount;\n    PRL_UINT32 i;\n    virDomainChrDefPtr chr = NULL;\n\n    ret = PrlVmCfg_GetSerialPortsCount(sdkdom, &serialPortsCount);\n    prlsdkCheckRetGoto(ret, cleanup);\n    for (i = 0; i < serialPortsCount; ++i) {\n        ret = PrlVmCfg_GetSerialPort(sdkdom, i, &serialPort);\n        prlsdkCheckRetGoto(ret, cleanup);\n\n        if (!(chr = virDomainChrDefNew(NULL)))\n            goto cleanup;\n\n        if (prlsdkGetSerialInfo(serialPort, chr))\n            goto cleanup;\n\n        PrlHandle_Free(serialPort);\n        serialPort = PRL_INVALID_HANDLE;\n\n        if (VIR_APPEND_ELEMENT(*serials, *nserials, chr) < 0)\n            goto cleanup;\n    }\n\n    return 0;\n\n cleanup:\n    PrlHandle_Free(serialPort);\n    virDomainChrDefFree(chr);\n    return -1;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkAddSerialInfo(PRL_HANDLE sdkdom,\n                    virDomainChrDefPtr **serials,\n                    size_t *nserials)\n{\n    PRL_RESULT ret;\n    PRL_HANDLE serialPort;\n    PRL_UINT32 serialPortsCount;\n    PRL_UINT32 i;\n    virDomainChrDefPtr chr = NULL;\n\n    ret = PrlVmCfg_GetSerialPortsCount(sdkdom, &serialPortsCount);\n    prlsdkCheckRetGoto(ret, cleanup);\n    for (i = 0; i < serialPortsCount; ++i) {\n        ret = PrlVmCfg_GetSerialPort(sdkdom, i, &serialPort);\n        prlsdkCheckRetGoto(ret, cleanup);\n\n        if (!(chr = virDomainChrDefNew(NULL)))\n            goto cleanup;\n\n        if (prlsdkGetSerialInfo(serialPort, chr))\n            goto cleanup;\n\n        PrlHandle_Free(serialPort);\n        serialPort = PRL_INVALID_HANDLE;\n\n        if (VIR_APPEND_ELEMENT(*serials, *nserials, chr) < 0)\n            goto cleanup;\n    }\n\n    return 0;\n\n cleanup:\n    PrlHandle_Free(serialPort);\n    virDomainChrDefFree(chr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkAddDomainNetInfo",
          "args": [
            "sdkdom",
            "def"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkAddDomainNetInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1133-1167",
          "snippet": "static int\nprlsdkAddDomainNetInfo(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    virDomainNetDefPtr net = NULL;\n    PRL_RESULT ret;\n    PRL_HANDLE netAdapter;\n    PRL_UINT32 netAdaptersCount;\n    PRL_UINT32 i;\n\n    ret = PrlVmCfg_GetNetAdaptersCount(sdkdom, &netAdaptersCount);\n    prlsdkCheckRetGoto(ret, error);\n    for (i = 0; i < netAdaptersCount; ++i) {\n        ret = PrlVmCfg_GetNetAdapter(sdkdom, i, &netAdapter);\n        prlsdkCheckRetGoto(ret, error);\n\n        if (VIR_ALLOC(net) < 0)\n            goto error;\n\n        if (prlsdkGetNetInfo(netAdapter, net, IS_CT(def)) < 0)\n            goto error;\n\n        PrlHandle_Free(netAdapter);\n        netAdapter = PRL_INVALID_HANDLE;\n\n        if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    PrlHandle_Free(netAdapter);\n    virDomainNetDefFree(net);\n    return -1;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkAddDomainNetInfo(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    virDomainNetDefPtr net = NULL;\n    PRL_RESULT ret;\n    PRL_HANDLE netAdapter;\n    PRL_UINT32 netAdaptersCount;\n    PRL_UINT32 i;\n\n    ret = PrlVmCfg_GetNetAdaptersCount(sdkdom, &netAdaptersCount);\n    prlsdkCheckRetGoto(ret, error);\n    for (i = 0; i < netAdaptersCount; ++i) {\n        ret = PrlVmCfg_GetNetAdapter(sdkdom, i, &netAdapter);\n        prlsdkCheckRetGoto(ret, error);\n\n        if (VIR_ALLOC(net) < 0)\n            goto error;\n\n        if (prlsdkGetNetInfo(netAdapter, net, IS_CT(def)) < 0)\n            goto error;\n\n        PrlHandle_Free(netAdapter);\n        netAdapter = PRL_INVALID_HANDLE;\n\n        if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    PrlHandle_Free(netAdapter);\n    virDomainNetDefFree(net);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkAddDomainOpticalDisksInfo",
          "args": [
            "driver",
            "sdkdom",
            "def"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkAddDomainOpticalDisksInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "866-901",
          "snippet": "static int\nprlsdkAddDomainOpticalDisksInfo(vzDriverPtr driver, PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 cdromsCount;\n    PRL_UINT32 i;\n    PRL_HANDLE cdrom = PRL_INVALID_HANDLE;\n    virDomainDiskDefPtr disk = NULL;\n\n    pret = PrlVmCfg_GetOpticalDisksCount(sdkdom, &cdromsCount);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < cdromsCount; ++i) {\n        pret = PrlVmCfg_GetOpticalDisk(sdkdom, i, &cdrom);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (!(disk = virDomainDiskDefNew(NULL)))\n            goto error;\n\n        if (prlsdkGetDiskInfo(driver, cdrom, disk, true, IS_CT(def)) < 0)\n            goto error;\n\n        PrlHandle_Free(cdrom);\n        cdrom = PRL_INVALID_HANDLE;\n\n        if (virDomainDiskInsert(def, disk) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    PrlHandle_Free(cdrom);\n    virDomainDiskDefFree(disk);\n    return -1;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int\nprlsdkAddDomainOpticalDisksInfo(vzDriverPtr driver, PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 cdromsCount;\n    PRL_UINT32 i;\n    PRL_HANDLE cdrom = PRL_INVALID_HANDLE;\n    virDomainDiskDefPtr disk = NULL;\n\n    pret = PrlVmCfg_GetOpticalDisksCount(sdkdom, &cdromsCount);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < cdromsCount; ++i) {\n        pret = PrlVmCfg_GetOpticalDisk(sdkdom, i, &cdrom);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (!(disk = virDomainDiskDefNew(NULL)))\n            goto error;\n\n        if (prlsdkGetDiskInfo(driver, cdrom, disk, true, IS_CT(def)) < 0)\n            goto error;\n\n        PrlHandle_Free(cdrom);\n        cdrom = PRL_INVALID_HANDLE;\n\n        if (virDomainDiskInsert(def, disk) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    PrlHandle_Free(cdrom);\n    virDomainDiskDefFree(disk);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkAddDomainHardDisksInfo",
          "args": [
            "driver",
            "sdkdom",
            "def"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkAddDomainHardDisksInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "803-864",
          "snippet": "static int\nprlsdkAddDomainHardDisksInfo(vzDriverPtr driver, PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 hddCount;\n    PRL_UINT32 i;\n    PRL_HANDLE hdd = PRL_INVALID_HANDLE;\n    virDomainDiskDefPtr disk = NULL;\n    virDomainFSDefPtr fs = NULL;\n\n    pret = PrlVmCfg_GetHardDisksCount(sdkdom, &hddCount);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < hddCount; ++i) {\n\n        PRL_UINT32 emulatedType;\n\n        pret = PrlVmCfg_GetHardDisk(sdkdom, i, &hdd);\n        prlsdkCheckRetGoto(pret, error);\n\n        pret = PrlVmDev_GetEmulatedType(hdd, &emulatedType);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (IS_CT(def) &&\n            prlsdkInBootList(sdkdom, hdd)) {\n\n            if (!(fs = virDomainFSDefNew(NULL)))\n                goto error;\n\n            if (prlsdkGetFSInfo(hdd, fs) < 0)\n                goto error;\n\n            if (virDomainFSInsert(def, fs) < 0)\n                goto error;\n\n            fs = NULL;\n            PrlHandle_Free(hdd);\n            hdd = PRL_INVALID_HANDLE;\n        } else {\n            if (!(disk = virDomainDiskDefNew(NULL)))\n                goto error;\n\n            if (prlsdkGetDiskInfo(driver, hdd, disk, false, IS_CT(def)) < 0)\n                goto error;\n\n            if (virDomainDiskInsert(def, disk) < 0)\n                goto error;\n\n            disk = NULL;\n            PrlHandle_Free(hdd);\n            hdd = PRL_INVALID_HANDLE;\n        }\n    }\n\n    return 0;\n\n error:\n    PrlHandle_Free(hdd);\n    virDomainDiskDefFree(disk);\n    virDomainFSDefFree(fs);\n    return -1;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int\nprlsdkAddDomainHardDisksInfo(vzDriverPtr driver, PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 hddCount;\n    PRL_UINT32 i;\n    PRL_HANDLE hdd = PRL_INVALID_HANDLE;\n    virDomainDiskDefPtr disk = NULL;\n    virDomainFSDefPtr fs = NULL;\n\n    pret = PrlVmCfg_GetHardDisksCount(sdkdom, &hddCount);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < hddCount; ++i) {\n\n        PRL_UINT32 emulatedType;\n\n        pret = PrlVmCfg_GetHardDisk(sdkdom, i, &hdd);\n        prlsdkCheckRetGoto(pret, error);\n\n        pret = PrlVmDev_GetEmulatedType(hdd, &emulatedType);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (IS_CT(def) &&\n            prlsdkInBootList(sdkdom, hdd)) {\n\n            if (!(fs = virDomainFSDefNew(NULL)))\n                goto error;\n\n            if (prlsdkGetFSInfo(hdd, fs) < 0)\n                goto error;\n\n            if (virDomainFSInsert(def, fs) < 0)\n                goto error;\n\n            fs = NULL;\n            PrlHandle_Free(hdd);\n            hdd = PRL_INVALID_HANDLE;\n        } else {\n            if (!(disk = virDomainDiskDefNew(NULL)))\n                goto error;\n\n            if (prlsdkGetDiskInfo(driver, hdd, disk, false, IS_CT(def)) < 0)\n                goto error;\n\n            if (virDomainDiskInsert(def, disk) < 0)\n                goto error;\n\n            disk = NULL;\n            PrlHandle_Free(hdd);\n            hdd = PRL_INVALID_HANDLE;\n        }\n    }\n\n    return 0;\n\n error:\n    PrlHandle_Free(hdd);\n    virDomainDiskDefFree(disk);\n    virDomainFSDefFree(fs);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkAddDomainVideoInfoVm",
          "args": [
            "sdkdom",
            "def"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkAddDomainVideoInfoVm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "573-605",
          "snippet": "static int\nprlsdkAddDomainVideoInfoVm(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    virDomainVideoDefPtr video = NULL;\n    virDomainVideoAccelDefPtr accel = NULL;\n    PRL_RESULT ret;\n    PRL_UINT32 videoRam;\n\n    /* video info */\n    ret = PrlVmCfg_GetVideoRamSize(sdkdom, &videoRam);\n    prlsdkCheckRetGoto(ret, error);\n\n    if (VIR_ALLOC(video) < 0)\n        goto error;\n\n    if (VIR_ALLOC(accel) < 0)\n        goto error;\n\n    if (VIR_APPEND_ELEMENT_COPY(def->videos, def->nvideos, video) < 0)\n        goto error;\n\n    video->type = VIR_DOMAIN_VIDEO_TYPE_VGA;\n    video->vram = videoRam << 10; /* from mbibytes to kbibytes */\n    video->heads = 1;\n    video->accel = accel;\n\n    return 0;\n\n error:\n    VIR_FREE(accel);\n    virDomainVideoDefFree(video);\n    return -1;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkAddDomainVideoInfoVm(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    virDomainVideoDefPtr video = NULL;\n    virDomainVideoAccelDefPtr accel = NULL;\n    PRL_RESULT ret;\n    PRL_UINT32 videoRam;\n\n    /* video info */\n    ret = PrlVmCfg_GetVideoRamSize(sdkdom, &videoRam);\n    prlsdkCheckRetGoto(ret, error);\n\n    if (VIR_ALLOC(video) < 0)\n        goto error;\n\n    if (VIR_ALLOC(accel) < 0)\n        goto error;\n\n    if (VIR_APPEND_ELEMENT_COPY(def->videos, def->nvideos, video) < 0)\n        goto error;\n\n    video->type = VIR_DOMAIN_VIDEO_TYPE_VGA;\n    video->vram = videoRam << 10; /* from mbibytes to kbibytes */\n    video->heads = 1;\n    video->accel = accel;\n\n    return 0;\n\n error:\n    VIR_FREE(accel);\n    virDomainVideoDefFree(video);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkAddDomainVideoInfoCt",
          "args": [
            "def",
            "xmlopt"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkAddDomainVideoInfoCt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "547-571",
          "snippet": "static int\nprlsdkAddDomainVideoInfoCt(virDomainDefPtr def,\n                           virDomainXMLOptionPtr xmlopt)\n{\n    virDomainVideoDefPtr video = NULL;\n    int ret = -1;\n\n    if (def->ngraphics == 0)\n        return 0;\n\n    if (!(video = virDomainVideoDefNew(xmlopt)))\n        goto cleanup;\n\n    video->type = VIR_DOMAIN_VIDEO_TYPE_PARALLELS;\n    video->vram = 0;\n\n    if (VIR_APPEND_ELEMENT(def->videos, def->nvideos, video) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virDomainVideoDefFree(video);\n\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkAddDomainVideoInfoCt(virDomainDefPtr def,\n                           virDomainXMLOptionPtr xmlopt)\n{\n    virDomainVideoDefPtr video = NULL;\n    int ret = -1;\n\n    if (def->ngraphics == 0)\n        return 0;\n\n    if (!(video = virDomainVideoDefNew(xmlopt)))\n        goto cleanup;\n\n    video->type = VIR_DOMAIN_VIDEO_TYPE_PARALLELS;\n    video->vram = 0;\n\n    if (VIR_APPEND_ELEMENT(def->videos, def->nvideos, video) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virDomainVideoDefFree(video);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "def"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkAddDomainHardware(vzDriverPtr driver,\n                        PRL_HANDLE sdkdom,\n                        virDomainDefPtr def,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    if (IS_CT(def)) {\n        if (prlsdkAddDomainVideoInfoCt(def, xmlopt) < 0)\n            return -1;\n    } else {\n        if (prlsdkAddDomainVideoInfoVm(sdkdom, def) < 0)\n            return -1;\n    }\n\n    if (prlsdkAddDomainHardDisksInfo(driver, sdkdom, def) < 0)\n        return -1;\n\n    if (prlsdkAddDomainOpticalDisksInfo(driver, sdkdom, def) < 0)\n        return -1;\n\n    if (prlsdkAddDomainNetInfo(sdkdom, def) < 0)\n        return -1;\n\n    if (prlsdkAddSerialInfo(sdkdom,\n                            &def->serials,\n                            &def->nserials) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkAddSerialInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "1250-1286",
    "snippet": "static int\nprlsdkAddSerialInfo(PRL_HANDLE sdkdom,\n                    virDomainChrDefPtr **serials,\n                    size_t *nserials)\n{\n    PRL_RESULT ret;\n    PRL_HANDLE serialPort;\n    PRL_UINT32 serialPortsCount;\n    PRL_UINT32 i;\n    virDomainChrDefPtr chr = NULL;\n\n    ret = PrlVmCfg_GetSerialPortsCount(sdkdom, &serialPortsCount);\n    prlsdkCheckRetGoto(ret, cleanup);\n    for (i = 0; i < serialPortsCount; ++i) {\n        ret = PrlVmCfg_GetSerialPort(sdkdom, i, &serialPort);\n        prlsdkCheckRetGoto(ret, cleanup);\n\n        if (!(chr = virDomainChrDefNew(NULL)))\n            goto cleanup;\n\n        if (prlsdkGetSerialInfo(serialPort, chr))\n            goto cleanup;\n\n        PrlHandle_Free(serialPort);\n        serialPort = PRL_INVALID_HANDLE;\n\n        if (VIR_APPEND_ELEMENT(*serials, *nserials, chr) < 0)\n            goto cleanup;\n    }\n\n    return 0;\n\n cleanup:\n    PrlHandle_Free(serialPort);\n    virDomainChrDefFree(chr);\n    return -1;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainChrDefFree",
          "args": [
            "chr"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2706-2733",
          "snippet": "void virDomainChrDefFree(virDomainChrDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch (def->deviceType) {\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL:\n        switch (def->targetType) {\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_GUESTFWD:\n            VIR_FREE(def->target.addr);\n            break;\n\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN:\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO:\n            VIR_FREE(def->target.name);\n            break;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    virObjectUnref(def->source);\n    virDomainDeviceInfoClear(&def->info);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainChrDefFree(virDomainChrDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch (def->deviceType) {\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL:\n        switch (def->targetType) {\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_GUESTFWD:\n            VIR_FREE(def->target.addr);\n            break;\n\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN:\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO:\n            VIR_FREE(def->target.name);\n            break;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    virObjectUnref(def->source);\n    virDomainDeviceInfoClear(&def->info);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "serialPort"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "*serials",
            "*nserials",
            "chr"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "serialPort"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetSerialInfo",
          "args": [
            "serialPort",
            "chr"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetSerialInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1169-1247",
          "snippet": "static int\nprlsdkGetSerialInfo(PRL_HANDLE serialPort, virDomainChrDefPtr chr)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 serialPortIndex;\n    PRL_UINT32 emulatedType;\n    char *friendlyName = NULL;\n    PRL_SERIAL_PORT_SOCKET_OPERATION_MODE socket_mode;\n    char *uristr = NULL;\n    virURIPtr uri = NULL;\n    int ret = -1;\n\n    chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n    pret = PrlVmDev_GetIndex(serialPort, &serialPortIndex);\n    prlsdkCheckRetGoto(pret, cleanup);\n    chr->target.port = serialPortIndex;\n\n    pret = PrlVmDev_GetEmulatedType(serialPort, &emulatedType);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (!(friendlyName = prlsdkGetStringParamVar(PrlVmDev_GetFriendlyName,\n                                                 serialPort)))\n        goto cleanup;\n\n    pret = PrlVmDevSerial_GetSocketMode(serialPort, &socket_mode);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    switch (emulatedType) {\n    case PDT_USE_OUTPUT_FILE:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n        chr->source->data.file.path = friendlyName;\n        friendlyName = NULL;\n        break;\n    case PDT_USE_SERIAL_PORT_SOCKET_MODE:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_UNIX;\n        chr->source->data.nix.path = friendlyName;\n        chr->source->data.nix.listen = socket_mode == PSP_SERIAL_SOCKET_SERVER;\n        friendlyName = NULL;\n        break;\n    case PDT_USE_REAL_DEVICE:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n        chr->source->data.file.path = friendlyName;\n        friendlyName = NULL;\n        break;\n    case PDT_USE_TCP:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_TCP;\n        uristr = g_strdup_printf(\"tcp://%s\", friendlyName);\n        if (!(uri = virURIParse(uristr)))\n            goto cleanup;\n        chr->source->data.tcp.host = g_strdup(uri->server);\n        chr->source->data.tcp.service = g_strdup_printf(\"%d\", uri->port);\n        chr->source->data.tcp.listen = socket_mode == PSP_SERIAL_SOCKET_SERVER;\n        break;\n    case PDT_USE_UDP:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_UDP;\n        uristr = g_strdup_printf(\"udp://%s\", friendlyName);\n        if (!(uri = virURIParse(uristr)))\n            goto cleanup;\n        chr->source->data.udp.bindHost = g_strdup(uri->server);\n        chr->source->data.udp.bindService = g_strdup_printf(\"%d\", uri->port);\n        chr->source->data.udp.connectHost = g_strdup(uri->server);\n        chr->source->data.udp.connectService = g_strdup_printf(\"%d\", uri->port);\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown serial type: %X\"), emulatedType);\n        goto cleanup;\n        break;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(friendlyName);\n    VIR_FREE(uristr);\n    virURIFree(uri);\n\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkGetSerialInfo(PRL_HANDLE serialPort, virDomainChrDefPtr chr)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 serialPortIndex;\n    PRL_UINT32 emulatedType;\n    char *friendlyName = NULL;\n    PRL_SERIAL_PORT_SOCKET_OPERATION_MODE socket_mode;\n    char *uristr = NULL;\n    virURIPtr uri = NULL;\n    int ret = -1;\n\n    chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n    pret = PrlVmDev_GetIndex(serialPort, &serialPortIndex);\n    prlsdkCheckRetGoto(pret, cleanup);\n    chr->target.port = serialPortIndex;\n\n    pret = PrlVmDev_GetEmulatedType(serialPort, &emulatedType);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (!(friendlyName = prlsdkGetStringParamVar(PrlVmDev_GetFriendlyName,\n                                                 serialPort)))\n        goto cleanup;\n\n    pret = PrlVmDevSerial_GetSocketMode(serialPort, &socket_mode);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    switch (emulatedType) {\n    case PDT_USE_OUTPUT_FILE:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n        chr->source->data.file.path = friendlyName;\n        friendlyName = NULL;\n        break;\n    case PDT_USE_SERIAL_PORT_SOCKET_MODE:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_UNIX;\n        chr->source->data.nix.path = friendlyName;\n        chr->source->data.nix.listen = socket_mode == PSP_SERIAL_SOCKET_SERVER;\n        friendlyName = NULL;\n        break;\n    case PDT_USE_REAL_DEVICE:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n        chr->source->data.file.path = friendlyName;\n        friendlyName = NULL;\n        break;\n    case PDT_USE_TCP:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_TCP;\n        uristr = g_strdup_printf(\"tcp://%s\", friendlyName);\n        if (!(uri = virURIParse(uristr)))\n            goto cleanup;\n        chr->source->data.tcp.host = g_strdup(uri->server);\n        chr->source->data.tcp.service = g_strdup_printf(\"%d\", uri->port);\n        chr->source->data.tcp.listen = socket_mode == PSP_SERIAL_SOCKET_SERVER;\n        break;\n    case PDT_USE_UDP:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_UDP;\n        uristr = g_strdup_printf(\"udp://%s\", friendlyName);\n        if (!(uri = virURIParse(uristr)))\n            goto cleanup;\n        chr->source->data.udp.bindHost = g_strdup(uri->server);\n        chr->source->data.udp.bindService = g_strdup_printf(\"%d\", uri->port);\n        chr->source->data.udp.connectHost = g_strdup(uri->server);\n        chr->source->data.udp.connectService = g_strdup_printf(\"%d\", uri->port);\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown serial type: %X\"), emulatedType);\n        goto cleanup;\n        break;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(friendlyName);\n    VIR_FREE(uristr);\n    virURIFree(uri);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainChrDefNew",
          "args": [
            "NULL"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "13232-13246",
          "snippet": "virDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "ret",
            "cleanup"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetSerialPort",
          "args": [
            "sdkdom",
            "i",
            "&serialPort"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "ret",
            "cleanup"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetSerialPortsCount",
          "args": [
            "sdkdom",
            "&serialPortsCount"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkAddSerialInfo(PRL_HANDLE sdkdom,\n                    virDomainChrDefPtr **serials,\n                    size_t *nserials)\n{\n    PRL_RESULT ret;\n    PRL_HANDLE serialPort;\n    PRL_UINT32 serialPortsCount;\n    PRL_UINT32 i;\n    virDomainChrDefPtr chr = NULL;\n\n    ret = PrlVmCfg_GetSerialPortsCount(sdkdom, &serialPortsCount);\n    prlsdkCheckRetGoto(ret, cleanup);\n    for (i = 0; i < serialPortsCount; ++i) {\n        ret = PrlVmCfg_GetSerialPort(sdkdom, i, &serialPort);\n        prlsdkCheckRetGoto(ret, cleanup);\n\n        if (!(chr = virDomainChrDefNew(NULL)))\n            goto cleanup;\n\n        if (prlsdkGetSerialInfo(serialPort, chr))\n            goto cleanup;\n\n        PrlHandle_Free(serialPort);\n        serialPort = PRL_INVALID_HANDLE;\n\n        if (VIR_APPEND_ELEMENT(*serials, *nserials, chr) < 0)\n            goto cleanup;\n    }\n\n    return 0;\n\n cleanup:\n    PrlHandle_Free(serialPort);\n    virDomainChrDefFree(chr);\n    return -1;\n}"
  },
  {
    "function_name": "prlsdkGetSerialInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "1169-1247",
    "snippet": "static int\nprlsdkGetSerialInfo(PRL_HANDLE serialPort, virDomainChrDefPtr chr)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 serialPortIndex;\n    PRL_UINT32 emulatedType;\n    char *friendlyName = NULL;\n    PRL_SERIAL_PORT_SOCKET_OPERATION_MODE socket_mode;\n    char *uristr = NULL;\n    virURIPtr uri = NULL;\n    int ret = -1;\n\n    chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n    pret = PrlVmDev_GetIndex(serialPort, &serialPortIndex);\n    prlsdkCheckRetGoto(pret, cleanup);\n    chr->target.port = serialPortIndex;\n\n    pret = PrlVmDev_GetEmulatedType(serialPort, &emulatedType);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (!(friendlyName = prlsdkGetStringParamVar(PrlVmDev_GetFriendlyName,\n                                                 serialPort)))\n        goto cleanup;\n\n    pret = PrlVmDevSerial_GetSocketMode(serialPort, &socket_mode);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    switch (emulatedType) {\n    case PDT_USE_OUTPUT_FILE:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n        chr->source->data.file.path = friendlyName;\n        friendlyName = NULL;\n        break;\n    case PDT_USE_SERIAL_PORT_SOCKET_MODE:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_UNIX;\n        chr->source->data.nix.path = friendlyName;\n        chr->source->data.nix.listen = socket_mode == PSP_SERIAL_SOCKET_SERVER;\n        friendlyName = NULL;\n        break;\n    case PDT_USE_REAL_DEVICE:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n        chr->source->data.file.path = friendlyName;\n        friendlyName = NULL;\n        break;\n    case PDT_USE_TCP:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_TCP;\n        uristr = g_strdup_printf(\"tcp://%s\", friendlyName);\n        if (!(uri = virURIParse(uristr)))\n            goto cleanup;\n        chr->source->data.tcp.host = g_strdup(uri->server);\n        chr->source->data.tcp.service = g_strdup_printf(\"%d\", uri->port);\n        chr->source->data.tcp.listen = socket_mode == PSP_SERIAL_SOCKET_SERVER;\n        break;\n    case PDT_USE_UDP:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_UDP;\n        uristr = g_strdup_printf(\"udp://%s\", friendlyName);\n        if (!(uri = virURIParse(uristr)))\n            goto cleanup;\n        chr->source->data.udp.bindHost = g_strdup(uri->server);\n        chr->source->data.udp.bindService = g_strdup_printf(\"%d\", uri->port);\n        chr->source->data.udp.connectHost = g_strdup(uri->server);\n        chr->source->data.udp.connectService = g_strdup_printf(\"%d\", uri->port);\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown serial type: %X\"), emulatedType);\n        goto cleanup;\n        break;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(friendlyName);\n    VIR_FREE(uristr);\n    virURIFree(uri);\n\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virURIFree",
          "args": [
            "uri"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "virURIFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "277-298",
          "snippet": "void virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvoid virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uristr"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "friendlyName"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown serial type: %X\")",
            "emulatedType"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown serial type: %X\""
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virURIParse",
          "args": [
            "uristr"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "virURIParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "143-194",
          "snippet": "virURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvirURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevSerial_GetSocketMode",
          "args": [
            "serialPort",
            "&socket_mode"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetStringParamVar",
          "args": [
            "PrlVmDev_GetFriendlyName",
            "serialPort"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetStringParamVar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "299-320",
          "snippet": "static char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_GetEmulatedType",
          "args": [
            "serialPort",
            "&emulatedType"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_GetIndex",
          "args": [
            "serialPort",
            "&serialPortIndex"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkGetSerialInfo(PRL_HANDLE serialPort, virDomainChrDefPtr chr)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 serialPortIndex;\n    PRL_UINT32 emulatedType;\n    char *friendlyName = NULL;\n    PRL_SERIAL_PORT_SOCKET_OPERATION_MODE socket_mode;\n    char *uristr = NULL;\n    virURIPtr uri = NULL;\n    int ret = -1;\n\n    chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n    pret = PrlVmDev_GetIndex(serialPort, &serialPortIndex);\n    prlsdkCheckRetGoto(pret, cleanup);\n    chr->target.port = serialPortIndex;\n\n    pret = PrlVmDev_GetEmulatedType(serialPort, &emulatedType);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    if (!(friendlyName = prlsdkGetStringParamVar(PrlVmDev_GetFriendlyName,\n                                                 serialPort)))\n        goto cleanup;\n\n    pret = PrlVmDevSerial_GetSocketMode(serialPort, &socket_mode);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    switch (emulatedType) {\n    case PDT_USE_OUTPUT_FILE:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n        chr->source->data.file.path = friendlyName;\n        friendlyName = NULL;\n        break;\n    case PDT_USE_SERIAL_PORT_SOCKET_MODE:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_UNIX;\n        chr->source->data.nix.path = friendlyName;\n        chr->source->data.nix.listen = socket_mode == PSP_SERIAL_SOCKET_SERVER;\n        friendlyName = NULL;\n        break;\n    case PDT_USE_REAL_DEVICE:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n        chr->source->data.file.path = friendlyName;\n        friendlyName = NULL;\n        break;\n    case PDT_USE_TCP:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_TCP;\n        uristr = g_strdup_printf(\"tcp://%s\", friendlyName);\n        if (!(uri = virURIParse(uristr)))\n            goto cleanup;\n        chr->source->data.tcp.host = g_strdup(uri->server);\n        chr->source->data.tcp.service = g_strdup_printf(\"%d\", uri->port);\n        chr->source->data.tcp.listen = socket_mode == PSP_SERIAL_SOCKET_SERVER;\n        break;\n    case PDT_USE_UDP:\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_UDP;\n        uristr = g_strdup_printf(\"udp://%s\", friendlyName);\n        if (!(uri = virURIParse(uristr)))\n            goto cleanup;\n        chr->source->data.udp.bindHost = g_strdup(uri->server);\n        chr->source->data.udp.bindService = g_strdup_printf(\"%d\", uri->port);\n        chr->source->data.udp.connectHost = g_strdup(uri->server);\n        chr->source->data.udp.connectService = g_strdup_printf(\"%d\", uri->port);\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown serial type: %X\"), emulatedType);\n        goto cleanup;\n        break;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(friendlyName);\n    VIR_FREE(uristr);\n    virURIFree(uri);\n\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkAddDomainNetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "1133-1167",
    "snippet": "static int\nprlsdkAddDomainNetInfo(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    virDomainNetDefPtr net = NULL;\n    PRL_RESULT ret;\n    PRL_HANDLE netAdapter;\n    PRL_UINT32 netAdaptersCount;\n    PRL_UINT32 i;\n\n    ret = PrlVmCfg_GetNetAdaptersCount(sdkdom, &netAdaptersCount);\n    prlsdkCheckRetGoto(ret, error);\n    for (i = 0; i < netAdaptersCount; ++i) {\n        ret = PrlVmCfg_GetNetAdapter(sdkdom, i, &netAdapter);\n        prlsdkCheckRetGoto(ret, error);\n\n        if (VIR_ALLOC(net) < 0)\n            goto error;\n\n        if (prlsdkGetNetInfo(netAdapter, net, IS_CT(def)) < 0)\n            goto error;\n\n        PrlHandle_Free(netAdapter);\n        netAdapter = PRL_INVALID_HANDLE;\n\n        if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    PrlHandle_Free(netAdapter);\n    virDomainNetDefFree(net);\n    return -1;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainNetDefFree",
          "args": [
            "net"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2481-2489",
          "snippet": "void\nvirDomainNetDefFree(virDomainNetDefPtr def)\n{\n    if (!def)\n        return;\n    virDomainNetDefClear(def);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainNetDefFree(virDomainNetDefPtr def)\n{\n    if (!def)\n        return;\n    virDomainNetDefClear(def);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "netAdapter"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->nets",
            "def->nnets",
            "net"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "netAdapter"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetNetInfo",
          "args": [
            "netAdapter",
            "net",
            "IS_CT(def)"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetNetInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1032-1131",
          "snippet": "static int\nprlsdkGetNetInfo(PRL_HANDLE netAdapter, virDomainNetDefPtr net, bool isCt)\n{\n    char macstr[VIR_MAC_STRING_BUFLEN];\n    PRL_UINT32 netAdapterIndex;\n    PRL_UINT32 emulatedType;\n    PRL_RESULT pret;\n    PRL_BOOL isConnected, isMacFilter;\n\n    /* use device name, shown by prlctl as target device\n     * for identifying network adapter in virDomainDefineXML */\n    if (!(net->ifname = prlsdkGetStringParamVar(PrlVmDevNet_GetHostInterfaceName,\n                                                netAdapter)))\n        return -1;\n\n    pret = PrlVmDev_GetIndex(netAdapter, &netAdapterIndex);\n    prlsdkCheckRetExit(pret, -1);\n\n    if (isCt && netAdapterIndex == (PRL_UINT32) -1) {\n        /* venet devices don't have mac address and\n         * always up */\n        net->linkstate = VIR_DOMAIN_NET_INTERFACE_LINK_STATE_UP;\n        net->type = VIR_DOMAIN_NET_TYPE_NETWORK;\n        net->data.network.name = g_strdup(PARALLELS_DOMAIN_ROUTED_NETWORK_NAME);\n        return 0;\n    }\n\n    pret = prlsdkGetStringParamBuf(PrlVmDevNet_GetMacAddressCanonical,\n                                   netAdapter, macstr, sizeof(macstr));\n    prlsdkCheckRetExit(pret, -1);\n\n    if (virMacAddrParse(macstr, &net->mac) < 0)\n        return -1;\n\n    if (prlsdkGetNetAddresses(netAdapter, net) < 0)\n        return -1;\n\n    if (prlsdkGetRoutes(netAdapter, net) < 0)\n        return -1;\n\n    pret = PrlVmDev_GetEmulatedType(netAdapter, &emulatedType);\n    prlsdkCheckRetExit(pret, -1);\n\n    if (emulatedType == PNA_ROUTED) {\n        net->type = VIR_DOMAIN_NET_TYPE_NETWORK;\n        net->data.network.name = g_strdup(PARALLELS_DOMAIN_ROUTED_NETWORK_NAME);\n    } else {\n        char *netid =\n              prlsdkGetStringParamVar(PrlVmDevNet_GetVirtualNetworkId,\n                                      netAdapter);\n\n        if (emulatedType == PNA_BRIDGE) {\n            net->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n            if (netid)\n                net->data.bridge.brname = netid;\n        } else {\n            net->type = VIR_DOMAIN_NET_TYPE_NETWORK;\n            if (netid)\n                net->data.network.name = netid;\n        }\n    }\n\n    if (!isCt) {\n        PRL_VM_NET_ADAPTER_TYPE type;\n        pret = PrlVmDevNet_GetAdapterType(netAdapter, &type);\n        prlsdkCheckRetExit(pret, -1);\n\n        switch ((int)type) {\n        case PNT_RTL:\n            net->model = VIR_DOMAIN_NET_MODEL_RTL8139;\n            break;\n        case PNT_E1000:\n            net->model = VIR_DOMAIN_NET_MODEL_E1000;\n            break;\n        case PNT_VIRTIO:\n            net->model = VIR_DOMAIN_NET_MODEL_VIRTIO;\n            break;\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown adapter type: %X\"), type);\n            return -1;\n        }\n    }\n\n    pret = PrlVmDev_IsConnected(netAdapter, &isConnected);\n    prlsdkCheckRetExit(pret, -1);\n\n    if (isConnected)\n        net->linkstate = VIR_DOMAIN_NET_INTERFACE_LINK_STATE_UP;\n    else\n        net->linkstate = VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN;\n\n    pret = PrlVmDevNet_IsPktFilterPreventMacSpoof(netAdapter, &isMacFilter);\n    prlsdkCheckRetExit(pret, -1);\n\n    net->trustGuestRxFilters = isMacFilter ? VIR_TRISTATE_BOOL_YES :\n                                             VIR_TRISTATE_BOOL_NO;\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);\n\nstatic int\nprlsdkGetNetInfo(PRL_HANDLE netAdapter, virDomainNetDefPtr net, bool isCt)\n{\n    char macstr[VIR_MAC_STRING_BUFLEN];\n    PRL_UINT32 netAdapterIndex;\n    PRL_UINT32 emulatedType;\n    PRL_RESULT pret;\n    PRL_BOOL isConnected, isMacFilter;\n\n    /* use device name, shown by prlctl as target device\n     * for identifying network adapter in virDomainDefineXML */\n    if (!(net->ifname = prlsdkGetStringParamVar(PrlVmDevNet_GetHostInterfaceName,\n                                                netAdapter)))\n        return -1;\n\n    pret = PrlVmDev_GetIndex(netAdapter, &netAdapterIndex);\n    prlsdkCheckRetExit(pret, -1);\n\n    if (isCt && netAdapterIndex == (PRL_UINT32) -1) {\n        /* venet devices don't have mac address and\n         * always up */\n        net->linkstate = VIR_DOMAIN_NET_INTERFACE_LINK_STATE_UP;\n        net->type = VIR_DOMAIN_NET_TYPE_NETWORK;\n        net->data.network.name = g_strdup(PARALLELS_DOMAIN_ROUTED_NETWORK_NAME);\n        return 0;\n    }\n\n    pret = prlsdkGetStringParamBuf(PrlVmDevNet_GetMacAddressCanonical,\n                                   netAdapter, macstr, sizeof(macstr));\n    prlsdkCheckRetExit(pret, -1);\n\n    if (virMacAddrParse(macstr, &net->mac) < 0)\n        return -1;\n\n    if (prlsdkGetNetAddresses(netAdapter, net) < 0)\n        return -1;\n\n    if (prlsdkGetRoutes(netAdapter, net) < 0)\n        return -1;\n\n    pret = PrlVmDev_GetEmulatedType(netAdapter, &emulatedType);\n    prlsdkCheckRetExit(pret, -1);\n\n    if (emulatedType == PNA_ROUTED) {\n        net->type = VIR_DOMAIN_NET_TYPE_NETWORK;\n        net->data.network.name = g_strdup(PARALLELS_DOMAIN_ROUTED_NETWORK_NAME);\n    } else {\n        char *netid =\n              prlsdkGetStringParamVar(PrlVmDevNet_GetVirtualNetworkId,\n                                      netAdapter);\n\n        if (emulatedType == PNA_BRIDGE) {\n            net->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n            if (netid)\n                net->data.bridge.brname = netid;\n        } else {\n            net->type = VIR_DOMAIN_NET_TYPE_NETWORK;\n            if (netid)\n                net->data.network.name = netid;\n        }\n    }\n\n    if (!isCt) {\n        PRL_VM_NET_ADAPTER_TYPE type;\n        pret = PrlVmDevNet_GetAdapterType(netAdapter, &type);\n        prlsdkCheckRetExit(pret, -1);\n\n        switch ((int)type) {\n        case PNT_RTL:\n            net->model = VIR_DOMAIN_NET_MODEL_RTL8139;\n            break;\n        case PNT_E1000:\n            net->model = VIR_DOMAIN_NET_MODEL_E1000;\n            break;\n        case PNT_VIRTIO:\n            net->model = VIR_DOMAIN_NET_MODEL_VIRTIO;\n            break;\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown adapter type: %X\"), type);\n            return -1;\n        }\n    }\n\n    pret = PrlVmDev_IsConnected(netAdapter, &isConnected);\n    prlsdkCheckRetExit(pret, -1);\n\n    if (isConnected)\n        net->linkstate = VIR_DOMAIN_NET_INTERFACE_LINK_STATE_UP;\n    else\n        net->linkstate = VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN;\n\n    pret = PrlVmDevNet_IsPktFilterPreventMacSpoof(netAdapter, &isMacFilter);\n    prlsdkCheckRetExit(pret, -1);\n\n    net->trustGuestRxFilters = isMacFilter ? VIR_TRISTATE_BOOL_YES :\n                                             VIR_TRISTATE_BOOL_NO;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "def"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "net"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "ret",
            "error"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetNetAdapter",
          "args": [
            "sdkdom",
            "i",
            "&netAdapter"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "ret",
            "error"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetNetAdaptersCount",
          "args": [
            "sdkdom",
            "&netAdaptersCount"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkAddDomainNetInfo(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    virDomainNetDefPtr net = NULL;\n    PRL_RESULT ret;\n    PRL_HANDLE netAdapter;\n    PRL_UINT32 netAdaptersCount;\n    PRL_UINT32 i;\n\n    ret = PrlVmCfg_GetNetAdaptersCount(sdkdom, &netAdaptersCount);\n    prlsdkCheckRetGoto(ret, error);\n    for (i = 0; i < netAdaptersCount; ++i) {\n        ret = PrlVmCfg_GetNetAdapter(sdkdom, i, &netAdapter);\n        prlsdkCheckRetGoto(ret, error);\n\n        if (VIR_ALLOC(net) < 0)\n            goto error;\n\n        if (prlsdkGetNetInfo(netAdapter, net, IS_CT(def)) < 0)\n            goto error;\n\n        PrlHandle_Free(netAdapter);\n        netAdapter = PRL_INVALID_HANDLE;\n\n        if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    PrlHandle_Free(netAdapter);\n    virDomainNetDefFree(net);\n    return -1;\n}"
  },
  {
    "function_name": "prlsdkGetNetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "1032-1131",
    "snippet": "static int\nprlsdkGetNetInfo(PRL_HANDLE netAdapter, virDomainNetDefPtr net, bool isCt)\n{\n    char macstr[VIR_MAC_STRING_BUFLEN];\n    PRL_UINT32 netAdapterIndex;\n    PRL_UINT32 emulatedType;\n    PRL_RESULT pret;\n    PRL_BOOL isConnected, isMacFilter;\n\n    /* use device name, shown by prlctl as target device\n     * for identifying network adapter in virDomainDefineXML */\n    if (!(net->ifname = prlsdkGetStringParamVar(PrlVmDevNet_GetHostInterfaceName,\n                                                netAdapter)))\n        return -1;\n\n    pret = PrlVmDev_GetIndex(netAdapter, &netAdapterIndex);\n    prlsdkCheckRetExit(pret, -1);\n\n    if (isCt && netAdapterIndex == (PRL_UINT32) -1) {\n        /* venet devices don't have mac address and\n         * always up */\n        net->linkstate = VIR_DOMAIN_NET_INTERFACE_LINK_STATE_UP;\n        net->type = VIR_DOMAIN_NET_TYPE_NETWORK;\n        net->data.network.name = g_strdup(PARALLELS_DOMAIN_ROUTED_NETWORK_NAME);\n        return 0;\n    }\n\n    pret = prlsdkGetStringParamBuf(PrlVmDevNet_GetMacAddressCanonical,\n                                   netAdapter, macstr, sizeof(macstr));\n    prlsdkCheckRetExit(pret, -1);\n\n    if (virMacAddrParse(macstr, &net->mac) < 0)\n        return -1;\n\n    if (prlsdkGetNetAddresses(netAdapter, net) < 0)\n        return -1;\n\n    if (prlsdkGetRoutes(netAdapter, net) < 0)\n        return -1;\n\n    pret = PrlVmDev_GetEmulatedType(netAdapter, &emulatedType);\n    prlsdkCheckRetExit(pret, -1);\n\n    if (emulatedType == PNA_ROUTED) {\n        net->type = VIR_DOMAIN_NET_TYPE_NETWORK;\n        net->data.network.name = g_strdup(PARALLELS_DOMAIN_ROUTED_NETWORK_NAME);\n    } else {\n        char *netid =\n              prlsdkGetStringParamVar(PrlVmDevNet_GetVirtualNetworkId,\n                                      netAdapter);\n\n        if (emulatedType == PNA_BRIDGE) {\n            net->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n            if (netid)\n                net->data.bridge.brname = netid;\n        } else {\n            net->type = VIR_DOMAIN_NET_TYPE_NETWORK;\n            if (netid)\n                net->data.network.name = netid;\n        }\n    }\n\n    if (!isCt) {\n        PRL_VM_NET_ADAPTER_TYPE type;\n        pret = PrlVmDevNet_GetAdapterType(netAdapter, &type);\n        prlsdkCheckRetExit(pret, -1);\n\n        switch ((int)type) {\n        case PNT_RTL:\n            net->model = VIR_DOMAIN_NET_MODEL_RTL8139;\n            break;\n        case PNT_E1000:\n            net->model = VIR_DOMAIN_NET_MODEL_E1000;\n            break;\n        case PNT_VIRTIO:\n            net->model = VIR_DOMAIN_NET_MODEL_VIRTIO;\n            break;\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown adapter type: %X\"), type);\n            return -1;\n        }\n    }\n\n    pret = PrlVmDev_IsConnected(netAdapter, &isConnected);\n    prlsdkCheckRetExit(pret, -1);\n\n    if (isConnected)\n        net->linkstate = VIR_DOMAIN_NET_INTERFACE_LINK_STATE_UP;\n    else\n        net->linkstate = VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN;\n\n    pret = PrlVmDevNet_IsPktFilterPreventMacSpoof(netAdapter, &isMacFilter);\n    prlsdkCheckRetExit(pret, -1);\n\n    net->trustGuestRxFilters = isMacFilter ? VIR_TRISTATE_BOOL_YES :\n                                             VIR_TRISTATE_BOOL_NO;\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);",
      "static PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevNet_IsPktFilterPreventMacSpoof",
          "args": [
            "netAdapter",
            "&isMacFilter"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_IsConnected",
          "args": [
            "netAdapter",
            "&isConnected"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown adapter type: %X\")",
            "type"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown adapter type: %X\""
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevNet_GetAdapterType",
          "args": [
            "netAdapter",
            "&type"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetStringParamVar",
          "args": [
            "PrlVmDevNet_GetVirtualNetworkId",
            "netAdapter"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetStringParamVar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "299-320",
          "snippet": "static char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_GetEmulatedType",
          "args": [
            "netAdapter",
            "&emulatedType"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetRoutes",
          "args": [
            "netAdapter",
            "net"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetRoutes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "987-1030",
          "snippet": "static int\nprlsdkGetRoutes(PRL_HANDLE sdknet, virDomainNetDefPtr net)\n{\n    int ret = -1;\n    char *gw = NULL;\n    char *gw6 = NULL;\n    virNetDevIPRoutePtr route = NULL;\n\n    if (!(gw = prlsdkGetStringParamVar(PrlVmDevNet_GetDefaultGateway, sdknet)))\n        goto cleanup;\n\n    if (!(gw6 = prlsdkGetStringParamVar(PrlVmDevNet_GetDefaultGatewayIPv6, sdknet)))\n        goto cleanup;\n\n    if (*gw != '\\0') {\n\n        if (!(route = virNetDevIPRouteCreate(_(\"Domain interface\"),\n                                               \"ipv4\", VIR_SOCKET_ADDR_IPV4_ALL,\n                                               NULL, gw, 0, true, 0, false)))\n            goto cleanup;\n\n        if (VIR_APPEND_ELEMENT(net->guestIP.routes, net->guestIP.nroutes, route) < 0)\n            goto cleanup;\n    }\n\n    if (*gw6 != '\\0') {\n        if (!(route = virNetDevIPRouteCreate(_(\"Domain interface\"),\n                                               \"ipv6\", VIR_SOCKET_ADDR_IPV6_ALL,\n                                               NULL, gw6, 0, true, 0, false)))\n            goto cleanup;\n\n        if (VIR_APPEND_ELEMENT(net->guestIP.routes, net->guestIP.nroutes, route) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virNetDevIPRouteFree(route);\n    VIR_FREE(gw);\n    VIR_FREE(gw6);\n\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkGetRoutes(PRL_HANDLE sdknet, virDomainNetDefPtr net)\n{\n    int ret = -1;\n    char *gw = NULL;\n    char *gw6 = NULL;\n    virNetDevIPRoutePtr route = NULL;\n\n    if (!(gw = prlsdkGetStringParamVar(PrlVmDevNet_GetDefaultGateway, sdknet)))\n        goto cleanup;\n\n    if (!(gw6 = prlsdkGetStringParamVar(PrlVmDevNet_GetDefaultGatewayIPv6, sdknet)))\n        goto cleanup;\n\n    if (*gw != '\\0') {\n\n        if (!(route = virNetDevIPRouteCreate(_(\"Domain interface\"),\n                                               \"ipv4\", VIR_SOCKET_ADDR_IPV4_ALL,\n                                               NULL, gw, 0, true, 0, false)))\n            goto cleanup;\n\n        if (VIR_APPEND_ELEMENT(net->guestIP.routes, net->guestIP.nroutes, route) < 0)\n            goto cleanup;\n    }\n\n    if (*gw6 != '\\0') {\n        if (!(route = virNetDevIPRouteCreate(_(\"Domain interface\"),\n                                               \"ipv6\", VIR_SOCKET_ADDR_IPV6_ALL,\n                                               NULL, gw6, 0, true, 0, false)))\n            goto cleanup;\n\n        if (VIR_APPEND_ELEMENT(net->guestIP.routes, net->guestIP.nroutes, route) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virNetDevIPRouteFree(route);\n    VIR_FREE(gw);\n    VIR_FREE(gw6);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkGetNetAddresses",
          "args": [
            "netAdapter",
            "net"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetNetAddresses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "942-985",
          "snippet": "static int\nprlsdkGetNetAddresses(PRL_HANDLE sdknet, virDomainNetDefPtr net)\n{\n    int ret = -1;\n    PRL_HANDLE addrlist = PRL_INVALID_HANDLE;\n    PRL_UINT32 num;\n    size_t i;\n    PRL_RESULT pret;\n\n    pret = PrlVmDevNet_GetNetAddresses(sdknet, &addrlist);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    PrlStrList_GetItemsCount(addrlist, &num);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < num; ++i) {\n        virNetDevIPAddrPtr ip = NULL;\n        PRL_UINT32 buflen = 0;\n        char *addr;\n\n        pret = PrlStrList_GetItem(addrlist, i, NULL, &buflen);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (VIR_ALLOC_N(addr, buflen) < 0)\n            goto cleanup;\n\n        pret = PrlStrList_GetItem(addrlist, i, addr, &buflen);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (!(ip = prlsdkParseNetAddress(addr)))\n            continue;\n\n        if (VIR_APPEND_ELEMENT(net->guestIP.ips, net->guestIP.nips, ip) < 0) {\n            VIR_FREE(ip);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n cleanup:\n\n    PrlHandle_Free(addrlist);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkGetNetAddresses(PRL_HANDLE sdknet, virDomainNetDefPtr net)\n{\n    int ret = -1;\n    PRL_HANDLE addrlist = PRL_INVALID_HANDLE;\n    PRL_UINT32 num;\n    size_t i;\n    PRL_RESULT pret;\n\n    pret = PrlVmDevNet_GetNetAddresses(sdknet, &addrlist);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    PrlStrList_GetItemsCount(addrlist, &num);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < num; ++i) {\n        virNetDevIPAddrPtr ip = NULL;\n        PRL_UINT32 buflen = 0;\n        char *addr;\n\n        pret = PrlStrList_GetItem(addrlist, i, NULL, &buflen);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (VIR_ALLOC_N(addr, buflen) < 0)\n            goto cleanup;\n\n        pret = PrlStrList_GetItem(addrlist, i, addr, &buflen);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (!(ip = prlsdkParseNetAddress(addr)))\n            continue;\n\n        if (VIR_APPEND_ELEMENT(net->guestIP.ips, net->guestIP.nips, ip) < 0) {\n            VIR_FREE(ip);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n cleanup:\n\n    PrlHandle_Free(addrlist);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrParse",
          "args": [
            "macstr",
            "&net->mac"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "205-218",
          "snippet": "int\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetStringParamBuf",
          "args": [
            "PrlVmDevNet_GetMacAddressCanonical",
            "netAdapter",
            "macstr",
            "sizeof(macstr)"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetStringParamBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "322-328",
          "snippet": "static PRL_RESULT\nprlsdkGetStringParamBuf(prlsdkParamGetterType getter,\n                        PRL_HANDLE handle, char *buf, size_t size)\n{\n    PRL_UINT32 buflen = size;\n    return getter(handle, buf, &buflen);\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_RESULT\nprlsdkGetStringParamBuf(prlsdkParamGetterType getter,\n                        PRL_HANDLE handle, char *buf, size_t size)\n{\n    PRL_UINT32 buflen = size;\n    return getter(handle, buf, &buflen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_GetIndex",
          "args": [
            "netAdapter",
            "&netAdapterIndex"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkFindNetByMAC(PRL_HANDLE sdkdom, virMacAddrPtr mac);\n\nstatic int\nprlsdkGetNetInfo(PRL_HANDLE netAdapter, virDomainNetDefPtr net, bool isCt)\n{\n    char macstr[VIR_MAC_STRING_BUFLEN];\n    PRL_UINT32 netAdapterIndex;\n    PRL_UINT32 emulatedType;\n    PRL_RESULT pret;\n    PRL_BOOL isConnected, isMacFilter;\n\n    /* use device name, shown by prlctl as target device\n     * for identifying network adapter in virDomainDefineXML */\n    if (!(net->ifname = prlsdkGetStringParamVar(PrlVmDevNet_GetHostInterfaceName,\n                                                netAdapter)))\n        return -1;\n\n    pret = PrlVmDev_GetIndex(netAdapter, &netAdapterIndex);\n    prlsdkCheckRetExit(pret, -1);\n\n    if (isCt && netAdapterIndex == (PRL_UINT32) -1) {\n        /* venet devices don't have mac address and\n         * always up */\n        net->linkstate = VIR_DOMAIN_NET_INTERFACE_LINK_STATE_UP;\n        net->type = VIR_DOMAIN_NET_TYPE_NETWORK;\n        net->data.network.name = g_strdup(PARALLELS_DOMAIN_ROUTED_NETWORK_NAME);\n        return 0;\n    }\n\n    pret = prlsdkGetStringParamBuf(PrlVmDevNet_GetMacAddressCanonical,\n                                   netAdapter, macstr, sizeof(macstr));\n    prlsdkCheckRetExit(pret, -1);\n\n    if (virMacAddrParse(macstr, &net->mac) < 0)\n        return -1;\n\n    if (prlsdkGetNetAddresses(netAdapter, net) < 0)\n        return -1;\n\n    if (prlsdkGetRoutes(netAdapter, net) < 0)\n        return -1;\n\n    pret = PrlVmDev_GetEmulatedType(netAdapter, &emulatedType);\n    prlsdkCheckRetExit(pret, -1);\n\n    if (emulatedType == PNA_ROUTED) {\n        net->type = VIR_DOMAIN_NET_TYPE_NETWORK;\n        net->data.network.name = g_strdup(PARALLELS_DOMAIN_ROUTED_NETWORK_NAME);\n    } else {\n        char *netid =\n              prlsdkGetStringParamVar(PrlVmDevNet_GetVirtualNetworkId,\n                                      netAdapter);\n\n        if (emulatedType == PNA_BRIDGE) {\n            net->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n            if (netid)\n                net->data.bridge.brname = netid;\n        } else {\n            net->type = VIR_DOMAIN_NET_TYPE_NETWORK;\n            if (netid)\n                net->data.network.name = netid;\n        }\n    }\n\n    if (!isCt) {\n        PRL_VM_NET_ADAPTER_TYPE type;\n        pret = PrlVmDevNet_GetAdapterType(netAdapter, &type);\n        prlsdkCheckRetExit(pret, -1);\n\n        switch ((int)type) {\n        case PNT_RTL:\n            net->model = VIR_DOMAIN_NET_MODEL_RTL8139;\n            break;\n        case PNT_E1000:\n            net->model = VIR_DOMAIN_NET_MODEL_E1000;\n            break;\n        case PNT_VIRTIO:\n            net->model = VIR_DOMAIN_NET_MODEL_VIRTIO;\n            break;\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown adapter type: %X\"), type);\n            return -1;\n        }\n    }\n\n    pret = PrlVmDev_IsConnected(netAdapter, &isConnected);\n    prlsdkCheckRetExit(pret, -1);\n\n    if (isConnected)\n        net->linkstate = VIR_DOMAIN_NET_INTERFACE_LINK_STATE_UP;\n    else\n        net->linkstate = VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN;\n\n    pret = PrlVmDevNet_IsPktFilterPreventMacSpoof(netAdapter, &isMacFilter);\n    prlsdkCheckRetExit(pret, -1);\n\n    net->trustGuestRxFilters = isMacFilter ? VIR_TRISTATE_BOOL_YES :\n                                             VIR_TRISTATE_BOOL_NO;\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkGetRoutes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "987-1030",
    "snippet": "static int\nprlsdkGetRoutes(PRL_HANDLE sdknet, virDomainNetDefPtr net)\n{\n    int ret = -1;\n    char *gw = NULL;\n    char *gw6 = NULL;\n    virNetDevIPRoutePtr route = NULL;\n\n    if (!(gw = prlsdkGetStringParamVar(PrlVmDevNet_GetDefaultGateway, sdknet)))\n        goto cleanup;\n\n    if (!(gw6 = prlsdkGetStringParamVar(PrlVmDevNet_GetDefaultGatewayIPv6, sdknet)))\n        goto cleanup;\n\n    if (*gw != '\\0') {\n\n        if (!(route = virNetDevIPRouteCreate(_(\"Domain interface\"),\n                                               \"ipv4\", VIR_SOCKET_ADDR_IPV4_ALL,\n                                               NULL, gw, 0, true, 0, false)))\n            goto cleanup;\n\n        if (VIR_APPEND_ELEMENT(net->guestIP.routes, net->guestIP.nroutes, route) < 0)\n            goto cleanup;\n    }\n\n    if (*gw6 != '\\0') {\n        if (!(route = virNetDevIPRouteCreate(_(\"Domain interface\"),\n                                               \"ipv6\", VIR_SOCKET_ADDR_IPV6_ALL,\n                                               NULL, gw6, 0, true, 0, false)))\n            goto cleanup;\n\n        if (VIR_APPEND_ELEMENT(net->guestIP.routes, net->guestIP.nroutes, route) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virNetDevIPRouteFree(route);\n    VIR_FREE(gw);\n    VIR_FREE(gw6);\n\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "gw6"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "gw"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteFree",
          "args": [
            "route"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "975-982",
          "snippet": "void\nvirNetDevIPRouteFree(virNetDevIPRoutePtr def)\n{\n    if (!def)\n        return;\n    VIR_FREE(def->family);\n    VIR_FREE(def);\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nvoid\nvirNetDevIPRouteFree(virNetDevIPRoutePtr def)\n{\n    if (!def)\n        return;\n    VIR_FREE(def->family);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "net->guestIP.routes",
            "net->guestIP.nroutes",
            "route"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteCreate",
          "args": [
            "_(\"Domain interface\")",
            "\"ipv6\"",
            "VIR_SOCKET_ADDR_IPV6_ALL",
            "NULL",
            "gw6",
            "0",
            "true",
            "0",
            "false"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/networkcommon_conf.c",
          "lines": "33-218",
          "snippet": "virNetDevIPRoutePtr\nvirNetDevIPRouteCreate(const char *errorDetail,\n                       const char *family,\n                       const char *address,\n                       const char *netmask,\n                       const char *gateway,\n                       unsigned int prefix,\n                       bool hasPrefix,\n                       unsigned int metric,\n                       bool hasMetric)\n{\n    virNetDevIPRoutePtr def = NULL;\n    virSocketAddr testAddr;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->family = g_strdup(family);\n\n    def->prefix = prefix;\n    def->has_prefix = hasPrefix;\n    def->metric = metric;\n    def->has_metric = hasMetric;\n\n    /* Note: both network and gateway addresses must be specified */\n\n    if (!address) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"%s: Missing required address attribute \"\n                         \"in route definition\"),\n                       errorDetail);\n        goto error;\n    }\n\n    if (!gateway) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"%s: Missing required gateway attribute \"\n                         \"in route definition\"),\n                       errorDetail);\n        goto error;\n    }\n\n    if (virSocketAddrParse(&def->address, address, AF_UNSPEC) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"%s: Bad network address '%s' \"\n                         \"in route definition\"),\n                       errorDetail, address);\n        goto error;\n    }\n\n    if (virSocketAddrParse(&def->gateway, gateway, AF_UNSPEC) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"%s: Bad gateway address '%s' \"\n                         \"in route definition\"),\n                       errorDetail, gateway);\n        goto error;\n    }\n\n    /* validate network address, etc. for each family */\n    if ((def->family == NULL) || (STREQ(def->family, \"ipv4\"))) {\n        if (!(VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET) ||\n              VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_UNSPEC))) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           def->family == NULL ?\n                           _(\"%s: No family specified for non-IPv4 address '%s' \"\n                             \"in route definition\") :\n                           _(\"%s: IPv4 family specified for non-IPv4 address '%s' \"\n                             \"in route definition\"),\n                           errorDetail, address);\n            goto error;\n        }\n        if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->gateway, AF_INET)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           def->family == NULL ?\n                           _(\"%s: No family specified for non-IPv4 gateway '%s' \"\n                             \"in route definition\") :\n                           _(\"%s: IPv4 family specified for non-IPv4 gateway '%s' \"\n                             \"in route definition\"),\n                           errorDetail, address);\n            goto error;\n        }\n        if (netmask) {\n            if (virSocketAddrParse(&def->netmask, netmask, AF_UNSPEC) < 0) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"%s: Bad netmask address '%s' \"\n                                 \"in route definition\"),\n                               errorDetail, netmask);\n                goto error;\n            }\n            if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET)) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"%s: Invalid netmask '%s' \"\n                                 \"for address '%s' (both must be IPv4)\"),\n                               errorDetail, netmask, address);\n                goto error;\n            }\n            if (def->has_prefix) {\n                /* can't have both netmask and prefix at the same time */\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"%s: Route definition cannot have both \"\n                                 \"a prefix and a netmask\"),\n                               errorDetail);\n                goto error;\n            }\n        }\n        if (def->prefix > 32) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"%s: Invalid prefix %u specified \"\n                             \"in route definition, \"\n                             \"must be 0 - 32\"),\n                           errorDetail, def->prefix);\n            goto error;\n        }\n    } else if (STREQ(def->family, \"ipv6\")) {\n        if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"%s: ipv6 family specified for non-IPv6 address '%s' \"\n                             \"in route definition\"),\n                           errorDetail, address);\n            goto error;\n        }\n        if (netmask) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"%s: Specifying netmask invalid for IPv6 address '%s' \"\n                             \"in route definition\"),\n                           errorDetail, address);\n            goto error;\n        }\n        if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->gateway, AF_INET6)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"%s: ipv6 specified for non-IPv6 gateway address '%s' \"\n                             \"in route definition\"),\n                           errorDetail, gateway);\n            goto error;\n        }\n        if (def->prefix > 128) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"%s: Invalid prefix %u specified \"\n                             \"in route definition, \"\n                             \"must be 0 - 128\"),\n                           errorDetail, def->prefix);\n            goto error;\n        }\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"%s: Unrecognized family '%s' \"\n                         \"in route definition\"),\n                       errorDetail, def->family);\n        goto error;\n    }\n\n    /* make sure the address is a network address */\n    if (netmask) {\n        if (virSocketAddrMask(&def->address, &def->netmask, &testAddr) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"%s: Error converting address '%s' with netmask '%s' \"\n                             \"to network-address \"\n                             \"in route definition\"),\n                           errorDetail, address, netmask);\n            goto error;\n        }\n    } else {\n        if (virSocketAddrMaskByPrefix(&def->address,\n                                      def->prefix, &testAddr) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"%s: Error converting address '%s' with prefix %u \"\n                             \"to network-address \"\n                             \"in route definition\"),\n                           errorDetail, address, def->prefix);\n            goto error;\n        }\n    }\n    if (!virSocketAddrEqual(&def->address, &testAddr)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"%s: Address '%s' in route definition \"\n                         \"is not a network address\"),\n                       errorDetail, address);\n        goto error;\n    }\n\n    return def;\n\n error:\n    virNetDevIPRouteFree(def);\n    return NULL;\n}",
          "includes": [
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"networkcommon_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirNetDevIPRoutePtr\nvirNetDevIPRouteCreate(const char *errorDetail,\n                       const char *family,\n                       const char *address,\n                       const char *netmask,\n                       const char *gateway,\n                       unsigned int prefix,\n                       bool hasPrefix,\n                       unsigned int metric,\n                       bool hasMetric)\n{\n    virNetDevIPRoutePtr def = NULL;\n    virSocketAddr testAddr;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->family = g_strdup(family);\n\n    def->prefix = prefix;\n    def->has_prefix = hasPrefix;\n    def->metric = metric;\n    def->has_metric = hasMetric;\n\n    /* Note: both network and gateway addresses must be specified */\n\n    if (!address) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"%s: Missing required address attribute \"\n                         \"in route definition\"),\n                       errorDetail);\n        goto error;\n    }\n\n    if (!gateway) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"%s: Missing required gateway attribute \"\n                         \"in route definition\"),\n                       errorDetail);\n        goto error;\n    }\n\n    if (virSocketAddrParse(&def->address, address, AF_UNSPEC) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"%s: Bad network address '%s' \"\n                         \"in route definition\"),\n                       errorDetail, address);\n        goto error;\n    }\n\n    if (virSocketAddrParse(&def->gateway, gateway, AF_UNSPEC) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"%s: Bad gateway address '%s' \"\n                         \"in route definition\"),\n                       errorDetail, gateway);\n        goto error;\n    }\n\n    /* validate network address, etc. for each family */\n    if ((def->family == NULL) || (STREQ(def->family, \"ipv4\"))) {\n        if (!(VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET) ||\n              VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_UNSPEC))) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           def->family == NULL ?\n                           _(\"%s: No family specified for non-IPv4 address '%s' \"\n                             \"in route definition\") :\n                           _(\"%s: IPv4 family specified for non-IPv4 address '%s' \"\n                             \"in route definition\"),\n                           errorDetail, address);\n            goto error;\n        }\n        if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->gateway, AF_INET)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           def->family == NULL ?\n                           _(\"%s: No family specified for non-IPv4 gateway '%s' \"\n                             \"in route definition\") :\n                           _(\"%s: IPv4 family specified for non-IPv4 gateway '%s' \"\n                             \"in route definition\"),\n                           errorDetail, address);\n            goto error;\n        }\n        if (netmask) {\n            if (virSocketAddrParse(&def->netmask, netmask, AF_UNSPEC) < 0) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"%s: Bad netmask address '%s' \"\n                                 \"in route definition\"),\n                               errorDetail, netmask);\n                goto error;\n            }\n            if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET)) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"%s: Invalid netmask '%s' \"\n                                 \"for address '%s' (both must be IPv4)\"),\n                               errorDetail, netmask, address);\n                goto error;\n            }\n            if (def->has_prefix) {\n                /* can't have both netmask and prefix at the same time */\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"%s: Route definition cannot have both \"\n                                 \"a prefix and a netmask\"),\n                               errorDetail);\n                goto error;\n            }\n        }\n        if (def->prefix > 32) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"%s: Invalid prefix %u specified \"\n                             \"in route definition, \"\n                             \"must be 0 - 32\"),\n                           errorDetail, def->prefix);\n            goto error;\n        }\n    } else if (STREQ(def->family, \"ipv6\")) {\n        if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET6)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"%s: ipv6 family specified for non-IPv6 address '%s' \"\n                             \"in route definition\"),\n                           errorDetail, address);\n            goto error;\n        }\n        if (netmask) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"%s: Specifying netmask invalid for IPv6 address '%s' \"\n                             \"in route definition\"),\n                           errorDetail, address);\n            goto error;\n        }\n        if (!VIR_SOCKET_ADDR_IS_FAMILY(&def->gateway, AF_INET6)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"%s: ipv6 specified for non-IPv6 gateway address '%s' \"\n                             \"in route definition\"),\n                           errorDetail, gateway);\n            goto error;\n        }\n        if (def->prefix > 128) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"%s: Invalid prefix %u specified \"\n                             \"in route definition, \"\n                             \"must be 0 - 128\"),\n                           errorDetail, def->prefix);\n            goto error;\n        }\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"%s: Unrecognized family '%s' \"\n                         \"in route definition\"),\n                       errorDetail, def->family);\n        goto error;\n    }\n\n    /* make sure the address is a network address */\n    if (netmask) {\n        if (virSocketAddrMask(&def->address, &def->netmask, &testAddr) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"%s: Error converting address '%s' with netmask '%s' \"\n                             \"to network-address \"\n                             \"in route definition\"),\n                           errorDetail, address, netmask);\n            goto error;\n        }\n    } else {\n        if (virSocketAddrMaskByPrefix(&def->address,\n                                      def->prefix, &testAddr) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"%s: Error converting address '%s' with prefix %u \"\n                             \"to network-address \"\n                             \"in route definition\"),\n                           errorDetail, address, def->prefix);\n            goto error;\n        }\n    }\n    if (!virSocketAddrEqual(&def->address, &testAddr)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"%s: Address '%s' in route definition \"\n                         \"is not a network address\"),\n                       errorDetail, address);\n        goto error;\n    }\n\n    return def;\n\n error:\n    virNetDevIPRouteFree(def);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Domain interface\""
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "net->guestIP.routes",
            "net->guestIP.nroutes",
            "route"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetStringParamVar",
          "args": [
            "PrlVmDevNet_GetDefaultGatewayIPv6",
            "sdknet"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetStringParamVar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "299-320",
          "snippet": "static char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkGetRoutes(PRL_HANDLE sdknet, virDomainNetDefPtr net)\n{\n    int ret = -1;\n    char *gw = NULL;\n    char *gw6 = NULL;\n    virNetDevIPRoutePtr route = NULL;\n\n    if (!(gw = prlsdkGetStringParamVar(PrlVmDevNet_GetDefaultGateway, sdknet)))\n        goto cleanup;\n\n    if (!(gw6 = prlsdkGetStringParamVar(PrlVmDevNet_GetDefaultGatewayIPv6, sdknet)))\n        goto cleanup;\n\n    if (*gw != '\\0') {\n\n        if (!(route = virNetDevIPRouteCreate(_(\"Domain interface\"),\n                                               \"ipv4\", VIR_SOCKET_ADDR_IPV4_ALL,\n                                               NULL, gw, 0, true, 0, false)))\n            goto cleanup;\n\n        if (VIR_APPEND_ELEMENT(net->guestIP.routes, net->guestIP.nroutes, route) < 0)\n            goto cleanup;\n    }\n\n    if (*gw6 != '\\0') {\n        if (!(route = virNetDevIPRouteCreate(_(\"Domain interface\"),\n                                               \"ipv6\", VIR_SOCKET_ADDR_IPV6_ALL,\n                                               NULL, gw6, 0, true, 0, false)))\n            goto cleanup;\n\n        if (VIR_APPEND_ELEMENT(net->guestIP.routes, net->guestIP.nroutes, route) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virNetDevIPRouteFree(route);\n    VIR_FREE(gw);\n    VIR_FREE(gw6);\n\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkGetNetAddresses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "942-985",
    "snippet": "static int\nprlsdkGetNetAddresses(PRL_HANDLE sdknet, virDomainNetDefPtr net)\n{\n    int ret = -1;\n    PRL_HANDLE addrlist = PRL_INVALID_HANDLE;\n    PRL_UINT32 num;\n    size_t i;\n    PRL_RESULT pret;\n\n    pret = PrlVmDevNet_GetNetAddresses(sdknet, &addrlist);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    PrlStrList_GetItemsCount(addrlist, &num);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < num; ++i) {\n        virNetDevIPAddrPtr ip = NULL;\n        PRL_UINT32 buflen = 0;\n        char *addr;\n\n        pret = PrlStrList_GetItem(addrlist, i, NULL, &buflen);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (VIR_ALLOC_N(addr, buflen) < 0)\n            goto cleanup;\n\n        pret = PrlStrList_GetItem(addrlist, i, addr, &buflen);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (!(ip = prlsdkParseNetAddress(addr)))\n            continue;\n\n        if (VIR_APPEND_ELEMENT(net->guestIP.ips, net->guestIP.nips, ip) < 0) {\n            VIR_FREE(ip);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n cleanup:\n\n    PrlHandle_Free(addrlist);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "addrlist"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ip"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "net->guestIP.ips",
            "net->guestIP.nips",
            "ip"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkParseNetAddress",
          "args": [
            "addr"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkParseNetAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "903-940",
          "snippet": "static virNetDevIPAddrPtr\nprlsdkParseNetAddress(char *addr)\n{\n    char *maskstr = NULL;\n    int nbits;\n    virSocketAddr mask;\n    virNetDevIPAddrPtr ip = NULL, ret = NULL;\n\n    if (!(maskstr = strchr(addr, '/')))\n        goto cleanup;\n\n    *maskstr = '\\0';\n    ++maskstr;\n\n    if (VIR_ALLOC(ip) < 0)\n        goto cleanup;\n\n    if (virSocketAddrParse(&ip->address, addr, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    if (virSocketAddrParse(&mask, maskstr, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    if ((nbits = virSocketAddrGetNumNetmaskBits(&mask)) < 0)\n        goto cleanup;\n    ip->prefix = nbits;\n\n    ret = g_steal_pointer(&ip);\n\n cleanup:\n    if (!ret)\n        VIR_WARN(\"cannot parse network address '%s'\", addr);\n\n    VIR_FREE(ip);\n    VIR_FREE(addr);\n\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virNetDevIPAddrPtr\nprlsdkParseNetAddress(char *addr)\n{\n    char *maskstr = NULL;\n    int nbits;\n    virSocketAddr mask;\n    virNetDevIPAddrPtr ip = NULL, ret = NULL;\n\n    if (!(maskstr = strchr(addr, '/')))\n        goto cleanup;\n\n    *maskstr = '\\0';\n    ++maskstr;\n\n    if (VIR_ALLOC(ip) < 0)\n        goto cleanup;\n\n    if (virSocketAddrParse(&ip->address, addr, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    if (virSocketAddrParse(&mask, maskstr, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    if ((nbits = virSocketAddrGetNumNetmaskBits(&mask)) < 0)\n        goto cleanup;\n    ip->prefix = nbits;\n\n    ret = g_steal_pointer(&ip);\n\n cleanup:\n    if (!ret)\n        VIR_WARN(\"cannot parse network address '%s'\", addr);\n\n    VIR_FREE(ip);\n    VIR_FREE(addr);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlStrList_GetItem",
          "args": [
            "addrlist",
            "i",
            "addr",
            "&buflen"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "addr",
            "buflen"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlStrList_GetItem",
          "args": [
            "addrlist",
            "i",
            "NULL",
            "&buflen"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlStrList_GetItemsCount",
          "args": [
            "addrlist",
            "&num"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevNet_GetNetAddresses",
          "args": [
            "sdknet",
            "&addrlist"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkGetNetAddresses(PRL_HANDLE sdknet, virDomainNetDefPtr net)\n{\n    int ret = -1;\n    PRL_HANDLE addrlist = PRL_INVALID_HANDLE;\n    PRL_UINT32 num;\n    size_t i;\n    PRL_RESULT pret;\n\n    pret = PrlVmDevNet_GetNetAddresses(sdknet, &addrlist);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    PrlStrList_GetItemsCount(addrlist, &num);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    for (i = 0; i < num; ++i) {\n        virNetDevIPAddrPtr ip = NULL;\n        PRL_UINT32 buflen = 0;\n        char *addr;\n\n        pret = PrlStrList_GetItem(addrlist, i, NULL, &buflen);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (VIR_ALLOC_N(addr, buflen) < 0)\n            goto cleanup;\n\n        pret = PrlStrList_GetItem(addrlist, i, addr, &buflen);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (!(ip = prlsdkParseNetAddress(addr)))\n            continue;\n\n        if (VIR_APPEND_ELEMENT(net->guestIP.ips, net->guestIP.nips, ip) < 0) {\n            VIR_FREE(ip);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n cleanup:\n\n    PrlHandle_Free(addrlist);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkParseNetAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "903-940",
    "snippet": "static virNetDevIPAddrPtr\nprlsdkParseNetAddress(char *addr)\n{\n    char *maskstr = NULL;\n    int nbits;\n    virSocketAddr mask;\n    virNetDevIPAddrPtr ip = NULL, ret = NULL;\n\n    if (!(maskstr = strchr(addr, '/')))\n        goto cleanup;\n\n    *maskstr = '\\0';\n    ++maskstr;\n\n    if (VIR_ALLOC(ip) < 0)\n        goto cleanup;\n\n    if (virSocketAddrParse(&ip->address, addr, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    if (virSocketAddrParse(&mask, maskstr, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    if ((nbits = virSocketAddrGetNumNetmaskBits(&mask)) < 0)\n        goto cleanup;\n    ip->prefix = nbits;\n\n    ret = g_steal_pointer(&ip);\n\n cleanup:\n    if (!ret)\n        VIR_WARN(\"cannot parse network address '%s'\", addr);\n\n    VIR_FREE(ip);\n    VIR_FREE(addr);\n\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addr"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ip"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"cannot parse network address '%s'\"",
            "addr"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&ip"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrGetNumNetmaskBits",
          "args": [
            "&mask"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetNumNetmaskBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1009-1084",
          "snippet": "int virSocketAddrGetNumNetmaskBits(const virSocketAddr *netmask)\n{\n    size_t i, j;\n    int c = 0;\n\n    if (netmask->data.stor.ss_family == AF_INET) {\n        virSocketAddrIPv4 tm;\n        uint8_t bit;\n\n        if (virSocketAddrGetIPv4Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 4; i++)\n            if (tm[i] == 0xff)\n                c += 8;\n            else\n                break;\n\n        if (c == 8 * 4)\n            return c;\n\n        j = i << 3;\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                return -1;\n            j++;\n        }\n\n        return c;\n    } else if (netmask->data.stor.ss_family == AF_INET6) {\n        virSocketAddrIPv6 tm;\n        uint16_t bit;\n\n        if (virSocketAddrGetIPv6Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 8; i++)\n            if (tm[i] == 0xffff)\n                c += 16;\n            else\n                break;\n\n        if (c == 16 * 8)\n            return c;\n\n        j = i << 4;\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4]) & bit)\n                return -1;\n            j++;\n        }\n\n        return c;\n    }\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrGetNumNetmaskBits(const virSocketAddr *netmask)\n{\n    size_t i, j;\n    int c = 0;\n\n    if (netmask->data.stor.ss_family == AF_INET) {\n        virSocketAddrIPv4 tm;\n        uint8_t bit;\n\n        if (virSocketAddrGetIPv4Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 4; i++)\n            if (tm[i] == 0xff)\n                c += 8;\n            else\n                break;\n\n        if (c == 8 * 4)\n            return c;\n\n        j = i << 3;\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                return -1;\n            j++;\n        }\n\n        return c;\n    } else if (netmask->data.stor.ss_family == AF_INET6) {\n        virSocketAddrIPv6 tm;\n        uint16_t bit;\n\n        if (virSocketAddrGetIPv6Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 8; i++)\n            if (tm[i] == 0xffff)\n                c += 16;\n            else\n                break;\n\n        if (c == 16 * 8)\n            return c;\n\n        j = i << 4;\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4]) & bit)\n                return -1;\n            j++;\n        }\n\n        return c;\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrParse",
          "args": [
            "&mask",
            "maskstr",
            "AF_UNSPEC"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "135-158",
          "snippet": "int virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ip"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "addr",
            "'/'"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virNetDevIPAddrPtr\nprlsdkParseNetAddress(char *addr)\n{\n    char *maskstr = NULL;\n    int nbits;\n    virSocketAddr mask;\n    virNetDevIPAddrPtr ip = NULL, ret = NULL;\n\n    if (!(maskstr = strchr(addr, '/')))\n        goto cleanup;\n\n    *maskstr = '\\0';\n    ++maskstr;\n\n    if (VIR_ALLOC(ip) < 0)\n        goto cleanup;\n\n    if (virSocketAddrParse(&ip->address, addr, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    if (virSocketAddrParse(&mask, maskstr, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    if ((nbits = virSocketAddrGetNumNetmaskBits(&mask)) < 0)\n        goto cleanup;\n    ip->prefix = nbits;\n\n    ret = g_steal_pointer(&ip);\n\n cleanup:\n    if (!ret)\n        VIR_WARN(\"cannot parse network address '%s'\", addr);\n\n    VIR_FREE(ip);\n    VIR_FREE(addr);\n\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkAddDomainOpticalDisksInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "866-901",
    "snippet": "static int\nprlsdkAddDomainOpticalDisksInfo(vzDriverPtr driver, PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 cdromsCount;\n    PRL_UINT32 i;\n    PRL_HANDLE cdrom = PRL_INVALID_HANDLE;\n    virDomainDiskDefPtr disk = NULL;\n\n    pret = PrlVmCfg_GetOpticalDisksCount(sdkdom, &cdromsCount);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < cdromsCount; ++i) {\n        pret = PrlVmCfg_GetOpticalDisk(sdkdom, i, &cdrom);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (!(disk = virDomainDiskDefNew(NULL)))\n            goto error;\n\n        if (prlsdkGetDiskInfo(driver, cdrom, disk, true, IS_CT(def)) < 0)\n            goto error;\n\n        PrlHandle_Free(cdrom);\n        cdrom = PRL_INVALID_HANDLE;\n\n        if (virDomainDiskInsert(def, disk) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    PrlHandle_Free(cdrom);\n    virDomainDiskDefFree(disk);\n    return -1;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);",
      "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDiskDefFree",
          "args": [
            "disk"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2117-2138",
          "snippet": "void\nvirDomainDiskDefFree(virDomainDiskDefPtr def)\n{\n    if (!def)\n        return;\n\n    virObjectUnref(def->src);\n    VIR_FREE(def->serial);\n    VIR_FREE(def->dst);\n    virObjectUnref(def->mirror);\n    VIR_FREE(def->wwn);\n    VIR_FREE(def->driverName);\n    VIR_FREE(def->vendor);\n    VIR_FREE(def->product);\n    VIR_FREE(def->domain_name);\n    VIR_FREE(def->blkdeviotune.group_name);\n    VIR_FREE(def->virtio);\n    virDomainDeviceInfoClear(&def->info);\n    virObjectUnref(def->privateData);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDiskDefFree(virDomainDiskDefPtr def)\n{\n    if (!def)\n        return;\n\n    virObjectUnref(def->src);\n    VIR_FREE(def->serial);\n    VIR_FREE(def->dst);\n    virObjectUnref(def->mirror);\n    VIR_FREE(def->wwn);\n    VIR_FREE(def->driverName);\n    VIR_FREE(def->vendor);\n    VIR_FREE(def->product);\n    VIR_FREE(def->domain_name);\n    VIR_FREE(def->blkdeviotune.group_name);\n    VIR_FREE(def->virtio);\n    virDomainDeviceInfoClear(&def->info);\n    virObjectUnref(def->privateData);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "cdrom"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskInsert",
          "args": [
            "def",
            "disk"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskInsertPreAlloced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17363-17394",
          "snippet": "void virDomainDiskInsertPreAlloced(virDomainDefPtr def,\n                                   virDomainDiskDefPtr disk)\n{\n    int idx;\n    /* Tentatively plan to insert disk at the end. */\n    int insertAt = -1;\n\n    /* Then work backwards looking for disks on\n     * the same bus. If we find a disk with a drive\n     * index greater than the new one, insert at\n     * that position\n     */\n    for (idx = (def->ndisks - 1); idx >= 0; idx--) {\n        /* If bus matches and current disk is after\n         * new disk, then new disk should go here */\n        if (def->disks[idx]->bus == disk->bus &&\n            (virDiskNameToIndex(def->disks[idx]->dst) >\n             virDiskNameToIndex(disk->dst))) {\n            insertAt = idx;\n        } else if (def->disks[idx]->bus == disk->bus &&\n                   insertAt == -1) {\n            /* Last disk with match bus is before the\n             * new disk, then put new disk just after\n             */\n            insertAt = idx + 1;\n        }\n    }\n\n    /* VIR_INSERT_ELEMENT_INPLACE will never return an error here. */\n    ignore_value(VIR_INSERT_ELEMENT_INPLACE(def->disks, insertAt,\n                                            def->ndisks, disk));\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDiskInsertPreAlloced(virDomainDefPtr def,\n                                   virDomainDiskDefPtr disk)\n{\n    int idx;\n    /* Tentatively plan to insert disk at the end. */\n    int insertAt = -1;\n\n    /* Then work backwards looking for disks on\n     * the same bus. If we find a disk with a drive\n     * index greater than the new one, insert at\n     * that position\n     */\n    for (idx = (def->ndisks - 1); idx >= 0; idx--) {\n        /* If bus matches and current disk is after\n         * new disk, then new disk should go here */\n        if (def->disks[idx]->bus == disk->bus &&\n            (virDiskNameToIndex(def->disks[idx]->dst) >\n             virDiskNameToIndex(disk->dst))) {\n            insertAt = idx;\n        } else if (def->disks[idx]->bus == disk->bus &&\n                   insertAt == -1) {\n            /* Last disk with match bus is before the\n             * new disk, then put new disk just after\n             */\n            insertAt = idx + 1;\n        }\n    }\n\n    /* VIR_INSERT_ELEMENT_INPLACE will never return an error here. */\n    ignore_value(VIR_INSERT_ELEMENT_INPLACE(def->disks, insertAt,\n                                            def->ndisks, disk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "cdrom"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetDiskInfo",
          "args": [
            "driver",
            "cdrom",
            "disk",
            "true",
            "IS_CT(def)"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetDiskInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "645-726",
          "snippet": "static int\nprlsdkGetDiskInfo(vzDriverPtr driver,\n                  PRL_HANDLE prldisk,\n                  virDomainDiskDefPtr disk,\n                  bool isCdrom,\n                  bool isCt)\n{\n    char *buf = NULL;\n    PRL_RESULT pret;\n    PRL_UINT32 emulatedType;\n    PRL_UINT32 size;\n    virDomainDeviceDriveAddressPtr address;\n    int busIdx, devIdx;\n    int ret = -1;\n\n    pret = PrlVmDev_GetEmulatedType(prldisk, &emulatedType);\n    prlsdkCheckRetGoto(pret, cleanup);\n    if (emulatedType == PDT_USE_IMAGE_FILE) {\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n        if (isCdrom) {\n            virDomainDiskSetFormat(disk, VIR_STORAGE_FILE_RAW);\n        } else {\n            if (isCt)\n                virDomainDiskSetFormat(disk, driver->vzCaps.ctDiskFormat);\n            else\n                virDomainDiskSetFormat(disk, driver->vzCaps.vmDiskFormat);\n        }\n    } else {\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_BLOCK);\n        virDomainDiskSetFormat(disk, VIR_STORAGE_FILE_RAW);\n    }\n\n    if (isCdrom) {\n        disk->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n        disk->src->readonly = true;\n    } else {\n        disk->device = VIR_DOMAIN_DISK_DEVICE_DISK;\n    }\n\n    if (!(buf = prlsdkGetStringParamVar(PrlVmDev_GetFriendlyName, prldisk)))\n        goto cleanup;\n\n    if (*buf != '\\0' && virDomainDiskSetSource(disk, buf) < 0)\n        goto cleanup;\n\n    if (prlsdkGetDiskId(prldisk, &disk->bus, &disk->dst) < 0)\n        goto cleanup;\n\n    if (virDiskNameToBusDeviceIndex(disk, &busIdx, &devIdx) < 0)\n        goto cleanup;\n\n    address = &disk->info.addr.drive;\n    address->bus = busIdx;\n    address->target = 0;\n    address->unit = devIdx;\n\n    disk->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n\n    if (!isCdrom) {\n        if (!(disk->serial = prlsdkGetStringParamVar(PrlVmDevHd_GetSerialNumber, prldisk)))\n            goto cleanup;\n\n        if (*disk->serial == '\\0')\n            VIR_FREE(disk->serial);\n    }\n\n    if (virDomainDiskSetDriver(disk, \"vz\") < 0)\n        goto cleanup;\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n        pret = PrlVmDevHd_GetDiskSize(prldisk, &size);\n        prlsdkCheckRetGoto(pret, cleanup);\n        /* from MiB to bytes */\n        disk->src->capacity = ((unsigned long long)size) << 20;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(buf);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int\nprlsdkGetDiskInfo(vzDriverPtr driver,\n                  PRL_HANDLE prldisk,\n                  virDomainDiskDefPtr disk,\n                  bool isCdrom,\n                  bool isCt)\n{\n    char *buf = NULL;\n    PRL_RESULT pret;\n    PRL_UINT32 emulatedType;\n    PRL_UINT32 size;\n    virDomainDeviceDriveAddressPtr address;\n    int busIdx, devIdx;\n    int ret = -1;\n\n    pret = PrlVmDev_GetEmulatedType(prldisk, &emulatedType);\n    prlsdkCheckRetGoto(pret, cleanup);\n    if (emulatedType == PDT_USE_IMAGE_FILE) {\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n        if (isCdrom) {\n            virDomainDiskSetFormat(disk, VIR_STORAGE_FILE_RAW);\n        } else {\n            if (isCt)\n                virDomainDiskSetFormat(disk, driver->vzCaps.ctDiskFormat);\n            else\n                virDomainDiskSetFormat(disk, driver->vzCaps.vmDiskFormat);\n        }\n    } else {\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_BLOCK);\n        virDomainDiskSetFormat(disk, VIR_STORAGE_FILE_RAW);\n    }\n\n    if (isCdrom) {\n        disk->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n        disk->src->readonly = true;\n    } else {\n        disk->device = VIR_DOMAIN_DISK_DEVICE_DISK;\n    }\n\n    if (!(buf = prlsdkGetStringParamVar(PrlVmDev_GetFriendlyName, prldisk)))\n        goto cleanup;\n\n    if (*buf != '\\0' && virDomainDiskSetSource(disk, buf) < 0)\n        goto cleanup;\n\n    if (prlsdkGetDiskId(prldisk, &disk->bus, &disk->dst) < 0)\n        goto cleanup;\n\n    if (virDiskNameToBusDeviceIndex(disk, &busIdx, &devIdx) < 0)\n        goto cleanup;\n\n    address = &disk->info.addr.drive;\n    address->bus = busIdx;\n    address->target = 0;\n    address->unit = devIdx;\n\n    disk->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n\n    if (!isCdrom) {\n        if (!(disk->serial = prlsdkGetStringParamVar(PrlVmDevHd_GetSerialNumber, prldisk)))\n            goto cleanup;\n\n        if (*disk->serial == '\\0')\n            VIR_FREE(disk->serial);\n    }\n\n    if (virDomainDiskSetDriver(disk, \"vz\") < 0)\n        goto cleanup;\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n        pret = PrlVmDevHd_GetDiskSize(prldisk, &size);\n        prlsdkCheckRetGoto(pret, cleanup);\n        /* from MiB to bytes */\n        disk->src->capacity = ((unsigned long long)size) << 20;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(buf);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "def"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskDefNew",
          "args": [
            "NULL"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2093-2114",
          "snippet": "virDomainDiskDefPtr\nvirDomainDiskDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDiskDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto error;\n\n    if (xmlopt &&\n        xmlopt->privateData.diskNew &&\n        !(ret->privateData = xmlopt->privateData.diskNew()))\n        goto error;\n\n    return ret;\n\n error:\n    virDomainDiskDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDiskDefPtr\nvirDomainDiskDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDiskDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto error;\n\n    if (xmlopt &&\n        xmlopt->privateData.diskNew &&\n        !(ret->privateData = xmlopt->privateData.diskNew()))\n        goto error;\n\n    return ret;\n\n error:\n    virDomainDiskDefFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetOpticalDisk",
          "args": [
            "sdkdom",
            "i",
            "&cdrom"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetOpticalDisksCount",
          "args": [
            "sdkdom",
            "&cdromsCount"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int\nprlsdkAddDomainOpticalDisksInfo(vzDriverPtr driver, PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 cdromsCount;\n    PRL_UINT32 i;\n    PRL_HANDLE cdrom = PRL_INVALID_HANDLE;\n    virDomainDiskDefPtr disk = NULL;\n\n    pret = PrlVmCfg_GetOpticalDisksCount(sdkdom, &cdromsCount);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < cdromsCount; ++i) {\n        pret = PrlVmCfg_GetOpticalDisk(sdkdom, i, &cdrom);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (!(disk = virDomainDiskDefNew(NULL)))\n            goto error;\n\n        if (prlsdkGetDiskInfo(driver, cdrom, disk, true, IS_CT(def)) < 0)\n            goto error;\n\n        PrlHandle_Free(cdrom);\n        cdrom = PRL_INVALID_HANDLE;\n\n        if (virDomainDiskInsert(def, disk) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    PrlHandle_Free(cdrom);\n    virDomainDiskDefFree(disk);\n    return -1;\n}"
  },
  {
    "function_name": "prlsdkAddDomainHardDisksInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "803-864",
    "snippet": "static int\nprlsdkAddDomainHardDisksInfo(vzDriverPtr driver, PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 hddCount;\n    PRL_UINT32 i;\n    PRL_HANDLE hdd = PRL_INVALID_HANDLE;\n    virDomainDiskDefPtr disk = NULL;\n    virDomainFSDefPtr fs = NULL;\n\n    pret = PrlVmCfg_GetHardDisksCount(sdkdom, &hddCount);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < hddCount; ++i) {\n\n        PRL_UINT32 emulatedType;\n\n        pret = PrlVmCfg_GetHardDisk(sdkdom, i, &hdd);\n        prlsdkCheckRetGoto(pret, error);\n\n        pret = PrlVmDev_GetEmulatedType(hdd, &emulatedType);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (IS_CT(def) &&\n            prlsdkInBootList(sdkdom, hdd)) {\n\n            if (!(fs = virDomainFSDefNew(NULL)))\n                goto error;\n\n            if (prlsdkGetFSInfo(hdd, fs) < 0)\n                goto error;\n\n            if (virDomainFSInsert(def, fs) < 0)\n                goto error;\n\n            fs = NULL;\n            PrlHandle_Free(hdd);\n            hdd = PRL_INVALID_HANDLE;\n        } else {\n            if (!(disk = virDomainDiskDefNew(NULL)))\n                goto error;\n\n            if (prlsdkGetDiskInfo(driver, hdd, disk, false, IS_CT(def)) < 0)\n                goto error;\n\n            if (virDomainDiskInsert(def, disk) < 0)\n                goto error;\n\n            disk = NULL;\n            PrlHandle_Free(hdd);\n            hdd = PRL_INVALID_HANDLE;\n        }\n    }\n\n    return 0;\n\n error:\n    PrlHandle_Free(hdd);\n    virDomainDiskDefFree(disk);\n    virDomainFSDefFree(fs);\n    return -1;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);",
      "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainFSDefFree",
          "args": [
            "fs"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainFSDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2328-2341",
          "snippet": "void virDomainFSDefFree(virDomainFSDefPtr def)\n{\n    if (!def)\n        return;\n\n    virObjectUnref(def->src);\n    VIR_FREE(def->dst);\n    virDomainDeviceInfoClear(&def->info);\n    VIR_FREE(def->virtio);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def->binary);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainFSDefFree(virDomainFSDefPtr def)\n{\n    if (!def)\n        return;\n\n    virObjectUnref(def->src);\n    VIR_FREE(def->dst);\n    virDomainDeviceInfoClear(&def->info);\n    VIR_FREE(def->virtio);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def->binary);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskDefFree",
          "args": [
            "disk"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2117-2138",
          "snippet": "void\nvirDomainDiskDefFree(virDomainDiskDefPtr def)\n{\n    if (!def)\n        return;\n\n    virObjectUnref(def->src);\n    VIR_FREE(def->serial);\n    VIR_FREE(def->dst);\n    virObjectUnref(def->mirror);\n    VIR_FREE(def->wwn);\n    VIR_FREE(def->driverName);\n    VIR_FREE(def->vendor);\n    VIR_FREE(def->product);\n    VIR_FREE(def->domain_name);\n    VIR_FREE(def->blkdeviotune.group_name);\n    VIR_FREE(def->virtio);\n    virDomainDeviceInfoClear(&def->info);\n    virObjectUnref(def->privateData);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDiskDefFree(virDomainDiskDefPtr def)\n{\n    if (!def)\n        return;\n\n    virObjectUnref(def->src);\n    VIR_FREE(def->serial);\n    VIR_FREE(def->dst);\n    virObjectUnref(def->mirror);\n    VIR_FREE(def->wwn);\n    VIR_FREE(def->driverName);\n    VIR_FREE(def->vendor);\n    VIR_FREE(def->product);\n    VIR_FREE(def->domain_name);\n    VIR_FREE(def->blkdeviotune.group_name);\n    VIR_FREE(def->virtio);\n    virDomainDeviceInfoClear(&def->info);\n    virObjectUnref(def->privateData);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "hdd"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "hdd"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskInsert",
          "args": [
            "def",
            "disk"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskInsertPreAlloced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17363-17394",
          "snippet": "void virDomainDiskInsertPreAlloced(virDomainDefPtr def,\n                                   virDomainDiskDefPtr disk)\n{\n    int idx;\n    /* Tentatively plan to insert disk at the end. */\n    int insertAt = -1;\n\n    /* Then work backwards looking for disks on\n     * the same bus. If we find a disk with a drive\n     * index greater than the new one, insert at\n     * that position\n     */\n    for (idx = (def->ndisks - 1); idx >= 0; idx--) {\n        /* If bus matches and current disk is after\n         * new disk, then new disk should go here */\n        if (def->disks[idx]->bus == disk->bus &&\n            (virDiskNameToIndex(def->disks[idx]->dst) >\n             virDiskNameToIndex(disk->dst))) {\n            insertAt = idx;\n        } else if (def->disks[idx]->bus == disk->bus &&\n                   insertAt == -1) {\n            /* Last disk with match bus is before the\n             * new disk, then put new disk just after\n             */\n            insertAt = idx + 1;\n        }\n    }\n\n    /* VIR_INSERT_ELEMENT_INPLACE will never return an error here. */\n    ignore_value(VIR_INSERT_ELEMENT_INPLACE(def->disks, insertAt,\n                                            def->ndisks, disk));\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDiskInsertPreAlloced(virDomainDefPtr def,\n                                   virDomainDiskDefPtr disk)\n{\n    int idx;\n    /* Tentatively plan to insert disk at the end. */\n    int insertAt = -1;\n\n    /* Then work backwards looking for disks on\n     * the same bus. If we find a disk with a drive\n     * index greater than the new one, insert at\n     * that position\n     */\n    for (idx = (def->ndisks - 1); idx >= 0; idx--) {\n        /* If bus matches and current disk is after\n         * new disk, then new disk should go here */\n        if (def->disks[idx]->bus == disk->bus &&\n            (virDiskNameToIndex(def->disks[idx]->dst) >\n             virDiskNameToIndex(disk->dst))) {\n            insertAt = idx;\n        } else if (def->disks[idx]->bus == disk->bus &&\n                   insertAt == -1) {\n            /* Last disk with match bus is before the\n             * new disk, then put new disk just after\n             */\n            insertAt = idx + 1;\n        }\n    }\n\n    /* VIR_INSERT_ELEMENT_INPLACE will never return an error here. */\n    ignore_value(VIR_INSERT_ELEMENT_INPLACE(def->disks, insertAt,\n                                            def->ndisks, disk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkGetDiskInfo",
          "args": [
            "driver",
            "hdd",
            "disk",
            "false",
            "IS_CT(def)"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetDiskInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "645-726",
          "snippet": "static int\nprlsdkGetDiskInfo(vzDriverPtr driver,\n                  PRL_HANDLE prldisk,\n                  virDomainDiskDefPtr disk,\n                  bool isCdrom,\n                  bool isCt)\n{\n    char *buf = NULL;\n    PRL_RESULT pret;\n    PRL_UINT32 emulatedType;\n    PRL_UINT32 size;\n    virDomainDeviceDriveAddressPtr address;\n    int busIdx, devIdx;\n    int ret = -1;\n\n    pret = PrlVmDev_GetEmulatedType(prldisk, &emulatedType);\n    prlsdkCheckRetGoto(pret, cleanup);\n    if (emulatedType == PDT_USE_IMAGE_FILE) {\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n        if (isCdrom) {\n            virDomainDiskSetFormat(disk, VIR_STORAGE_FILE_RAW);\n        } else {\n            if (isCt)\n                virDomainDiskSetFormat(disk, driver->vzCaps.ctDiskFormat);\n            else\n                virDomainDiskSetFormat(disk, driver->vzCaps.vmDiskFormat);\n        }\n    } else {\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_BLOCK);\n        virDomainDiskSetFormat(disk, VIR_STORAGE_FILE_RAW);\n    }\n\n    if (isCdrom) {\n        disk->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n        disk->src->readonly = true;\n    } else {\n        disk->device = VIR_DOMAIN_DISK_DEVICE_DISK;\n    }\n\n    if (!(buf = prlsdkGetStringParamVar(PrlVmDev_GetFriendlyName, prldisk)))\n        goto cleanup;\n\n    if (*buf != '\\0' && virDomainDiskSetSource(disk, buf) < 0)\n        goto cleanup;\n\n    if (prlsdkGetDiskId(prldisk, &disk->bus, &disk->dst) < 0)\n        goto cleanup;\n\n    if (virDiskNameToBusDeviceIndex(disk, &busIdx, &devIdx) < 0)\n        goto cleanup;\n\n    address = &disk->info.addr.drive;\n    address->bus = busIdx;\n    address->target = 0;\n    address->unit = devIdx;\n\n    disk->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n\n    if (!isCdrom) {\n        if (!(disk->serial = prlsdkGetStringParamVar(PrlVmDevHd_GetSerialNumber, prldisk)))\n            goto cleanup;\n\n        if (*disk->serial == '\\0')\n            VIR_FREE(disk->serial);\n    }\n\n    if (virDomainDiskSetDriver(disk, \"vz\") < 0)\n        goto cleanup;\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n        pret = PrlVmDevHd_GetDiskSize(prldisk, &size);\n        prlsdkCheckRetGoto(pret, cleanup);\n        /* from MiB to bytes */\n        disk->src->capacity = ((unsigned long long)size) << 20;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(buf);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int\nprlsdkGetDiskInfo(vzDriverPtr driver,\n                  PRL_HANDLE prldisk,\n                  virDomainDiskDefPtr disk,\n                  bool isCdrom,\n                  bool isCt)\n{\n    char *buf = NULL;\n    PRL_RESULT pret;\n    PRL_UINT32 emulatedType;\n    PRL_UINT32 size;\n    virDomainDeviceDriveAddressPtr address;\n    int busIdx, devIdx;\n    int ret = -1;\n\n    pret = PrlVmDev_GetEmulatedType(prldisk, &emulatedType);\n    prlsdkCheckRetGoto(pret, cleanup);\n    if (emulatedType == PDT_USE_IMAGE_FILE) {\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n        if (isCdrom) {\n            virDomainDiskSetFormat(disk, VIR_STORAGE_FILE_RAW);\n        } else {\n            if (isCt)\n                virDomainDiskSetFormat(disk, driver->vzCaps.ctDiskFormat);\n            else\n                virDomainDiskSetFormat(disk, driver->vzCaps.vmDiskFormat);\n        }\n    } else {\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_BLOCK);\n        virDomainDiskSetFormat(disk, VIR_STORAGE_FILE_RAW);\n    }\n\n    if (isCdrom) {\n        disk->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n        disk->src->readonly = true;\n    } else {\n        disk->device = VIR_DOMAIN_DISK_DEVICE_DISK;\n    }\n\n    if (!(buf = prlsdkGetStringParamVar(PrlVmDev_GetFriendlyName, prldisk)))\n        goto cleanup;\n\n    if (*buf != '\\0' && virDomainDiskSetSource(disk, buf) < 0)\n        goto cleanup;\n\n    if (prlsdkGetDiskId(prldisk, &disk->bus, &disk->dst) < 0)\n        goto cleanup;\n\n    if (virDiskNameToBusDeviceIndex(disk, &busIdx, &devIdx) < 0)\n        goto cleanup;\n\n    address = &disk->info.addr.drive;\n    address->bus = busIdx;\n    address->target = 0;\n    address->unit = devIdx;\n\n    disk->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n\n    if (!isCdrom) {\n        if (!(disk->serial = prlsdkGetStringParamVar(PrlVmDevHd_GetSerialNumber, prldisk)))\n            goto cleanup;\n\n        if (*disk->serial == '\\0')\n            VIR_FREE(disk->serial);\n    }\n\n    if (virDomainDiskSetDriver(disk, \"vz\") < 0)\n        goto cleanup;\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n        pret = PrlVmDevHd_GetDiskSize(prldisk, &size);\n        prlsdkCheckRetGoto(pret, cleanup);\n        /* from MiB to bytes */\n        disk->src->capacity = ((unsigned long long)size) << 20;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(buf);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "def"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskDefNew",
          "args": [
            "NULL"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2093-2114",
          "snippet": "virDomainDiskDefPtr\nvirDomainDiskDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDiskDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto error;\n\n    if (xmlopt &&\n        xmlopt->privateData.diskNew &&\n        !(ret->privateData = xmlopt->privateData.diskNew()))\n        goto error;\n\n    return ret;\n\n error:\n    virDomainDiskDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDiskDefPtr\nvirDomainDiskDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDiskDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto error;\n\n    if (xmlopt &&\n        xmlopt->privateData.diskNew &&\n        !(ret->privateData = xmlopt->privateData.diskNew()))\n        goto error;\n\n    return ret;\n\n error:\n    virDomainDiskDefFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "hdd"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainFSInsert",
          "args": [
            "def",
            "fs"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainFSInsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29805-29809",
          "snippet": "int\nvirDomainFSInsert(virDomainDefPtr def, virDomainFSDefPtr fs)\n{\n    return VIR_APPEND_ELEMENT(def->fss, def->nfss, fs);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainFSInsert(virDomainDefPtr def, virDomainFSDefPtr fs)\n{\n    return VIR_APPEND_ELEMENT(def->fss, def->nfss, fs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkGetFSInfo",
          "args": [
            "hdd",
            "fs"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetFSInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "728-801",
          "snippet": "static int\nprlsdkGetFSInfo(PRL_HANDLE prldisk,\n                virDomainFSDefPtr fs)\n{\n    char *buf = NULL;\n    int ret = -1;\n    char **matches = NULL;\n    virURIPtr uri = NULL;\n\n    fs->type = VIR_DOMAIN_FS_TYPE_FILE;\n    fs->fsdriver = VIR_DOMAIN_FS_DRIVER_TYPE_PLOOP;\n    fs->accessmode = VIR_DOMAIN_FS_ACCESSMODE_PASSTHROUGH;\n    fs->wrpolicy = VIR_DOMAIN_FS_WRPOLICY_DEFAULT;\n    fs->format = VIR_STORAGE_FILE_PLOOP;\n\n    fs->readonly = false;\n    fs->symlinksResolved = false;\n\n    if (!(buf = prlsdkGetStringParamVar(PrlVmDevHd_GetStorageURL, prldisk)))\n        goto cleanup;\n\n    if (!virStringIsEmpty(buf)) {\n        if (!(uri = virURIParse(buf)))\n            goto cleanup;\n        if (STRNEQ(\"libvirt\", uri->scheme)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown uri scheme: '%s'\"),\n                           uri->scheme);\n            goto cleanup;\n        }\n\n        if (!(matches = virStringSplitCount(uri->path, \"/\", 0, NULL)) ||\n            !matches[0]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"splitting StorageUrl failed %s\"), uri->path);\n            goto cleanup;\n        }\n        if (!matches[1]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"can't identify pool in uri %s \"), uri->path);\n            goto cleanup;\n        }\n        if (!matches[2]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"can't identify volume in uri %s\"), uri->path);\n            goto cleanup;\n        }\n        fs->type = VIR_DOMAIN_FS_TYPE_VOLUME;\n        if (VIR_ALLOC(fs->src->srcpool) < 0)\n            goto cleanup;\n        fs->src->srcpool->pool = g_strdup(matches[1]);\n        fs->src->srcpool->volume = g_strdup(matches[2]);\n        VIR_FREE(buf);\n    } else {\n        fs->type = VIR_DOMAIN_FS_TYPE_FILE;\n        if (!(buf = prlsdkGetStringParamVar(PrlVmDev_GetImagePath, prldisk)))\n            goto cleanup;\n\n        fs->src->path = buf;\n        buf = NULL;\n    }\n    if (!(buf = prlsdkGetStringParamVar(PrlVmDevHd_GetMountPoint, prldisk)))\n        goto cleanup;\n\n    fs->dst = buf;\n    buf = NULL;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(buf);\n    virStringListFree(matches);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkGetFSInfo(PRL_HANDLE prldisk,\n                virDomainFSDefPtr fs)\n{\n    char *buf = NULL;\n    int ret = -1;\n    char **matches = NULL;\n    virURIPtr uri = NULL;\n\n    fs->type = VIR_DOMAIN_FS_TYPE_FILE;\n    fs->fsdriver = VIR_DOMAIN_FS_DRIVER_TYPE_PLOOP;\n    fs->accessmode = VIR_DOMAIN_FS_ACCESSMODE_PASSTHROUGH;\n    fs->wrpolicy = VIR_DOMAIN_FS_WRPOLICY_DEFAULT;\n    fs->format = VIR_STORAGE_FILE_PLOOP;\n\n    fs->readonly = false;\n    fs->symlinksResolved = false;\n\n    if (!(buf = prlsdkGetStringParamVar(PrlVmDevHd_GetStorageURL, prldisk)))\n        goto cleanup;\n\n    if (!virStringIsEmpty(buf)) {\n        if (!(uri = virURIParse(buf)))\n            goto cleanup;\n        if (STRNEQ(\"libvirt\", uri->scheme)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown uri scheme: '%s'\"),\n                           uri->scheme);\n            goto cleanup;\n        }\n\n        if (!(matches = virStringSplitCount(uri->path, \"/\", 0, NULL)) ||\n            !matches[0]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"splitting StorageUrl failed %s\"), uri->path);\n            goto cleanup;\n        }\n        if (!matches[1]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"can't identify pool in uri %s \"), uri->path);\n            goto cleanup;\n        }\n        if (!matches[2]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"can't identify volume in uri %s\"), uri->path);\n            goto cleanup;\n        }\n        fs->type = VIR_DOMAIN_FS_TYPE_VOLUME;\n        if (VIR_ALLOC(fs->src->srcpool) < 0)\n            goto cleanup;\n        fs->src->srcpool->pool = g_strdup(matches[1]);\n        fs->src->srcpool->volume = g_strdup(matches[2]);\n        VIR_FREE(buf);\n    } else {\n        fs->type = VIR_DOMAIN_FS_TYPE_FILE;\n        if (!(buf = prlsdkGetStringParamVar(PrlVmDev_GetImagePath, prldisk)))\n            goto cleanup;\n\n        fs->src->path = buf;\n        buf = NULL;\n    }\n    if (!(buf = prlsdkGetStringParamVar(PrlVmDevHd_GetMountPoint, prldisk)))\n        goto cleanup;\n\n    fs->dst = buf;\n    buf = NULL;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(buf);\n    virStringListFree(matches);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainFSDefNew",
          "args": [
            "NULL"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainFSDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2304-2326",
          "snippet": "virDomainFSDefPtr\nvirDomainFSDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainFSDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto cleanup;\n\n    if (xmlopt &&\n        xmlopt->privateData.fsNew &&\n        !(ret->privateData = xmlopt->privateData.fsNew()))\n        goto cleanup;\n\n    return ret;\n\n cleanup:\n    virDomainFSDefFree(ret);\n    return NULL;\n\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainFSDefPtr\nvirDomainFSDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainFSDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto cleanup;\n\n    if (xmlopt &&\n        xmlopt->privateData.fsNew &&\n        !(ret->privateData = xmlopt->privateData.fsNew()))\n        goto cleanup;\n\n    return ret;\n\n cleanup:\n    virDomainFSDefFree(ret);\n    return NULL;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkInBootList",
          "args": [
            "sdkdom",
            "hdd"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkInBootList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "1595-1648",
          "snippet": "static bool\nprlsdkInBootList(PRL_HANDLE sdkdom,\n                 PRL_HANDLE sdktargetdev)\n{\n    bool ret = false;\n    PRL_RESULT pret;\n    PRL_UINT32 bootNum;\n    PRL_HANDLE bootDev = PRL_INVALID_HANDLE;\n    PRL_BOOL inUse;\n    PRL_DEVICE_TYPE sdkType, targetType;\n    PRL_UINT32 sdkIndex, targetIndex;\n    size_t i;\n\n    pret = PrlVmDev_GetType(sdktargetdev, &targetType);\n    prlsdkCheckRetExit(pret, false);\n\n    pret = PrlVmDev_GetIndex(sdktargetdev, &targetIndex);\n    prlsdkCheckRetExit(pret, false);\n\n    pret = PrlVmCfg_GetBootDevCount(sdkdom, &bootNum);\n    prlsdkCheckRetExit(pret, false);\n\n    for (i = 0; i < bootNum; ++i) {\n        pret = PrlVmCfg_GetBootDev(sdkdom, i, &bootDev);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlBootDev_IsInUse(bootDev, &inUse);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (!inUse) {\n            PrlHandle_Free(bootDev);\n            bootDev = PRL_INVALID_HANDLE;\n            continue;\n        }\n\n        pret = PrlBootDev_GetType(bootDev, &sdkType);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlBootDev_GetIndex(bootDev, &sdkIndex);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        PrlHandle_Free(bootDev);\n        bootDev = PRL_INVALID_HANDLE;\n\n        if (sdkIndex == targetIndex && sdkType == targetType) {\n            ret = true;\n            break;\n        }\n    }\n\n cleanup:\n    PrlHandle_Free(bootDev);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static bool\nprlsdkInBootList(PRL_HANDLE sdkdom,\n                 PRL_HANDLE sdktargetdev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic bool\nprlsdkInBootList(PRL_HANDLE sdkdom,\n                 PRL_HANDLE sdktargetdev);\n\nstatic bool\nprlsdkInBootList(PRL_HANDLE sdkdom,\n                 PRL_HANDLE sdktargetdev)\n{\n    bool ret = false;\n    PRL_RESULT pret;\n    PRL_UINT32 bootNum;\n    PRL_HANDLE bootDev = PRL_INVALID_HANDLE;\n    PRL_BOOL inUse;\n    PRL_DEVICE_TYPE sdkType, targetType;\n    PRL_UINT32 sdkIndex, targetIndex;\n    size_t i;\n\n    pret = PrlVmDev_GetType(sdktargetdev, &targetType);\n    prlsdkCheckRetExit(pret, false);\n\n    pret = PrlVmDev_GetIndex(sdktargetdev, &targetIndex);\n    prlsdkCheckRetExit(pret, false);\n\n    pret = PrlVmCfg_GetBootDevCount(sdkdom, &bootNum);\n    prlsdkCheckRetExit(pret, false);\n\n    for (i = 0; i < bootNum; ++i) {\n        pret = PrlVmCfg_GetBootDev(sdkdom, i, &bootDev);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlBootDev_IsInUse(bootDev, &inUse);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        if (!inUse) {\n            PrlHandle_Free(bootDev);\n            bootDev = PRL_INVALID_HANDLE;\n            continue;\n        }\n\n        pret = PrlBootDev_GetType(bootDev, &sdkType);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        pret = PrlBootDev_GetIndex(bootDev, &sdkIndex);\n        prlsdkCheckRetGoto(pret, cleanup);\n\n        PrlHandle_Free(bootDev);\n        bootDev = PRL_INVALID_HANDLE;\n\n        if (sdkIndex == targetIndex && sdkType == targetType) {\n            ret = true;\n            break;\n        }\n    }\n\n cleanup:\n    PrlHandle_Free(bootDev);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_CT",
          "args": [
            "def"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_GetEmulatedType",
          "args": [
            "hdd",
            "&emulatedType"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetHardDisk",
          "args": [
            "sdkdom",
            "i",
            "&hdd"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetHardDisksCount",
          "args": [
            "sdkdom",
            "&hddCount"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int\nprlsdkAddDomainHardDisksInfo(vzDriverPtr driver, PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 hddCount;\n    PRL_UINT32 i;\n    PRL_HANDLE hdd = PRL_INVALID_HANDLE;\n    virDomainDiskDefPtr disk = NULL;\n    virDomainFSDefPtr fs = NULL;\n\n    pret = PrlVmCfg_GetHardDisksCount(sdkdom, &hddCount);\n    prlsdkCheckRetGoto(pret, error);\n\n    for (i = 0; i < hddCount; ++i) {\n\n        PRL_UINT32 emulatedType;\n\n        pret = PrlVmCfg_GetHardDisk(sdkdom, i, &hdd);\n        prlsdkCheckRetGoto(pret, error);\n\n        pret = PrlVmDev_GetEmulatedType(hdd, &emulatedType);\n        prlsdkCheckRetGoto(pret, error);\n\n        if (IS_CT(def) &&\n            prlsdkInBootList(sdkdom, hdd)) {\n\n            if (!(fs = virDomainFSDefNew(NULL)))\n                goto error;\n\n            if (prlsdkGetFSInfo(hdd, fs) < 0)\n                goto error;\n\n            if (virDomainFSInsert(def, fs) < 0)\n                goto error;\n\n            fs = NULL;\n            PrlHandle_Free(hdd);\n            hdd = PRL_INVALID_HANDLE;\n        } else {\n            if (!(disk = virDomainDiskDefNew(NULL)))\n                goto error;\n\n            if (prlsdkGetDiskInfo(driver, hdd, disk, false, IS_CT(def)) < 0)\n                goto error;\n\n            if (virDomainDiskInsert(def, disk) < 0)\n                goto error;\n\n            disk = NULL;\n            PrlHandle_Free(hdd);\n            hdd = PRL_INVALID_HANDLE;\n        }\n    }\n\n    return 0;\n\n error:\n    PrlHandle_Free(hdd);\n    virDomainDiskDefFree(disk);\n    virDomainFSDefFree(fs);\n    return -1;\n}"
  },
  {
    "function_name": "prlsdkGetFSInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "728-801",
    "snippet": "static int\nprlsdkGetFSInfo(PRL_HANDLE prldisk,\n                virDomainFSDefPtr fs)\n{\n    char *buf = NULL;\n    int ret = -1;\n    char **matches = NULL;\n    virURIPtr uri = NULL;\n\n    fs->type = VIR_DOMAIN_FS_TYPE_FILE;\n    fs->fsdriver = VIR_DOMAIN_FS_DRIVER_TYPE_PLOOP;\n    fs->accessmode = VIR_DOMAIN_FS_ACCESSMODE_PASSTHROUGH;\n    fs->wrpolicy = VIR_DOMAIN_FS_WRPOLICY_DEFAULT;\n    fs->format = VIR_STORAGE_FILE_PLOOP;\n\n    fs->readonly = false;\n    fs->symlinksResolved = false;\n\n    if (!(buf = prlsdkGetStringParamVar(PrlVmDevHd_GetStorageURL, prldisk)))\n        goto cleanup;\n\n    if (!virStringIsEmpty(buf)) {\n        if (!(uri = virURIParse(buf)))\n            goto cleanup;\n        if (STRNEQ(\"libvirt\", uri->scheme)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown uri scheme: '%s'\"),\n                           uri->scheme);\n            goto cleanup;\n        }\n\n        if (!(matches = virStringSplitCount(uri->path, \"/\", 0, NULL)) ||\n            !matches[0]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"splitting StorageUrl failed %s\"), uri->path);\n            goto cleanup;\n        }\n        if (!matches[1]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"can't identify pool in uri %s \"), uri->path);\n            goto cleanup;\n        }\n        if (!matches[2]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"can't identify volume in uri %s\"), uri->path);\n            goto cleanup;\n        }\n        fs->type = VIR_DOMAIN_FS_TYPE_VOLUME;\n        if (VIR_ALLOC(fs->src->srcpool) < 0)\n            goto cleanup;\n        fs->src->srcpool->pool = g_strdup(matches[1]);\n        fs->src->srcpool->volume = g_strdup(matches[2]);\n        VIR_FREE(buf);\n    } else {\n        fs->type = VIR_DOMAIN_FS_TYPE_FILE;\n        if (!(buf = prlsdkGetStringParamVar(PrlVmDev_GetImagePath, prldisk)))\n            goto cleanup;\n\n        fs->src->path = buf;\n        buf = NULL;\n    }\n    if (!(buf = prlsdkGetStringParamVar(PrlVmDevHd_GetMountPoint, prldisk)))\n        goto cleanup;\n\n    fs->dst = buf;\n    buf = NULL;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(buf);\n    virStringListFree(matches);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "matches"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buf"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetStringParamVar",
          "args": [
            "PrlVmDevHd_GetMountPoint",
            "prldisk"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetStringParamVar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "299-320",
          "snippet": "static char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buf"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "matches[2]"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "fs->src->srcpool"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"can't identify volume in uri %s\")",
            "uri->path"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"can't identify pool in uri %s \")",
            "uri->path"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"splitting StorageUrl failed %s\")",
            "uri->path"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSplitCount",
          "args": [
            "uri->path",
            "\"/\"",
            "0",
            "NULL"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplitCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "69-123",
          "snippet": "char **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown uri scheme: '%s'\")",
            "uri->scheme"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "\"libvirt\"",
            "uri->scheme"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virURIParse",
          "args": [
            "buf"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "virURIParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "143-194",
          "snippet": "virURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvirURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringIsEmpty",
          "args": [
            "buf"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "virStringIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "882-890",
          "snippet": "bool\nvirStringIsEmpty(const char *str)\n{\n    if (!str)\n        return true;\n\n    virSkipSpaces(&str);\n    return str[0] == '\\0';\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nbool\nvirStringIsEmpty(const char *str)\n{\n    if (!str)\n        return true;\n\n    virSkipSpaces(&str);\n    return str[0] == '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkGetFSInfo(PRL_HANDLE prldisk,\n                virDomainFSDefPtr fs)\n{\n    char *buf = NULL;\n    int ret = -1;\n    char **matches = NULL;\n    virURIPtr uri = NULL;\n\n    fs->type = VIR_DOMAIN_FS_TYPE_FILE;\n    fs->fsdriver = VIR_DOMAIN_FS_DRIVER_TYPE_PLOOP;\n    fs->accessmode = VIR_DOMAIN_FS_ACCESSMODE_PASSTHROUGH;\n    fs->wrpolicy = VIR_DOMAIN_FS_WRPOLICY_DEFAULT;\n    fs->format = VIR_STORAGE_FILE_PLOOP;\n\n    fs->readonly = false;\n    fs->symlinksResolved = false;\n\n    if (!(buf = prlsdkGetStringParamVar(PrlVmDevHd_GetStorageURL, prldisk)))\n        goto cleanup;\n\n    if (!virStringIsEmpty(buf)) {\n        if (!(uri = virURIParse(buf)))\n            goto cleanup;\n        if (STRNEQ(\"libvirt\", uri->scheme)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown uri scheme: '%s'\"),\n                           uri->scheme);\n            goto cleanup;\n        }\n\n        if (!(matches = virStringSplitCount(uri->path, \"/\", 0, NULL)) ||\n            !matches[0]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"splitting StorageUrl failed %s\"), uri->path);\n            goto cleanup;\n        }\n        if (!matches[1]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"can't identify pool in uri %s \"), uri->path);\n            goto cleanup;\n        }\n        if (!matches[2]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"can't identify volume in uri %s\"), uri->path);\n            goto cleanup;\n        }\n        fs->type = VIR_DOMAIN_FS_TYPE_VOLUME;\n        if (VIR_ALLOC(fs->src->srcpool) < 0)\n            goto cleanup;\n        fs->src->srcpool->pool = g_strdup(matches[1]);\n        fs->src->srcpool->volume = g_strdup(matches[2]);\n        VIR_FREE(buf);\n    } else {\n        fs->type = VIR_DOMAIN_FS_TYPE_FILE;\n        if (!(buf = prlsdkGetStringParamVar(PrlVmDev_GetImagePath, prldisk)))\n            goto cleanup;\n\n        fs->src->path = buf;\n        buf = NULL;\n    }\n    if (!(buf = prlsdkGetStringParamVar(PrlVmDevHd_GetMountPoint, prldisk)))\n        goto cleanup;\n\n    fs->dst = buf;\n    buf = NULL;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(buf);\n    virStringListFree(matches);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkGetDiskInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "645-726",
    "snippet": "static int\nprlsdkGetDiskInfo(vzDriverPtr driver,\n                  PRL_HANDLE prldisk,\n                  virDomainDiskDefPtr disk,\n                  bool isCdrom,\n                  bool isCt)\n{\n    char *buf = NULL;\n    PRL_RESULT pret;\n    PRL_UINT32 emulatedType;\n    PRL_UINT32 size;\n    virDomainDeviceDriveAddressPtr address;\n    int busIdx, devIdx;\n    int ret = -1;\n\n    pret = PrlVmDev_GetEmulatedType(prldisk, &emulatedType);\n    prlsdkCheckRetGoto(pret, cleanup);\n    if (emulatedType == PDT_USE_IMAGE_FILE) {\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n        if (isCdrom) {\n            virDomainDiskSetFormat(disk, VIR_STORAGE_FILE_RAW);\n        } else {\n            if (isCt)\n                virDomainDiskSetFormat(disk, driver->vzCaps.ctDiskFormat);\n            else\n                virDomainDiskSetFormat(disk, driver->vzCaps.vmDiskFormat);\n        }\n    } else {\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_BLOCK);\n        virDomainDiskSetFormat(disk, VIR_STORAGE_FILE_RAW);\n    }\n\n    if (isCdrom) {\n        disk->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n        disk->src->readonly = true;\n    } else {\n        disk->device = VIR_DOMAIN_DISK_DEVICE_DISK;\n    }\n\n    if (!(buf = prlsdkGetStringParamVar(PrlVmDev_GetFriendlyName, prldisk)))\n        goto cleanup;\n\n    if (*buf != '\\0' && virDomainDiskSetSource(disk, buf) < 0)\n        goto cleanup;\n\n    if (prlsdkGetDiskId(prldisk, &disk->bus, &disk->dst) < 0)\n        goto cleanup;\n\n    if (virDiskNameToBusDeviceIndex(disk, &busIdx, &devIdx) < 0)\n        goto cleanup;\n\n    address = &disk->info.addr.drive;\n    address->bus = busIdx;\n    address->target = 0;\n    address->unit = devIdx;\n\n    disk->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n\n    if (!isCdrom) {\n        if (!(disk->serial = prlsdkGetStringParamVar(PrlVmDevHd_GetSerialNumber, prldisk)))\n            goto cleanup;\n\n        if (*disk->serial == '\\0')\n            VIR_FREE(disk->serial);\n    }\n\n    if (virDomainDiskSetDriver(disk, \"vz\") < 0)\n        goto cleanup;\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n        pret = PrlVmDevHd_GetDiskSize(prldisk, &size);\n        prlsdkCheckRetGoto(pret, cleanup);\n        /* from MiB to bytes */\n        disk->src->capacity = ((unsigned long long)size) << 20;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(buf);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);",
      "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buf"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDevHd_GetDiskSize",
          "args": [
            "prldisk",
            "&size"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskSetDriver",
          "args": [
            "disk",
            "\"vz\""
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskSetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2192-2199",
          "snippet": "int\nvirDomainDiskSetDriver(virDomainDiskDefPtr def, const char *name)\n{\n    char *tmp = g_strdup(name);\n    g_free(def->driverName);\n    def->driverName = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskSetDriver(virDomainDiskDefPtr def, const char *name)\n{\n    char *tmp = g_strdup(name);\n    g_free(def->driverName);\n    def->driverName = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "disk->serial"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetStringParamVar",
          "args": [
            "PrlVmDevHd_GetSerialNumber",
            "prldisk"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetStringParamVar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "299-320",
          "snippet": "static char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDiskNameToBusDeviceIndex",
          "args": [
            "disk",
            "&busIdx",
            "&devIdx"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "virDiskNameToBusDeviceIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29773-29803",
          "snippet": "int\nvirDiskNameToBusDeviceIndex(virDomainDiskDefPtr disk,\n                            int *busIdx,\n                            int *devIdx)\n{\n    int idx = virDiskNameToIndex(disk->dst);\n    if (idx < 0)\n        return -1;\n\n    switch (disk->bus) {\n        case VIR_DOMAIN_DISK_BUS_IDE:\n            *busIdx = idx / 2;\n            *devIdx = idx % 2;\n            break;\n        case VIR_DOMAIN_DISK_BUS_SCSI:\n            *busIdx = idx / 7;\n            *devIdx = idx % 7;\n            break;\n        case VIR_DOMAIN_DISK_BUS_FDC:\n        case VIR_DOMAIN_DISK_BUS_USB:\n        case VIR_DOMAIN_DISK_BUS_VIRTIO:\n        case VIR_DOMAIN_DISK_BUS_XEN:\n        case VIR_DOMAIN_DISK_BUS_SD:\n        default:\n            *busIdx = 0;\n            *devIdx = idx;\n            break;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDiskNameToBusDeviceIndex(virDomainDiskDefPtr disk,\n                            int *busIdx,\n                            int *devIdx)\n{\n    int idx = virDiskNameToIndex(disk->dst);\n    if (idx < 0)\n        return -1;\n\n    switch (disk->bus) {\n        case VIR_DOMAIN_DISK_BUS_IDE:\n            *busIdx = idx / 2;\n            *devIdx = idx % 2;\n            break;\n        case VIR_DOMAIN_DISK_BUS_SCSI:\n            *busIdx = idx / 7;\n            *devIdx = idx % 7;\n            break;\n        case VIR_DOMAIN_DISK_BUS_FDC:\n        case VIR_DOMAIN_DISK_BUS_USB:\n        case VIR_DOMAIN_DISK_BUS_VIRTIO:\n        case VIR_DOMAIN_DISK_BUS_XEN:\n        case VIR_DOMAIN_DISK_BUS_SD:\n        default:\n            *busIdx = 0;\n            *devIdx = idx;\n            break;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkGetDiskId",
          "args": [
            "prldisk",
            "&disk->bus",
            "&disk->dst"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetDiskId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "607-643",
          "snippet": "static int\nprlsdkGetDiskId(PRL_HANDLE disk, int *bus, char **dst)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 pos, ifType;\n\n    pret = PrlVmDev_GetStackIndex(disk, &pos);\n    prlsdkCheckRetExit(pret, -1);\n\n    pret = PrlVmDev_GetIfaceType(disk, &ifType);\n    prlsdkCheckRetExit(pret, -1);\n\n    switch (ifType) {\n    case PMS_IDE_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_IDE;\n        *dst = virIndexToDiskName(pos, \"hd\");\n        break;\n    case PMS_SCSI_DEVICE:\n    case PMS_UNKNOWN_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_SCSI;\n        *dst = virIndexToDiskName(pos, \"sd\");\n        break;\n    case PMS_SATA_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_SATA;\n        *dst = virIndexToDiskName(pos, \"sd\");\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown disk bus: %X\"), ifType);\n        return -1;\n    }\n\n    if (NULL == *dst)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);",
            "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int\nprlsdkGetDiskId(PRL_HANDLE disk, int *bus, char **dst)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 pos, ifType;\n\n    pret = PrlVmDev_GetStackIndex(disk, &pos);\n    prlsdkCheckRetExit(pret, -1);\n\n    pret = PrlVmDev_GetIfaceType(disk, &ifType);\n    prlsdkCheckRetExit(pret, -1);\n\n    switch (ifType) {\n    case PMS_IDE_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_IDE;\n        *dst = virIndexToDiskName(pos, \"hd\");\n        break;\n    case PMS_SCSI_DEVICE:\n    case PMS_UNKNOWN_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_SCSI;\n        *dst = virIndexToDiskName(pos, \"sd\");\n        break;\n    case PMS_SATA_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_SATA;\n        *dst = virIndexToDiskName(pos, \"sd\");\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown disk bus: %X\"), ifType);\n        return -1;\n    }\n\n    if (NULL == *dst)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskSetSource",
          "args": [
            "disk",
            "buf"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskSetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2162-2169",
          "snippet": "int\nvirDomainDiskSetSource(virDomainDiskDefPtr def, const char *src)\n{\n    char *tmp = g_strdup(src);\n    g_free(def->src->path);\n    def->src->path = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskSetSource(virDomainDiskDefPtr def, const char *src)\n{\n    char *tmp = g_strdup(src);\n    g_free(def->src->path);\n    def->src->path = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskSetFormat",
          "args": [
            "disk",
            "VIR_STORAGE_FILE_RAW"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskSetFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2209-2213",
          "snippet": "void\nvirDomainDiskSetFormat(virDomainDiskDefPtr def, int format)\n{\n    def->src->format = format;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDiskSetFormat(virDomainDiskDefPtr def, int format)\n{\n    def->src->format = format;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskSetType",
          "args": [
            "disk",
            "VIR_STORAGE_TYPE_BLOCK"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskSetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2148-2152",
          "snippet": "void\nvirDomainDiskSetType(virDomainDiskDefPtr def, int type)\n{\n    def->src->type = type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDiskSetType(virDomainDiskDefPtr def, int type)\n{\n    def->src->type = type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_GetEmulatedType",
          "args": [
            "prldisk",
            "&emulatedType"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int\nprlsdkGetDiskInfo(vzDriverPtr driver,\n                  PRL_HANDLE prldisk,\n                  virDomainDiskDefPtr disk,\n                  bool isCdrom,\n                  bool isCt)\n{\n    char *buf = NULL;\n    PRL_RESULT pret;\n    PRL_UINT32 emulatedType;\n    PRL_UINT32 size;\n    virDomainDeviceDriveAddressPtr address;\n    int busIdx, devIdx;\n    int ret = -1;\n\n    pret = PrlVmDev_GetEmulatedType(prldisk, &emulatedType);\n    prlsdkCheckRetGoto(pret, cleanup);\n    if (emulatedType == PDT_USE_IMAGE_FILE) {\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n        if (isCdrom) {\n            virDomainDiskSetFormat(disk, VIR_STORAGE_FILE_RAW);\n        } else {\n            if (isCt)\n                virDomainDiskSetFormat(disk, driver->vzCaps.ctDiskFormat);\n            else\n                virDomainDiskSetFormat(disk, driver->vzCaps.vmDiskFormat);\n        }\n    } else {\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_BLOCK);\n        virDomainDiskSetFormat(disk, VIR_STORAGE_FILE_RAW);\n    }\n\n    if (isCdrom) {\n        disk->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n        disk->src->readonly = true;\n    } else {\n        disk->device = VIR_DOMAIN_DISK_DEVICE_DISK;\n    }\n\n    if (!(buf = prlsdkGetStringParamVar(PrlVmDev_GetFriendlyName, prldisk)))\n        goto cleanup;\n\n    if (*buf != '\\0' && virDomainDiskSetSource(disk, buf) < 0)\n        goto cleanup;\n\n    if (prlsdkGetDiskId(prldisk, &disk->bus, &disk->dst) < 0)\n        goto cleanup;\n\n    if (virDiskNameToBusDeviceIndex(disk, &busIdx, &devIdx) < 0)\n        goto cleanup;\n\n    address = &disk->info.addr.drive;\n    address->bus = busIdx;\n    address->target = 0;\n    address->unit = devIdx;\n\n    disk->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n\n    if (!isCdrom) {\n        if (!(disk->serial = prlsdkGetStringParamVar(PrlVmDevHd_GetSerialNumber, prldisk)))\n            goto cleanup;\n\n        if (*disk->serial == '\\0')\n            VIR_FREE(disk->serial);\n    }\n\n    if (virDomainDiskSetDriver(disk, \"vz\") < 0)\n        goto cleanup;\n\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n        pret = PrlVmDevHd_GetDiskSize(prldisk, &size);\n        prlsdkCheckRetGoto(pret, cleanup);\n        /* from MiB to bytes */\n        disk->src->capacity = ((unsigned long long)size) << 20;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(buf);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkGetDiskId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "607-643",
    "snippet": "static int\nprlsdkGetDiskId(PRL_HANDLE disk, int *bus, char **dst)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 pos, ifType;\n\n    pret = PrlVmDev_GetStackIndex(disk, &pos);\n    prlsdkCheckRetExit(pret, -1);\n\n    pret = PrlVmDev_GetIfaceType(disk, &ifType);\n    prlsdkCheckRetExit(pret, -1);\n\n    switch (ifType) {\n    case PMS_IDE_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_IDE;\n        *dst = virIndexToDiskName(pos, \"hd\");\n        break;\n    case PMS_SCSI_DEVICE:\n    case PMS_UNKNOWN_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_SCSI;\n        *dst = virIndexToDiskName(pos, \"sd\");\n        break;\n    case PMS_SATA_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_SATA;\n        *dst = virIndexToDiskName(pos, \"sd\");\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown disk bus: %X\"), ifType);\n        return -1;\n    }\n\n    if (NULL == *dst)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);",
      "static PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown disk bus: %X\")",
            "ifType"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown disk bus: %X\""
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virIndexToDiskName",
          "args": [
            "pos",
            "\"sd\""
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "virIndexToDiskName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "436-463",
          "snippet": "char *virIndexToDiskName(int idx, const char *prefix)\n{\n    char *name = NULL;\n    size_t i;\n    int ctr;\n    int offset;\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Disk index %d is negative\"), idx);\n        return NULL;\n    }\n\n    for (i = 0, ctr = idx; ctr >= 0; ++i, ctr = ctr / 26 - 1) { }\n\n    offset = strlen(prefix);\n\n    if (VIR_ALLOC_N(name, offset + i + 1))\n        return NULL;\n\n    strcpy(name, prefix);\n    name[offset + i] = '\\0';\n\n    for (i = i - 1, ctr = idx; ctr >= 0; --i, ctr = ctr / 26 - 1)\n        name[offset + i] = 'a' + (ctr % 26);\n\n    return name;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virIndexToDiskName(int idx, const char *prefix)\n{\n    char *name = NULL;\n    size_t i;\n    int ctr;\n    int offset;\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Disk index %d is negative\"), idx);\n        return NULL;\n    }\n\n    for (i = 0, ctr = idx; ctr >= 0; ++i, ctr = ctr / 26 - 1) { }\n\n    offset = strlen(prefix);\n\n    if (VIR_ALLOC_N(name, offset + i + 1))\n        return NULL;\n\n    strcpy(name, prefix);\n    name[offset + i] = '\\0';\n\n    for (i = i - 1, ctr = idx; ctr >= 0; --i, ctr = ctr / 26 - 1)\n        name[offset + i] = 'a' + (ctr % 26);\n\n    return name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_GetIfaceType",
          "args": [
            "disk",
            "&ifType"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmDev_GetStackIndex",
          "args": [
            "disk",
            "&pos"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\nstatic PRL_HANDLE\nprlsdkGetDisk(PRL_HANDLE sdkdom, virDomainDiskDefPtr disk);\n\nstatic int\nprlsdkGetDiskId(PRL_HANDLE disk, int *bus, char **dst)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 pos, ifType;\n\n    pret = PrlVmDev_GetStackIndex(disk, &pos);\n    prlsdkCheckRetExit(pret, -1);\n\n    pret = PrlVmDev_GetIfaceType(disk, &ifType);\n    prlsdkCheckRetExit(pret, -1);\n\n    switch (ifType) {\n    case PMS_IDE_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_IDE;\n        *dst = virIndexToDiskName(pos, \"hd\");\n        break;\n    case PMS_SCSI_DEVICE:\n    case PMS_UNKNOWN_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_SCSI;\n        *dst = virIndexToDiskName(pos, \"sd\");\n        break;\n    case PMS_SATA_DEVICE:\n        *bus = VIR_DOMAIN_DISK_BUS_SATA;\n        *dst = virIndexToDiskName(pos, \"sd\");\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown disk bus: %X\"), ifType);\n        return -1;\n    }\n\n    if (NULL == *dst)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkAddDomainVideoInfoVm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "573-605",
    "snippet": "static int\nprlsdkAddDomainVideoInfoVm(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    virDomainVideoDefPtr video = NULL;\n    virDomainVideoAccelDefPtr accel = NULL;\n    PRL_RESULT ret;\n    PRL_UINT32 videoRam;\n\n    /* video info */\n    ret = PrlVmCfg_GetVideoRamSize(sdkdom, &videoRam);\n    prlsdkCheckRetGoto(ret, error);\n\n    if (VIR_ALLOC(video) < 0)\n        goto error;\n\n    if (VIR_ALLOC(accel) < 0)\n        goto error;\n\n    if (VIR_APPEND_ELEMENT_COPY(def->videos, def->nvideos, video) < 0)\n        goto error;\n\n    video->type = VIR_DOMAIN_VIDEO_TYPE_VGA;\n    video->vram = videoRam << 10; /* from mbibytes to kbibytes */\n    video->heads = 1;\n    video->accel = accel;\n\n    return 0;\n\n error:\n    VIR_FREE(accel);\n    virDomainVideoDefFree(video);\n    return -1;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainVideoDefFree",
          "args": [
            "video"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVideoDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2879-2886",
          "snippet": "void virDomainVideoDefFree(virDomainVideoDefPtr def)\n{\n    if (!def)\n        return;\n\n    virDomainVideoDefClear(def);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def)\n{\n    if (!def)\n        return;\n\n    virDomainVideoDefClear(def);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "accel"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT_COPY",
          "args": [
            "def->videos",
            "def->nvideos",
            "video"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "accel"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "video"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "ret",
            "error"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmCfg_GetVideoRamSize",
          "args": [
            "sdkdom",
            "&videoRam"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkAddDomainVideoInfoVm(PRL_HANDLE sdkdom, virDomainDefPtr def)\n{\n    virDomainVideoDefPtr video = NULL;\n    virDomainVideoAccelDefPtr accel = NULL;\n    PRL_RESULT ret;\n    PRL_UINT32 videoRam;\n\n    /* video info */\n    ret = PrlVmCfg_GetVideoRamSize(sdkdom, &videoRam);\n    prlsdkCheckRetGoto(ret, error);\n\n    if (VIR_ALLOC(video) < 0)\n        goto error;\n\n    if (VIR_ALLOC(accel) < 0)\n        goto error;\n\n    if (VIR_APPEND_ELEMENT_COPY(def->videos, def->nvideos, video) < 0)\n        goto error;\n\n    video->type = VIR_DOMAIN_VIDEO_TYPE_VGA;\n    video->vram = videoRam << 10; /* from mbibytes to kbibytes */\n    video->heads = 1;\n    video->accel = accel;\n\n    return 0;\n\n error:\n    VIR_FREE(accel);\n    virDomainVideoDefFree(video);\n    return -1;\n}"
  },
  {
    "function_name": "prlsdkAddDomainVideoInfoCt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "547-571",
    "snippet": "static int\nprlsdkAddDomainVideoInfoCt(virDomainDefPtr def,\n                           virDomainXMLOptionPtr xmlopt)\n{\n    virDomainVideoDefPtr video = NULL;\n    int ret = -1;\n\n    if (def->ngraphics == 0)\n        return 0;\n\n    if (!(video = virDomainVideoDefNew(xmlopt)))\n        goto cleanup;\n\n    video->type = VIR_DOMAIN_VIDEO_TYPE_PARALLELS;\n    video->vram = 0;\n\n    if (VIR_APPEND_ELEMENT(def->videos, def->nvideos, video) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virDomainVideoDefFree(video);\n\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainVideoDefFree",
          "args": [
            "video"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVideoDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2879-2886",
          "snippet": "void virDomainVideoDefFree(virDomainVideoDefPtr def)\n{\n    if (!def)\n        return;\n\n    virDomainVideoDefClear(def);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def)\n{\n    if (!def)\n        return;\n\n    virDomainVideoDefClear(def);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->videos",
            "def->nvideos",
            "video"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVideoDefNew",
          "args": [
            "xmlopt"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVideoDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2838-2854",
          "snippet": "virDomainVideoDefPtr\nvirDomainVideoDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainVideoDefPtr def;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (xmlopt && xmlopt->privateData.videoNew &&\n        !(def->privateData = xmlopt->privateData.videoNew())) {\n        VIR_FREE(def);\n        return NULL;\n    }\n\n    def->heads = 1;\n    return def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainVideoDefPtr\nvirDomainVideoDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainVideoDefPtr def;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (xmlopt && xmlopt->privateData.videoNew &&\n        !(def->privateData = xmlopt->privateData.videoNew())) {\n        VIR_FREE(def);\n        return NULL;\n    }\n\n    def->heads = 1;\n    return def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkAddDomainVideoInfoCt(virDomainDefPtr def,\n                           virDomainXMLOptionPtr xmlopt)\n{\n    virDomainVideoDefPtr video = NULL;\n    int ret = -1;\n\n    if (def->ngraphics == 0)\n        return 0;\n\n    if (!(video = virDomainVideoDefNew(xmlopt)))\n        goto cleanup;\n\n    video->type = VIR_DOMAIN_VIDEO_TYPE_PARALLELS;\n    video->vram = 0;\n\n    if (VIR_APPEND_ELEMENT(def->videos, def->nvideos, video) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virDomainVideoDefFree(video);\n\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkGetDomainState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "519-545",
    "snippet": "static int\nprlsdkGetDomainState(virDomainObjPtr dom, PRL_HANDLE sdkdom, VIRTUAL_MACHINE_STATE_PTR vmState)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_HANDLE vmInfo = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    int ret = -1;\n\n    job = PrlVm_GetState(sdkdom);\n\n    if (PRL_FAILED(getDomainJobResult(job, dom, &result)))\n        goto cleanup;\n\n    pret = PrlResult_GetParamByIndex(result, 0, &vmInfo);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmInfo_GetState(vmInfo, vmState);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(vmInfo);\n    PrlHandle_Free(result);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "result"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "vmInfo"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVmInfo_GetState",
          "args": [
            "vmInfo",
            "vmState"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlResult_GetParamByIndex",
          "args": [
            "result",
            "0",
            "&vmInfo"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "getDomainJobResult(job, dom, &result)"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getDomainJobResult",
          "args": [
            "job",
            "dom",
            "&result"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlVm_GetState",
          "args": [
            "sdkdom"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkGetDomainState(virDomainObjPtr dom, PRL_HANDLE sdkdom, VIRTUAL_MACHINE_STATE_PTR vmState)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_HANDLE vmInfo = PRL_INVALID_HANDLE;\n    PRL_RESULT pret;\n    int ret = -1;\n\n    job = PrlVm_GetState(sdkdom);\n\n    if (PRL_FAILED(getDomainJobResult(job, dom, &result)))\n        goto cleanup;\n\n    pret = PrlResult_GetParamByIndex(result, 0, &vmInfo);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    pret = PrlVmInfo_GetState(vmInfo, vmState);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(vmInfo);\n    PrlHandle_Free(result);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkUUIDParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "496-517",
    "snippet": "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    char *tmp = NULL;\n    int ret = -1;\n\n    virCheckNonNullArgGoto(uuidstr, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    tmp = g_strdup(uuidstr);\n\n    tmp[strlen(tmp) - 1] = '\\0';\n\n    /* trim curly braces */\n    if (virUUIDParse(tmp + 1, uuid) < 0)\n        goto error;\n\n    ret = 0;\n error:\n    VIR_FREE(tmp);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "tmp + 1",
            "uuid"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "uuidstr"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgGoto",
          "args": [
            "uuid",
            "error"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgGoto",
          "args": [
            "uuidstr",
            "error"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    char *tmp = NULL;\n    int ret = -1;\n\n    virCheckNonNullArgGoto(uuidstr, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    tmp = g_strdup(uuidstr);\n\n    tmp[strlen(tmp) - 1] = '\\0';\n\n    /* trim curly braces */\n    if (virUUIDParse(tmp + 1, uuid) < 0)\n        goto error;\n\n    ret = 0;\n error:\n    VIR_FREE(tmp);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkSdkDomainLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "481-494",
    "snippet": "PRL_HANDLE\nprlsdkSdkDomainLookupByName(vzDriverPtr driver, const char *name)\n{\n    PRL_HANDLE sdkdom = PRL_INVALID_HANDLE;\n\n    if (prlsdkSdkDomainLookup(driver, name,\n                              PGVC_SEARCH_BY_NAME, &sdkdom) < 0) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching name '%s'\"), name);\n        return PRL_INVALID_HANDLE;\n    }\n\n    return sdkdom;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "_(\"no domain with matching name '%s'\")",
            "name"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no domain with matching name '%s'\""
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkSdkDomainLookup",
          "args": [
            "driver",
            "name",
            "PGVC_SEARCH_BY_NAME",
            "&sdkdom"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkSdkDomainLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "427-450",
          "snippet": "static int\nprlsdkSdkDomainLookup(vzDriverPtr driver,\n                      const char *id,\n                      unsigned int flags,\n                      PRL_HANDLE *sdkdom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_RESULT pret = PRL_ERR_UNINITIALIZED;\n    int ret = -1;\n\n    job = PrlSrv_GetVmConfig(driver->server, id, flags);\n    if (PRL_FAILED(getJobResult(job, &result)))\n        goto cleanup;\n\n    pret = PrlResult_GetParamByIndex(result, 0, sdkdom);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(result);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkSdkDomainLookup(vzDriverPtr driver,\n                      const char *id,\n                      unsigned int flags,\n                      PRL_HANDLE *sdkdom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_RESULT pret = PRL_ERR_UNINITIALIZED;\n    int ret = -1;\n\n    job = PrlSrv_GetVmConfig(driver->server, id, flags);\n    if (PRL_FAILED(getJobResult(job, &result)))\n        goto cleanup;\n\n    pret = PrlResult_GetParamByIndex(result, 0, sdkdom);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(result);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nPRL_HANDLE\nprlsdkSdkDomainLookupByName(vzDriverPtr driver, const char *name)\n{\n    PRL_HANDLE sdkdom = PRL_INVALID_HANDLE;\n\n    if (prlsdkSdkDomainLookup(driver, name,\n                              PGVC_SEARCH_BY_NAME, &sdkdom) < 0) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching name '%s'\"), name);\n        return PRL_INVALID_HANDLE;\n    }\n\n    return sdkdom;\n}"
  },
  {
    "function_name": "prlsdkSdkDomainLookupByUUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "462-479",
    "snippet": "static PRL_HANDLE\nprlsdkSdkDomainLookupByUUID(vzDriverPtr driver, const unsigned char *uuid)\n{\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n    PRL_HANDLE sdkdom = PRL_INVALID_HANDLE;\n\n    prlsdkUUIDFormat(uuid, uuidstr);\n\n    if (prlsdkSdkDomainLookup(driver, uuidstr,\n                              PGVC_SEARCH_BY_UUID, &sdkdom) < 0) {\n        virUUIDFormat(uuid, uuidstr);\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching uuid '%s'\"), uuidstr);\n        return PRL_INVALID_HANDLE;\n    }\n\n    return sdkdom;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "_(\"no domain with matching uuid '%s'\")",
            "uuidstr"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no domain with matching uuid '%s'\""
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "uuid",
            "uuidstr"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkSdkDomainLookup",
          "args": [
            "driver",
            "uuidstr",
            "PGVC_SEARCH_BY_UUID",
            "&sdkdom"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkSdkDomainLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "427-450",
          "snippet": "static int\nprlsdkSdkDomainLookup(vzDriverPtr driver,\n                      const char *id,\n                      unsigned int flags,\n                      PRL_HANDLE *sdkdom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_RESULT pret = PRL_ERR_UNINITIALIZED;\n    int ret = -1;\n\n    job = PrlSrv_GetVmConfig(driver->server, id, flags);\n    if (PRL_FAILED(getJobResult(job, &result)))\n        goto cleanup;\n\n    pret = PrlResult_GetParamByIndex(result, 0, sdkdom);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(result);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprlsdkConvertError(PRL_RESULT pret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkSdkDomainLookup(vzDriverPtr driver,\n                      const char *id,\n                      unsigned int flags,\n                      PRL_HANDLE *sdkdom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_RESULT pret = PRL_ERR_UNINITIALIZED;\n    int ret = -1;\n\n    job = PrlSrv_GetVmConfig(driver->server, id, flags);\n    if (PRL_FAILED(getJobResult(job, &result)))\n        goto cleanup;\n\n    pret = PrlResult_GetParamByIndex(result, 0, sdkdom);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(result);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkUUIDFormat",
          "args": [
            "uuid",
            "uuidstr"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "452-460",
          "snippet": "static void\nprlsdkUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    virUUIDFormat(uuid, uuidstr + 1);\n\n    uuidstr[0] = '{';\n    uuidstr[VIR_UUID_STRING_BUFLEN] = '}';\n    uuidstr[VIR_UUID_STRING_BUFLEN + 1] = '\\0';\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic void\nprlsdkUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    virUUIDFormat(uuid, uuidstr + 1);\n\n    uuidstr[0] = '{';\n    uuidstr[VIR_UUID_STRING_BUFLEN] = '}';\n    uuidstr[VIR_UUID_STRING_BUFLEN + 1] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic PRL_HANDLE\nprlsdkSdkDomainLookupByUUID(vzDriverPtr driver, const unsigned char *uuid)\n{\n    char uuidstr[VIR_UUID_STRING_BRACED_BUFLEN];\n    PRL_HANDLE sdkdom = PRL_INVALID_HANDLE;\n\n    prlsdkUUIDFormat(uuid, uuidstr);\n\n    if (prlsdkSdkDomainLookup(driver, uuidstr,\n                              PGVC_SEARCH_BY_UUID, &sdkdom) < 0) {\n        virUUIDFormat(uuid, uuidstr);\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching uuid '%s'\"), uuidstr);\n        return PRL_INVALID_HANDLE;\n    }\n\n    return sdkdom;\n}"
  },
  {
    "function_name": "prlsdkUUIDFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "452-460",
    "snippet": "static void\nprlsdkUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    virUUIDFormat(uuid, uuidstr + 1);\n\n    uuidstr[0] = '{';\n    uuidstr[VIR_UUID_STRING_BUFLEN] = '}';\n    uuidstr[VIR_UUID_STRING_BUFLEN + 1] = '\\0';\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "uuid",
            "uuidstr + 1"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic void\nprlsdkUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    virUUIDFormat(uuid, uuidstr + 1);\n\n    uuidstr[0] = '{';\n    uuidstr[VIR_UUID_STRING_BUFLEN] = '}';\n    uuidstr[VIR_UUID_STRING_BUFLEN + 1] = '\\0';\n}"
  },
  {
    "function_name": "prlsdkSdkDomainLookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "427-450",
    "snippet": "static int\nprlsdkSdkDomainLookup(vzDriverPtr driver,\n                      const char *id,\n                      unsigned int flags,\n                      PRL_HANDLE *sdkdom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_RESULT pret = PRL_ERR_UNINITIALIZED;\n    int ret = -1;\n\n    job = PrlSrv_GetVmConfig(driver->server, id, flags);\n    if (PRL_FAILED(getJobResult(job, &result)))\n        goto cleanup;\n\n    pret = PrlResult_GetParamByIndex(result, 0, sdkdom);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(result);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "result"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "cleanup"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlResult_GetParamByIndex",
          "args": [
            "result",
            "0",
            "sdkdom"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "getJobResult(job, &result)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getJobResult",
          "args": [
            "job",
            "&result"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlSrv_GetVmConfig",
          "args": [
            "driver->server",
            "id",
            "flags"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic int\nprlsdkSdkDomainLookup(vzDriverPtr driver,\n                      const char *id,\n                      unsigned int flags,\n                      PRL_HANDLE *sdkdom)\n{\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_RESULT pret = PRL_ERR_UNINITIALIZED;\n    int ret = -1;\n\n    job = PrlSrv_GetVmConfig(driver->server, id, flags);\n    if (PRL_FAILED(getJobResult(job, &result)))\n        goto cleanup;\n\n    pret = PrlResult_GetParamByIndex(result, 0, sdkdom);\n    prlsdkCheckRetGoto(pret, cleanup);\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(result);\n    return ret;\n}"
  },
  {
    "function_name": "prlsdkDisconnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "405-425",
    "snippet": "void\nprlsdkDisconnect(vzDriverPtr driver)\n{\n    PRL_HANDLE job;\n    PRL_RESULT ret;\n\n    if (driver->server == PRL_INVALID_HANDLE)\n        return;\n\n    ret = PrlSrv_UnregEventHandler(driver->server,\n                                   prlsdkEventsHandler,\n                                   driver);\n    if (PRL_FAILED(ret))\n        logPrlError(ret);\n\n    job = PrlSrv_Logoff(driver->server);\n    waitJob(job);\n\n    PrlHandle_Free(driver->server);\n    driver->server = PRL_INVALID_HANDLE;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "driver->server"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitJob",
          "args": [
            "job"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlSrv_Logoff",
          "args": [
            "driver->server"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logPrlError",
          "args": [
            "ret"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "ret"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlSrv_UnregEventHandler",
          "args": [
            "driver->server",
            "prlsdkEventsHandler",
            "driver"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nprlsdkDisconnect(vzDriverPtr driver)\n{\n    PRL_HANDLE job;\n    PRL_RESULT ret;\n\n    if (driver->server == PRL_INVALID_HANDLE)\n        return;\n\n    ret = PrlSrv_UnregEventHandler(driver->server,\n                                   prlsdkEventsHandler,\n                                   driver);\n    if (PRL_FAILED(ret))\n        logPrlError(ret);\n\n    job = PrlSrv_Logoff(driver->server);\n    waitJob(job);\n\n    PrlHandle_Free(driver->server);\n    driver->server = PRL_INVALID_HANDLE;\n}"
  },
  {
    "function_name": "prlsdkConnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "353-403",
    "snippet": "int\nprlsdkConnect(vzDriverPtr driver)\n{\n    int ret = -1;\n    PRL_RESULT pret;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_HANDLE response = PRL_INVALID_HANDLE;\n    char session_uuid[VIR_UUID_STRING_BRACED_BUFLEN];\n\n    pret = PrlSrv_Create(&driver->server);\n    prlsdkCheckRetExit(pret, -1);\n\n    job = PrlSrv_LoginLocalEx(driver->server, NULL, 0,\n                              PSL_HIGH_SECURITY, PACF_NON_INTERACTIVE_MODE);\n    if (PRL_FAILED(getJobResult(job, &result)))\n        goto destroy;\n\n    pret = PrlResult_GetParam(result, &response);\n    prlsdkCheckRetGoto(pret, logoff);\n\n    pret = prlsdkGetStringParamBuf(PrlLoginResponse_GetSessionUuid,\n                                   response, session_uuid, sizeof(session_uuid));\n    prlsdkCheckRetGoto(pret, logoff);\n\n    if (prlsdkUUIDParse(session_uuid, driver->session_uuid) < 0)\n        goto logoff;\n\n    pret = PrlSrv_RegEventHandler(driver->server,\n                                  prlsdkEventsHandler,\n                                  driver);\n    prlsdkCheckRetGoto(pret, logoff);\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(result);\n    PrlHandle_Free(response);\n\n    return ret;\n\n logoff:\n    job = PrlSrv_Logoff(driver->server);\n    waitJob(job);\n\n destroy:\n    PrlHandle_Free(driver->server);\n    driver->server = PRL_INVALID_HANDLE;\n\n    goto cleanup;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "driver->server"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitJob",
          "args": [
            "job"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlSrv_Logoff",
          "args": [
            "driver->server"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "response"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "result"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "logoff"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlSrv_RegEventHandler",
          "args": [
            "driver->server",
            "prlsdkEventsHandler",
            "driver"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkUUIDParse",
          "args": [
            "session_uuid",
            "driver->session_uuid"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "496-517",
          "snippet": "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    char *tmp = NULL;\n    int ret = -1;\n\n    virCheckNonNullArgGoto(uuidstr, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    tmp = g_strdup(uuidstr);\n\n    tmp[strlen(tmp) - 1] = '\\0';\n\n    /* trim curly braces */\n    if (virUUIDParse(tmp + 1, uuid) < 0)\n        goto error;\n\n    ret = 0;\n error:\n    VIR_FREE(tmp);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid);\n\nstatic int\nprlsdkUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    char *tmp = NULL;\n    int ret = -1;\n\n    virCheckNonNullArgGoto(uuidstr, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    tmp = g_strdup(uuidstr);\n\n    tmp[strlen(tmp) - 1] = '\\0';\n\n    /* trim curly braces */\n    if (virUUIDParse(tmp + 1, uuid) < 0)\n        goto error;\n\n    ret = 0;\n error:\n    VIR_FREE(tmp);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "logoff"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkGetStringParamBuf",
          "args": [
            "PrlLoginResponse_GetSessionUuid",
            "response",
            "session_uuid",
            "sizeof(session_uuid)"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "prlsdkGetStringParamBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "322-328",
          "snippet": "static PRL_RESULT\nprlsdkGetStringParamBuf(prlsdkParamGetterType getter,\n                        PRL_HANDLE handle, char *buf, size_t size)\n{\n    PRL_UINT32 buflen = size;\n    return getter(handle, buf, &buflen);\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_RESULT\nprlsdkGetStringParamBuf(prlsdkParamGetterType getter,\n                        PRL_HANDLE handle, char *buf, size_t size)\n{\n    PRL_UINT32 buflen = size;\n    return getter(handle, buf, &buflen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "logoff"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlResult_GetParam",
          "args": [
            "result",
            "&response"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "getJobResult(job, &result)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getJobResult",
          "args": [
            "job",
            "&result"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlSrv_LoginLocalEx",
          "args": [
            "driver->server",
            "NULL",
            "0",
            "PSL_HIGH_SECURITY",
            "PACF_NON_INTERACTIVE_MODE"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetExit",
          "args": [
            "pret",
            "-1"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlSrv_Create",
          "args": [
            "&driver->server"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nint\nprlsdkConnect(vzDriverPtr driver)\n{\n    int ret = -1;\n    PRL_RESULT pret;\n    PRL_HANDLE job = PRL_INVALID_HANDLE;\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_HANDLE response = PRL_INVALID_HANDLE;\n    char session_uuid[VIR_UUID_STRING_BRACED_BUFLEN];\n\n    pret = PrlSrv_Create(&driver->server);\n    prlsdkCheckRetExit(pret, -1);\n\n    job = PrlSrv_LoginLocalEx(driver->server, NULL, 0,\n                              PSL_HIGH_SECURITY, PACF_NON_INTERACTIVE_MODE);\n    if (PRL_FAILED(getJobResult(job, &result)))\n        goto destroy;\n\n    pret = PrlResult_GetParam(result, &response);\n    prlsdkCheckRetGoto(pret, logoff);\n\n    pret = prlsdkGetStringParamBuf(PrlLoginResponse_GetSessionUuid,\n                                   response, session_uuid, sizeof(session_uuid));\n    prlsdkCheckRetGoto(pret, logoff);\n\n    if (prlsdkUUIDParse(session_uuid, driver->session_uuid) < 0)\n        goto logoff;\n\n    pret = PrlSrv_RegEventHandler(driver->server,\n                                  prlsdkEventsHandler,\n                                  driver);\n    prlsdkCheckRetGoto(pret, logoff);\n\n    ret = 0;\n\n cleanup:\n    PrlHandle_Free(result);\n    PrlHandle_Free(response);\n\n    return ret;\n\n logoff:\n    job = PrlSrv_Logoff(driver->server);\n    waitJob(job);\n\n destroy:\n    PrlHandle_Free(driver->server);\n    driver->server = PRL_INVALID_HANDLE;\n\n    goto cleanup;\n}"
  },
  {
    "function_name": "prlsdkDeinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "347-351",
    "snippet": "void\nprlsdkDeinit(void)\n{\n    PrlApi_Deinit();\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlApi_Deinit",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nprlsdkDeinit(void)\n{\n    PrlApi_Deinit();\n}"
  },
  {
    "function_name": "prlsdkInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "330-345",
    "snippet": "int\nprlsdkInit(void)\n{\n    PRL_RESULT ret;\n\n    /* Disable console output */\n    PrlApi_SwitchConsoleLogging(0);\n\n    ret = PrlApi_InitEx(PARALLELS_API_VER, PAM_SERVER, 0, 0);\n    if (PRL_FAILED(ret)) {\n        logPrlError(ret);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logPrlError",
          "args": [
            "ret"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "ret"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlApi_InitEx",
          "args": [
            "PARALLELS_API_VER",
            "PAM_SERVER",
            "0",
            "0"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlApi_SwitchConsoleLogging",
          "args": [
            "0"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nprlsdkInit(void)\n{\n    PRL_RESULT ret;\n\n    /* Disable console output */\n    PrlApi_SwitchConsoleLogging(0);\n\n    ret = PrlApi_InitEx(PARALLELS_API_VER, PAM_SERVER, 0, 0);\n    if (PRL_FAILED(ret)) {\n        logPrlError(ret);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "prlsdkGetStringParamBuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "322-328",
    "snippet": "static PRL_RESULT\nprlsdkGetStringParamBuf(prlsdkParamGetterType getter,\n                        PRL_HANDLE handle, char *buf, size_t size)\n{\n    PRL_UINT32 buflen = size;\n    return getter(handle, buf, &buflen);\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getter",
          "args": [
            "handle",
            "buf",
            "&buflen"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_RESULT\nprlsdkGetStringParamBuf(prlsdkParamGetterType getter,\n                        PRL_HANDLE handle, char *buf, size_t size)\n{\n    PRL_UINT32 buflen = size;\n    return getter(handle, buf, &buflen);\n}"
  },
  {
    "function_name": "prlsdkGetStringParamVar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "299-320",
    "snippet": "static char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getter",
          "args": [
            "handle",
            "str",
            "&buflen"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "str",
            "buflen"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prlsdkCheckRetGoto",
          "args": [
            "pret",
            "error"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getter",
          "args": [
            "handle",
            "NULL",
            "&buflen"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic char*\nprlsdkGetStringParamVar(prlsdkParamGetterType getter, PRL_HANDLE handle)\n{\n    PRL_RESULT pret;\n    PRL_UINT32 buflen = 0;\n    char *str = NULL;\n\n    pret = getter(handle, NULL, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    if (VIR_ALLOC_N(str, buflen) < 0)\n        goto error;\n\n    pret = getter(handle, str, &buflen);\n    prlsdkCheckRetGoto(pret, error);\n\n    return str;\n\n error:\n    VIR_FREE(str);\n    return NULL;\n}"
  },
  {
    "function_name": "prlsdkCancelJob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "275-297",
    "snippet": "int\nprlsdkCancelJob(virDomainObjPtr dom)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n    PRL_HANDLE job;\n\n    if (!privdom->job.active) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"no job is active on the domain\"));\n        return -1;\n    }\n\n   privdom->job.cancelled = true;\n   job = PrlJob_Cancel(privdom->job.sdkJob);\n\n   virObjectUnlock(dom);\n   pret = waitJobHelper(job, JOB_INFINIT_WAIT_TIMEOUT,\n                        __FILE__, __FUNCTION__, __LINE__);\n   virObjectLock(dom);\n\n   return PRL_FAILED(pret) ? -1 : 0;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define JOB_INFINIT_WAIT_TIMEOUT UINT_MAX"
    ],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "pret"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "dom"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitJobHelper",
          "args": [
            "job",
            "JOB_INFINIT_WAIT_TIMEOUT",
            "__FILE__",
            "__FUNCTION__",
            "__LINE__"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "waitJobHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "226-238",
          "snippet": "static PRL_RESULT\nwaitJobHelper(PRL_HANDLE job, unsigned int timeout,\n              const char *filename, const char *funcname,\n              size_t linenr)\n{\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_RESULT ret;\n\n    ret = getJobResultHelper(job, timeout, &result,\n                             filename, funcname, linenr);\n    PrlHandle_Free(result);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_RESULT\nwaitJobHelper(PRL_HANDLE job, unsigned int timeout,\n              const char *filename, const char *funcname,\n              size_t linenr)\n{\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_RESULT ret;\n\n    ret = getJobResultHelper(job, timeout, &result,\n                             filename, funcname, linenr);\n    PrlHandle_Free(result);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "dom"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlJob_Cancel",
          "args": [
            "privdom->job.sdkJob"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"no job is active on the domain\")"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no job is active on the domain\""
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define JOB_INFINIT_WAIT_TIMEOUT UINT_MAX\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nint\nprlsdkCancelJob(virDomainObjPtr dom)\n{\n    vzDomObjPtr privdom = dom->privateData;\n    PRL_RESULT pret;\n    PRL_HANDLE job;\n\n    if (!privdom->job.active) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"no job is active on the domain\"));\n        return -1;\n    }\n\n   privdom->job.cancelled = true;\n   job = PrlJob_Cancel(privdom->job.sdkJob);\n\n   virObjectUnlock(dom);\n   pret = waitJobHelper(job, JOB_INFINIT_WAIT_TIMEOUT,\n                        __FILE__, __FUNCTION__, __LINE__);\n   virObjectLock(dom);\n\n   return PRL_FAILED(pret) ? -1 : 0;\n}"
  },
  {
    "function_name": "waitDomainJobHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "244-267",
    "snippet": "static PRL_RESULT\nwaitDomainJobHelper(PRL_HANDLE job, virDomainObjPtr dom, unsigned int timeout,\n                    const char *filename, const char *funcname,\n                    size_t linenr)\n{\n    vzDomObjPtr pdom = dom->privateData;\n    PRL_RESULT ret;\n\n    if (pdom->job.cancelled) {\n        virReportError(VIR_ERR_OPERATION_ABORTED, \"%s\",\n                       _(\"Operation cancelled by client\"));\n        return PRL_ERR_FAILURE;\n    }\n\n    pdom->job.sdkJob = job;\n    if (dom)\n        virObjectUnlock(dom);\n    ret = waitJobHelper(job, timeout, filename, funcname, linenr);\n    if (dom)\n        virObjectLock(dom);\n    pdom->job.sdkJob = NULL;\n\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "dom"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitJobHelper",
          "args": [
            "job",
            "timeout",
            "filename",
            "funcname",
            "linenr"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "waitJobHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "226-238",
          "snippet": "static PRL_RESULT\nwaitJobHelper(PRL_HANDLE job, unsigned int timeout,\n              const char *filename, const char *funcname,\n              size_t linenr)\n{\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_RESULT ret;\n\n    ret = getJobResultHelper(job, timeout, &result,\n                             filename, funcname, linenr);\n    PrlHandle_Free(result);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_RESULT\nwaitJobHelper(PRL_HANDLE job, unsigned int timeout,\n              const char *filename, const char *funcname,\n              size_t linenr)\n{\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_RESULT ret;\n\n    ret = getJobResultHelper(job, timeout, &result,\n                             filename, funcname, linenr);\n    PrlHandle_Free(result);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "dom"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_ABORTED",
            "\"%s\"",
            "_(\"Operation cancelled by client\")"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Operation cancelled by client\""
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_RESULT\nwaitDomainJobHelper(PRL_HANDLE job, virDomainObjPtr dom, unsigned int timeout,\n                    const char *filename, const char *funcname,\n                    size_t linenr)\n{\n    vzDomObjPtr pdom = dom->privateData;\n    PRL_RESULT ret;\n\n    if (pdom->job.cancelled) {\n        virReportError(VIR_ERR_OPERATION_ABORTED, \"%s\",\n                       _(\"Operation cancelled by client\"));\n        return PRL_ERR_FAILURE;\n    }\n\n    pdom->job.sdkJob = job;\n    if (dom)\n        virObjectUnlock(dom);\n    ret = waitJobHelper(job, timeout, filename, funcname, linenr);\n    if (dom)\n        virObjectLock(dom);\n    pdom->job.sdkJob = NULL;\n\n    return ret;\n}"
  },
  {
    "function_name": "waitJobHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "226-238",
    "snippet": "static PRL_RESULT\nwaitJobHelper(PRL_HANDLE job, unsigned int timeout,\n              const char *filename, const char *funcname,\n              size_t linenr)\n{\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_RESULT ret;\n\n    ret = getJobResultHelper(job, timeout, &result,\n                             filename, funcname, linenr);\n    PrlHandle_Free(result);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "result"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getJobResultHelper",
          "args": [
            "job",
            "timeout",
            "&result",
            "filename",
            "funcname",
            "linenr"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "getJobResultHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "145-199",
          "snippet": "static PRL_RESULT\ngetJobResultHelper(PRL_HANDLE job, unsigned int timeout, PRL_HANDLE *result,\n                   const char *filename, const char *funcname,\n                   size_t linenr)\n{\n    PRL_RESULT ret, retCode;\n\n    if (PRL_FAILED(ret = PrlJob_Wait(job, timeout))) {\n        logPrlErrorHelper(ret, filename, funcname, linenr);\n        goto cleanup;\n    }\n\n    if (PRL_FAILED(ret = PrlJob_GetRetCode(job, &retCode))) {\n        logPrlErrorHelper(ret, filename, funcname, linenr);\n        goto cleanup;\n    }\n\n    if (retCode) {\n        PRL_HANDLE err_handle;\n\n        ret = retCode;\n\n        /* Sometimes it's possible to get additional error info. */\n        if (PRL_FAILED(retCode = PrlJob_GetError(job, &err_handle))) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            goto cleanup;\n        }\n\n        if (PRL_FAILED(retCode = PrlEvent_GetErrCode(err_handle, &retCode))) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            if (PRL_ERR_NO_DATA != retCode)\n                logPrlError(retCode);\n            PrlHandle_Free(err_handle);\n            goto cleanup;\n        }\n\n        logPrlEventErrorHelper(err_handle, filename, funcname, linenr);\n\n        PrlHandle_Free(err_handle);\n    } else {\n        ret = PrlJob_GetResult(job, result);\n        if (PRL_FAILED(ret)) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            PrlHandle_Free(*result);\n            *result = NULL;\n            goto cleanup;\n        }\n\n        ret = PRL_ERR_SUCCESS;\n    }\n\n cleanup:\n    PrlHandle_Free(job);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_RESULT\ngetJobResultHelper(PRL_HANDLE job, unsigned int timeout, PRL_HANDLE *result,\n                   const char *filename, const char *funcname,\n                   size_t linenr)\n{\n    PRL_RESULT ret, retCode;\n\n    if (PRL_FAILED(ret = PrlJob_Wait(job, timeout))) {\n        logPrlErrorHelper(ret, filename, funcname, linenr);\n        goto cleanup;\n    }\n\n    if (PRL_FAILED(ret = PrlJob_GetRetCode(job, &retCode))) {\n        logPrlErrorHelper(ret, filename, funcname, linenr);\n        goto cleanup;\n    }\n\n    if (retCode) {\n        PRL_HANDLE err_handle;\n\n        ret = retCode;\n\n        /* Sometimes it's possible to get additional error info. */\n        if (PRL_FAILED(retCode = PrlJob_GetError(job, &err_handle))) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            goto cleanup;\n        }\n\n        if (PRL_FAILED(retCode = PrlEvent_GetErrCode(err_handle, &retCode))) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            if (PRL_ERR_NO_DATA != retCode)\n                logPrlError(retCode);\n            PrlHandle_Free(err_handle);\n            goto cleanup;\n        }\n\n        logPrlEventErrorHelper(err_handle, filename, funcname, linenr);\n\n        PrlHandle_Free(err_handle);\n    } else {\n        ret = PrlJob_GetResult(job, result);\n        if (PRL_FAILED(ret)) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            PrlHandle_Free(*result);\n            *result = NULL;\n            goto cleanup;\n        }\n\n        ret = PRL_ERR_SUCCESS;\n    }\n\n cleanup:\n    PrlHandle_Free(job);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_RESULT\nwaitJobHelper(PRL_HANDLE job, unsigned int timeout,\n              const char *filename, const char *funcname,\n              size_t linenr)\n{\n    PRL_HANDLE result = PRL_INVALID_HANDLE;\n    PRL_RESULT ret;\n\n    ret = getJobResultHelper(job, timeout, &result,\n                             filename, funcname, linenr);\n    PrlHandle_Free(result);\n    return ret;\n}"
  },
  {
    "function_name": "getDomainJobResultHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "205-220",
    "snippet": "static PRL_RESULT\ngetDomainJobResultHelper(PRL_HANDLE job, virDomainObjPtr dom,\n                         unsigned int timeout, PRL_HANDLE *result,\n                         const char *filename, const char *funcname,\n                         size_t linenr)\n{\n    PRL_RESULT pret;\n\n    if (dom)\n        virObjectUnlock(dom);\n    pret = getJobResultHelper(job, timeout, result, filename, funcname, linenr);\n    if (dom)\n        virObjectLock(dom);\n\n    return pret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprlsdkConvertError(PRL_RESULT pret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "dom"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getJobResultHelper",
          "args": [
            "job",
            "timeout",
            "result",
            "filename",
            "funcname",
            "linenr"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "getJobResultHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "145-199",
          "snippet": "static PRL_RESULT\ngetJobResultHelper(PRL_HANDLE job, unsigned int timeout, PRL_HANDLE *result,\n                   const char *filename, const char *funcname,\n                   size_t linenr)\n{\n    PRL_RESULT ret, retCode;\n\n    if (PRL_FAILED(ret = PrlJob_Wait(job, timeout))) {\n        logPrlErrorHelper(ret, filename, funcname, linenr);\n        goto cleanup;\n    }\n\n    if (PRL_FAILED(ret = PrlJob_GetRetCode(job, &retCode))) {\n        logPrlErrorHelper(ret, filename, funcname, linenr);\n        goto cleanup;\n    }\n\n    if (retCode) {\n        PRL_HANDLE err_handle;\n\n        ret = retCode;\n\n        /* Sometimes it's possible to get additional error info. */\n        if (PRL_FAILED(retCode = PrlJob_GetError(job, &err_handle))) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            goto cleanup;\n        }\n\n        if (PRL_FAILED(retCode = PrlEvent_GetErrCode(err_handle, &retCode))) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            if (PRL_ERR_NO_DATA != retCode)\n                logPrlError(retCode);\n            PrlHandle_Free(err_handle);\n            goto cleanup;\n        }\n\n        logPrlEventErrorHelper(err_handle, filename, funcname, linenr);\n\n        PrlHandle_Free(err_handle);\n    } else {\n        ret = PrlJob_GetResult(job, result);\n        if (PRL_FAILED(ret)) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            PrlHandle_Free(*result);\n            *result = NULL;\n            goto cleanup;\n        }\n\n        ret = PRL_ERR_SUCCESS;\n    }\n\n cleanup:\n    PrlHandle_Free(job);\n    return ret;\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_RESULT\ngetJobResultHelper(PRL_HANDLE job, unsigned int timeout, PRL_HANDLE *result,\n                   const char *filename, const char *funcname,\n                   size_t linenr)\n{\n    PRL_RESULT ret, retCode;\n\n    if (PRL_FAILED(ret = PrlJob_Wait(job, timeout))) {\n        logPrlErrorHelper(ret, filename, funcname, linenr);\n        goto cleanup;\n    }\n\n    if (PRL_FAILED(ret = PrlJob_GetRetCode(job, &retCode))) {\n        logPrlErrorHelper(ret, filename, funcname, linenr);\n        goto cleanup;\n    }\n\n    if (retCode) {\n        PRL_HANDLE err_handle;\n\n        ret = retCode;\n\n        /* Sometimes it's possible to get additional error info. */\n        if (PRL_FAILED(retCode = PrlJob_GetError(job, &err_handle))) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            goto cleanup;\n        }\n\n        if (PRL_FAILED(retCode = PrlEvent_GetErrCode(err_handle, &retCode))) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            if (PRL_ERR_NO_DATA != retCode)\n                logPrlError(retCode);\n            PrlHandle_Free(err_handle);\n            goto cleanup;\n        }\n\n        logPrlEventErrorHelper(err_handle, filename, funcname, linenr);\n\n        PrlHandle_Free(err_handle);\n    } else {\n        ret = PrlJob_GetResult(job, result);\n        if (PRL_FAILED(ret)) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            PrlHandle_Free(*result);\n            *result = NULL;\n            goto cleanup;\n        }\n\n        ret = PRL_ERR_SUCCESS;\n    }\n\n cleanup:\n    PrlHandle_Free(job);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "dom"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nprlsdkConvertError(PRL_RESULT pret);\n\nstatic PRL_RESULT\ngetDomainJobResultHelper(PRL_HANDLE job, virDomainObjPtr dom,\n                         unsigned int timeout, PRL_HANDLE *result,\n                         const char *filename, const char *funcname,\n                         size_t linenr)\n{\n    PRL_RESULT pret;\n\n    if (dom)\n        virObjectUnlock(dom);\n    pret = getJobResultHelper(job, timeout, result, filename, funcname, linenr);\n    if (dom)\n        virObjectLock(dom);\n\n    return pret;\n}"
  },
  {
    "function_name": "getJobResultHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "145-199",
    "snippet": "static PRL_RESULT\ngetJobResultHelper(PRL_HANDLE job, unsigned int timeout, PRL_HANDLE *result,\n                   const char *filename, const char *funcname,\n                   size_t linenr)\n{\n    PRL_RESULT ret, retCode;\n\n    if (PRL_FAILED(ret = PrlJob_Wait(job, timeout))) {\n        logPrlErrorHelper(ret, filename, funcname, linenr);\n        goto cleanup;\n    }\n\n    if (PRL_FAILED(ret = PrlJob_GetRetCode(job, &retCode))) {\n        logPrlErrorHelper(ret, filename, funcname, linenr);\n        goto cleanup;\n    }\n\n    if (retCode) {\n        PRL_HANDLE err_handle;\n\n        ret = retCode;\n\n        /* Sometimes it's possible to get additional error info. */\n        if (PRL_FAILED(retCode = PrlJob_GetError(job, &err_handle))) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            goto cleanup;\n        }\n\n        if (PRL_FAILED(retCode = PrlEvent_GetErrCode(err_handle, &retCode))) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            if (PRL_ERR_NO_DATA != retCode)\n                logPrlError(retCode);\n            PrlHandle_Free(err_handle);\n            goto cleanup;\n        }\n\n        logPrlEventErrorHelper(err_handle, filename, funcname, linenr);\n\n        PrlHandle_Free(err_handle);\n    } else {\n        ret = PrlJob_GetResult(job, result);\n        if (PRL_FAILED(ret)) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            PrlHandle_Free(*result);\n            *result = NULL;\n            goto cleanup;\n        }\n\n        ret = PRL_ERR_SUCCESS;\n    }\n\n cleanup:\n    PrlHandle_Free(job);\n    return ret;\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "job"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "*result"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logPrlErrorHelper",
          "args": [
            "ret",
            "filename",
            "funcname",
            "linenr"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "logPrlErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "63-94",
          "snippet": "static void\nlogPrlErrorHelper(PRL_RESULT err, const char *filename,\n                  const char *funcname, size_t linenr)\n{\n    char *msg1 = NULL, *msg2 = NULL;\n    PRL_UINT32 len = 0;\n\n    /* Get required buffer length */\n    PrlApi_GetResultDescription(err, PRL_TRUE, PRL_FALSE, NULL, &len);\n\n    if (VIR_ALLOC_N(msg1, len) < 0)\n        goto cleanup;\n\n    /* get short error description */\n    PrlApi_GetResultDescription(err, PRL_TRUE, PRL_FALSE, msg1, &len);\n\n    PrlApi_GetResultDescription(err, PRL_FALSE, PRL_FALSE, NULL, &len);\n\n    if (VIR_ALLOC_N(msg2, len) < 0)\n        goto cleanup;\n\n    /* get long error description */\n    PrlApi_GetResultDescription(err, PRL_FALSE, PRL_FALSE, msg2, &len);\n\n    virReportErrorHelper(VIR_FROM_THIS, VIR_ERR_INTERNAL_ERROR,\n                         filename, funcname, linenr,\n                         _(\"%s %s\"), msg1, msg2);\n\n cleanup:\n    VIR_FREE(msg1);\n    VIR_FREE(msg2);\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_FROM_THIS VIR_FROM_PARALLELS"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define VIR_FROM_THIS VIR_FROM_PARALLELS\n\nstatic void\nlogPrlErrorHelper(PRL_RESULT err, const char *filename,\n                  const char *funcname, size_t linenr)\n{\n    char *msg1 = NULL, *msg2 = NULL;\n    PRL_UINT32 len = 0;\n\n    /* Get required buffer length */\n    PrlApi_GetResultDescription(err, PRL_TRUE, PRL_FALSE, NULL, &len);\n\n    if (VIR_ALLOC_N(msg1, len) < 0)\n        goto cleanup;\n\n    /* get short error description */\n    PrlApi_GetResultDescription(err, PRL_TRUE, PRL_FALSE, msg1, &len);\n\n    PrlApi_GetResultDescription(err, PRL_FALSE, PRL_FALSE, NULL, &len);\n\n    if (VIR_ALLOC_N(msg2, len) < 0)\n        goto cleanup;\n\n    /* get long error description */\n    PrlApi_GetResultDescription(err, PRL_FALSE, PRL_FALSE, msg2, &len);\n\n    virReportErrorHelper(VIR_FROM_THIS, VIR_ERR_INTERNAL_ERROR,\n                         filename, funcname, linenr,\n                         _(\"%s %s\"), msg1, msg2);\n\n cleanup:\n    VIR_FREE(msg1);\n    VIR_FREE(msg2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "ret"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlJob_GetResult",
          "args": [
            "job",
            "result"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "err_handle"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logPrlEventErrorHelper",
          "args": [
            "err_handle",
            "filename",
            "funcname",
            "linenr"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "logPrlEventErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
          "lines": "116-143",
          "snippet": "static void\nlogPrlEventErrorHelper(PRL_HANDLE event, const char *filename,\n                       const char *funcname, size_t linenr)\n{\n    char *msg1 = NULL, *msg2 = NULL;\n    PRL_UINT32 len = 0;\n\n    PrlEvent_GetErrString(event, PRL_TRUE, PRL_FALSE, NULL, &len);\n\n    if (VIR_ALLOC_N(msg1, len) < 0)\n        goto cleanup;\n\n    PrlEvent_GetErrString(event, PRL_TRUE, PRL_FALSE, msg1, &len);\n\n    PrlEvent_GetErrString(event, PRL_FALSE, PRL_FALSE, NULL, &len);\n\n    if (VIR_ALLOC_N(msg2, len) < 0)\n        goto cleanup;\n\n    PrlEvent_GetErrString(event, PRL_FALSE, PRL_FALSE, msg2, &len);\n\n    virReportErrorHelper(VIR_FROM_THIS, VIR_ERR_INTERNAL_ERROR,\n                         filename, funcname, linenr,\n                         _(\"%s %s\"), msg1, msg2);\n cleanup:\n    VIR_FREE(msg1);\n    VIR_FREE(msg2);\n}",
          "includes": [
            "#include \"vz_sdk.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtime.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_FROM_THIS VIR_FROM_PARALLELS"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define VIR_FROM_THIS VIR_FROM_PARALLELS\n\nstatic void\nlogPrlEventErrorHelper(PRL_HANDLE event, const char *filename,\n                       const char *funcname, size_t linenr)\n{\n    char *msg1 = NULL, *msg2 = NULL;\n    PRL_UINT32 len = 0;\n\n    PrlEvent_GetErrString(event, PRL_TRUE, PRL_FALSE, NULL, &len);\n\n    if (VIR_ALLOC_N(msg1, len) < 0)\n        goto cleanup;\n\n    PrlEvent_GetErrString(event, PRL_TRUE, PRL_FALSE, msg1, &len);\n\n    PrlEvent_GetErrString(event, PRL_FALSE, PRL_FALSE, NULL, &len);\n\n    if (VIR_ALLOC_N(msg2, len) < 0)\n        goto cleanup;\n\n    PrlEvent_GetErrString(event, PRL_FALSE, PRL_FALSE, msg2, &len);\n\n    virReportErrorHelper(VIR_FROM_THIS, VIR_ERR_INTERNAL_ERROR,\n                         filename, funcname, linenr,\n                         _(\"%s %s\"), msg1, msg2);\n cleanup:\n    VIR_FREE(msg1);\n    VIR_FREE(msg2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlHandle_Free",
          "args": [
            "err_handle"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logPrlError",
          "args": [
            "retCode"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "retCode = PrlEvent_GetErrCode(err_handle, &retCode)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlEvent_GetErrCode",
          "args": [
            "err_handle",
            "&retCode"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "retCode = PrlJob_GetError(job, &err_handle)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlJob_GetError",
          "args": [
            "job",
            "&err_handle"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "ret = PrlJob_GetRetCode(job, &retCode)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlJob_GetRetCode",
          "args": [
            "job",
            "&retCode"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRL_FAILED",
          "args": [
            "ret = PrlJob_Wait(job, timeout)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlJob_Wait",
          "args": [
            "job",
            "timeout"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic PRL_RESULT\ngetJobResultHelper(PRL_HANDLE job, unsigned int timeout, PRL_HANDLE *result,\n                   const char *filename, const char *funcname,\n                   size_t linenr)\n{\n    PRL_RESULT ret, retCode;\n\n    if (PRL_FAILED(ret = PrlJob_Wait(job, timeout))) {\n        logPrlErrorHelper(ret, filename, funcname, linenr);\n        goto cleanup;\n    }\n\n    if (PRL_FAILED(ret = PrlJob_GetRetCode(job, &retCode))) {\n        logPrlErrorHelper(ret, filename, funcname, linenr);\n        goto cleanup;\n    }\n\n    if (retCode) {\n        PRL_HANDLE err_handle;\n\n        ret = retCode;\n\n        /* Sometimes it's possible to get additional error info. */\n        if (PRL_FAILED(retCode = PrlJob_GetError(job, &err_handle))) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            goto cleanup;\n        }\n\n        if (PRL_FAILED(retCode = PrlEvent_GetErrCode(err_handle, &retCode))) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            if (PRL_ERR_NO_DATA != retCode)\n                logPrlError(retCode);\n            PrlHandle_Free(err_handle);\n            goto cleanup;\n        }\n\n        logPrlEventErrorHelper(err_handle, filename, funcname, linenr);\n\n        PrlHandle_Free(err_handle);\n    } else {\n        ret = PrlJob_GetResult(job, result);\n        if (PRL_FAILED(ret)) {\n            logPrlErrorHelper(ret, filename, funcname, linenr);\n            PrlHandle_Free(*result);\n            *result = NULL;\n            goto cleanup;\n        }\n\n        ret = PRL_ERR_SUCCESS;\n    }\n\n cleanup:\n    PrlHandle_Free(job);\n    return ret;\n}"
  },
  {
    "function_name": "logPrlEventErrorHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "116-143",
    "snippet": "static void\nlogPrlEventErrorHelper(PRL_HANDLE event, const char *filename,\n                       const char *funcname, size_t linenr)\n{\n    char *msg1 = NULL, *msg2 = NULL;\n    PRL_UINT32 len = 0;\n\n    PrlEvent_GetErrString(event, PRL_TRUE, PRL_FALSE, NULL, &len);\n\n    if (VIR_ALLOC_N(msg1, len) < 0)\n        goto cleanup;\n\n    PrlEvent_GetErrString(event, PRL_TRUE, PRL_FALSE, msg1, &len);\n\n    PrlEvent_GetErrString(event, PRL_FALSE, PRL_FALSE, NULL, &len);\n\n    if (VIR_ALLOC_N(msg2, len) < 0)\n        goto cleanup;\n\n    PrlEvent_GetErrString(event, PRL_FALSE, PRL_FALSE, msg2, &len);\n\n    virReportErrorHelper(VIR_FROM_THIS, VIR_ERR_INTERNAL_ERROR,\n                         filename, funcname, linenr,\n                         _(\"%s %s\"), msg1, msg2);\n cleanup:\n    VIR_FREE(msg1);\n    VIR_FREE(msg2);\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VIR_FROM_THIS VIR_FROM_PARALLELS"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "msg2"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "msg1"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportErrorHelper",
          "args": [
            "VIR_FROM_THIS",
            "VIR_ERR_INTERNAL_ERROR",
            "filename",
            "funcname",
            "linenr",
            "_(\"%s %s\")",
            "msg1",
            "msg2"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s %s\""
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlEvent_GetErrString",
          "args": [
            "event",
            "PRL_FALSE",
            "PRL_FALSE",
            "msg2",
            "&len"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "msg2",
            "len"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlEvent_GetErrString",
          "args": [
            "event",
            "PRL_FALSE",
            "PRL_FALSE",
            "NULL",
            "&len"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlEvent_GetErrString",
          "args": [
            "event",
            "PRL_TRUE",
            "PRL_FALSE",
            "msg1",
            "&len"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "msg1",
            "len"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlEvent_GetErrString",
          "args": [
            "event",
            "PRL_TRUE",
            "PRL_FALSE",
            "NULL",
            "&len"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define VIR_FROM_THIS VIR_FROM_PARALLELS\n\nstatic void\nlogPrlEventErrorHelper(PRL_HANDLE event, const char *filename,\n                       const char *funcname, size_t linenr)\n{\n    char *msg1 = NULL, *msg2 = NULL;\n    PRL_UINT32 len = 0;\n\n    PrlEvent_GetErrString(event, PRL_TRUE, PRL_FALSE, NULL, &len);\n\n    if (VIR_ALLOC_N(msg1, len) < 0)\n        goto cleanup;\n\n    PrlEvent_GetErrString(event, PRL_TRUE, PRL_FALSE, msg1, &len);\n\n    PrlEvent_GetErrString(event, PRL_FALSE, PRL_FALSE, NULL, &len);\n\n    if (VIR_ALLOC_N(msg2, len) < 0)\n        goto cleanup;\n\n    PrlEvent_GetErrString(event, PRL_FALSE, PRL_FALSE, msg2, &len);\n\n    virReportErrorHelper(VIR_FROM_THIS, VIR_ERR_INTERNAL_ERROR,\n                         filename, funcname, linenr,\n                         _(\"%s %s\"), msg1, msg2);\n cleanup:\n    VIR_FREE(msg1);\n    VIR_FREE(msg2);\n}"
  },
  {
    "function_name": "logPrlErrorHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vz/vz_sdk.c",
    "lines": "63-94",
    "snippet": "static void\nlogPrlErrorHelper(PRL_RESULT err, const char *filename,\n                  const char *funcname, size_t linenr)\n{\n    char *msg1 = NULL, *msg2 = NULL;\n    PRL_UINT32 len = 0;\n\n    /* Get required buffer length */\n    PrlApi_GetResultDescription(err, PRL_TRUE, PRL_FALSE, NULL, &len);\n\n    if (VIR_ALLOC_N(msg1, len) < 0)\n        goto cleanup;\n\n    /* get short error description */\n    PrlApi_GetResultDescription(err, PRL_TRUE, PRL_FALSE, msg1, &len);\n\n    PrlApi_GetResultDescription(err, PRL_FALSE, PRL_FALSE, NULL, &len);\n\n    if (VIR_ALLOC_N(msg2, len) < 0)\n        goto cleanup;\n\n    /* get long error description */\n    PrlApi_GetResultDescription(err, PRL_FALSE, PRL_FALSE, msg2, &len);\n\n    virReportErrorHelper(VIR_FROM_THIS, VIR_ERR_INTERNAL_ERROR,\n                         filename, funcname, linenr,\n                         _(\"%s %s\"), msg1, msg2);\n\n cleanup:\n    VIR_FREE(msg1);\n    VIR_FREE(msg2);\n}",
    "includes": [
      "#include \"vz_sdk.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virtime.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VIR_FROM_THIS VIR_FROM_PARALLELS"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "msg2"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "msg1"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportErrorHelper",
          "args": [
            "VIR_FROM_THIS",
            "VIR_ERR_INTERNAL_ERROR",
            "filename",
            "funcname",
            "linenr",
            "_(\"%s %s\")",
            "msg1",
            "msg2"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s %s\""
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrlApi_GetResultDescription",
          "args": [
            "err",
            "PRL_FALSE",
            "PRL_FALSE",
            "msg2",
            "&len"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "msg2",
            "len"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlApi_GetResultDescription",
          "args": [
            "err",
            "PRL_FALSE",
            "PRL_FALSE",
            "NULL",
            "&len"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlApi_GetResultDescription",
          "args": [
            "err",
            "PRL_TRUE",
            "PRL_FALSE",
            "msg1",
            "&len"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "msg1",
            "len"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrlApi_GetResultDescription",
          "args": [
            "err",
            "PRL_TRUE",
            "PRL_FALSE",
            "NULL",
            "&len"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vz_sdk.h\"\n#include \"virutil.h\"\n#include \"virsocketaddr.h\"\n#include \"virhostcpu.h\"\n#include \"virtime.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\n#define VIR_FROM_THIS VIR_FROM_PARALLELS\n\nstatic void\nlogPrlErrorHelper(PRL_RESULT err, const char *filename,\n                  const char *funcname, size_t linenr)\n{\n    char *msg1 = NULL, *msg2 = NULL;\n    PRL_UINT32 len = 0;\n\n    /* Get required buffer length */\n    PrlApi_GetResultDescription(err, PRL_TRUE, PRL_FALSE, NULL, &len);\n\n    if (VIR_ALLOC_N(msg1, len) < 0)\n        goto cleanup;\n\n    /* get short error description */\n    PrlApi_GetResultDescription(err, PRL_TRUE, PRL_FALSE, msg1, &len);\n\n    PrlApi_GetResultDescription(err, PRL_FALSE, PRL_FALSE, NULL, &len);\n\n    if (VIR_ALLOC_N(msg2, len) < 0)\n        goto cleanup;\n\n    /* get long error description */\n    PrlApi_GetResultDescription(err, PRL_FALSE, PRL_FALSE, msg2, &len);\n\n    virReportErrorHelper(VIR_FROM_THIS, VIR_ERR_INTERNAL_ERROR,\n                         filename, funcname, linenr,\n                         _(\"%s %s\"), msg1, msg2);\n\n cleanup:\n    VIR_FREE(msg1);\n    VIR_FREE(msg2);\n}"
  }
]