[
  {
    "function_name": "virURIGetParam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
    "lines": "380-393",
    "snippet": "const char *\nvirURIGetParam(virURIPtr uri, const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        if (STREQ(uri->params[i].name, name))\n            return uri->params[i].value;\n    }\n\n    virReportError(VIR_ERR_INVALID_ARG,\n                   _(\"Missing URI parameter '%s'\"), name);\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruri.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Missing URI parameter '%s'\")",
            "name"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing URI parameter '%s'\""
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "uri->params[i].name",
            "name"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nconst char *\nvirURIGetParam(virURIPtr uri, const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        if (STREQ(uri->params[i].name, name))\n            return uri->params[i].value;\n    }\n\n    virReportError(VIR_ERR_INVALID_ARG,\n                   _(\"Missing URI parameter '%s'\"), name);\n    return NULL;\n}"
  },
  {
    "function_name": "virURIResolveAlias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
    "lines": "358-377",
    "snippet": "int\nvirURIResolveAlias(virConfPtr conf, const char *alias, char **uri)\n{\n    int ret = -1;\n    char **aliases = NULL;\n\n    *uri = NULL;\n\n    if (virConfGetValueStringList(conf, \"uri_aliases\", false, &aliases) < 0)\n        return -1;\n\n    if (aliases && *aliases) {\n        ret = virURIFindAliasMatch(aliases, alias, uri);\n        virStringListFree(aliases);\n    } else {\n        ret = 0;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruri.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "aliases"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virURIFindAliasMatch",
          "args": [
            "aliases",
            "alias",
            "uri"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "virURIFindAliasMatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "303-344",
          "snippet": "static int\nvirURIFindAliasMatch(char *const*aliases, const char *alias,\n                     char **uri)\n{\n    size_t alias_len;\n\n    alias_len = strlen(alias);\n    while (*aliases) {\n        char *offset;\n        size_t safe;\n\n        if (!(offset = strchr(*aliases, '='))) {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Malformed 'uri_aliases' config entry '%s', \"\n                             \"expected 'alias=uri://host/path'\"), *aliases);\n            return -1;\n        }\n\n        safe = strspn(*aliases, URI_ALIAS_CHARS);\n        if (safe < (offset - *aliases)) {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Malformed 'uri_aliases' config entry '%s', \"\n                             \"aliases may only contain 'a-Z, 0-9, _, -'\"),\n                           *aliases);\n            return -1;\n        }\n\n        if (alias_len == (offset - *aliases) &&\n            STREQLEN(*aliases, alias, alias_len)) {\n            VIR_DEBUG(\"Resolved alias '%s' to '%s'\",\n                      alias, offset+1);\n            *uri = g_strdup(offset + 1);\n            return 0;\n        }\n\n        aliases++;\n    }\n\n    VIR_DEBUG(\"No alias found for '%s', continuing...\",\n              alias);\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define URI_ALIAS_CHARS \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\n#define URI_ALIAS_CHARS \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-\"\n\nstatic int\nvirURIFindAliasMatch(char *const*aliases, const char *alias,\n                     char **uri)\n{\n    size_t alias_len;\n\n    alias_len = strlen(alias);\n    while (*aliases) {\n        char *offset;\n        size_t safe;\n\n        if (!(offset = strchr(*aliases, '='))) {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Malformed 'uri_aliases' config entry '%s', \"\n                             \"expected 'alias=uri://host/path'\"), *aliases);\n            return -1;\n        }\n\n        safe = strspn(*aliases, URI_ALIAS_CHARS);\n        if (safe < (offset - *aliases)) {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Malformed 'uri_aliases' config entry '%s', \"\n                             \"aliases may only contain 'a-Z, 0-9, _, -'\"),\n                           *aliases);\n            return -1;\n        }\n\n        if (alias_len == (offset - *aliases) &&\n            STREQLEN(*aliases, alias, alias_len)) {\n            VIR_DEBUG(\"Resolved alias '%s' to '%s'\",\n                      alias, offset+1);\n            *uri = g_strdup(offset + 1);\n            return 0;\n        }\n\n        aliases++;\n    }\n\n    VIR_DEBUG(\"No alias found for '%s', continuing...\",\n              alias);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValueStringList",
          "args": [
            "conf",
            "\"uri_aliases\"",
            "false",
            "&aliases"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueStringList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "920-984",
          "snippet": "int virConfGetValueStringList(virConfPtr conf,\n                              const char *setting,\n                              bool compatString,\n                              char ***values)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    size_t len;\n    virConfValuePtr eval;\n\n    VIR_DEBUG(\"Get value string list %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    virStringListFree(*values);\n    *values = NULL;\n\n    switch (cval->type) {\n    case VIR_CONF_LIST:\n        /* Calc length and check items */\n        for (len = 0, eval = cval->list; eval; len++, eval = eval->next) {\n            if (eval->type != VIR_CONF_STRING) {\n                virReportError(VIR_ERR_CONF_SYNTAX,\n                               _(\"%s: expected a string list for '%s' parameter\"),\n                               conf->filename, setting);\n                return -1;\n            }\n        }\n\n        if (VIR_ALLOC_N(*values, len + 1) < 0)\n            return -1;\n\n        for (len = 0, eval = cval->list; eval; len++, eval = eval->next)\n            (*values)[len] = g_strdup(eval->str);\n        break;\n\n    case VIR_CONF_STRING:\n        if (compatString) {\n            if (VIR_ALLOC_N(*values, cval->str ? 2 : 1) < 0)\n                return -1;\n            if (cval->str)\n                (*values)[0] = g_strdup(cval->str);\n            break;\n        }\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_CONF_LLONG:\n    case VIR_CONF_ULLONG:\n    case VIR_CONF_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       compatString ?\n                       _(\"%s: expected a string or string list for '%s' parameter\") :\n                       _(\"%s: expected a string list for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n\n    case VIR_CONF_LAST:\n    default:\n        virReportEnumRangeError(virConfType, cval->type);\n        return -1;\n    }\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueStringList(virConfPtr conf,\n                              const char *setting,\n                              bool compatString,\n                              char ***values)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    size_t len;\n    virConfValuePtr eval;\n\n    VIR_DEBUG(\"Get value string list %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    virStringListFree(*values);\n    *values = NULL;\n\n    switch (cval->type) {\n    case VIR_CONF_LIST:\n        /* Calc length and check items */\n        for (len = 0, eval = cval->list; eval; len++, eval = eval->next) {\n            if (eval->type != VIR_CONF_STRING) {\n                virReportError(VIR_ERR_CONF_SYNTAX,\n                               _(\"%s: expected a string list for '%s' parameter\"),\n                               conf->filename, setting);\n                return -1;\n            }\n        }\n\n        if (VIR_ALLOC_N(*values, len + 1) < 0)\n            return -1;\n\n        for (len = 0, eval = cval->list; eval; len++, eval = eval->next)\n            (*values)[len] = g_strdup(eval->str);\n        break;\n\n    case VIR_CONF_STRING:\n        if (compatString) {\n            if (VIR_ALLOC_N(*values, cval->str ? 2 : 1) < 0)\n                return -1;\n            if (cval->str)\n                (*values)[0] = g_strdup(cval->str);\n            break;\n        }\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_CONF_LLONG:\n    case VIR_CONF_ULLONG:\n    case VIR_CONF_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       compatString ?\n                       _(\"%s: expected a string or string list for '%s' parameter\") :\n                       _(\"%s: expected a string list for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n\n    case VIR_CONF_LAST:\n    default:\n        virReportEnumRangeError(virConfType, cval->type);\n        return -1;\n    }\n\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nint\nvirURIResolveAlias(virConfPtr conf, const char *alias, char **uri)\n{\n    int ret = -1;\n    char **aliases = NULL;\n\n    *uri = NULL;\n\n    if (virConfGetValueStringList(conf, \"uri_aliases\", false, &aliases) < 0)\n        return -1;\n\n    if (aliases && *aliases) {\n        ret = virURIFindAliasMatch(aliases, alias, uri);\n        virStringListFree(aliases);\n    } else {\n        ret = 0;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virURIFindAliasMatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
    "lines": "303-344",
    "snippet": "static int\nvirURIFindAliasMatch(char *const*aliases, const char *alias,\n                     char **uri)\n{\n    size_t alias_len;\n\n    alias_len = strlen(alias);\n    while (*aliases) {\n        char *offset;\n        size_t safe;\n\n        if (!(offset = strchr(*aliases, '='))) {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Malformed 'uri_aliases' config entry '%s', \"\n                             \"expected 'alias=uri://host/path'\"), *aliases);\n            return -1;\n        }\n\n        safe = strspn(*aliases, URI_ALIAS_CHARS);\n        if (safe < (offset - *aliases)) {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Malformed 'uri_aliases' config entry '%s', \"\n                             \"aliases may only contain 'a-Z, 0-9, _, -'\"),\n                           *aliases);\n            return -1;\n        }\n\n        if (alias_len == (offset - *aliases) &&\n            STREQLEN(*aliases, alias, alias_len)) {\n            VIR_DEBUG(\"Resolved alias '%s' to '%s'\",\n                      alias, offset+1);\n            *uri = g_strdup(offset + 1);\n            return 0;\n        }\n\n        aliases++;\n    }\n\n    VIR_DEBUG(\"No alias found for '%s', continuing...\",\n              alias);\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruri.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define URI_ALIAS_CHARS \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No alias found for '%s', continuing...\"",
            "alias"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "offset + 1"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Resolved alias '%s' to '%s'\"",
            "alias",
            "offset+1"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQLEN",
          "args": [
            "*aliases",
            "alias",
            "alias_len"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONF_SYNTAX",
            "_(\"Malformed 'uri_aliases' config entry '%s', \"\n                             \"aliases may only contain 'a-Z, 0-9, _, -'\")",
            "*aliases"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "*aliases",
            "URI_ALIAS_CHARS"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONF_SYNTAX",
            "_(\"Malformed 'uri_aliases' config entry '%s', \"\n                             \"expected 'alias=uri://host/path'\")",
            "*aliases"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "*aliases",
            "'='"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "alias"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\n#define URI_ALIAS_CHARS \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-\"\n\nstatic int\nvirURIFindAliasMatch(char *const*aliases, const char *alias,\n                     char **uri)\n{\n    size_t alias_len;\n\n    alias_len = strlen(alias);\n    while (*aliases) {\n        char *offset;\n        size_t safe;\n\n        if (!(offset = strchr(*aliases, '='))) {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Malformed 'uri_aliases' config entry '%s', \"\n                             \"expected 'alias=uri://host/path'\"), *aliases);\n            return -1;\n        }\n\n        safe = strspn(*aliases, URI_ALIAS_CHARS);\n        if (safe < (offset - *aliases)) {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Malformed 'uri_aliases' config entry '%s', \"\n                             \"aliases may only contain 'a-Z, 0-9, _, -'\"),\n                           *aliases);\n            return -1;\n        }\n\n        if (alias_len == (offset - *aliases) &&\n            STREQLEN(*aliases, alias, alias_len)) {\n            VIR_DEBUG(\"Resolved alias '%s' to '%s'\",\n                      alias, offset+1);\n            *uri = g_strdup(offset + 1);\n            return 0;\n        }\n\n        aliases++;\n    }\n\n    VIR_DEBUG(\"No alias found for '%s', continuing...\",\n              alias);\n    return 0;\n}"
  },
  {
    "function_name": "virURIFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
    "lines": "277-298",
    "snippet": "void virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruri.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uri"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uri->params"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uri->params[i].value"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uri->params[i].name"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uri->fragment"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uri->query"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uri->path"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uri->user"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uri->server"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uri->scheme"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvoid virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}"
  },
  {
    "function_name": "virURIFormatParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
    "lines": "253-269",
    "snippet": "char *virURIFormatParams(virURIPtr uri)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    bool amp = false;\n\n    for (i = 0; i < uri->paramsCount; ++i) {\n        if (!uri->params[i].ignore) {\n            if (amp) virBufferAddChar(&buf, '&');\n            virBufferStrcat(&buf, uri->params[i].name, \"=\", NULL);\n            virBufferURIEncodeString(&buf, uri->params[i].value);\n            amp = true;\n        }\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruri.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferURIEncodeString",
          "args": [
            "&buf",
            "uri->params[i].value"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferURIEncodeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "534-544",
          "snippet": "void\nvirBufferURIEncodeString(virBufferPtr buf, const char *str)\n{\n    if ((buf == NULL) || (str == NULL))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    g_string_append_uri_escaped(buf->str, str, NULL, false);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferURIEncodeString(virBufferPtr buf, const char *str)\n{\n    if ((buf == NULL) || (str == NULL))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    g_string_append_uri_escaped(buf->str, str, NULL, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferStrcat",
          "args": [
            "&buf",
            "uri->params[i].name",
            "\"=\"",
            "NULL"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferStrcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "624-635",
          "snippet": "void\nvirBufferStrcat(virBufferPtr buf, ...)\n{\n    va_list ap;\n\n    if (!buf)\n        return;\n\n    va_start(ap, buf);\n    virBufferStrcatVArgs(buf, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferStrcat(virBufferPtr buf, ...)\n{\n    va_list ap;\n\n    if (!buf)\n        return;\n\n    va_start(ap, buf);\n    virBufferStrcatVArgs(buf, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddChar",
          "args": [
            "&buf",
            "'&'"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "206-210",
          "snippet": "void\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nchar *virURIFormatParams(virURIPtr uri)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    bool amp = false;\n\n    for (i = 0; i < uri->paramsCount; ++i) {\n        if (!uri->params[i].ignore) {\n            if (amp) virBufferAddChar(&buf, '&');\n            virBufferStrcat(&buf, uri->params[i].name, \"=\", NULL);\n            virBufferURIEncodeString(&buf, uri->params[i].value);\n            amp = true;\n        }\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
  },
  {
    "function_name": "virURIFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
    "lines": "207-250",
    "snippet": "char *\nvirURIFormat(virURIPtr uri)\n{\n    xmlURI xmluri;\n    char *tmpserver = NULL;\n    char *ret;\n\n    memset(&xmluri, 0, sizeof(xmluri));\n\n    xmluri.scheme = uri->scheme;\n    xmluri.server = uri->server;\n    xmluri.port = uri->port;\n    xmluri.path = uri->path;\n    xmluri.query_raw = uri->query;\n    xmluri.fragment = uri->fragment;\n    xmluri.user = uri->user;\n\n    /* First check: does it make sense to do anything */\n    if (xmluri.server != NULL &&\n        strchr(xmluri.server, ':') != NULL) {\n\n        tmpserver = g_strdup_printf(\"[%s]\", xmluri.server);\n\n        xmluri.server = tmpserver;\n    }\n\n    /*\n     * This helps libxml2 deal with the difference\n     * between uri:/absolute/path and uri:///absolute/path.\n     */\n    if (!xmluri.server && !xmluri.port)\n        xmluri.port = -1;\n\n    ret = (char *)xmlSaveUri(&xmluri);\n    if (!ret) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n cleanup:\n    VIR_FREE(tmpserver);\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruri.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmpserver"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlSaveUri",
          "args": [
            "&xmluri"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"[%s]\"",
            "xmluri.server"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "xmluri.server",
            "':'"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&xmluri",
            "0",
            "sizeof(xmluri)"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nchar *\nvirURIFormat(virURIPtr uri)\n{\n    xmlURI xmluri;\n    char *tmpserver = NULL;\n    char *ret;\n\n    memset(&xmluri, 0, sizeof(xmluri));\n\n    xmluri.scheme = uri->scheme;\n    xmluri.server = uri->server;\n    xmluri.port = uri->port;\n    xmluri.path = uri->path;\n    xmluri.query_raw = uri->query;\n    xmluri.fragment = uri->fragment;\n    xmluri.user = uri->user;\n\n    /* First check: does it make sense to do anything */\n    if (xmluri.server != NULL &&\n        strchr(xmluri.server, ':') != NULL) {\n\n        tmpserver = g_strdup_printf(\"[%s]\", xmluri.server);\n\n        xmluri.server = tmpserver;\n    }\n\n    /*\n     * This helps libxml2 deal with the difference\n     * between uri:/absolute/path and uri:///absolute/path.\n     */\n    if (!xmluri.server && !xmluri.port)\n        xmluri.port = -1;\n\n    ret = (char *)xmlSaveUri(&xmluri);\n    if (!ret) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n cleanup:\n    VIR_FREE(tmpserver);\n\n    return ret;\n}"
  },
  {
    "function_name": "virURIParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
    "lines": "143-194",
    "snippet": "virURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruri.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virURIFree",
          "args": [
            "ret"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "virURIFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "277-298",
          "snippet": "void virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvoid virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlFreeURI",
          "args": [
            "xmluri"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeURI",
          "args": [
            "xmluri"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virURIParseParams",
          "args": [
            "ret"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "virURIParseParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "63-129",
          "snippet": "static int\nvirURIParseParams(virURIPtr uri)\n{\n    const char *end, *eq;\n    const char *query = uri->query;\n\n    if (!query || query[0] == '\\0')\n        return 0;\n\n    while (*query) {\n        g_autofree char *name = NULL;\n        g_autofree char *value = NULL;\n\n        /* Find the next separator, or end of the string. */\n        end = strchr(query, '&');\n        if (!end)\n            end = strchr(query, ';');\n        if (!end)\n            end = query + strlen(query);\n\n        /* Find the first '=' character between here and end. */\n        eq = strchr(query, '=');\n        if (eq && eq >= end) eq = NULL;\n\n        if (end == query) {\n            /* Empty section (eg. \"&&\"). */\n            goto next;\n        } else if (!eq) {\n            /* If there is no '=' character, then we have just \"name\"\n             * and consistent with CGI.pm we assume value is \"\".\n             */\n            name = xmlURIUnescapeString(query, end - query, NULL);\n            if (!name)\n                return -1;\n        } else if (eq+1 == end) {\n            /* Or if we have \"name=\" here (works around annoying\n             * problem when calling xmlURIUnescapeString with len = 0).\n             */\n            name = xmlURIUnescapeString(query, eq - query, NULL);\n            if (!name)\n                return -1;\n        } else if (query == eq) {\n            /* If the '=' character is at the beginning then we have\n             * \"=value\" and consistent with CGI.pm we _ignore_ this.\n             */\n            goto next;\n        } else {\n            /* Otherwise it's \"name=value\". */\n            name = xmlURIUnescapeString(query, eq - query, NULL);\n            if (!name)\n                return -1;\n            value = xmlURIUnescapeString(eq+1, end - (eq+1), NULL);\n            if (!value)\n                return -1;\n        }\n\n        /* Append to the parameter set. */\n        if (virURIParamAppend(uri, name, NULLSTR_EMPTY(value)) < 0)\n            return -1;\n\n    next:\n        query = end;\n        if (*query) query ++; /* skip '&' separator */\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nstatic int\nvirURIParseParams(virURIPtr uri)\n{\n    const char *end, *eq;\n    const char *query = uri->query;\n\n    if (!query || query[0] == '\\0')\n        return 0;\n\n    while (*query) {\n        g_autofree char *name = NULL;\n        g_autofree char *value = NULL;\n\n        /* Find the next separator, or end of the string. */\n        end = strchr(query, '&');\n        if (!end)\n            end = strchr(query, ';');\n        if (!end)\n            end = query + strlen(query);\n\n        /* Find the first '=' character between here and end. */\n        eq = strchr(query, '=');\n        if (eq && eq >= end) eq = NULL;\n\n        if (end == query) {\n            /* Empty section (eg. \"&&\"). */\n            goto next;\n        } else if (!eq) {\n            /* If there is no '=' character, then we have just \"name\"\n             * and consistent with CGI.pm we assume value is \"\".\n             */\n            name = xmlURIUnescapeString(query, end - query, NULL);\n            if (!name)\n                return -1;\n        } else if (eq+1 == end) {\n            /* Or if we have \"name=\" here (works around annoying\n             * problem when calling xmlURIUnescapeString with len = 0).\n             */\n            name = xmlURIUnescapeString(query, eq - query, NULL);\n            if (!name)\n                return -1;\n        } else if (query == eq) {\n            /* If the '=' character is at the beginning then we have\n             * \"=value\" and consistent with CGI.pm we _ignore_ this.\n             */\n            goto next;\n        } else {\n            /* Otherwise it's \"name=value\". */\n            name = xmlURIUnescapeString(query, eq - query, NULL);\n            if (!name)\n                return -1;\n            value = xmlURIUnescapeString(eq+1, end - (eq+1), NULL);\n            if (!value)\n                return -1;\n        }\n\n        /* Append to the parameter set. */\n        if (virURIParamAppend(uri, name, NULLSTR_EMPTY(value)) < 0)\n            return -1;\n\n    next:\n        query = end;\n        if (*query) query ++; /* skip '&' separator */\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringStripIPv6Brackets",
          "args": [
            "ret->server"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "virStringStripIPv6Brackets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1165-1178",
          "snippet": "void\nvirStringStripIPv6Brackets(char *str)\n{\n    size_t len;\n\n    if (!str)\n        return;\n\n    len = strlen(str);\n    if (str[0] == '[' && str[len - 1] == ']' && strchr(str, ':')) {\n        memmove(&str[0], &str[1], len - 2);\n        str[len - 2] = '\\0';\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirStringStripIPv6Brackets(char *str)\n{\n    size_t len;\n\n    if (!str)\n        return;\n\n    len = strlen(str);\n    if (str[0] == '[' && str[len - 1] == ']' && strchr(str, ':')) {\n        memmove(&str[0], &str[1], len - 2);\n        str[len - 2] = '\\0';\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "xmluri->user"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "ret->server",
            "\"\""
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ret"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to parse URI %s\")",
            "uri"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlParseURI",
          "args": [
            "uri"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvirURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}"
  },
  {
    "function_name": "virURIParseParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
    "lines": "63-129",
    "snippet": "static int\nvirURIParseParams(virURIPtr uri)\n{\n    const char *end, *eq;\n    const char *query = uri->query;\n\n    if (!query || query[0] == '\\0')\n        return 0;\n\n    while (*query) {\n        g_autofree char *name = NULL;\n        g_autofree char *value = NULL;\n\n        /* Find the next separator, or end of the string. */\n        end = strchr(query, '&');\n        if (!end)\n            end = strchr(query, ';');\n        if (!end)\n            end = query + strlen(query);\n\n        /* Find the first '=' character between here and end. */\n        eq = strchr(query, '=');\n        if (eq && eq >= end) eq = NULL;\n\n        if (end == query) {\n            /* Empty section (eg. \"&&\"). */\n            goto next;\n        } else if (!eq) {\n            /* If there is no '=' character, then we have just \"name\"\n             * and consistent with CGI.pm we assume value is \"\".\n             */\n            name = xmlURIUnescapeString(query, end - query, NULL);\n            if (!name)\n                return -1;\n        } else if (eq+1 == end) {\n            /* Or if we have \"name=\" here (works around annoying\n             * problem when calling xmlURIUnescapeString with len = 0).\n             */\n            name = xmlURIUnescapeString(query, eq - query, NULL);\n            if (!name)\n                return -1;\n        } else if (query == eq) {\n            /* If the '=' character is at the beginning then we have\n             * \"=value\" and consistent with CGI.pm we _ignore_ this.\n             */\n            goto next;\n        } else {\n            /* Otherwise it's \"name=value\". */\n            name = xmlURIUnescapeString(query, eq - query, NULL);\n            if (!name)\n                return -1;\n            value = xmlURIUnescapeString(eq+1, end - (eq+1), NULL);\n            if (!value)\n                return -1;\n        }\n\n        /* Append to the parameter set. */\n        if (virURIParamAppend(uri, name, NULLSTR_EMPTY(value)) < 0)\n            return -1;\n\n    next:\n        query = end;\n        if (*query) query ++; /* skip '&' separator */\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruri.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virURIParamAppend",
          "args": [
            "uri",
            "name",
            "NULLSTR_EMPTY(value)"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "virURIParamAppend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "35-60",
          "snippet": "static int\nvirURIParamAppend(virURIPtr uri,\n                  const char *name,\n                  const char *value)\n{\n    char *pname = NULL;\n    char *pvalue = NULL;\n\n    pname = g_strdup(name);\n    pvalue = g_strdup(value);\n\n    if (VIR_RESIZE_N(uri->params, uri->paramsAlloc, uri->paramsCount, 1) < 0)\n        goto error;\n\n    uri->params[uri->paramsCount].name = pname;\n    uri->params[uri->paramsCount].value = pvalue;\n    uri->params[uri->paramsCount].ignore = 0;\n    uri->paramsCount++;\n\n    return 0;\n\n error:\n    VIR_FREE(pname);\n    VIR_FREE(pvalue);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nstatic int\nvirURIParamAppend(virURIPtr uri,\n                  const char *name,\n                  const char *value)\n{\n    char *pname = NULL;\n    char *pvalue = NULL;\n\n    pname = g_strdup(name);\n    pvalue = g_strdup(value);\n\n    if (VIR_RESIZE_N(uri->params, uri->paramsAlloc, uri->paramsCount, 1) < 0)\n        goto error;\n\n    uri->params[uri->paramsCount].name = pname;\n    uri->params[uri->paramsCount].value = pvalue;\n    uri->params[uri->paramsCount].ignore = 0;\n    uri->paramsCount++;\n\n    return 0;\n\n error:\n    VIR_FREE(pname);\n    VIR_FREE(pvalue);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "value"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlURIUnescapeString",
          "args": [
            "eq+1",
            "end - (eq+1)",
            "NULL"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlURIUnescapeString",
          "args": [
            "query",
            "eq - query",
            "NULL"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlURIUnescapeString",
          "args": [
            "query",
            "eq - query",
            "NULL"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlURIUnescapeString",
          "args": [
            "query",
            "end - query",
            "NULL"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "query",
            "'='"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "query"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "query",
            "';'"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "query",
            "'&'"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nstatic int\nvirURIParseParams(virURIPtr uri)\n{\n    const char *end, *eq;\n    const char *query = uri->query;\n\n    if (!query || query[0] == '\\0')\n        return 0;\n\n    while (*query) {\n        g_autofree char *name = NULL;\n        g_autofree char *value = NULL;\n\n        /* Find the next separator, or end of the string. */\n        end = strchr(query, '&');\n        if (!end)\n            end = strchr(query, ';');\n        if (!end)\n            end = query + strlen(query);\n\n        /* Find the first '=' character between here and end. */\n        eq = strchr(query, '=');\n        if (eq && eq >= end) eq = NULL;\n\n        if (end == query) {\n            /* Empty section (eg. \"&&\"). */\n            goto next;\n        } else if (!eq) {\n            /* If there is no '=' character, then we have just \"name\"\n             * and consistent with CGI.pm we assume value is \"\".\n             */\n            name = xmlURIUnescapeString(query, end - query, NULL);\n            if (!name)\n                return -1;\n        } else if (eq+1 == end) {\n            /* Or if we have \"name=\" here (works around annoying\n             * problem when calling xmlURIUnescapeString with len = 0).\n             */\n            name = xmlURIUnescapeString(query, eq - query, NULL);\n            if (!name)\n                return -1;\n        } else if (query == eq) {\n            /* If the '=' character is at the beginning then we have\n             * \"=value\" and consistent with CGI.pm we _ignore_ this.\n             */\n            goto next;\n        } else {\n            /* Otherwise it's \"name=value\". */\n            name = xmlURIUnescapeString(query, eq - query, NULL);\n            if (!name)\n                return -1;\n            value = xmlURIUnescapeString(eq+1, end - (eq+1), NULL);\n            if (!value)\n                return -1;\n        }\n\n        /* Append to the parameter set. */\n        if (virURIParamAppend(uri, name, NULLSTR_EMPTY(value)) < 0)\n            return -1;\n\n    next:\n        query = end;\n        if (*query) query ++; /* skip '&' separator */\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virURIParamAppend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
    "lines": "35-60",
    "snippet": "static int\nvirURIParamAppend(virURIPtr uri,\n                  const char *name,\n                  const char *value)\n{\n    char *pname = NULL;\n    char *pvalue = NULL;\n\n    pname = g_strdup(name);\n    pvalue = g_strdup(value);\n\n    if (VIR_RESIZE_N(uri->params, uri->paramsAlloc, uri->paramsCount, 1) < 0)\n        goto error;\n\n    uri->params[uri->paramsCount].name = pname;\n    uri->params[uri->paramsCount].value = pvalue;\n    uri->params[uri->paramsCount].ignore = 0;\n    uri->paramsCount++;\n\n    return 0;\n\n error:\n    VIR_FREE(pname);\n    VIR_FREE(pvalue);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruri.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pvalue"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pname"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "uri->params",
            "uri->paramsAlloc",
            "uri->paramsCount",
            "1"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "value"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nstatic int\nvirURIParamAppend(virURIPtr uri,\n                  const char *name,\n                  const char *value)\n{\n    char *pname = NULL;\n    char *pvalue = NULL;\n\n    pname = g_strdup(name);\n    pvalue = g_strdup(value);\n\n    if (VIR_RESIZE_N(uri->params, uri->paramsAlloc, uri->paramsCount, 1) < 0)\n        goto error;\n\n    uri->params[uri->paramsCount].name = pname;\n    uri->params[uri->paramsCount].value = pvalue;\n    uri->params[uri->paramsCount].ignore = 0;\n    uri->paramsCount++;\n\n    return 0;\n\n error:\n    VIR_FREE(pname);\n    VIR_FREE(pvalue);\n    return -1;\n}"
  }
]