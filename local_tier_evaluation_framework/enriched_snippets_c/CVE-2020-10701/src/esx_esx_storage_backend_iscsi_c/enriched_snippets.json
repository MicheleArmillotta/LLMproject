[
  {
    "function_name": "esxStorageVolGetPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "771-778",
    "snippet": "static char *\nesxStorageVolGetPath(virStorageVolPtr volume)\n{\n    char *path;\n\n    path = g_strdup(volume->name);\n    return path;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "volume->name"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nesxStorageVolGetPath(virStorageVolPtr volume)\n{\n    char *path;\n\n    path = g_strdup(volume->name);\n    return path;\n}"
  },
  {
    "function_name": "esxStorageVolWipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "756-767",
    "snippet": "static int\nesxStorageVolWipe(virStorageVolPtr volume G_GNUC_UNUSED,\n                  unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"iSCSI storage pool does not support volume wiping\"));\n\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "\"%s\"",
            "_(\"iSCSI storage pool does not support volume wiping\")"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"iSCSI storage pool does not support volume wiping\""
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxStorageVolWipe(virStorageVolPtr volume G_GNUC_UNUSED,\n                  unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"iSCSI storage pool does not support volume wiping\"));\n\n    return -1;\n}"
  },
  {
    "function_name": "esxStorageVolDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "742-752",
    "snippet": "static int\nesxStorageVolDelete(virStorageVolPtr volume G_GNUC_UNUSED,\n                    unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"iSCSI storage pool does not support volume deletion\"));\n\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "\"%s\"",
            "_(\"iSCSI storage pool does not support volume deletion\")"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"iSCSI storage pool does not support volume deletion\""
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxStorageVolDelete(virStorageVolPtr volume G_GNUC_UNUSED,\n                    unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"iSCSI storage pool does not support volume deletion\"));\n\n    return -1;\n}"
  },
  {
    "function_name": "esxStorageVolGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "668-738",
    "snippet": "static char *\nesxStorageVolGetXMLDesc(virStorageVolPtr volume,\n                        unsigned int flags)\n{\n    char *xml = NULL;\n    esxPrivate *priv = volume->conn->privateData;\n    virStoragePoolDef pool;\n    esxVI_ScsiLun *scsiLunList = NULL;\n    esxVI_ScsiLun *scsiLun;\n    esxVI_HostScsiDisk *hostScsiDisk = NULL;\n    virStorageVolDef def;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    virCheckFlags(0, NULL);\n\n    memset(&pool, 0, sizeof(pool));\n    memset(&def, 0, sizeof(def));\n\n    if (esxVI_LookupScsiLunList(priv->primary, &scsiLunList) < 0)\n        goto cleanup;\n\n    for (scsiLun = scsiLunList; scsiLun;\n         scsiLun = scsiLun->_next) {\n        hostScsiDisk = esxVI_HostScsiDisk_DynamicCast(scsiLun);\n\n        if (hostScsiDisk &&\n            STREQ(hostScsiDisk->deviceName, volume->name)) {\n            break;\n        }\n    }\n\n    if (!scsiLun) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could find volume with name: %s\"), volume->name);\n        goto cleanup;\n    }\n\n    pool.type = VIR_STORAGE_POOL_ISCSI;\n\n    def.name = volume->name;\n\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, scsiLun->uuid,  md5) < 0)\n        goto cleanup;\n\n    virUUIDFormat(md5, uuid_string);\n\n    def.key = g_strdup(uuid_string);\n\n    /* iSCSI LUN exposes a block device */\n    def.type = VIR_STORAGE_VOL_BLOCK;\n\n    def.target.path = hostScsiDisk->devicePath;\n\n    def.target.capacity = hostScsiDisk->capacity->block->value *\n                   hostScsiDisk->capacity->blockSize->value;\n\n    def.target.allocation = def.target.capacity;\n\n    /* iSCSI LUN(s) hosting a datastore will be auto-mounted by ESX host */\n    def.target.format = VIR_STORAGE_FILE_RAW;\n\n    xml = virStorageVolDefFormat(&pool, &def);\n\n cleanup:\n    esxVI_ScsiLun_Free(&scsiLunList);\n    VIR_FREE(def.key);\n\n    return xml;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def.key"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ScsiLun_Free",
          "args": [
            "&scsiLunList"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageVolDefFormat",
          "args": [
            "&pool",
            "&def"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageVolDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "1594-1670",
          "snippet": "char *\nvirStorageVolDefFormat(virStoragePoolDefPtr pool,\n                       virStorageVolDefPtr def)\n{\n    virStorageVolOptionsPtr options;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    options = virStorageVolOptionsForPoolType(pool->type);\n    if (options == NULL)\n        return NULL;\n\n    virBufferAsprintf(&buf, \"<volume type='%s'>\\n\",\n                      virStorageVolTypeToString(def->type));\n    virBufferAdjustIndent(&buf, 2);\n\n    virBufferEscapeString(&buf, \"<name>%s</name>\\n\", def->name);\n    virBufferEscapeString(&buf, \"<key>%s</key>\\n\", def->key);\n    virBufferAddLit(&buf, \"<source>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    if (def->source.nextent) {\n        size_t i;\n        const char *thispath = NULL;\n        for (i = 0; i < def->source.nextent; i++) {\n            if (thispath == NULL ||\n                STRNEQ(thispath, def->source.extents[i].path)) {\n                if (thispath != NULL)\n                    virBufferAddLit(&buf, \"</device>\\n\");\n\n                virBufferEscapeString(&buf, \"<device path='%s'>\\n\",\n                                      def->source.extents[i].path);\n            }\n\n            virBufferAdjustIndent(&buf, 2);\n            virBufferAsprintf(&buf, \"<extent start='%llu' end='%llu'/>\\n\",\n                              def->source.extents[i].start,\n                              def->source.extents[i].end);\n            virBufferAdjustIndent(&buf, -2);\n            thispath = def->source.extents[i].path;\n        }\n        if (thispath != NULL)\n            virBufferAddLit(&buf, \"</device>\\n\");\n    }\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</source>\\n\");\n\n    virBufferAsprintf(&buf, \"<capacity unit='bytes'>%llu</capacity>\\n\",\n                      def->target.capacity);\n    virBufferAsprintf(&buf, \"<allocation unit='bytes'>%llu</allocation>\\n\",\n                      def->target.allocation);\n    /* NB: Display only - since virStorageVolInfo is limited to just\n     * 'capacity' and 'allocation' on output. Since we don't read this\n     * in, be sure it was filled in before printing */\n    if (def->target.physical)\n        virBufferAsprintf(&buf, \"<physical unit='bytes'>%llu</physical>\\n\",\n                          def->target.physical);\n\n    if (virStorageVolTargetDefFormat(options, &buf,\n                                     &def->target, \"target\") < 0)\n        goto cleanup;\n\n    if (virStorageSourceHasBacking(&def->target) &&\n        virStorageVolTargetDefFormat(options, &buf,\n                                     def->target.backingStore,\n                                     \"backingStore\") < 0)\n        goto cleanup;\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</volume>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirStorageVolDefFormat(virStoragePoolDefPtr pool,\n                       virStorageVolDefPtr def)\n{\n    virStorageVolOptionsPtr options;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    options = virStorageVolOptionsForPoolType(pool->type);\n    if (options == NULL)\n        return NULL;\n\n    virBufferAsprintf(&buf, \"<volume type='%s'>\\n\",\n                      virStorageVolTypeToString(def->type));\n    virBufferAdjustIndent(&buf, 2);\n\n    virBufferEscapeString(&buf, \"<name>%s</name>\\n\", def->name);\n    virBufferEscapeString(&buf, \"<key>%s</key>\\n\", def->key);\n    virBufferAddLit(&buf, \"<source>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    if (def->source.nextent) {\n        size_t i;\n        const char *thispath = NULL;\n        for (i = 0; i < def->source.nextent; i++) {\n            if (thispath == NULL ||\n                STRNEQ(thispath, def->source.extents[i].path)) {\n                if (thispath != NULL)\n                    virBufferAddLit(&buf, \"</device>\\n\");\n\n                virBufferEscapeString(&buf, \"<device path='%s'>\\n\",\n                                      def->source.extents[i].path);\n            }\n\n            virBufferAdjustIndent(&buf, 2);\n            virBufferAsprintf(&buf, \"<extent start='%llu' end='%llu'/>\\n\",\n                              def->source.extents[i].start,\n                              def->source.extents[i].end);\n            virBufferAdjustIndent(&buf, -2);\n            thispath = def->source.extents[i].path;\n        }\n        if (thispath != NULL)\n            virBufferAddLit(&buf, \"</device>\\n\");\n    }\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</source>\\n\");\n\n    virBufferAsprintf(&buf, \"<capacity unit='bytes'>%llu</capacity>\\n\",\n                      def->target.capacity);\n    virBufferAsprintf(&buf, \"<allocation unit='bytes'>%llu</allocation>\\n\",\n                      def->target.allocation);\n    /* NB: Display only - since virStorageVolInfo is limited to just\n     * 'capacity' and 'allocation' on output. Since we don't read this\n     * in, be sure it was filled in before printing */\n    if (def->target.physical)\n        virBufferAsprintf(&buf, \"<physical unit='bytes'>%llu</physical>\\n\",\n                          def->target.physical);\n\n    if (virStorageVolTargetDefFormat(options, &buf,\n                                     &def->target, \"target\") < 0)\n        goto cleanup;\n\n    if (virStorageSourceHasBacking(&def->target) &&\n        virStorageVolTargetDefFormat(options, &buf,\n                                     def->target.backingStore,\n                                     \"backingStore\") < 0)\n        goto cleanup;\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</volume>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "uuid_string"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "md5",
            "uuid_string"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCryptoHashBuf",
          "args": [
            "VIR_CRYPTO_HASH_MD5",
            "scsiLun->uuid",
            "md5"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "virCryptoHashBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
          "lines": "52-73",
          "snippet": "ssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"virrandom.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nstruct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};\n\nssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could find volume with name: %s\")",
            "volume->name"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could find volume with name: %s\""
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "hostScsiDisk->deviceName",
            "volume->name"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostScsiDisk_DynamicCast",
          "args": [
            "scsiLun"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupScsiLunList",
          "args": [
            "priv->primary",
            "&scsiLunList"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupScsiLunList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4656-4692",
          "snippet": "int\nesxVI_LookupScsiLunList(esxVI_Context *ctx, esxVI_ScsiLun **scsiLunList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.storageDevice.scsiLun\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.storageDevice.scsiLun\")) {\n            if (esxVI_ScsiLun_CastListFromAnyType(dynamicProperty->val,\n                                                  scsiLunList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupScsiLunList(esxVI_Context *ctx, esxVI_ScsiLun **scsiLunList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.storageDevice.scsiLun\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.storageDevice.scsiLun\")) {\n            if (esxVI_ScsiLun_CastListFromAnyType(dynamicProperty->val,\n                                                  scsiLunList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&def",
            "0",
            "sizeof(def)"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&pool",
            "0",
            "sizeof(pool)"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nesxStorageVolGetXMLDesc(virStorageVolPtr volume,\n                        unsigned int flags)\n{\n    char *xml = NULL;\n    esxPrivate *priv = volume->conn->privateData;\n    virStoragePoolDef pool;\n    esxVI_ScsiLun *scsiLunList = NULL;\n    esxVI_ScsiLun *scsiLun;\n    esxVI_HostScsiDisk *hostScsiDisk = NULL;\n    virStorageVolDef def;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    virCheckFlags(0, NULL);\n\n    memset(&pool, 0, sizeof(pool));\n    memset(&def, 0, sizeof(def));\n\n    if (esxVI_LookupScsiLunList(priv->primary, &scsiLunList) < 0)\n        goto cleanup;\n\n    for (scsiLun = scsiLunList; scsiLun;\n         scsiLun = scsiLun->_next) {\n        hostScsiDisk = esxVI_HostScsiDisk_DynamicCast(scsiLun);\n\n        if (hostScsiDisk &&\n            STREQ(hostScsiDisk->deviceName, volume->name)) {\n            break;\n        }\n    }\n\n    if (!scsiLun) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could find volume with name: %s\"), volume->name);\n        goto cleanup;\n    }\n\n    pool.type = VIR_STORAGE_POOL_ISCSI;\n\n    def.name = volume->name;\n\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, scsiLun->uuid,  md5) < 0)\n        goto cleanup;\n\n    virUUIDFormat(md5, uuid_string);\n\n    def.key = g_strdup(uuid_string);\n\n    /* iSCSI LUN exposes a block device */\n    def.type = VIR_STORAGE_VOL_BLOCK;\n\n    def.target.path = hostScsiDisk->devicePath;\n\n    def.target.capacity = hostScsiDisk->capacity->block->value *\n                   hostScsiDisk->capacity->blockSize->value;\n\n    def.target.allocation = def.target.capacity;\n\n    /* iSCSI LUN(s) hosting a datastore will be auto-mounted by ESX host */\n    def.target.format = VIR_STORAGE_FILE_RAW;\n\n    xml = virStorageVolDefFormat(&pool, &def);\n\n cleanup:\n    esxVI_ScsiLun_Free(&scsiLunList);\n    VIR_FREE(def.key);\n\n    return xml;\n}"
  },
  {
    "function_name": "esxStorageVolGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "623-664",
    "snippet": "static int\nesxStorageVolGetInfo(virStorageVolPtr volume,\n                     virStorageVolInfoPtr info)\n{\n    int result = -1;\n    esxPrivate *priv = volume->conn->privateData;\n    esxVI_ScsiLun *scsiLunList = NULL;\n    esxVI_ScsiLun *scsiLun;\n    esxVI_HostScsiDisk *hostScsiDisk = NULL;\n\n    if (esxVI_LookupScsiLunList(priv->primary, &scsiLunList) < 0)\n        goto cleanup;\n\n    for (scsiLun = scsiLunList; scsiLun;\n         scsiLun = scsiLun->_next) {\n        hostScsiDisk = esxVI_HostScsiDisk_DynamicCast(scsiLun);\n\n        if (hostScsiDisk &&\n            STREQ(hostScsiDisk->deviceName, volume->name)) {\n            break;\n        }\n    }\n\n    if (!hostScsiDisk) {\n        virReportError(VIR_ERR_NO_STORAGE_VOL,\n                       _(\"Could not find volume with name: %s\"),\n                       volume->name);\n        goto cleanup;\n    }\n\n    info->type = VIR_STORAGE_VOL_BLOCK;\n    info->capacity = hostScsiDisk->capacity->block->value *\n                     hostScsiDisk->capacity->blockSize->value;\n    info->allocation = info->capacity;\n\n    result = 0;\n\n cleanup:\n    esxVI_ScsiLun_Free(&scsiLunList);\n\n    return result;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ScsiLun_Free",
          "args": [
            "&scsiLunList"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_STORAGE_VOL",
            "_(\"Could not find volume with name: %s\")",
            "volume->name"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find volume with name: %s\""
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "hostScsiDisk->deviceName",
            "volume->name"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostScsiDisk_DynamicCast",
          "args": [
            "scsiLun"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupScsiLunList",
          "args": [
            "priv->primary",
            "&scsiLunList"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupScsiLunList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4656-4692",
          "snippet": "int\nesxVI_LookupScsiLunList(esxVI_Context *ctx, esxVI_ScsiLun **scsiLunList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.storageDevice.scsiLun\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.storageDevice.scsiLun\")) {\n            if (esxVI_ScsiLun_CastListFromAnyType(dynamicProperty->val,\n                                                  scsiLunList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupScsiLunList(esxVI_Context *ctx, esxVI_ScsiLun **scsiLunList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.storageDevice.scsiLun\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.storageDevice.scsiLun\")) {\n            if (esxVI_ScsiLun_CastListFromAnyType(dynamicProperty->val,\n                                                  scsiLunList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxStorageVolGetInfo(virStorageVolPtr volume,\n                     virStorageVolInfoPtr info)\n{\n    int result = -1;\n    esxPrivate *priv = volume->conn->privateData;\n    esxVI_ScsiLun *scsiLunList = NULL;\n    esxVI_ScsiLun *scsiLun;\n    esxVI_HostScsiDisk *hostScsiDisk = NULL;\n\n    if (esxVI_LookupScsiLunList(priv->primary, &scsiLunList) < 0)\n        goto cleanup;\n\n    for (scsiLun = scsiLunList; scsiLun;\n         scsiLun = scsiLun->_next) {\n        hostScsiDisk = esxVI_HostScsiDisk_DynamicCast(scsiLun);\n\n        if (hostScsiDisk &&\n            STREQ(hostScsiDisk->deviceName, volume->name)) {\n            break;\n        }\n    }\n\n    if (!hostScsiDisk) {\n        virReportError(VIR_ERR_NO_STORAGE_VOL,\n                       _(\"Could not find volume with name: %s\"),\n                       volume->name);\n        goto cleanup;\n    }\n\n    info->type = VIR_STORAGE_VOL_BLOCK;\n    info->capacity = hostScsiDisk->capacity->block->value *\n                     hostScsiDisk->capacity->blockSize->value;\n    info->allocation = info->capacity;\n\n    result = 0;\n\n cleanup:\n    esxVI_ScsiLun_Free(&scsiLunList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxStorageVolCreateXMLFrom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "607-619",
    "snippet": "static virStorageVolPtr\nesxStorageVolCreateXMLFrom(virStoragePoolPtr pool G_GNUC_UNUSED,\n                           const char *xmldesc G_GNUC_UNUSED,\n                           virStorageVolPtr sourceVolume G_GNUC_UNUSED,\n                           unsigned int flags)\n{\n    virCheckFlags(0, NULL);\n\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"iSCSI storage pool does not support volume creation\"));\n\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "\"%s\"",
            "_(\"iSCSI storage pool does not support volume creation\")"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"iSCSI storage pool does not support volume creation\""
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virStorageVolPtr\nesxStorageVolCreateXMLFrom(virStoragePoolPtr pool G_GNUC_UNUSED,\n                           const char *xmldesc G_GNUC_UNUSED,\n                           virStorageVolPtr sourceVolume G_GNUC_UNUSED,\n                           unsigned int flags)\n{\n    virCheckFlags(0, NULL);\n\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"iSCSI storage pool does not support volume creation\"));\n\n    return NULL;\n}"
  },
  {
    "function_name": "esxStorageVolCreateXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "592-603",
    "snippet": "static virStorageVolPtr\nesxStorageVolCreateXML(virStoragePoolPtr pool G_GNUC_UNUSED,\n                       const char *xmldesc G_GNUC_UNUSED,\n                       unsigned int flags)\n{\n    virCheckFlags(0, NULL);\n\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"iSCSI storage pool does not support volume creation\"));\n\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "\"%s\"",
            "_(\"iSCSI storage pool does not support volume creation\")"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"iSCSI storage pool does not support volume creation\""
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virStorageVolPtr\nesxStorageVolCreateXML(virStoragePoolPtr pool G_GNUC_UNUSED,\n                       const char *xmldesc G_GNUC_UNUSED,\n                       unsigned int flags)\n{\n    virCheckFlags(0, NULL);\n\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"iSCSI storage pool does not support volume creation\"));\n\n    return NULL;\n}"
  },
  {
    "function_name": "esxStorageVolLookupByKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "538-588",
    "snippet": "static virStorageVolPtr\nesxStorageVolLookupByKey(virConnectPtr conn, const char *key)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = conn->privateData;\n    char *poolName = NULL;\n    esxVI_ScsiLun *scsiLunList = NULL;\n    esxVI_ScsiLun *scsiLun;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    /* key may be LUN device path */\n    if (STRPREFIX(key, \"/\"))\n        return esxStorageVolLookupByPath(conn, key);\n\n    if (esxVI_LookupScsiLunList(priv->primary, &scsiLunList) < 0)\n        goto cleanup;\n\n    for (scsiLun = scsiLunList; scsiLun;\n         scsiLun = scsiLun->_next) {\n        memset(uuid_string, '\\0', sizeof(uuid_string));\n        memset(md5, '\\0', sizeof(md5));\n\n        if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, scsiLun->uuid, md5) < 0)\n            goto cleanup;\n        virUUIDFormat(md5, uuid_string);\n\n        if (STREQ(key, uuid_string)) {\n            /* Found matching UUID */\n            VIR_FREE(poolName);\n\n            if (esxVI_LookupStoragePoolNameByScsiLunKey(priv->primary,\n                                                        scsiLun->key,\n                                                        &poolName) < 0) {\n                goto cleanup;\n            }\n\n            volume = virGetStorageVol(conn, poolName, scsiLun->deviceName,\n                                      uuid_string, &esxStorageBackendISCSI,\n                                      NULL);\n            break;\n        }\n    }\n\n cleanup:\n    esxVI_ScsiLun_Free(&scsiLunList);\n    VIR_FREE(poolName);\n\n    return volume;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virStorageDriver esxStorageBackendISCSI = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 1.0.1 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 1.0.1 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 1.0.1 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 1.0.1 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 1.0.1 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 1.0.1 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 1.0.1 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 1.0.1 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 1.0.1 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 1.0.1 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 1.0.1 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 1.0.1 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 1.0.1 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 1.0.1 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 1.2.5 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 1.0.1 */\n    .storageVolDelete = esxStorageVolDelete, /* 1.0.1 */\n    .storageVolWipe = esxStorageVolWipe, /* 1.0.1 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 1.0.1 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "poolName"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ScsiLun_Free",
          "args": [
            "&scsiLunList"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetStorageVol",
          "args": [
            "conn",
            "poolName",
            "scsiLun->deviceName",
            "uuid_string",
            "&esxStorageBackendISCSI",
            "NULL"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "virGetStorageVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "600-632",
          "snippet": "virStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virStorageVolClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virStorageVolClass;\n\nvirStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupStoragePoolNameByScsiLunKey",
          "args": [
            "priv->primary",
            "scsiLun->key",
            "&poolName"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupStoragePoolNameByScsiLunKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4786-4867",
          "snippet": "int\nesxVI_LookupStoragePoolNameByScsiLunKey(esxVI_Context *ctx,\n                                        const char *key,\n                                        char **poolName)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterfaceList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterface = NULL;\n    esxVI_HostScsiTopologyTarget *hostScsiTopologyTarget = NULL;\n    esxVI_HostInternetScsiTargetTransport *candidate;\n    esxVI_HostScsiTopologyLun *hostScsiTopologyLun;\n    bool found = false;\n\n    ESX_VI_CHECK_ARG_LIST(poolName);\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList,\n           \"config.storageDevice.scsiTopology.adapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.scsiTopology.adapter\")) {\n            esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n            if (esxVI_HostScsiTopologyInterface_CastListFromAnyType\n                  (dynamicProperty->val, &hostScsiInterfaceList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!hostScsiInterfaceList) {\n        /* iSCSI adapter may not be enabled */\n        return 0;\n    }\n\n    /* See vSphere API documentation about HostScsiTopologyInterface */\n    for (hostScsiInterface = hostScsiInterfaceList;\n         hostScsiInterface && !found;\n         hostScsiInterface = hostScsiInterface->_next) {\n        for (hostScsiTopologyTarget = hostScsiInterface->target;\n             hostScsiTopologyTarget;\n             hostScsiTopologyTarget = hostScsiTopologyTarget->_next) {\n            candidate = esxVI_HostInternetScsiTargetTransport_DynamicCast\n                (hostScsiTopologyTarget->transport);\n\n            if (candidate) {\n                /* iterate hostScsiTopologyLun list to find matching key */\n                for (hostScsiTopologyLun = hostScsiTopologyTarget->lun;\n                     hostScsiTopologyLun;\n                     hostScsiTopologyLun = hostScsiTopologyLun->_next) {\n                    if (STREQ(hostScsiTopologyLun->scsiLun, key))\n                        *poolName = g_strdup(candidate->iScsiName);\n                }\n\n                /* hostScsiTopologyLun iteration done, terminate loop */\n                break;\n            }\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupStoragePoolNameByScsiLunKey(esxVI_Context *ctx,\n                                        const char *key,\n                                        char **poolName)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterfaceList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterface = NULL;\n    esxVI_HostScsiTopologyTarget *hostScsiTopologyTarget = NULL;\n    esxVI_HostInternetScsiTargetTransport *candidate;\n    esxVI_HostScsiTopologyLun *hostScsiTopologyLun;\n    bool found = false;\n\n    ESX_VI_CHECK_ARG_LIST(poolName);\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList,\n           \"config.storageDevice.scsiTopology.adapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.scsiTopology.adapter\")) {\n            esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n            if (esxVI_HostScsiTopologyInterface_CastListFromAnyType\n                  (dynamicProperty->val, &hostScsiInterfaceList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!hostScsiInterfaceList) {\n        /* iSCSI adapter may not be enabled */\n        return 0;\n    }\n\n    /* See vSphere API documentation about HostScsiTopologyInterface */\n    for (hostScsiInterface = hostScsiInterfaceList;\n         hostScsiInterface && !found;\n         hostScsiInterface = hostScsiInterface->_next) {\n        for (hostScsiTopologyTarget = hostScsiInterface->target;\n             hostScsiTopologyTarget;\n             hostScsiTopologyTarget = hostScsiTopologyTarget->_next) {\n            candidate = esxVI_HostInternetScsiTargetTransport_DynamicCast\n                (hostScsiTopologyTarget->transport);\n\n            if (candidate) {\n                /* iterate hostScsiTopologyLun list to find matching key */\n                for (hostScsiTopologyLun = hostScsiTopologyTarget->lun;\n                     hostScsiTopologyLun;\n                     hostScsiTopologyLun = hostScsiTopologyLun->_next) {\n                    if (STREQ(hostScsiTopologyLun->scsiLun, key))\n                        *poolName = g_strdup(candidate->iScsiName);\n                }\n\n                /* hostScsiTopologyLun iteration done, terminate loop */\n                break;\n            }\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "poolName"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "key",
            "uuid_string"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "md5",
            "uuid_string"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCryptoHashBuf",
          "args": [
            "VIR_CRYPTO_HASH_MD5",
            "scsiLun->uuid",
            "md5"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "virCryptoHashBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
          "lines": "52-73",
          "snippet": "ssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"virrandom.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nstruct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};\n\nssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "md5",
            "'\\0'",
            "sizeof(md5)"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "uuid_string",
            "'\\0'",
            "sizeof(uuid_string)"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupScsiLunList",
          "args": [
            "priv->primary",
            "&scsiLunList"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupScsiLunList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4656-4692",
          "snippet": "int\nesxVI_LookupScsiLunList(esxVI_Context *ctx, esxVI_ScsiLun **scsiLunList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.storageDevice.scsiLun\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.storageDevice.scsiLun\")) {\n            if (esxVI_ScsiLun_CastListFromAnyType(dynamicProperty->val,\n                                                  scsiLunList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupScsiLunList(esxVI_Context *ctx, esxVI_ScsiLun **scsiLunList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.storageDevice.scsiLun\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.storageDevice.scsiLun\")) {\n            if (esxVI_ScsiLun_CastListFromAnyType(dynamicProperty->val,\n                                                  scsiLunList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxStorageVolLookupByPath",
          "args": [
            "conn",
            "key"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "esxStorageVolLookupByPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
          "lines": "490-534",
          "snippet": "static virStorageVolPtr\nesxStorageVolLookupByPath(virConnectPtr conn, const char *path)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = conn->privateData;\n    esxVI_ScsiLun *scsiLunList = NULL;\n    esxVI_ScsiLun *scsiLun;\n    esxVI_HostScsiDisk *hostScsiDisk = NULL;\n    char *poolName = NULL;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    if (esxVI_LookupScsiLunList(priv->primary, &scsiLunList) < 0)\n        goto cleanup;\n\n    for (scsiLun = scsiLunList; scsiLun; scsiLun = scsiLun->_next) {\n        hostScsiDisk = esxVI_HostScsiDisk_DynamicCast(scsiLun);\n\n        if (hostScsiDisk && STREQ(hostScsiDisk->devicePath, path)) {\n            /* Found matching device */\n            VIR_FREE(poolName);\n\n            if (esxVI_LookupStoragePoolNameByScsiLunKey(priv->primary,\n                                                        hostScsiDisk->key,\n                                                        &poolName) < 0) {\n                goto cleanup;\n            }\n\n            if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, scsiLun->uuid, md5) < 0)\n                goto cleanup;\n            virUUIDFormat(md5, uuid_string);\n\n            volume = virGetStorageVol(conn, poolName, path, uuid_string,\n                                      &esxStorageBackendISCSI, NULL);\n            break;\n        }\n    }\n\n cleanup:\n    esxVI_ScsiLun_Free(&scsiLunList);\n    VIR_FREE(poolName);\n\n    return volume;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vircrypto.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_backend_iscsi.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virStorageDriver esxStorageBackendISCSI = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 1.0.1 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 1.0.1 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 1.0.1 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 1.0.1 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 1.0.1 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 1.0.1 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 1.0.1 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 1.0.1 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 1.0.1 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 1.0.1 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 1.0.1 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 1.0.1 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 1.0.1 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 1.0.1 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 1.2.5 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 1.0.1 */\n    .storageVolDelete = esxStorageVolDelete, /* 1.0.1 */\n    .storageVolWipe = esxStorageVolWipe, /* 1.0.1 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 1.0.1 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirStorageDriver esxStorageBackendISCSI = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 1.0.1 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 1.0.1 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 1.0.1 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 1.0.1 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 1.0.1 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 1.0.1 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 1.0.1 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 1.0.1 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 1.0.1 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 1.0.1 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 1.0.1 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 1.0.1 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 1.0.1 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 1.0.1 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 1.2.5 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 1.0.1 */\n    .storageVolDelete = esxStorageVolDelete, /* 1.0.1 */\n    .storageVolWipe = esxStorageVolWipe, /* 1.0.1 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 1.0.1 */\n};\n\nstatic virStorageVolPtr\nesxStorageVolLookupByPath(virConnectPtr conn, const char *path)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = conn->privateData;\n    esxVI_ScsiLun *scsiLunList = NULL;\n    esxVI_ScsiLun *scsiLun;\n    esxVI_HostScsiDisk *hostScsiDisk = NULL;\n    char *poolName = NULL;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    if (esxVI_LookupScsiLunList(priv->primary, &scsiLunList) < 0)\n        goto cleanup;\n\n    for (scsiLun = scsiLunList; scsiLun; scsiLun = scsiLun->_next) {\n        hostScsiDisk = esxVI_HostScsiDisk_DynamicCast(scsiLun);\n\n        if (hostScsiDisk && STREQ(hostScsiDisk->devicePath, path)) {\n            /* Found matching device */\n            VIR_FREE(poolName);\n\n            if (esxVI_LookupStoragePoolNameByScsiLunKey(priv->primary,\n                                                        hostScsiDisk->key,\n                                                        &poolName) < 0) {\n                goto cleanup;\n            }\n\n            if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, scsiLun->uuid, md5) < 0)\n                goto cleanup;\n            virUUIDFormat(md5, uuid_string);\n\n            volume = virGetStorageVol(conn, poolName, path, uuid_string,\n                                      &esxStorageBackendISCSI, NULL);\n            break;\n        }\n    }\n\n cleanup:\n    esxVI_ScsiLun_Free(&scsiLunList);\n    VIR_FREE(poolName);\n\n    return volume;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"/\""
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirStorageDriver esxStorageBackendISCSI = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 1.0.1 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 1.0.1 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 1.0.1 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 1.0.1 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 1.0.1 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 1.0.1 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 1.0.1 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 1.0.1 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 1.0.1 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 1.0.1 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 1.0.1 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 1.0.1 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 1.0.1 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 1.0.1 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 1.2.5 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 1.0.1 */\n    .storageVolDelete = esxStorageVolDelete, /* 1.0.1 */\n    .storageVolWipe = esxStorageVolWipe, /* 1.0.1 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 1.0.1 */\n};\n\nstatic virStorageVolPtr\nesxStorageVolLookupByKey(virConnectPtr conn, const char *key)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = conn->privateData;\n    char *poolName = NULL;\n    esxVI_ScsiLun *scsiLunList = NULL;\n    esxVI_ScsiLun *scsiLun;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    /* key may be LUN device path */\n    if (STRPREFIX(key, \"/\"))\n        return esxStorageVolLookupByPath(conn, key);\n\n    if (esxVI_LookupScsiLunList(priv->primary, &scsiLunList) < 0)\n        goto cleanup;\n\n    for (scsiLun = scsiLunList; scsiLun;\n         scsiLun = scsiLun->_next) {\n        memset(uuid_string, '\\0', sizeof(uuid_string));\n        memset(md5, '\\0', sizeof(md5));\n\n        if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, scsiLun->uuid, md5) < 0)\n            goto cleanup;\n        virUUIDFormat(md5, uuid_string);\n\n        if (STREQ(key, uuid_string)) {\n            /* Found matching UUID */\n            VIR_FREE(poolName);\n\n            if (esxVI_LookupStoragePoolNameByScsiLunKey(priv->primary,\n                                                        scsiLun->key,\n                                                        &poolName) < 0) {\n                goto cleanup;\n            }\n\n            volume = virGetStorageVol(conn, poolName, scsiLun->deviceName,\n                                      uuid_string, &esxStorageBackendISCSI,\n                                      NULL);\n            break;\n        }\n    }\n\n cleanup:\n    esxVI_ScsiLun_Free(&scsiLunList);\n    VIR_FREE(poolName);\n\n    return volume;\n}"
  },
  {
    "function_name": "esxStorageVolLookupByPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "490-534",
    "snippet": "static virStorageVolPtr\nesxStorageVolLookupByPath(virConnectPtr conn, const char *path)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = conn->privateData;\n    esxVI_ScsiLun *scsiLunList = NULL;\n    esxVI_ScsiLun *scsiLun;\n    esxVI_HostScsiDisk *hostScsiDisk = NULL;\n    char *poolName = NULL;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    if (esxVI_LookupScsiLunList(priv->primary, &scsiLunList) < 0)\n        goto cleanup;\n\n    for (scsiLun = scsiLunList; scsiLun; scsiLun = scsiLun->_next) {\n        hostScsiDisk = esxVI_HostScsiDisk_DynamicCast(scsiLun);\n\n        if (hostScsiDisk && STREQ(hostScsiDisk->devicePath, path)) {\n            /* Found matching device */\n            VIR_FREE(poolName);\n\n            if (esxVI_LookupStoragePoolNameByScsiLunKey(priv->primary,\n                                                        hostScsiDisk->key,\n                                                        &poolName) < 0) {\n                goto cleanup;\n            }\n\n            if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, scsiLun->uuid, md5) < 0)\n                goto cleanup;\n            virUUIDFormat(md5, uuid_string);\n\n            volume = virGetStorageVol(conn, poolName, path, uuid_string,\n                                      &esxStorageBackendISCSI, NULL);\n            break;\n        }\n    }\n\n cleanup:\n    esxVI_ScsiLun_Free(&scsiLunList);\n    VIR_FREE(poolName);\n\n    return volume;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virStorageDriver esxStorageBackendISCSI = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 1.0.1 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 1.0.1 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 1.0.1 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 1.0.1 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 1.0.1 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 1.0.1 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 1.0.1 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 1.0.1 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 1.0.1 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 1.0.1 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 1.0.1 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 1.0.1 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 1.0.1 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 1.0.1 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 1.2.5 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 1.0.1 */\n    .storageVolDelete = esxStorageVolDelete, /* 1.0.1 */\n    .storageVolWipe = esxStorageVolWipe, /* 1.0.1 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 1.0.1 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "poolName"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ScsiLun_Free",
          "args": [
            "&scsiLunList"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetStorageVol",
          "args": [
            "conn",
            "poolName",
            "path",
            "uuid_string",
            "&esxStorageBackendISCSI",
            "NULL"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "virGetStorageVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "600-632",
          "snippet": "virStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virStorageVolClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virStorageVolClass;\n\nvirStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "md5",
            "uuid_string"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCryptoHashBuf",
          "args": [
            "VIR_CRYPTO_HASH_MD5",
            "scsiLun->uuid",
            "md5"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "virCryptoHashBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
          "lines": "52-73",
          "snippet": "ssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"virrandom.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nstruct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};\n\nssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupStoragePoolNameByScsiLunKey",
          "args": [
            "priv->primary",
            "hostScsiDisk->key",
            "&poolName"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupStoragePoolNameByScsiLunKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4786-4867",
          "snippet": "int\nesxVI_LookupStoragePoolNameByScsiLunKey(esxVI_Context *ctx,\n                                        const char *key,\n                                        char **poolName)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterfaceList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterface = NULL;\n    esxVI_HostScsiTopologyTarget *hostScsiTopologyTarget = NULL;\n    esxVI_HostInternetScsiTargetTransport *candidate;\n    esxVI_HostScsiTopologyLun *hostScsiTopologyLun;\n    bool found = false;\n\n    ESX_VI_CHECK_ARG_LIST(poolName);\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList,\n           \"config.storageDevice.scsiTopology.adapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.scsiTopology.adapter\")) {\n            esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n            if (esxVI_HostScsiTopologyInterface_CastListFromAnyType\n                  (dynamicProperty->val, &hostScsiInterfaceList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!hostScsiInterfaceList) {\n        /* iSCSI adapter may not be enabled */\n        return 0;\n    }\n\n    /* See vSphere API documentation about HostScsiTopologyInterface */\n    for (hostScsiInterface = hostScsiInterfaceList;\n         hostScsiInterface && !found;\n         hostScsiInterface = hostScsiInterface->_next) {\n        for (hostScsiTopologyTarget = hostScsiInterface->target;\n             hostScsiTopologyTarget;\n             hostScsiTopologyTarget = hostScsiTopologyTarget->_next) {\n            candidate = esxVI_HostInternetScsiTargetTransport_DynamicCast\n                (hostScsiTopologyTarget->transport);\n\n            if (candidate) {\n                /* iterate hostScsiTopologyLun list to find matching key */\n                for (hostScsiTopologyLun = hostScsiTopologyTarget->lun;\n                     hostScsiTopologyLun;\n                     hostScsiTopologyLun = hostScsiTopologyLun->_next) {\n                    if (STREQ(hostScsiTopologyLun->scsiLun, key))\n                        *poolName = g_strdup(candidate->iScsiName);\n                }\n\n                /* hostScsiTopologyLun iteration done, terminate loop */\n                break;\n            }\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupStoragePoolNameByScsiLunKey(esxVI_Context *ctx,\n                                        const char *key,\n                                        char **poolName)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterfaceList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterface = NULL;\n    esxVI_HostScsiTopologyTarget *hostScsiTopologyTarget = NULL;\n    esxVI_HostInternetScsiTargetTransport *candidate;\n    esxVI_HostScsiTopologyLun *hostScsiTopologyLun;\n    bool found = false;\n\n    ESX_VI_CHECK_ARG_LIST(poolName);\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList,\n           \"config.storageDevice.scsiTopology.adapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.scsiTopology.adapter\")) {\n            esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n            if (esxVI_HostScsiTopologyInterface_CastListFromAnyType\n                  (dynamicProperty->val, &hostScsiInterfaceList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!hostScsiInterfaceList) {\n        /* iSCSI adapter may not be enabled */\n        return 0;\n    }\n\n    /* See vSphere API documentation about HostScsiTopologyInterface */\n    for (hostScsiInterface = hostScsiInterfaceList;\n         hostScsiInterface && !found;\n         hostScsiInterface = hostScsiInterface->_next) {\n        for (hostScsiTopologyTarget = hostScsiInterface->target;\n             hostScsiTopologyTarget;\n             hostScsiTopologyTarget = hostScsiTopologyTarget->_next) {\n            candidate = esxVI_HostInternetScsiTargetTransport_DynamicCast\n                (hostScsiTopologyTarget->transport);\n\n            if (candidate) {\n                /* iterate hostScsiTopologyLun list to find matching key */\n                for (hostScsiTopologyLun = hostScsiTopologyTarget->lun;\n                     hostScsiTopologyLun;\n                     hostScsiTopologyLun = hostScsiTopologyLun->_next) {\n                    if (STREQ(hostScsiTopologyLun->scsiLun, key))\n                        *poolName = g_strdup(candidate->iScsiName);\n                }\n\n                /* hostScsiTopologyLun iteration done, terminate loop */\n                break;\n            }\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "poolName"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "hostScsiDisk->devicePath",
            "path"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostScsiDisk_DynamicCast",
          "args": [
            "scsiLun"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupScsiLunList",
          "args": [
            "priv->primary",
            "&scsiLunList"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupScsiLunList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4656-4692",
          "snippet": "int\nesxVI_LookupScsiLunList(esxVI_Context *ctx, esxVI_ScsiLun **scsiLunList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.storageDevice.scsiLun\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.storageDevice.scsiLun\")) {\n            if (esxVI_ScsiLun_CastListFromAnyType(dynamicProperty->val,\n                                                  scsiLunList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupScsiLunList(esxVI_Context *ctx, esxVI_ScsiLun **scsiLunList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.storageDevice.scsiLun\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.storageDevice.scsiLun\")) {\n            if (esxVI_ScsiLun_CastListFromAnyType(dynamicProperty->val,\n                                                  scsiLunList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirStorageDriver esxStorageBackendISCSI = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 1.0.1 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 1.0.1 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 1.0.1 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 1.0.1 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 1.0.1 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 1.0.1 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 1.0.1 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 1.0.1 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 1.0.1 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 1.0.1 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 1.0.1 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 1.0.1 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 1.0.1 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 1.0.1 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 1.2.5 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 1.0.1 */\n    .storageVolDelete = esxStorageVolDelete, /* 1.0.1 */\n    .storageVolWipe = esxStorageVolWipe, /* 1.0.1 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 1.0.1 */\n};\n\nstatic virStorageVolPtr\nesxStorageVolLookupByPath(virConnectPtr conn, const char *path)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = conn->privateData;\n    esxVI_ScsiLun *scsiLunList = NULL;\n    esxVI_ScsiLun *scsiLun;\n    esxVI_HostScsiDisk *hostScsiDisk = NULL;\n    char *poolName = NULL;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    if (esxVI_LookupScsiLunList(priv->primary, &scsiLunList) < 0)\n        goto cleanup;\n\n    for (scsiLun = scsiLunList; scsiLun; scsiLun = scsiLun->_next) {\n        hostScsiDisk = esxVI_HostScsiDisk_DynamicCast(scsiLun);\n\n        if (hostScsiDisk && STREQ(hostScsiDisk->devicePath, path)) {\n            /* Found matching device */\n            VIR_FREE(poolName);\n\n            if (esxVI_LookupStoragePoolNameByScsiLunKey(priv->primary,\n                                                        hostScsiDisk->key,\n                                                        &poolName) < 0) {\n                goto cleanup;\n            }\n\n            if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, scsiLun->uuid, md5) < 0)\n                goto cleanup;\n            virUUIDFormat(md5, uuid_string);\n\n            volume = virGetStorageVol(conn, poolName, path, uuid_string,\n                                      &esxStorageBackendISCSI, NULL);\n            break;\n        }\n    }\n\n cleanup:\n    esxVI_ScsiLun_Free(&scsiLunList);\n    VIR_FREE(poolName);\n\n    return volume;\n}"
  },
  {
    "function_name": "esxStorageVolLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "443-486",
    "snippet": "static virStorageVolPtr\nesxStorageVolLookupByName(virStoragePoolPtr pool,\n                          const char *name)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_ScsiLun *scsiLunList = NULL;\n    esxVI_ScsiLun *scsiLun;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    if (esxVI_LookupScsiLunList(priv->primary, &scsiLunList) < 0)\n        goto cleanup;\n\n    for (scsiLun = scsiLunList; scsiLun;\n         scsiLun = scsiLun->_next) {\n        if (STREQ(scsiLun->deviceName, name)) {\n            /*\n             * ScsiLun provides a UUID field that is unique across\n             * multiple servers. But this field length is ~55 characters\n             * compute MD5 hash to transform it to an acceptable\n             * libvirt format\n             */\n            if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, scsiLun->uuid, md5) < 0)\n                goto cleanup;\n            virUUIDFormat(md5, uuid_string);\n\n            /*\n             * ScsiLun provides displayName and canonicalName but both are\n             * optional and its observed that they can be NULL, using\n             * deviceName to create volume.\n             */\n            volume = virGetStorageVol(pool->conn, pool->name, name, uuid_string,\n                                      &esxStorageBackendISCSI, NULL);\n            break;\n        }\n    }\n\n cleanup:\n    esxVI_ScsiLun_Free(&scsiLunList);\n\n    return volume;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virStorageDriver esxStorageBackendISCSI = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 1.0.1 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 1.0.1 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 1.0.1 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 1.0.1 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 1.0.1 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 1.0.1 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 1.0.1 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 1.0.1 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 1.0.1 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 1.0.1 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 1.0.1 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 1.0.1 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 1.0.1 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 1.0.1 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 1.2.5 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 1.0.1 */\n    .storageVolDelete = esxStorageVolDelete, /* 1.0.1 */\n    .storageVolWipe = esxStorageVolWipe, /* 1.0.1 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 1.0.1 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ScsiLun_Free",
          "args": [
            "&scsiLunList"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetStorageVol",
          "args": [
            "pool->conn",
            "pool->name",
            "name",
            "uuid_string",
            "&esxStorageBackendISCSI",
            "NULL"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "virGetStorageVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "600-632",
          "snippet": "virStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virStorageVolClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virStorageVolClass;\n\nvirStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "md5",
            "uuid_string"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCryptoHashBuf",
          "args": [
            "VIR_CRYPTO_HASH_MD5",
            "scsiLun->uuid",
            "md5"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "virCryptoHashBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
          "lines": "52-73",
          "snippet": "ssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"virrandom.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nstruct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};\n\nssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "scsiLun->deviceName",
            "name"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupScsiLunList",
          "args": [
            "priv->primary",
            "&scsiLunList"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupScsiLunList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4656-4692",
          "snippet": "int\nesxVI_LookupScsiLunList(esxVI_Context *ctx, esxVI_ScsiLun **scsiLunList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.storageDevice.scsiLun\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.storageDevice.scsiLun\")) {\n            if (esxVI_ScsiLun_CastListFromAnyType(dynamicProperty->val,\n                                                  scsiLunList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupScsiLunList(esxVI_Context *ctx, esxVI_ScsiLun **scsiLunList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.storageDevice.scsiLun\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.storageDevice.scsiLun\")) {\n            if (esxVI_ScsiLun_CastListFromAnyType(dynamicProperty->val,\n                                                  scsiLunList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirStorageDriver esxStorageBackendISCSI = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 1.0.1 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 1.0.1 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 1.0.1 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 1.0.1 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 1.0.1 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 1.0.1 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 1.0.1 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 1.0.1 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 1.0.1 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 1.0.1 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 1.0.1 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 1.0.1 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 1.0.1 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 1.0.1 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 1.2.5 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 1.0.1 */\n    .storageVolDelete = esxStorageVolDelete, /* 1.0.1 */\n    .storageVolWipe = esxStorageVolWipe, /* 1.0.1 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 1.0.1 */\n};\n\nstatic virStorageVolPtr\nesxStorageVolLookupByName(virStoragePoolPtr pool,\n                          const char *name)\n{\n    virStorageVolPtr volume = NULL;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_ScsiLun *scsiLunList = NULL;\n    esxVI_ScsiLun *scsiLun;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    if (esxVI_LookupScsiLunList(priv->primary, &scsiLunList) < 0)\n        goto cleanup;\n\n    for (scsiLun = scsiLunList; scsiLun;\n         scsiLun = scsiLun->_next) {\n        if (STREQ(scsiLun->deviceName, name)) {\n            /*\n             * ScsiLun provides a UUID field that is unique across\n             * multiple servers. But this field length is ~55 characters\n             * compute MD5 hash to transform it to an acceptable\n             * libvirt format\n             */\n            if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, scsiLun->uuid, md5) < 0)\n                goto cleanup;\n            virUUIDFormat(md5, uuid_string);\n\n            /*\n             * ScsiLun provides displayName and canonicalName but both are\n             * optional and its observed that they can be NULL, using\n             * deviceName to create volume.\n             */\n            volume = virGetStorageVol(pool->conn, pool->name, name, uuid_string,\n                                      &esxStorageBackendISCSI, NULL);\n            break;\n        }\n    }\n\n cleanup:\n    esxVI_ScsiLun_Free(&scsiLunList);\n\n    return volume;\n}"
  },
  {
    "function_name": "esxStoragePoolListVolumes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "386-439",
    "snippet": "static int\nesxStoragePoolListVolumes(virStoragePoolPtr pool, char **const names,\n                          int maxnames)\n{\n    bool success = false;\n    int count = 0;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_HostScsiTopologyLun *hostScsiTopologyLunList = NULL;\n    esxVI_HostScsiTopologyLun *hostScsiTopologyLun;\n    esxVI_ScsiLun *scsiLunList = NULL;\n    esxVI_ScsiLun *scsiLun = NULL;\n    size_t i;\n\n    if (esxVI_LookupHostScsiTopologyLunListByTargetName\n          (priv->primary, pool->name, &hostScsiTopologyLunList) < 0) {\n        goto cleanup;\n    }\n\n    if (!hostScsiTopologyLunList) {\n        /* iSCSI adapter may not be enabled on ESX host */\n        return 0;\n    }\n\n    if (esxVI_LookupScsiLunList(priv->primary, &scsiLunList) < 0)\n        goto cleanup;\n\n    for (scsiLun = scsiLunList; scsiLun && count < maxnames;\n         scsiLun = scsiLun->_next) {\n        for (hostScsiTopologyLun = hostScsiTopologyLunList;\n             hostScsiTopologyLun && count < maxnames;\n             hostScsiTopologyLun = hostScsiTopologyLun->_next) {\n            if (STREQ(hostScsiTopologyLun->scsiLun, scsiLun->key)) {\n                names[count] = g_strdup(scsiLun->deviceName);\n\n                ++count;\n            }\n        }\n    }\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        for (i = 0; i < count; ++i)\n            VIR_FREE(names[i]);\n\n        count = -1;\n    }\n\n    esxVI_HostScsiTopologyLun_Free(&hostScsiTopologyLunList);\n    esxVI_ScsiLun_Free(&scsiLunList);\n\n    return count;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ScsiLun_Free",
          "args": [
            "&scsiLunList"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostScsiTopologyLun_Free",
          "args": [
            "&hostScsiTopologyLunList"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "names[i]"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "scsiLun->deviceName"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "hostScsiTopologyLun->scsiLun",
            "scsiLun->key"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupScsiLunList",
          "args": [
            "priv->primary",
            "&scsiLunList"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupScsiLunList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4656-4692",
          "snippet": "int\nesxVI_LookupScsiLunList(esxVI_Context *ctx, esxVI_ScsiLun **scsiLunList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.storageDevice.scsiLun\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.storageDevice.scsiLun\")) {\n            if (esxVI_ScsiLun_CastListFromAnyType(dynamicProperty->val,\n                                                  scsiLunList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupScsiLunList(esxVI_Context *ctx, esxVI_ScsiLun **scsiLunList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.storageDevice.scsiLun\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.storageDevice.scsiLun\")) {\n            if (esxVI_ScsiLun_CastListFromAnyType(dynamicProperty->val,\n                                                  scsiLunList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostScsiTopologyLunListByTargetName",
          "args": [
            "priv->primary",
            "pool->name",
            "&hostScsiTopologyLunList"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostScsiTopologyLunListByTargetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4696-4782",
          "snippet": "int\nesxVI_LookupHostScsiTopologyLunListByTargetName\n  (esxVI_Context *ctx, const char *name,\n   esxVI_HostScsiTopologyLun **hostScsiTopologyLunList)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterfaceList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterface = NULL;\n    esxVI_HostScsiTopologyTarget *hostScsiTopologyTarget = NULL;\n    bool found = false;\n    esxVI_HostInternetScsiTargetTransport *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostScsiTopologyLunList);\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList,\n           \"config.storageDevice.scsiTopology.adapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.scsiTopology.adapter\")) {\n            esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n            if (esxVI_HostScsiTopologyInterface_CastListFromAnyType\n                  (dynamicProperty->val, &hostScsiInterfaceList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (hostScsiInterfaceList == NULL) {\n        /* iSCSI adapter may not be enabled */\n        return 0;\n    }\n\n    /* See vSphere API documentation about HostScsiTopologyInterface */\n    for (hostScsiInterface = hostScsiInterfaceList;\n         hostScsiInterface && !found;\n         hostScsiInterface = hostScsiInterface->_next) {\n        for (hostScsiTopologyTarget = hostScsiInterface->target;\n             hostScsiTopologyTarget;\n             hostScsiTopologyTarget = hostScsiTopologyTarget->_next) {\n            candidate = esxVI_HostInternetScsiTargetTransport_DynamicCast\n                          (hostScsiTopologyTarget->transport);\n\n            if (candidate && STREQ(candidate->iScsiName, name)) {\n                found = true;\n                break;\n            }\n        }\n    }\n\n    if (!found || !hostScsiTopologyTarget)\n        goto cleanup;\n\n    if (!hostScsiTopologyTarget->lun) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Target not found\"));\n        goto cleanup;\n    }\n\n    if (esxVI_HostScsiTopologyLun_DeepCopyList(hostScsiTopologyLunList,\n                                               hostScsiTopologyTarget->lun) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostScsiTopologyLunListByTargetName\n  (esxVI_Context *ctx, const char *name,\n   esxVI_HostScsiTopologyLun **hostScsiTopologyLunList)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterfaceList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterface = NULL;\n    esxVI_HostScsiTopologyTarget *hostScsiTopologyTarget = NULL;\n    bool found = false;\n    esxVI_HostInternetScsiTargetTransport *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostScsiTopologyLunList);\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList,\n           \"config.storageDevice.scsiTopology.adapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.scsiTopology.adapter\")) {\n            esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n            if (esxVI_HostScsiTopologyInterface_CastListFromAnyType\n                  (dynamicProperty->val, &hostScsiInterfaceList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (hostScsiInterfaceList == NULL) {\n        /* iSCSI adapter may not be enabled */\n        return 0;\n    }\n\n    /* See vSphere API documentation about HostScsiTopologyInterface */\n    for (hostScsiInterface = hostScsiInterfaceList;\n         hostScsiInterface && !found;\n         hostScsiInterface = hostScsiInterface->_next) {\n        for (hostScsiTopologyTarget = hostScsiInterface->target;\n             hostScsiTopologyTarget;\n             hostScsiTopologyTarget = hostScsiTopologyTarget->_next) {\n            candidate = esxVI_HostInternetScsiTargetTransport_DynamicCast\n                          (hostScsiTopologyTarget->transport);\n\n            if (candidate && STREQ(candidate->iScsiName, name)) {\n                found = true;\n                break;\n            }\n        }\n    }\n\n    if (!found || !hostScsiTopologyTarget)\n        goto cleanup;\n\n    if (!hostScsiTopologyTarget->lun) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Target not found\"));\n        goto cleanup;\n    }\n\n    if (esxVI_HostScsiTopologyLun_DeepCopyList(hostScsiTopologyLunList,\n                                               hostScsiTopologyTarget->lun) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxStoragePoolListVolumes(virStoragePoolPtr pool, char **const names,\n                          int maxnames)\n{\n    bool success = false;\n    int count = 0;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_HostScsiTopologyLun *hostScsiTopologyLunList = NULL;\n    esxVI_HostScsiTopologyLun *hostScsiTopologyLun;\n    esxVI_ScsiLun *scsiLunList = NULL;\n    esxVI_ScsiLun *scsiLun = NULL;\n    size_t i;\n\n    if (esxVI_LookupHostScsiTopologyLunListByTargetName\n          (priv->primary, pool->name, &hostScsiTopologyLunList) < 0) {\n        goto cleanup;\n    }\n\n    if (!hostScsiTopologyLunList) {\n        /* iSCSI adapter may not be enabled on ESX host */\n        return 0;\n    }\n\n    if (esxVI_LookupScsiLunList(priv->primary, &scsiLunList) < 0)\n        goto cleanup;\n\n    for (scsiLun = scsiLunList; scsiLun && count < maxnames;\n         scsiLun = scsiLun->_next) {\n        for (hostScsiTopologyLun = hostScsiTopologyLunList;\n             hostScsiTopologyLun && count < maxnames;\n             hostScsiTopologyLun = hostScsiTopologyLun->_next) {\n            if (STREQ(hostScsiTopologyLun->scsiLun, scsiLun->key)) {\n                names[count] = g_strdup(scsiLun->deviceName);\n\n                ++count;\n            }\n        }\n    }\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        for (i = 0; i < count; ++i)\n            VIR_FREE(names[i]);\n\n        count = -1;\n    }\n\n    esxVI_HostScsiTopologyLun_Free(&hostScsiTopologyLunList);\n    esxVI_ScsiLun_Free(&scsiLunList);\n\n    return count;\n}"
  },
  {
    "function_name": "esxStoragePoolNumOfVolumes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "360-382",
    "snippet": "static int\nesxStoragePoolNumOfVolumes(virStoragePoolPtr pool)\n{\n    int count = 0;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_HostScsiTopologyLun *hostScsiTopologyLunList = NULL;\n    esxVI_HostScsiTopologyLun *hostScsiTopologyLun;\n\n    if (esxVI_LookupHostScsiTopologyLunListByTargetName\n          (priv->primary, pool->name, &hostScsiTopologyLunList) < 0) {\n        return -1;\n    }\n\n    for (hostScsiTopologyLun = hostScsiTopologyLunList;\n         hostScsiTopologyLun;\n         hostScsiTopologyLun = hostScsiTopologyLun->_next) {\n        ++count;\n    }\n\n    esxVI_HostScsiTopologyLun_Free(&hostScsiTopologyLunList);\n\n    return count;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostScsiTopologyLun_Free",
          "args": [
            "&hostScsiTopologyLunList"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostScsiTopologyLunListByTargetName",
          "args": [
            "priv->primary",
            "pool->name",
            "&hostScsiTopologyLunList"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostScsiTopologyLunListByTargetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4696-4782",
          "snippet": "int\nesxVI_LookupHostScsiTopologyLunListByTargetName\n  (esxVI_Context *ctx, const char *name,\n   esxVI_HostScsiTopologyLun **hostScsiTopologyLunList)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterfaceList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterface = NULL;\n    esxVI_HostScsiTopologyTarget *hostScsiTopologyTarget = NULL;\n    bool found = false;\n    esxVI_HostInternetScsiTargetTransport *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostScsiTopologyLunList);\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList,\n           \"config.storageDevice.scsiTopology.adapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.scsiTopology.adapter\")) {\n            esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n            if (esxVI_HostScsiTopologyInterface_CastListFromAnyType\n                  (dynamicProperty->val, &hostScsiInterfaceList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (hostScsiInterfaceList == NULL) {\n        /* iSCSI adapter may not be enabled */\n        return 0;\n    }\n\n    /* See vSphere API documentation about HostScsiTopologyInterface */\n    for (hostScsiInterface = hostScsiInterfaceList;\n         hostScsiInterface && !found;\n         hostScsiInterface = hostScsiInterface->_next) {\n        for (hostScsiTopologyTarget = hostScsiInterface->target;\n             hostScsiTopologyTarget;\n             hostScsiTopologyTarget = hostScsiTopologyTarget->_next) {\n            candidate = esxVI_HostInternetScsiTargetTransport_DynamicCast\n                          (hostScsiTopologyTarget->transport);\n\n            if (candidate && STREQ(candidate->iScsiName, name)) {\n                found = true;\n                break;\n            }\n        }\n    }\n\n    if (!found || !hostScsiTopologyTarget)\n        goto cleanup;\n\n    if (!hostScsiTopologyTarget->lun) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Target not found\"));\n        goto cleanup;\n    }\n\n    if (esxVI_HostScsiTopologyLun_DeepCopyList(hostScsiTopologyLunList,\n                                               hostScsiTopologyTarget->lun) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostScsiTopologyLunListByTargetName\n  (esxVI_Context *ctx, const char *name,\n   esxVI_HostScsiTopologyLun **hostScsiTopologyLunList)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterfaceList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterface = NULL;\n    esxVI_HostScsiTopologyTarget *hostScsiTopologyTarget = NULL;\n    bool found = false;\n    esxVI_HostInternetScsiTargetTransport *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostScsiTopologyLunList);\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList,\n           \"config.storageDevice.scsiTopology.adapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.scsiTopology.adapter\")) {\n            esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n            if (esxVI_HostScsiTopologyInterface_CastListFromAnyType\n                  (dynamicProperty->val, &hostScsiInterfaceList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (hostScsiInterfaceList == NULL) {\n        /* iSCSI adapter may not be enabled */\n        return 0;\n    }\n\n    /* See vSphere API documentation about HostScsiTopologyInterface */\n    for (hostScsiInterface = hostScsiInterfaceList;\n         hostScsiInterface && !found;\n         hostScsiInterface = hostScsiInterface->_next) {\n        for (hostScsiTopologyTarget = hostScsiInterface->target;\n             hostScsiTopologyTarget;\n             hostScsiTopologyTarget = hostScsiTopologyTarget->_next) {\n            candidate = esxVI_HostInternetScsiTargetTransport_DynamicCast\n                          (hostScsiTopologyTarget->transport);\n\n            if (candidate && STREQ(candidate->iScsiName, name)) {\n                found = true;\n                break;\n            }\n        }\n    }\n\n    if (!found || !hostScsiTopologyTarget)\n        goto cleanup;\n\n    if (!hostScsiTopologyTarget->lun) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Target not found\"));\n        goto cleanup;\n    }\n\n    if (esxVI_HostScsiTopologyLun_DeepCopyList(hostScsiTopologyLunList,\n                                               hostScsiTopologyTarget->lun) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxStoragePoolNumOfVolumes(virStoragePoolPtr pool)\n{\n    int count = 0;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_HostScsiTopologyLun *hostScsiTopologyLunList = NULL;\n    esxVI_HostScsiTopologyLun *hostScsiTopologyLun;\n\n    if (esxVI_LookupHostScsiTopologyLunListByTargetName\n          (priv->primary, pool->name, &hostScsiTopologyLunList) < 0) {\n        return -1;\n    }\n\n    for (hostScsiTopologyLun = hostScsiTopologyLunList;\n         hostScsiTopologyLun;\n         hostScsiTopologyLun = hostScsiTopologyLun->_next) {\n        ++count;\n    }\n\n    esxVI_HostScsiTopologyLun_Free(&hostScsiTopologyLunList);\n\n    return count;\n}"
  },
  {
    "function_name": "esxStoragePoolGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "300-356",
    "snippet": "static char *\nesxStoragePoolGetXMLDesc(virStoragePoolPtr pool, unsigned int flags)\n{\n    char *xml = NULL;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_HostInternetScsiHba *hostInternetScsiHba = NULL;\n    esxVI_HostInternetScsiHbaStaticTarget *target;\n    virStoragePoolDef def;\n\n    virCheckFlags(0, NULL);\n\n    memset(&def, 0, sizeof(def));\n\n    if (esxVI_LookupHostInternetScsiHba(priv->primary, &hostInternetScsiHba))\n        goto cleanup;\n\n    for (target = hostInternetScsiHba->configuredStaticTarget;\n         target; target = target->_next) {\n        if (STREQ(target->iScsiName, pool->name))\n            break;\n    }\n\n    if (!target) {\n        /* pool not found */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find storage pool with name '%s'\"),\n                       pool->name);\n        goto cleanup;\n    }\n\n    def.name = pool->name;\n\n    memcpy(def.uuid, pool->uuid, VIR_UUID_BUFLEN);\n\n    def.type = VIR_STORAGE_POOL_ISCSI;\n\n    def.source.initiator.iqn = target->iScsiName;\n\n    def.source.nhost = 1;\n\n    if (VIR_ALLOC_N(def.source.hosts, def.source.nhost) < 0)\n        goto cleanup;\n\n    def.source.hosts[0].name = target->address;\n\n    if (target->port)\n        def.source.hosts[0].port = target->port->value;\n\n    /* TODO: add CHAP authentication params */\n    xml = virStoragePoolDefFormat(&def);\n\n cleanup:\n    VIR_FREE(def.source.hosts);\n    esxVI_HostInternetScsiHba_Free(&hostInternetScsiHba);\n\n    return xml;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostInternetScsiHba_Free",
          "args": [
            "&hostInternetScsiHba"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def.source.hosts"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolDefFormat",
          "args": [
            "&def"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "1225-1238",
          "snippet": "char *\nvirStoragePoolDefFormat(virStoragePoolDefPtr def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virStoragePoolDefFormatBuf(&buf, def) < 0)\n        goto error;\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirStoragePoolDefFormat(virStoragePoolDefPtr def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virStoragePoolDefFormatBuf(&buf, def) < 0)\n        goto error;\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def.source.hosts",
            "def.source.nhost"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "def.uuid",
            "pool->uuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not find storage pool with name '%s'\")",
            "pool->name"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find storage pool with name '%s'\""
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "target->iScsiName",
            "pool->name"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostInternetScsiHba",
          "args": [
            "priv->primary",
            "&hostInternetScsiHba"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostInternetScsiHba",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4596-4652",
          "snippet": "int\nesxVI_LookupHostInternetScsiHba(esxVI_Context *ctx,\n                                esxVI_HostInternetScsiHba **hostInternetScsiHba)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapterList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapter = NULL;\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList, \"config.storageDevice.hostBusAdapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.hostBusAdapter\")) {\n            if (esxVI_HostHostBusAdapter_CastListFromAnyType\n                (dynamicProperty->val, &hostHostBusAdapterList) < 0 ||\n                !hostHostBusAdapterList) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    /* See vSphere API documentation about HostInternetScsiHba for details */\n    for (hostHostBusAdapter = hostHostBusAdapterList;\n         hostHostBusAdapter;\n         hostHostBusAdapter = hostHostBusAdapter->_next) {\n        esxVI_HostInternetScsiHba *candidate =\n            esxVI_HostInternetScsiHba_DynamicCast(hostHostBusAdapter);\n\n        if (candidate) {\n            if (esxVI_HostInternetScsiHba_DeepCopy(hostInternetScsiHba,\n                  candidate) < 0) {\n                goto cleanup;\n            }\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostHostBusAdapter_Free(&hostHostBusAdapterList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostInternetScsiHba(esxVI_Context *ctx,\n                                esxVI_HostInternetScsiHba **hostInternetScsiHba)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapterList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapter = NULL;\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList, \"config.storageDevice.hostBusAdapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.hostBusAdapter\")) {\n            if (esxVI_HostHostBusAdapter_CastListFromAnyType\n                (dynamicProperty->val, &hostHostBusAdapterList) < 0 ||\n                !hostHostBusAdapterList) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    /* See vSphere API documentation about HostInternetScsiHba for details */\n    for (hostHostBusAdapter = hostHostBusAdapterList;\n         hostHostBusAdapter;\n         hostHostBusAdapter = hostHostBusAdapter->_next) {\n        esxVI_HostInternetScsiHba *candidate =\n            esxVI_HostInternetScsiHba_DynamicCast(hostHostBusAdapter);\n\n        if (candidate) {\n            if (esxVI_HostInternetScsiHba_DeepCopy(hostInternetScsiHba,\n                  candidate) < 0) {\n                goto cleanup;\n            }\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostHostBusAdapter_Free(&hostHostBusAdapterList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&def",
            "0",
            "sizeof(def)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nesxStoragePoolGetXMLDesc(virStoragePoolPtr pool, unsigned int flags)\n{\n    char *xml = NULL;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_HostInternetScsiHba *hostInternetScsiHba = NULL;\n    esxVI_HostInternetScsiHbaStaticTarget *target;\n    virStoragePoolDef def;\n\n    virCheckFlags(0, NULL);\n\n    memset(&def, 0, sizeof(def));\n\n    if (esxVI_LookupHostInternetScsiHba(priv->primary, &hostInternetScsiHba))\n        goto cleanup;\n\n    for (target = hostInternetScsiHba->configuredStaticTarget;\n         target; target = target->_next) {\n        if (STREQ(target->iScsiName, pool->name))\n            break;\n    }\n\n    if (!target) {\n        /* pool not found */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find storage pool with name '%s'\"),\n                       pool->name);\n        goto cleanup;\n    }\n\n    def.name = pool->name;\n\n    memcpy(def.uuid, pool->uuid, VIR_UUID_BUFLEN);\n\n    def.type = VIR_STORAGE_POOL_ISCSI;\n\n    def.source.initiator.iqn = target->iScsiName;\n\n    def.source.nhost = 1;\n\n    if (VIR_ALLOC_N(def.source.hosts, def.source.nhost) < 0)\n        goto cleanup;\n\n    def.source.hosts[0].name = target->address;\n\n    if (target->port)\n        def.source.hosts[0].port = target->port->value;\n\n    /* TODO: add CHAP authentication params */\n    xml = virStoragePoolDefFormat(&def);\n\n cleanup:\n    VIR_FREE(def.source.hosts);\n    esxVI_HostInternetScsiHba_Free(&hostInternetScsiHba);\n\n    return xml;\n}"
  },
  {
    "function_name": "esxStoragePoolGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "287-296",
    "snippet": "static int\nesxStoragePoolGetInfo(virStoragePoolPtr pool G_GNUC_UNUSED,\n                      virStoragePoolInfoPtr info)\n{\n    /* These fields are not valid for iSCSI pool */\n    info->allocation = info->capacity = info->available = 0;\n    info->state = VIR_STORAGE_POOL_RUNNING;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxStoragePoolGetInfo(virStoragePoolPtr pool G_GNUC_UNUSED,\n                      virStoragePoolInfoPtr info)\n{\n    /* These fields are not valid for iSCSI pool */\n    info->allocation = info->capacity = info->available = 0;\n    info->state = VIR_STORAGE_POOL_RUNNING;\n\n    return 0;\n}"
  },
  {
    "function_name": "esxStoragePoolRefresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "252-283",
    "snippet": "static int\nesxStoragePoolRefresh(virStoragePoolPtr pool,\n                      unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_HostInternetScsiHba *hostInternetScsiHba = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_LookupHostInternetScsiHba(priv->primary,\n                                        &hostInternetScsiHba) < 0) {\n        goto cleanup;\n    }\n\n    /*\n     * ESX does not allow rescan on a particular target,\n     * rescan all the static targets\n     */\n    if (esxVI_RescanHba(priv->primary,\n                        priv->primary->hostSystem->configManager->storageSystem,\n                        hostInternetScsiHba->device) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_HostInternetScsiHba_Free(&hostInternetScsiHba);\n\n    return result;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostInternetScsiHba_Free",
          "args": [
            "&hostInternetScsiHba"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_RescanHba",
          "args": [
            "priv->primary",
            "priv->primary->hostSystem->configManager->storageSystem",
            "hostInternetScsiHba->device"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostInternetScsiHba",
          "args": [
            "priv->primary",
            "&hostInternetScsiHba"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostInternetScsiHba",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4596-4652",
          "snippet": "int\nesxVI_LookupHostInternetScsiHba(esxVI_Context *ctx,\n                                esxVI_HostInternetScsiHba **hostInternetScsiHba)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapterList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapter = NULL;\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList, \"config.storageDevice.hostBusAdapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.hostBusAdapter\")) {\n            if (esxVI_HostHostBusAdapter_CastListFromAnyType\n                (dynamicProperty->val, &hostHostBusAdapterList) < 0 ||\n                !hostHostBusAdapterList) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    /* See vSphere API documentation about HostInternetScsiHba for details */\n    for (hostHostBusAdapter = hostHostBusAdapterList;\n         hostHostBusAdapter;\n         hostHostBusAdapter = hostHostBusAdapter->_next) {\n        esxVI_HostInternetScsiHba *candidate =\n            esxVI_HostInternetScsiHba_DynamicCast(hostHostBusAdapter);\n\n        if (candidate) {\n            if (esxVI_HostInternetScsiHba_DeepCopy(hostInternetScsiHba,\n                  candidate) < 0) {\n                goto cleanup;\n            }\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostHostBusAdapter_Free(&hostHostBusAdapterList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostInternetScsiHba(esxVI_Context *ctx,\n                                esxVI_HostInternetScsiHba **hostInternetScsiHba)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapterList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapter = NULL;\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList, \"config.storageDevice.hostBusAdapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.hostBusAdapter\")) {\n            if (esxVI_HostHostBusAdapter_CastListFromAnyType\n                (dynamicProperty->val, &hostHostBusAdapterList) < 0 ||\n                !hostHostBusAdapterList) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    /* See vSphere API documentation about HostInternetScsiHba for details */\n    for (hostHostBusAdapter = hostHostBusAdapterList;\n         hostHostBusAdapter;\n         hostHostBusAdapter = hostHostBusAdapter->_next) {\n        esxVI_HostInternetScsiHba *candidate =\n            esxVI_HostInternetScsiHba_DynamicCast(hostHostBusAdapter);\n\n        if (candidate) {\n            if (esxVI_HostInternetScsiHba_DeepCopy(hostInternetScsiHba,\n                  candidate) < 0) {\n                goto cleanup;\n            }\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostHostBusAdapter_Free(&hostHostBusAdapterList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxStoragePoolRefresh(virStoragePoolPtr pool,\n                      unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = pool->conn->privateData;\n    esxVI_HostInternetScsiHba *hostInternetScsiHba = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_LookupHostInternetScsiHba(priv->primary,\n                                        &hostInternetScsiHba) < 0) {\n        goto cleanup;\n    }\n\n    /*\n     * ESX does not allow rescan on a particular target,\n     * rescan all the static targets\n     */\n    if (esxVI_RescanHba(priv->primary,\n                        priv->primary->hostSystem->configManager->storageSystem,\n                        hostInternetScsiHba->device) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_HostInternetScsiHba_Free(&hostInternetScsiHba);\n\n    return result;\n}"
  },
  {
    "function_name": "esxStoragePoolLookupByUUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "203-248",
    "snippet": "static virStoragePoolPtr\nesxStoragePoolLookupByUUID(virConnectPtr conn,\n                           const unsigned char *uuid)\n{\n    virStoragePoolPtr pool = NULL;\n    esxPrivate *priv = conn->privateData;\n    esxVI_HostInternetScsiHba *hostInternetScsiHba = NULL;\n    esxVI_HostInternetScsiHbaStaticTarget *target;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n\n    if (esxVI_LookupHostInternetScsiHba(priv->primary,\n                                        &hostInternetScsiHba) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to obtain iSCSI adapter\"));\n        goto cleanup;\n    }\n\n    /* FIXME: code just looks for software iSCSI adapter */\n    if (!hostInternetScsiHba) {\n        /* iSCSI adapter may not be enabled for this host */\n        return NULL;\n    }\n\n    for (target = hostInternetScsiHba->configuredStaticTarget;\n         target; target = target->_next) {\n        if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, target->iScsiName, md5) < 0)\n            goto cleanup;\n\n        if (memcmp(uuid, md5, VIR_UUID_BUFLEN) == 0)\n            break;\n    }\n\n    if (!target) {\n        /* pool not found, error handling done by the base driver */\n        goto cleanup;\n    }\n\n    pool = virGetStoragePool(conn, target->iScsiName, md5,\n                             &esxStorageBackendISCSI, NULL);\n\n cleanup:\n    esxVI_HostInternetScsiHba_Free(&hostInternetScsiHba);\n\n    return pool;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virStorageDriver esxStorageBackendISCSI = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 1.0.1 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 1.0.1 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 1.0.1 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 1.0.1 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 1.0.1 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 1.0.1 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 1.0.1 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 1.0.1 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 1.0.1 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 1.0.1 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 1.0.1 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 1.0.1 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 1.0.1 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 1.0.1 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 1.2.5 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 1.0.1 */\n    .storageVolDelete = esxStorageVolDelete, /* 1.0.1 */\n    .storageVolWipe = esxStorageVolWipe, /* 1.0.1 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 1.0.1 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostInternetScsiHba_Free",
          "args": [
            "&hostInternetScsiHba"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetStoragePool",
          "args": [
            "conn",
            "target->iScsiName",
            "md5",
            "&esxStorageBackendISCSI",
            "NULL"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "virGetStoragePool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "525-556",
          "snippet": "virStoragePoolPtr\nvirGetStoragePool(virConnectPtr conn, const char *name,\n                  const unsigned char *uuid,\n                  void *privateData, virFreeCallback freeFunc)\n{\n    virStoragePoolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virStoragePoolClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    /* set the driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virStoragePoolClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virStoragePoolClass;\n\nvirStoragePoolPtr\nvirGetStoragePool(virConnectPtr conn, const char *name,\n                  const unsigned char *uuid,\n                  void *privateData, virFreeCallback freeFunc)\n{\n    virStoragePoolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virStoragePoolClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    /* set the driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "uuid",
            "md5",
            "VIR_UUID_BUFLEN"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCryptoHashBuf",
          "args": [
            "VIR_CRYPTO_HASH_MD5",
            "target->iScsiName",
            "md5"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "virCryptoHashBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
          "lines": "52-73",
          "snippet": "ssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"virrandom.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nstruct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};\n\nssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to obtain iSCSI adapter\")"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to obtain iSCSI adapter\""
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostInternetScsiHba",
          "args": [
            "priv->primary",
            "&hostInternetScsiHba"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostInternetScsiHba",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4596-4652",
          "snippet": "int\nesxVI_LookupHostInternetScsiHba(esxVI_Context *ctx,\n                                esxVI_HostInternetScsiHba **hostInternetScsiHba)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapterList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapter = NULL;\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList, \"config.storageDevice.hostBusAdapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.hostBusAdapter\")) {\n            if (esxVI_HostHostBusAdapter_CastListFromAnyType\n                (dynamicProperty->val, &hostHostBusAdapterList) < 0 ||\n                !hostHostBusAdapterList) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    /* See vSphere API documentation about HostInternetScsiHba for details */\n    for (hostHostBusAdapter = hostHostBusAdapterList;\n         hostHostBusAdapter;\n         hostHostBusAdapter = hostHostBusAdapter->_next) {\n        esxVI_HostInternetScsiHba *candidate =\n            esxVI_HostInternetScsiHba_DynamicCast(hostHostBusAdapter);\n\n        if (candidate) {\n            if (esxVI_HostInternetScsiHba_DeepCopy(hostInternetScsiHba,\n                  candidate) < 0) {\n                goto cleanup;\n            }\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostHostBusAdapter_Free(&hostHostBusAdapterList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostInternetScsiHba(esxVI_Context *ctx,\n                                esxVI_HostInternetScsiHba **hostInternetScsiHba)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapterList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapter = NULL;\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList, \"config.storageDevice.hostBusAdapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.hostBusAdapter\")) {\n            if (esxVI_HostHostBusAdapter_CastListFromAnyType\n                (dynamicProperty->val, &hostHostBusAdapterList) < 0 ||\n                !hostHostBusAdapterList) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    /* See vSphere API documentation about HostInternetScsiHba for details */\n    for (hostHostBusAdapter = hostHostBusAdapterList;\n         hostHostBusAdapter;\n         hostHostBusAdapter = hostHostBusAdapter->_next) {\n        esxVI_HostInternetScsiHba *candidate =\n            esxVI_HostInternetScsiHba_DynamicCast(hostHostBusAdapter);\n\n        if (candidate) {\n            if (esxVI_HostInternetScsiHba_DeepCopy(hostInternetScsiHba,\n                  candidate) < 0) {\n                goto cleanup;\n            }\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostHostBusAdapter_Free(&hostHostBusAdapterList);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirStorageDriver esxStorageBackendISCSI = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 1.0.1 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 1.0.1 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 1.0.1 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 1.0.1 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 1.0.1 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 1.0.1 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 1.0.1 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 1.0.1 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 1.0.1 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 1.0.1 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 1.0.1 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 1.0.1 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 1.0.1 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 1.0.1 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 1.2.5 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 1.0.1 */\n    .storageVolDelete = esxStorageVolDelete, /* 1.0.1 */\n    .storageVolWipe = esxStorageVolWipe, /* 1.0.1 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 1.0.1 */\n};\n\nstatic virStoragePoolPtr\nesxStoragePoolLookupByUUID(virConnectPtr conn,\n                           const unsigned char *uuid)\n{\n    virStoragePoolPtr pool = NULL;\n    esxPrivate *priv = conn->privateData;\n    esxVI_HostInternetScsiHba *hostInternetScsiHba = NULL;\n    esxVI_HostInternetScsiHbaStaticTarget *target;\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n\n    if (esxVI_LookupHostInternetScsiHba(priv->primary,\n                                        &hostInternetScsiHba) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to obtain iSCSI adapter\"));\n        goto cleanup;\n    }\n\n    /* FIXME: code just looks for software iSCSI adapter */\n    if (!hostInternetScsiHba) {\n        /* iSCSI adapter may not be enabled for this host */\n        return NULL;\n    }\n\n    for (target = hostInternetScsiHba->configuredStaticTarget;\n         target; target = target->_next) {\n        if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, target->iScsiName, md5) < 0)\n            goto cleanup;\n\n        if (memcmp(uuid, md5, VIR_UUID_BUFLEN) == 0)\n            break;\n    }\n\n    if (!target) {\n        /* pool not found, error handling done by the base driver */\n        goto cleanup;\n    }\n\n    pool = virGetStoragePool(conn, target->iScsiName, md5,\n                             &esxStorageBackendISCSI, NULL);\n\n cleanup:\n    esxVI_HostInternetScsiHba_Free(&hostInternetScsiHba);\n\n    return pool;\n}"
  },
  {
    "function_name": "esxStoragePoolLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "170-199",
    "snippet": "static virStoragePoolPtr\nesxStoragePoolLookupByName(virConnectPtr conn,\n                           const char *name)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_HostInternetScsiHbaStaticTarget *target = NULL;\n    virStoragePoolPtr pool = NULL;\n\n    /*\n     * Lookup routine are used by the base driver to determine\n     * appropriate backend driver, lookup targetName as optional\n     * parameter\n     */\n    if (esxVI_LookupHostInternetScsiHbaStaticTargetByName\n          (priv->primary, name, &target, esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!target) {\n        /* pool not found, error handling done by the base driver */\n        goto cleanup;\n    }\n\n    pool = targetToStoragePool(conn, name, target);\n\n cleanup:\n    esxVI_HostInternetScsiHbaStaticTarget_Free(&target);\n\n    return pool;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostInternetScsiHbaStaticTarget_Free",
          "args": [
            "&target"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "targetToStoragePool",
          "args": [
            "conn",
            "name",
            "target"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "targetToStoragePool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
          "lines": "150-167",
          "snippet": "static virStoragePoolPtr\ntargetToStoragePool(virConnectPtr conn,\n                    const char *name,\n                    esxVI_HostInternetScsiHbaStaticTarget *target)\n{\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n\n    /*\n     * HostInternetScsiHbaStaticTarget does not provide a uuid field,\n     * but iScsiName (or widely known as IQN) is unique across the multiple\n     * hosts, using it to compute key\n     */\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, target->iScsiName, md5) < 0)\n        return NULL;\n\n    return virGetStoragePool(conn, name, md5, &esxStorageBackendISCSI, NULL);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vircrypto.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_backend_iscsi.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virStorageDriver esxStorageBackendISCSI = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 1.0.1 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 1.0.1 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 1.0.1 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 1.0.1 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 1.0.1 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 1.0.1 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 1.0.1 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 1.0.1 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 1.0.1 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 1.0.1 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 1.0.1 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 1.0.1 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 1.0.1 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 1.0.1 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 1.2.5 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 1.0.1 */\n    .storageVolDelete = esxStorageVolDelete, /* 1.0.1 */\n    .storageVolWipe = esxStorageVolWipe, /* 1.0.1 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 1.0.1 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirStorageDriver esxStorageBackendISCSI = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 1.0.1 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 1.0.1 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 1.0.1 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 1.0.1 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 1.0.1 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 1.0.1 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 1.0.1 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 1.0.1 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 1.0.1 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 1.0.1 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 1.0.1 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 1.0.1 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 1.0.1 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 1.0.1 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 1.2.5 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 1.0.1 */\n    .storageVolDelete = esxStorageVolDelete, /* 1.0.1 */\n    .storageVolWipe = esxStorageVolWipe, /* 1.0.1 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 1.0.1 */\n};\n\nstatic virStoragePoolPtr\ntargetToStoragePool(virConnectPtr conn,\n                    const char *name,\n                    esxVI_HostInternetScsiHbaStaticTarget *target)\n{\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n\n    /*\n     * HostInternetScsiHbaStaticTarget does not provide a uuid field,\n     * but iScsiName (or widely known as IQN) is unique across the multiple\n     * hosts, using it to compute key\n     */\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, target->iScsiName, md5) < 0)\n        return NULL;\n\n    return virGetStoragePool(conn, name, md5, &esxStorageBackendISCSI, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostInternetScsiHbaStaticTargetByName",
          "args": [
            "priv->primary",
            "name",
            "&target",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostInternetScsiHbaStaticTargetByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4548-4592",
          "snippet": "int\nesxVI_LookupHostInternetScsiHbaStaticTargetByName\n  (esxVI_Context *ctx, const char *name,\n   esxVI_HostInternetScsiHbaStaticTarget **target, esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_HostInternetScsiHba *hostInternetScsiHba = NULL;\n    esxVI_HostInternetScsiHbaStaticTarget *candidate = NULL;\n\n    if (esxVI_LookupHostInternetScsiHba(ctx, &hostInternetScsiHba) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to obtain hostInternetScsiHba\"));\n        goto cleanup;\n    }\n\n    if (!hostInternetScsiHba) {\n        /* iSCSI adapter may not be enabled for this host */\n        return 0;\n    }\n\n    for (candidate = hostInternetScsiHba->configuredStaticTarget;\n         candidate; candidate = candidate->_next) {\n        if (STREQ(candidate->iScsiName, name))\n            break;\n    }\n\n    if (!candidate) {\n        if (occurrence == esxVI_Occurrence_RequiredItem) {\n            virReportError(VIR_ERR_NO_STORAGE_POOL,\n                           _(\"Could not find storage pool with name: %s\"), name);\n        }\n\n        goto cleanup;\n    }\n\n    if (esxVI_HostInternetScsiHbaStaticTarget_DeepCopy(target, candidate) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_HostInternetScsiHba_Free(&hostInternetScsiHba);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostInternetScsiHbaStaticTargetByName\n  (esxVI_Context *ctx, const char *name,\n   esxVI_HostInternetScsiHbaStaticTarget **target, esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_HostInternetScsiHba *hostInternetScsiHba = NULL;\n    esxVI_HostInternetScsiHbaStaticTarget *candidate = NULL;\n\n    if (esxVI_LookupHostInternetScsiHba(ctx, &hostInternetScsiHba) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to obtain hostInternetScsiHba\"));\n        goto cleanup;\n    }\n\n    if (!hostInternetScsiHba) {\n        /* iSCSI adapter may not be enabled for this host */\n        return 0;\n    }\n\n    for (candidate = hostInternetScsiHba->configuredStaticTarget;\n         candidate; candidate = candidate->_next) {\n        if (STREQ(candidate->iScsiName, name))\n            break;\n    }\n\n    if (!candidate) {\n        if (occurrence == esxVI_Occurrence_RequiredItem) {\n            virReportError(VIR_ERR_NO_STORAGE_POOL,\n                           _(\"Could not find storage pool with name: %s\"), name);\n        }\n\n        goto cleanup;\n    }\n\n    if (esxVI_HostInternetScsiHbaStaticTarget_DeepCopy(target, candidate) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_HostInternetScsiHba_Free(&hostInternetScsiHba);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virStoragePoolPtr\nesxStoragePoolLookupByName(virConnectPtr conn,\n                           const char *name)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_HostInternetScsiHbaStaticTarget *target = NULL;\n    virStoragePoolPtr pool = NULL;\n\n    /*\n     * Lookup routine are used by the base driver to determine\n     * appropriate backend driver, lookup targetName as optional\n     * parameter\n     */\n    if (esxVI_LookupHostInternetScsiHbaStaticTargetByName\n          (priv->primary, name, &target, esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!target) {\n        /* pool not found, error handling done by the base driver */\n        goto cleanup;\n    }\n\n    pool = targetToStoragePool(conn, name, target);\n\n cleanup:\n    esxVI_HostInternetScsiHbaStaticTarget_Free(&target);\n\n    return pool;\n}"
  },
  {
    "function_name": "targetToStoragePool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "150-167",
    "snippet": "static virStoragePoolPtr\ntargetToStoragePool(virConnectPtr conn,\n                    const char *name,\n                    esxVI_HostInternetScsiHbaStaticTarget *target)\n{\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n\n    /*\n     * HostInternetScsiHbaStaticTarget does not provide a uuid field,\n     * but iScsiName (or widely known as IQN) is unique across the multiple\n     * hosts, using it to compute key\n     */\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, target->iScsiName, md5) < 0)\n        return NULL;\n\n    return virGetStoragePool(conn, name, md5, &esxStorageBackendISCSI, NULL);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virStorageDriver esxStorageBackendISCSI = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 1.0.1 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 1.0.1 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 1.0.1 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 1.0.1 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 1.0.1 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 1.0.1 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 1.0.1 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 1.0.1 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 1.0.1 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 1.0.1 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 1.0.1 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 1.0.1 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 1.0.1 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 1.0.1 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 1.2.5 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 1.0.1 */\n    .storageVolDelete = esxStorageVolDelete, /* 1.0.1 */\n    .storageVolWipe = esxStorageVolWipe, /* 1.0.1 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 1.0.1 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virGetStoragePool",
          "args": [
            "conn",
            "name",
            "md5",
            "&esxStorageBackendISCSI",
            "NULL"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "virGetStoragePool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "525-556",
          "snippet": "virStoragePoolPtr\nvirGetStoragePool(virConnectPtr conn, const char *name,\n                  const unsigned char *uuid,\n                  void *privateData, virFreeCallback freeFunc)\n{\n    virStoragePoolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virStoragePoolClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    /* set the driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virStoragePoolClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virStoragePoolClass;\n\nvirStoragePoolPtr\nvirGetStoragePool(virConnectPtr conn, const char *name,\n                  const unsigned char *uuid,\n                  void *privateData, virFreeCallback freeFunc)\n{\n    virStoragePoolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virStoragePoolClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    /* set the driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCryptoHashBuf",
          "args": [
            "VIR_CRYPTO_HASH_MD5",
            "target->iScsiName",
            "md5"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "virCryptoHashBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircrypto.c",
          "lines": "52-73",
          "snippet": "ssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"virrandom.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"virrandom.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include <config.h>\n\nstruct virHashInfo {\n    gnutls_digest_algorithm_t algorithm;\n    size_t hashlen;\n} hashinfo[] = {\n    { GNUTLS_DIG_MD5, VIR_CRYPTO_HASH_SIZE_MD5 },\n    { GNUTLS_DIG_SHA256, VIR_CRYPTO_HASH_SIZE_SHA256 },\n};\n\nssize_t\nvirCryptoHashBuf(virCryptoHash hash,\n                 const char *input,\n                 unsigned char *output)\n{\n    int rc;\n    if (hash >= VIR_CRYPTO_HASH_LAST) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unknown crypto hash %d\"), hash);\n        return -1;\n    }\n\n    rc = gnutls_hash_fast(hashinfo[hash].algorithm, input, strlen(input), output);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to compute hash of data: %s\"),\n                       gnutls_strerror(rc));\n        return -1;\n    }\n\n    return hashinfo[hash].hashlen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirStorageDriver esxStorageBackendISCSI = {\n    .connectNumOfStoragePools = esxConnectNumOfStoragePools, /* 1.0.1 */\n    .connectListStoragePools = esxConnectListStoragePools, /* 1.0.1 */\n    .storagePoolLookupByName = esxStoragePoolLookupByName, /* 1.0.1 */\n    .storagePoolLookupByUUID = esxStoragePoolLookupByUUID, /* 1.0.1 */\n    .storagePoolRefresh = esxStoragePoolRefresh, /* 1.0.1 */\n    .storagePoolGetInfo = esxStoragePoolGetInfo, /* 1.0.1 */\n    .storagePoolGetXMLDesc = esxStoragePoolGetXMLDesc, /* 1.0.1 */\n    .storagePoolNumOfVolumes = esxStoragePoolNumOfVolumes, /* 1.0.1 */\n    .storagePoolListVolumes = esxStoragePoolListVolumes, /* 1.0.1 */\n    .storageVolLookupByName = esxStorageVolLookupByName, /* 1.0.1 */\n    .storageVolLookupByPath = esxStorageVolLookupByPath, /* 1.0.1 */\n    .storageVolLookupByKey = esxStorageVolLookupByKey, /* 1.0.1 */\n    .storageVolCreateXML = esxStorageVolCreateXML, /* 1.0.1 */\n    .storageVolCreateXMLFrom = esxStorageVolCreateXMLFrom, /* 1.0.1 */\n    .storageVolGetInfo = esxStorageVolGetInfo, /* 1.2.5 */\n    .storageVolGetXMLDesc = esxStorageVolGetXMLDesc, /* 1.0.1 */\n    .storageVolDelete = esxStorageVolDelete, /* 1.0.1 */\n    .storageVolWipe = esxStorageVolWipe, /* 1.0.1 */\n    .storageVolGetPath = esxStorageVolGetPath, /* 1.0.1 */\n};\n\nstatic virStoragePoolPtr\ntargetToStoragePool(virConnectPtr conn,\n                    const char *name,\n                    esxVI_HostInternetScsiHbaStaticTarget *target)\n{\n    /* VIR_CRYPTO_HASH_SIZE_MD5 = VIR_UUID_BUFLEN = 16 */\n    unsigned char md5[VIR_CRYPTO_HASH_SIZE_MD5];\n\n    /*\n     * HostInternetScsiHbaStaticTarget does not provide a uuid field,\n     * but iScsiName (or widely known as IQN) is unique across the multiple\n     * hosts, using it to compute key\n     */\n    if (virCryptoHashBuf(VIR_CRYPTO_HASH_MD5, target->iScsiName, md5) < 0)\n        return NULL;\n\n    return virGetStoragePool(conn, name, md5, &esxStorageBackendISCSI, NULL);\n}"
  },
  {
    "function_name": "esxConnectListStoragePools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "94-146",
    "snippet": "static int\nesxConnectListStoragePools(virConnectPtr conn, char **const names,\n                           const int maxnames)\n{\n    bool success = false;\n    int count = 0;\n    esxPrivate *priv = conn->privateData;\n    esxVI_HostInternetScsiHba *hostInternetScsiHba = NULL;\n    esxVI_HostInternetScsiHbaStaticTarget *target;\n    size_t i;\n\n    if (maxnames == 0)\n        return 0;\n\n    if (esxVI_LookupHostInternetScsiHba(priv->primary,\n                                        &hostInternetScsiHba) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to obtain iSCSI adapter\"));\n        goto cleanup;\n    }\n\n    /* FIXME: code looks for software iSCSI adapter only */\n    if (!hostInternetScsiHba) {\n        /* iSCSI adapter may not be enabled for this host */\n        return 0;\n    }\n\n    /*\n     * ESX has two kind of targets:\n     * 1. staticIscsiTargets\n     * 2. dynamicIscsiTargets\n     * For each dynamic target if its reachable a static target is added.\n     * return iSCSI names for all static targets to avoid duplicate names.\n     */\n    for (target = hostInternetScsiHba->configuredStaticTarget;\n         target && count < maxnames; target = target->_next) {\n        names[count] = g_strdup(target->iScsiName);\n\n        ++count;\n    }\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        for (i = 0; i < count; ++i)\n            VIR_FREE(names[i]);\n    }\n\n    esxVI_HostInternetScsiHba_Free(&hostInternetScsiHba);\n\n    return success ? count : -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostInternetScsiHba_Free",
          "args": [
            "&hostInternetScsiHba"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "names[i]"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "target->iScsiName"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to obtain iSCSI adapter\")"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to obtain iSCSI adapter\""
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostInternetScsiHba",
          "args": [
            "priv->primary",
            "&hostInternetScsiHba"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostInternetScsiHba",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4596-4652",
          "snippet": "int\nesxVI_LookupHostInternetScsiHba(esxVI_Context *ctx,\n                                esxVI_HostInternetScsiHba **hostInternetScsiHba)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapterList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapter = NULL;\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList, \"config.storageDevice.hostBusAdapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.hostBusAdapter\")) {\n            if (esxVI_HostHostBusAdapter_CastListFromAnyType\n                (dynamicProperty->val, &hostHostBusAdapterList) < 0 ||\n                !hostHostBusAdapterList) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    /* See vSphere API documentation about HostInternetScsiHba for details */\n    for (hostHostBusAdapter = hostHostBusAdapterList;\n         hostHostBusAdapter;\n         hostHostBusAdapter = hostHostBusAdapter->_next) {\n        esxVI_HostInternetScsiHba *candidate =\n            esxVI_HostInternetScsiHba_DynamicCast(hostHostBusAdapter);\n\n        if (candidate) {\n            if (esxVI_HostInternetScsiHba_DeepCopy(hostInternetScsiHba,\n                  candidate) < 0) {\n                goto cleanup;\n            }\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostHostBusAdapter_Free(&hostHostBusAdapterList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostInternetScsiHba(esxVI_Context *ctx,\n                                esxVI_HostInternetScsiHba **hostInternetScsiHba)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapterList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapter = NULL;\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList, \"config.storageDevice.hostBusAdapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.hostBusAdapter\")) {\n            if (esxVI_HostHostBusAdapter_CastListFromAnyType\n                (dynamicProperty->val, &hostHostBusAdapterList) < 0 ||\n                !hostHostBusAdapterList) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    /* See vSphere API documentation about HostInternetScsiHba for details */\n    for (hostHostBusAdapter = hostHostBusAdapterList;\n         hostHostBusAdapter;\n         hostHostBusAdapter = hostHostBusAdapter->_next) {\n        esxVI_HostInternetScsiHba *candidate =\n            esxVI_HostInternetScsiHba_DynamicCast(hostHostBusAdapter);\n\n        if (candidate) {\n            if (esxVI_HostInternetScsiHba_DeepCopy(hostInternetScsiHba,\n                  candidate) < 0) {\n                goto cleanup;\n            }\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostHostBusAdapter_Free(&hostHostBusAdapterList);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxConnectListStoragePools(virConnectPtr conn, char **const names,\n                           const int maxnames)\n{\n    bool success = false;\n    int count = 0;\n    esxPrivate *priv = conn->privateData;\n    esxVI_HostInternetScsiHba *hostInternetScsiHba = NULL;\n    esxVI_HostInternetScsiHbaStaticTarget *target;\n    size_t i;\n\n    if (maxnames == 0)\n        return 0;\n\n    if (esxVI_LookupHostInternetScsiHba(priv->primary,\n                                        &hostInternetScsiHba) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to obtain iSCSI adapter\"));\n        goto cleanup;\n    }\n\n    /* FIXME: code looks for software iSCSI adapter only */\n    if (!hostInternetScsiHba) {\n        /* iSCSI adapter may not be enabled for this host */\n        return 0;\n    }\n\n    /*\n     * ESX has two kind of targets:\n     * 1. staticIscsiTargets\n     * 2. dynamicIscsiTargets\n     * For each dynamic target if its reachable a static target is added.\n     * return iSCSI names for all static targets to avoid duplicate names.\n     */\n    for (target = hostInternetScsiHba->configuredStaticTarget;\n         target && count < maxnames; target = target->_next) {\n        names[count] = g_strdup(target->iScsiName);\n\n        ++count;\n    }\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        for (i = 0; i < count; ++i)\n            VIR_FREE(names[i]);\n    }\n\n    esxVI_HostInternetScsiHba_Free(&hostInternetScsiHba);\n\n    return success ? count : -1;\n}"
  },
  {
    "function_name": "esxConnectNumOfStoragePools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_backend_iscsi.c",
    "lines": "50-90",
    "snippet": "static int\nesxConnectNumOfStoragePools(virConnectPtr conn)\n{\n    bool success = false;\n    int count = 0;\n    esxPrivate *priv = conn->privateData;\n    esxVI_HostInternetScsiHba *hostInternetScsiHba = NULL;\n    esxVI_HostInternetScsiHbaStaticTarget *target;\n\n    if (esxVI_LookupHostInternetScsiHba(priv->primary,\n                                        &hostInternetScsiHba) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to obtain iSCSI adapter\"));\n        goto cleanup;\n    }\n\n    /* FIXME: code looks for software iSCSI adapter only */\n    if (!hostInternetScsiHba) {\n        /* iSCSI adapter may not be enabled for this host */\n        return 0;\n    }\n\n    /*\n     * ESX has two kind of targets:\n     * 1. staticIscsiTargets\n     * 2. dynamicIscsiTargets\n     * For each dynamic target if its reachable a static target is added.\n     * return iSCSI names for all static targets to avoid duplicate names.\n     */\n    for (target = hostInternetScsiHba->configuredStaticTarget;\n         target; target = target->_next) {\n        ++count;\n    }\n\n    success = true;\n\n cleanup:\n    esxVI_HostInternetScsiHba_Free(&hostInternetScsiHba);\n\n    return success ? count : -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"vircrypto.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostInternetScsiHba_Free",
          "args": [
            "&hostInternetScsiHba"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to obtain iSCSI adapter\")"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to obtain iSCSI adapter\""
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostInternetScsiHba",
          "args": [
            "priv->primary",
            "&hostInternetScsiHba"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostInternetScsiHba",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4596-4652",
          "snippet": "int\nesxVI_LookupHostInternetScsiHba(esxVI_Context *ctx,\n                                esxVI_HostInternetScsiHba **hostInternetScsiHba)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapterList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapter = NULL;\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList, \"config.storageDevice.hostBusAdapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.hostBusAdapter\")) {\n            if (esxVI_HostHostBusAdapter_CastListFromAnyType\n                (dynamicProperty->val, &hostHostBusAdapterList) < 0 ||\n                !hostHostBusAdapterList) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    /* See vSphere API documentation about HostInternetScsiHba for details */\n    for (hostHostBusAdapter = hostHostBusAdapterList;\n         hostHostBusAdapter;\n         hostHostBusAdapter = hostHostBusAdapter->_next) {\n        esxVI_HostInternetScsiHba *candidate =\n            esxVI_HostInternetScsiHba_DynamicCast(hostHostBusAdapter);\n\n        if (candidate) {\n            if (esxVI_HostInternetScsiHba_DeepCopy(hostInternetScsiHba,\n                  candidate) < 0) {\n                goto cleanup;\n            }\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostHostBusAdapter_Free(&hostHostBusAdapterList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostInternetScsiHba(esxVI_Context *ctx,\n                                esxVI_HostInternetScsiHba **hostInternetScsiHba)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapterList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapter = NULL;\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList, \"config.storageDevice.hostBusAdapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.hostBusAdapter\")) {\n            if (esxVI_HostHostBusAdapter_CastListFromAnyType\n                (dynamicProperty->val, &hostHostBusAdapterList) < 0 ||\n                !hostHostBusAdapterList) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    /* See vSphere API documentation about HostInternetScsiHba for details */\n    for (hostHostBusAdapter = hostHostBusAdapterList;\n         hostHostBusAdapter;\n         hostHostBusAdapter = hostHostBusAdapter->_next) {\n        esxVI_HostInternetScsiHba *candidate =\n            esxVI_HostInternetScsiHba_DynamicCast(hostHostBusAdapter);\n\n        if (candidate) {\n            if (esxVI_HostInternetScsiHba_DeepCopy(hostInternetScsiHba,\n                  candidate) < 0) {\n                goto cleanup;\n            }\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostHostBusAdapter_Free(&hostHostBusAdapterList);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"vircrypto.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_backend_iscsi.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nesxConnectNumOfStoragePools(virConnectPtr conn)\n{\n    bool success = false;\n    int count = 0;\n    esxPrivate *priv = conn->privateData;\n    esxVI_HostInternetScsiHba *hostInternetScsiHba = NULL;\n    esxVI_HostInternetScsiHbaStaticTarget *target;\n\n    if (esxVI_LookupHostInternetScsiHba(priv->primary,\n                                        &hostInternetScsiHba) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to obtain iSCSI adapter\"));\n        goto cleanup;\n    }\n\n    /* FIXME: code looks for software iSCSI adapter only */\n    if (!hostInternetScsiHba) {\n        /* iSCSI adapter may not be enabled for this host */\n        return 0;\n    }\n\n    /*\n     * ESX has two kind of targets:\n     * 1. staticIscsiTargets\n     * 2. dynamicIscsiTargets\n     * For each dynamic target if its reachable a static target is added.\n     * return iSCSI names for all static targets to avoid duplicate names.\n     */\n    for (target = hostInternetScsiHba->configuredStaticTarget;\n         target; target = target->_next) {\n        ++count;\n    }\n\n    success = true;\n\n cleanup:\n    esxVI_HostInternetScsiHba_Free(&hostInternetScsiHba);\n\n    return success ? count : -1;\n}"
  }
]