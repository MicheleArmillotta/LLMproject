[
  {
    "function_name": "virNetServerServiceClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
    "lines": "442-454",
    "snippet": "void virNetServerServiceClose(virNetServerServicePtr svc)\n{\n    size_t i;\n\n    if (!svc)\n        return;\n\n    for (i = 0; i < svc->nsocks; i++) {\n        virNetSocketRemoveIOCallback(svc->socks[i]);\n        virNetSocketClose(svc->socks[i]);\n        virObjectUnref(svc);\n    }\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include \"virnetserverservice.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "svc"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketClose",
          "args": [
            "svc->socks[i]"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2254-2277",
          "snippet": "void virNetSocketClose(virNetSocketPtr sock)\n{\n    if (!sock)\n        return;\n\n    virObjectLock(sock);\n\n    if (sock->fd != -1) {\n        closesocket(sock->fd);\n        sock->fd = -1;\n    }\n\n#ifndef WIN32\n    /* If a server socket, then unlink UNIX path */\n    if (sock->unlinkUNIX &&\n        sock->localAddr.data.sa.sa_family == AF_UNIX &&\n        sock->localAddr.data.un.sun_path[0] != '\\0') {\n        if (unlink(sock->localAddr.data.un.sun_path) == 0)\n            sock->localAddr.data.un.sun_path[0] = '\\0';\n    }\n#endif\n\n    virObjectUnlock(sock);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketClose(virNetSocketPtr sock)\n{\n    if (!sock)\n        return;\n\n    virObjectLock(sock);\n\n    if (sock->fd != -1) {\n        closesocket(sock->fd);\n        sock->fd = -1;\n    }\n\n#ifndef WIN32\n    /* If a server socket, then unlink UNIX path */\n    if (sock->unlinkUNIX &&\n        sock->localAddr.data.sa.sa_family == AF_UNIX &&\n        sock->localAddr.data.un.sun_path[0] != '\\0') {\n        if (unlink(sock->localAddr.data.un.sun_path) == 0)\n            sock->localAddr.data.un.sun_path[0] = '\\0';\n    }\n#endif\n\n    virObjectUnlock(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketRemoveIOCallback",
          "args": [
            "svc->socks[i]"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketRemoveIOCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2237-2252",
          "snippet": "void virNetSocketRemoveIOCallback(virNetSocketPtr sock)\n{\n    virObjectLock(sock);\n\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventRemoveHandle(sock->watch);\n    /* Don't unref @sock, it's done via eventloop callback. */\n    sock->watch = -1;\n\n    virObjectUnlock(sock);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketRemoveIOCallback(virNetSocketPtr sock)\n{\n    virObjectLock(sock);\n\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventRemoveHandle(sock->watch);\n    /* Don't unref @sock, it's done via eventloop callback. */\n    sock->watch = -1;\n\n    virObjectUnlock(sock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nvoid virNetServerServiceClose(virNetServerServicePtr svc)\n{\n    size_t i;\n\n    if (!svc)\n        return;\n\n    for (i = 0; i < svc->nsocks; i++) {\n        virNetSocketRemoveIOCallback(svc->socks[i]);\n        virNetSocketClose(svc->socks[i]);\n        virObjectUnref(svc);\n    }\n}"
  },
  {
    "function_name": "virNetServerServiceToggle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
    "lines": "430-440",
    "snippet": "void virNetServerServiceToggle(virNetServerServicePtr svc,\n                               bool enabled)\n{\n    size_t i;\n\n    for (i = 0; i < svc->nsocks; i++)\n        virNetSocketUpdateIOCallback(svc->socks[i],\n                                     enabled ?\n                                     VIR_EVENT_HANDLE_READABLE :\n                                     0);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include \"virnetserverservice.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetSocketUpdateIOCallback",
          "args": [
            "svc->socks[i]",
            "enabled ?\n                                     VIR_EVENT_HANDLE_READABLE :\n                                     0"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketUpdateIOCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2222-2235",
          "snippet": "void virNetSocketUpdateIOCallback(virNetSocketPtr sock,\n                                  int events)\n{\n    virObjectLock(sock);\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventUpdateHandle(sock->watch, events);\n\n    virObjectUnlock(sock);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketUpdateIOCallback(virNetSocketPtr sock,\n                                  int events)\n{\n    virObjectLock(sock);\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventUpdateHandle(sock->watch, events);\n\n    virObjectUnlock(sock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nvoid virNetServerServiceToggle(virNetServerServicePtr svc,\n                               bool enabled)\n{\n    size_t i;\n\n    for (i = 0; i < svc->nsocks; i++)\n        virNetSocketUpdateIOCallback(svc->socks[i],\n                                     enabled ?\n                                     VIR_EVENT_HANDLE_READABLE :\n                                     0);\n}"
  },
  {
    "function_name": "virNetServerServiceDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
    "lines": "418-428",
    "snippet": "void virNetServerServiceDispose(void *obj)\n{\n    virNetServerServicePtr svc = obj;\n    size_t i;\n\n    for (i = 0; i < svc->nsocks; i++)\n       virObjectUnref(svc->socks[i]);\n    VIR_FREE(svc->socks);\n\n    virObjectUnref(svc->tls);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include \"virnetserverservice.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetServerServiceDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "svc->tls"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "svc->socks"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nstatic void virNetServerServiceDispose(void *obj);\n\nvoid virNetServerServiceDispose(void *obj)\n{\n    virNetServerServicePtr svc = obj;\n    size_t i;\n\n    for (i = 0; i < svc->nsocks; i++)\n       virObjectUnref(svc->socks[i]);\n    VIR_FREE(svc->socks);\n\n    virObjectUnref(svc->tls);\n}"
  },
  {
    "function_name": "virNetServerServiceSetDispatcher",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
    "lines": "409-415",
    "snippet": "void virNetServerServiceSetDispatcher(virNetServerServicePtr svc,\n                                      virNetServerServiceDispatchFunc func,\n                                      void *opaque)\n{\n    svc->dispatchFunc = func;\n    svc->dispatchOpaque = opaque;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include \"virnetserverservice.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nvoid virNetServerServiceSetDispatcher(virNetServerServicePtr svc,\n                                      virNetServerServiceDispatchFunc func,\n                                      void *opaque)\n{\n    svc->dispatchFunc = func;\n    svc->dispatchOpaque = opaque;\n}"
  },
  {
    "function_name": "virNetServerServiceGetTLSContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
    "lines": "404-407",
    "snippet": "virNetTLSContextPtr virNetServerServiceGetTLSContext(virNetServerServicePtr svc)\n{\n    return svc->tls;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include \"virnetserverservice.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nvirNetTLSContextPtr virNetServerServiceGetTLSContext(virNetServerServicePtr svc)\n{\n    return svc->tls;\n}"
  },
  {
    "function_name": "virNetServerServiceGetMaxRequests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
    "lines": "399-402",
    "snippet": "size_t virNetServerServiceGetMaxRequests(virNetServerServicePtr svc)\n{\n    return svc->nrequests_client_max;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include \"virnetserverservice.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nsize_t virNetServerServiceGetMaxRequests(virNetServerServicePtr svc)\n{\n    return svc->nrequests_client_max;\n}"
  },
  {
    "function_name": "virNetServerServiceIsReadonly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
    "lines": "393-396",
    "snippet": "bool virNetServerServiceIsReadonly(virNetServerServicePtr svc)\n{\n    return svc->readonly;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include \"virnetserverservice.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nbool virNetServerServiceIsReadonly(virNetServerServicePtr svc)\n{\n    return svc->readonly;\n}"
  },
  {
    "function_name": "virNetServerServiceGetAuth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
    "lines": "387-390",
    "snippet": "int virNetServerServiceGetAuth(virNetServerServicePtr svc)\n{\n    return svc->auth;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include \"virnetserverservice.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nint virNetServerServiceGetAuth(virNetServerServicePtr svc)\n{\n    return svc->auth;\n}"
  },
  {
    "function_name": "virNetServerServiceGetPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
    "lines": "379-384",
    "snippet": "int virNetServerServiceGetPort(virNetServerServicePtr svc)\n{\n    /* We're assuming if there are multiple sockets\n     * for IPv4 & 6, then they are all on same port */\n    return virNetSocketGetPort(svc->socks[0]);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include \"virnetserverservice.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetSocketGetPort",
          "args": [
            "svc->socks[0]"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketGetPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1445-1452",
          "snippet": "int virNetSocketGetPort(virNetSocketPtr sock)\n{\n    int port;\n    virObjectLock(sock);\n    port = virSocketAddrGetPort(&sock->localAddr);\n    virObjectUnlock(sock);\n    return port;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketGetPort(virNetSocketPtr sock)\n{\n    int port;\n    virObjectLock(sock);\n    port = virSocketAddrGetPort(&sock->localAddr);\n    virObjectUnlock(sock);\n    return port;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nint virNetServerServiceGetPort(virNetServerServicePtr svc)\n{\n    /* We're assuming if there are multiple sockets\n     * for IPv4 & 6, then they are all on same port */\n    return virNetSocketGetPort(svc->socks[0]);\n}"
  },
  {
    "function_name": "virNetServerServicePreExecRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
    "lines": "340-376",
    "snippet": "virJSONValuePtr virNetServerServicePreExecRestart(virNetServerServicePtr svc)\n{\n    virJSONValuePtr object = virJSONValueNewObject();\n    virJSONValuePtr socks;\n    size_t i;\n\n    if (virJSONValueObjectAppendNumberInt(object, \"auth\", svc->auth) < 0)\n        goto error;\n    if (virJSONValueObjectAppendBoolean(object, \"readonly\", svc->readonly) < 0)\n        goto error;\n    if (virJSONValueObjectAppendNumberUint(object, \"nrequests_client_max\", svc->nrequests_client_max) < 0)\n        goto error;\n\n    socks = virJSONValueNewArray();\n\n    if (virJSONValueObjectAppend(object, \"socks\", socks) < 0) {\n        virJSONValueFree(socks);\n        goto error;\n    }\n\n    for (i = 0; i < svc->nsocks; i++) {\n        virJSONValuePtr child;\n        if (!(child = virNetSocketPreExecRestart(svc->socks[i])))\n            goto error;\n\n        if (virJSONValueArrayAppend(socks, child) < 0) {\n            virJSONValueFree(child);\n            goto error;\n        }\n    }\n\n    return object;\n\n error:\n    virJSONValueFree(object);\n    return NULL;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include \"virnetserverservice.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueFree",
          "args": [
            "object"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "391-423",
          "snippet": "void\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvoid\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayAppend",
          "args": [
            "socks",
            "child"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayAppendString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "792-804",
          "snippet": "int\nvirJSONValueArrayAppendString(virJSONValuePtr object,\n                              const char *value)\n{\n    virJSONValuePtr jvalue = virJSONValueNewString(value);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueArrayAppend(object, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueArrayAppendString(virJSONValuePtr object,\n                              const char *value)\n{\n    virJSONValuePtr jvalue = virJSONValueNewString(value);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueArrayAppend(object, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketPreExecRestart",
          "args": [
            "svc->socks[i]"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketPreExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1267-1324",
          "snippet": "virJSONValuePtr virNetSocketPreExecRestart(virNetSocketPtr sock)\n{\n    virJSONValuePtr object = NULL;\n\n    virObjectLock(sock);\n\n#if WITH_SASL\n    if (sock->saslSession) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Unable to save socket state when SASL session is active\"));\n        goto error;\n    }\n#endif\n    if (sock->tlsSession) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Unable to save socket state when TLS session is active\"));\n        goto error;\n    }\n\n    object = virJSONValueNewObject();\n\n    if (virJSONValueObjectAppendNumberInt(object, \"fd\", sock->fd) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendNumberInt(object, \"errfd\", sock->errfd) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendNumberInt(object, \"pid\", sock->pid) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendBoolean(object, \"isClient\", sock->isClient) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendBoolean(object, \"unlinkUNIX\", sock->unlinkUNIX) < 0)\n        goto error;\n\n    if (virSetInherit(sock->fd, true) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot disable close-on-exec flag on socket %d\"),\n                             sock->fd);\n        goto error;\n    }\n    if (sock->errfd != -1 &&\n        virSetInherit(sock->errfd, true) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot disable close-on-exec flag on pipe %d\"),\n                             sock->errfd);\n        goto error;\n    }\n\n    virObjectUnlock(sock);\n    return object;\n\n error:\n    virObjectUnlock(sock);\n    virJSONValueFree(object);\n    return NULL;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvirJSONValuePtr virNetSocketPreExecRestart(virNetSocketPtr sock)\n{\n    virJSONValuePtr object = NULL;\n\n    virObjectLock(sock);\n\n#if WITH_SASL\n    if (sock->saslSession) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Unable to save socket state when SASL session is active\"));\n        goto error;\n    }\n#endif\n    if (sock->tlsSession) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Unable to save socket state when TLS session is active\"));\n        goto error;\n    }\n\n    object = virJSONValueNewObject();\n\n    if (virJSONValueObjectAppendNumberInt(object, \"fd\", sock->fd) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendNumberInt(object, \"errfd\", sock->errfd) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendNumberInt(object, \"pid\", sock->pid) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendBoolean(object, \"isClient\", sock->isClient) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendBoolean(object, \"unlinkUNIX\", sock->unlinkUNIX) < 0)\n        goto error;\n\n    if (virSetInherit(sock->fd, true) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot disable close-on-exec flag on socket %d\"),\n                             sock->fd);\n        goto error;\n    }\n    if (sock->errfd != -1 &&\n        virSetInherit(sock->errfd, true) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot disable close-on-exec flag on pipe %d\"),\n                             sock->errfd);\n        goto error;\n    }\n\n    virObjectUnlock(sock);\n    return object;\n\n error:\n    virObjectUnlock(sock);\n    virJSONValueFree(object);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectAppend",
          "args": [
            "object",
            "\"socks\"",
            "socks"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "741-754",
          "snippet": "int\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueNewArray",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "560-568",
          "snippet": "virJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectAppendNumberUint",
          "args": [
            "object",
            "\"nrequests_client_max\"",
            "svc->nrequests_client_max"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendNumberUint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "677-690",
          "snippet": "int\nvirJSONValueObjectAppendNumberUint(virJSONValuePtr object,\n                                   const char *key,\n                                   unsigned int number)\n{\n    virJSONValuePtr jvalue = virJSONValueNewNumberUint(number);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendNumberUint(virJSONValuePtr object,\n                                   const char *key,\n                                   unsigned int number)\n{\n    virJSONValuePtr jvalue = virJSONValueNewNumberUint(number);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectAppendNumberInt",
          "args": [
            "object",
            "\"auth\"",
            "svc->auth"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendNumberInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "661-674",
          "snippet": "int\nvirJSONValueObjectAppendNumberInt(virJSONValuePtr object,\n                                  const char *key,\n                                  int number)\n{\n    virJSONValuePtr jvalue = virJSONValueNewNumberInt(number);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendNumberInt(virJSONValuePtr object,\n                                  const char *key,\n                                  int number)\n{\n    virJSONValuePtr jvalue = virJSONValueNewNumberInt(number);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueNewObject",
          "args": [],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "571-579",
          "snippet": "virJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nvirJSONValuePtr virNetServerServicePreExecRestart(virNetServerServicePtr svc)\n{\n    virJSONValuePtr object = virJSONValueNewObject();\n    virJSONValuePtr socks;\n    size_t i;\n\n    if (virJSONValueObjectAppendNumberInt(object, \"auth\", svc->auth) < 0)\n        goto error;\n    if (virJSONValueObjectAppendBoolean(object, \"readonly\", svc->readonly) < 0)\n        goto error;\n    if (virJSONValueObjectAppendNumberUint(object, \"nrequests_client_max\", svc->nrequests_client_max) < 0)\n        goto error;\n\n    socks = virJSONValueNewArray();\n\n    if (virJSONValueObjectAppend(object, \"socks\", socks) < 0) {\n        virJSONValueFree(socks);\n        goto error;\n    }\n\n    for (i = 0; i < svc->nsocks; i++) {\n        virJSONValuePtr child;\n        if (!(child = virNetSocketPreExecRestart(svc->socks[i])))\n            goto error;\n\n        if (virJSONValueArrayAppend(socks, child) < 0) {\n            virJSONValueFree(child);\n            goto error;\n        }\n    }\n\n    return object;\n\n error:\n    virJSONValueFree(object);\n    return NULL;\n}"
  },
  {
    "function_name": "virNetServerServiceNewPostExecRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
    "lines": "259-337",
    "snippet": "virNetServerServicePtr virNetServerServiceNewPostExecRestart(virJSONValuePtr object)\n{\n    virNetServerServicePtr svc;\n    virJSONValuePtr socks;\n    size_t i;\n    size_t n;\n    unsigned int max;\n\n    if (virNetServerServiceInitialize() < 0)\n        return NULL;\n\n    if (!(svc = virObjectNew(virNetServerServiceClass)))\n        return NULL;\n\n    if (virJSONValueObjectGetNumberInt(object, \"auth\", &svc->auth) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing auth field in JSON state document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetBoolean(object, \"readonly\", &svc->readonly) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing readonly field in JSON state document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"nrequests_client_max\",\n                                        &max) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing nrequests_client_max field in JSON state document\"));\n        goto error;\n    }\n    svc->nrequests_client_max = max;\n\n    if (!(socks = virJSONValueObjectGet(object, \"socks\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing socks field in JSON state document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(socks)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed socks array\"));\n        goto error;\n    }\n\n    n = virJSONValueArraySize(socks);\n    if (VIR_ALLOC_N(svc->socks, n) < 0)\n        goto error;\n    svc->nsocks = n;\n\n    for (i = 0; i < svc->nsocks; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(socks, i);\n        virNetSocketPtr sock;\n\n        if (!(sock = virNetSocketNewPostExecRestart(child))) {\n            virObjectUnref(sock);\n            goto error;\n        }\n\n        svc->socks[i] = sock;\n\n        /* IO callback is initially disabled, until we're ready\n         * to deal with incoming clients */\n        virObjectRef(svc);\n        if (virNetSocketAddIOCallback(sock,\n                                      0,\n                                      virNetServerServiceAccept,\n                                      svc,\n                                      virObjectFreeCallback) < 0) {\n            virObjectUnref(svc);\n            goto error;\n        }\n    }\n\n    return svc;\n\n error:\n    virObjectUnref(svc);\n    return NULL;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include \"virnetserverservice.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virNetServerServiceClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "svc"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketAddIOCallback",
          "args": [
            "sock",
            "0",
            "virNetServerServiceAccept",
            "svc",
            "virObjectFreeCallback"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketAddIOCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2186-2220",
          "snippet": "int virNetSocketAddIOCallback(virNetSocketPtr sock,\n                              int events,\n                              virNetSocketIOFunc func,\n                              void *opaque,\n                              virFreeCallback ff)\n{\n    int ret = -1;\n\n    virObjectRef(sock);\n    virObjectLock(sock);\n    if (sock->watch >= 0) {\n        VIR_DEBUG(\"Watch already registered on socket %p\", sock);\n        goto cleanup;\n    }\n\n    if ((sock->watch = virEventAddHandle(sock->fd,\n                                         events,\n                                         virNetSocketEventHandle,\n                                         sock,\n                                         virNetSocketEventFree)) < 0) {\n        VIR_DEBUG(\"Failed to register watch on socket %p\", sock);\n        goto cleanup;\n    }\n    sock->func = func;\n    sock->opaque = opaque;\n    sock->ff = ff;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sock);\n    if (ret != 0)\n        virObjectUnref(sock);\n    return ret;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketAddIOCallback(virNetSocketPtr sock,\n                              int events,\n                              virNetSocketIOFunc func,\n                              void *opaque,\n                              virFreeCallback ff)\n{\n    int ret = -1;\n\n    virObjectRef(sock);\n    virObjectLock(sock);\n    if (sock->watch >= 0) {\n        VIR_DEBUG(\"Watch already registered on socket %p\", sock);\n        goto cleanup;\n    }\n\n    if ((sock->watch = virEventAddHandle(sock->fd,\n                                         events,\n                                         virNetSocketEventHandle,\n                                         sock,\n                                         virNetSocketEventFree)) < 0) {\n        VIR_DEBUG(\"Failed to register watch on socket %p\", sock);\n        goto cleanup;\n    }\n    sock->func = func;\n    sock->opaque = opaque;\n    sock->ff = ff;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sock);\n    if (ret != 0)\n        virObjectUnref(sock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "svc"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketNewPostExecRestart",
          "args": [
            "child"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNewPostExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1212-1264",
          "snippet": "virNetSocketPtr virNetSocketNewPostExecRestart(virJSONValuePtr object)\n{\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    int fd, thepid, errfd;\n    bool isClient;\n    bool unlinkUNIX;\n\n    if (virJSONValueObjectGetNumberInt(object, \"fd\", &fd) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing fd data in JSON document\"));\n        return NULL;\n    }\n\n    if (virJSONValueObjectGetNumberInt(object, \"pid\", &thepid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing pid data in JSON document\"));\n        return NULL;\n    }\n\n    if (virJSONValueObjectGetNumberInt(object, \"errfd\", &errfd) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing errfd data in JSON document\"));\n        return NULL;\n    }\n\n    if (virJSONValueObjectGetBoolean(object, \"isClient\", &isClient) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing isClient data in JSON document\"));\n        return NULL;\n    }\n\n    if (virJSONValueObjectGetBoolean(object, \"unlinkUNIX\", &unlinkUNIX) < 0)\n        unlinkUNIX = !isClient;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    remoteAddr.len = sizeof(remoteAddr.data.stor);\n    if (getsockname(fd, &remoteAddr.data.sa, &remoteAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get peer socket name\"));\n        return NULL;\n    }\n\n    localAddr.len = sizeof(localAddr.data.stor);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        return NULL;\n    }\n\n    return virNetSocketNew(&localAddr, &remoteAddr, isClient,\n                           fd, errfd, thepid, unlinkUNIX);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvirNetSocketPtr virNetSocketNewPostExecRestart(virJSONValuePtr object)\n{\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    int fd, thepid, errfd;\n    bool isClient;\n    bool unlinkUNIX;\n\n    if (virJSONValueObjectGetNumberInt(object, \"fd\", &fd) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing fd data in JSON document\"));\n        return NULL;\n    }\n\n    if (virJSONValueObjectGetNumberInt(object, \"pid\", &thepid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing pid data in JSON document\"));\n        return NULL;\n    }\n\n    if (virJSONValueObjectGetNumberInt(object, \"errfd\", &errfd) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing errfd data in JSON document\"));\n        return NULL;\n    }\n\n    if (virJSONValueObjectGetBoolean(object, \"isClient\", &isClient) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing isClient data in JSON document\"));\n        return NULL;\n    }\n\n    if (virJSONValueObjectGetBoolean(object, \"unlinkUNIX\", &unlinkUNIX) < 0)\n        unlinkUNIX = !isClient;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    remoteAddr.len = sizeof(remoteAddr.data.stor);\n    if (getsockname(fd, &remoteAddr.data.sa, &remoteAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get peer socket name\"));\n        return NULL;\n    }\n\n    localAddr.len = sizeof(localAddr.data.stor);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        return NULL;\n    }\n\n    return virNetSocketNew(&localAddr, &remoteAddr, isClient,\n                           fd, errfd, thepid, unlinkUNIX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayGet",
          "args": [
            "socks",
            "i"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1024-1035",
          "snippet": "virJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "svc->socks",
            "n"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueArraySize",
          "args": [
            "socks"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArraySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1017-1021",
          "snippet": "size_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nsize_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Malformed socks array\")"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Malformed socks array\""
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueIsArray",
          "args": [
            "socks"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueIsArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1010-1014",
          "snippet": "bool\nvirJSONValueIsArray(virJSONValuePtr array)\n{\n    return array->type == VIR_JSON_TYPE_ARRAY;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nbool\nvirJSONValueIsArray(virJSONValuePtr array)\n{\n    return array->type == VIR_JSON_TYPE_ARRAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing socks field in JSON state document\")"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGet",
          "args": [
            "object",
            "\"socks\""
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1422-1426",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing nrequests_client_max field in JSON state document\")"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetNumberUint",
          "args": [
            "object",
            "\"nrequests_client_max\"",
            "&max"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetNumberUint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1345-1356",
          "snippet": "int\nvirJSONValueObjectGetNumberUint(virJSONValuePtr object,\n                                const char *key,\n                                unsigned int *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberUint(val, value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectGetNumberUint(virJSONValuePtr object,\n                                const char *key,\n                                unsigned int *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberUint(val, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing readonly field in JSON state document\")"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetBoolean",
          "args": [
            "object",
            "\"readonly\"",
            "&svc->readonly"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1401-1412",
          "snippet": "int\nvirJSONValueObjectGetBoolean(virJSONValuePtr object,\n                             const char *key,\n                             bool *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetBoolean(val, value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectGetBoolean(virJSONValuePtr object,\n                             const char *key,\n                             bool *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetBoolean(val, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing auth field in JSON state document\")"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetNumberInt",
          "args": [
            "object",
            "\"auth\"",
            "&svc->auth"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetNumberInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1331-1342",
          "snippet": "int\nvirJSONValueObjectGetNumberInt(virJSONValuePtr object,\n                               const char *key,\n                               int *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberInt(val, value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectGetNumberInt(virJSONValuePtr object,\n                               const char *key,\n                               int *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberInt(val, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "virNetServerServiceClass"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerServiceInitialize",
          "args": [],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nstatic virClassPtr virNetServerServiceClass;\n\nvirNetServerServicePtr virNetServerServiceNewPostExecRestart(virJSONValuePtr object)\n{\n    virNetServerServicePtr svc;\n    virJSONValuePtr socks;\n    size_t i;\n    size_t n;\n    unsigned int max;\n\n    if (virNetServerServiceInitialize() < 0)\n        return NULL;\n\n    if (!(svc = virObjectNew(virNetServerServiceClass)))\n        return NULL;\n\n    if (virJSONValueObjectGetNumberInt(object, \"auth\", &svc->auth) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing auth field in JSON state document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetBoolean(object, \"readonly\", &svc->readonly) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing readonly field in JSON state document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"nrequests_client_max\",\n                                        &max) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing nrequests_client_max field in JSON state document\"));\n        goto error;\n    }\n    svc->nrequests_client_max = max;\n\n    if (!(socks = virJSONValueObjectGet(object, \"socks\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing socks field in JSON state document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(socks)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed socks array\"));\n        goto error;\n    }\n\n    n = virJSONValueArraySize(socks);\n    if (VIR_ALLOC_N(svc->socks, n) < 0)\n        goto error;\n    svc->nsocks = n;\n\n    for (i = 0; i < svc->nsocks; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(socks, i);\n        virNetSocketPtr sock;\n\n        if (!(sock = virNetSocketNewPostExecRestart(child))) {\n            virObjectUnref(sock);\n            goto error;\n        }\n\n        svc->socks[i] = sock;\n\n        /* IO callback is initially disabled, until we're ready\n         * to deal with incoming clients */\n        virObjectRef(svc);\n        if (virNetSocketAddIOCallback(sock,\n                                      0,\n                                      virNetServerServiceAccept,\n                                      svc,\n                                      virObjectFreeCallback) < 0) {\n            virObjectUnref(svc);\n            goto error;\n        }\n    }\n\n    return svc;\n\n error:\n    virObjectUnref(svc);\n    return NULL;\n}"
  },
  {
    "function_name": "virNetServerServiceNewFDs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
    "lines": "220-256",
    "snippet": "virNetServerServicePtr virNetServerServiceNewFDs(int *fds,\n                                                 size_t nfds,\n                                                 bool unlinkUNIX,\n                                                 int auth,\n                                                 virNetTLSContextPtr tls,\n                                                 bool readonly,\n                                                 size_t max_queued_clients,\n                                                 size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc = NULL;\n    virNetSocketPtr *socks;\n    size_t i;\n\n    if (VIR_ALLOC_N(socks, nfds) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nfds; i++) {\n        if (virNetSocketNewListenFD(fds[i],\n                                    unlinkUNIX,\n                                    &socks[i]) < 0)\n            goto cleanup;\n    }\n\n    svc = virNetServerServiceNewSocket(socks,\n                                       nfds,\n                                       auth,\n                                       tls,\n                                       readonly,\n                                       max_queued_clients,\n                                       nrequests_client_max);\n\n cleanup:\n    for (i = 0; i < nfds && socks; i++)\n        virObjectUnref(socks[i]);\n    VIR_FREE(socks);\n    return svc;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include \"virnetserverservice.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "socks"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "socks[i]"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerServiceNewSocket",
          "args": [
            "socks",
            "nfds",
            "auth",
            "tls",
            "readonly",
            "max_queued_clients",
            "nrequests_client_max"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerServiceNewSocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
          "lines": "91-144",
          "snippet": "static virNetServerServicePtr\nvirNetServerServiceNewSocket(virNetSocketPtr *socks,\n                             size_t nsocks,\n                             int auth,\n                             virNetTLSContextPtr tls,\n                             bool readonly,\n                             size_t max_queued_clients,\n                             size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc;\n    size_t i;\n\n    if (virNetServerServiceInitialize() < 0)\n        return NULL;\n\n    if (!(svc = virObjectNew(virNetServerServiceClass)))\n        return NULL;\n\n    if (VIR_ALLOC_N(svc->socks, nsocks) < 0)\n        goto error;\n    svc->nsocks = nsocks;\n    for (i = 0; i < svc->nsocks; i++) {\n        svc->socks[i] = socks[i];\n        virObjectRef(svc->socks[i]);\n    }\n    svc->auth = auth;\n    svc->readonly = readonly;\n    svc->nrequests_client_max = nrequests_client_max;\n    svc->tls = virObjectRef(tls);\n\n    for (i = 0; i < svc->nsocks; i++) {\n        if (virNetSocketListen(svc->socks[i], max_queued_clients) < 0)\n            goto error;\n\n        /* IO callback is initially disabled, until we're ready\n         * to deal with incoming clients */\n        virObjectRef(svc);\n        if (virNetSocketAddIOCallback(svc->socks[i],\n                                      0,\n                                      virNetServerServiceAccept,\n                                      svc,\n                                      virObjectFreeCallback) < 0) {\n            virObjectUnref(svc);\n            goto error;\n        }\n    }\n\n\n    return svc;\n\n error:\n    virObjectUnref(svc);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include \"virnetserverservice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetServerServiceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nstatic virClassPtr virNetServerServiceClass;\n\nstatic virNetServerServicePtr\nvirNetServerServiceNewSocket(virNetSocketPtr *socks,\n                             size_t nsocks,\n                             int auth,\n                             virNetTLSContextPtr tls,\n                             bool readonly,\n                             size_t max_queued_clients,\n                             size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc;\n    size_t i;\n\n    if (virNetServerServiceInitialize() < 0)\n        return NULL;\n\n    if (!(svc = virObjectNew(virNetServerServiceClass)))\n        return NULL;\n\n    if (VIR_ALLOC_N(svc->socks, nsocks) < 0)\n        goto error;\n    svc->nsocks = nsocks;\n    for (i = 0; i < svc->nsocks; i++) {\n        svc->socks[i] = socks[i];\n        virObjectRef(svc->socks[i]);\n    }\n    svc->auth = auth;\n    svc->readonly = readonly;\n    svc->nrequests_client_max = nrequests_client_max;\n    svc->tls = virObjectRef(tls);\n\n    for (i = 0; i < svc->nsocks; i++) {\n        if (virNetSocketListen(svc->socks[i], max_queued_clients) < 0)\n            goto error;\n\n        /* IO callback is initially disabled, until we're ready\n         * to deal with incoming clients */\n        virObjectRef(svc);\n        if (virNetSocketAddIOCallback(svc->socks[i],\n                                      0,\n                                      virNetServerServiceAccept,\n                                      svc,\n                                      virObjectFreeCallback) < 0) {\n            virObjectUnref(svc);\n            goto error;\n        }\n    }\n\n\n    return svc;\n\n error:\n    virObjectUnref(svc);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketNewListenFD",
          "args": [
            "fds[i]",
            "unlinkUNIX",
            "&socks[i]"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNewListenFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "536-555",
          "snippet": "int virNetSocketNewListenFD(int fd,\n                            bool unlinkUNIX,\n                            virNetSocketPtr *retsock)\n{\n    virSocketAddr addr;\n    *retsock = NULL;\n\n    memset(&addr, 0, sizeof(addr));\n\n    addr.len = sizeof(addr.data);\n    if (getsockname(fd, &addr.data.sa, &addr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        return -1;\n    }\n\n    if (!(*retsock = virNetSocketNew(&addr, NULL, false, fd, -1, 0, unlinkUNIX)))\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewListenFD(int fd,\n                            bool unlinkUNIX,\n                            virNetSocketPtr *retsock)\n{\n    virSocketAddr addr;\n    *retsock = NULL;\n\n    memset(&addr, 0, sizeof(addr));\n\n    addr.len = sizeof(addr.data);\n    if (getsockname(fd, &addr.data.sa, &addr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        return -1;\n    }\n\n    if (!(*retsock = virNetSocketNew(&addr, NULL, false, fd, -1, 0, unlinkUNIX)))\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "socks",
            "nfds"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nvirNetServerServicePtr virNetServerServiceNewFDs(int *fds,\n                                                 size_t nfds,\n                                                 bool unlinkUNIX,\n                                                 int auth,\n                                                 virNetTLSContextPtr tls,\n                                                 bool readonly,\n                                                 size_t max_queued_clients,\n                                                 size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc = NULL;\n    virNetSocketPtr *socks;\n    size_t i;\n\n    if (VIR_ALLOC_N(socks, nfds) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nfds; i++) {\n        if (virNetSocketNewListenFD(fds[i],\n                                    unlinkUNIX,\n                                    &socks[i]) < 0)\n            goto cleanup;\n    }\n\n    svc = virNetServerServiceNewSocket(socks,\n                                       nfds,\n                                       auth,\n                                       tls,\n                                       readonly,\n                                       max_queued_clients,\n                                       nrequests_client_max);\n\n cleanup:\n    for (i = 0; i < nfds && socks; i++)\n        virObjectUnref(socks[i]);\n    VIR_FREE(socks);\n    return svc;\n}"
  },
  {
    "function_name": "virNetServerServiceNewUNIX",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
    "lines": "186-218",
    "snippet": "virNetServerServicePtr virNetServerServiceNewUNIX(const char *path,\n                                                  mode_t mask,\n                                                  gid_t grp,\n                                                  int auth,\n                                                  virNetTLSContextPtr tls,\n                                                  bool readonly,\n                                                  size_t max_queued_clients,\n                                                  size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc;\n    virNetSocketPtr sock;\n\n    VIR_DEBUG(\"Creating new UNIX server path='%s' mask=%o gid=%u\",\n              path, mask, grp);\n    if (virNetSocketNewListenUNIX(path,\n                                  mask,\n                                  -1,\n                                  grp,\n                                  &sock) < 0)\n        return NULL;\n\n    svc = virNetServerServiceNewSocket(&sock,\n                                       1,\n                                       auth,\n                                       tls,\n                                       readonly,\n                                       max_queued_clients,\n                                       nrequests_client_max);\n\n    virObjectUnref(sock);\n\n    return svc;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include \"virnetserverservice.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "sock"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerServiceNewSocket",
          "args": [
            "&sock",
            "1",
            "auth",
            "tls",
            "readonly",
            "max_queued_clients",
            "nrequests_client_max"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerServiceNewSocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
          "lines": "91-144",
          "snippet": "static virNetServerServicePtr\nvirNetServerServiceNewSocket(virNetSocketPtr *socks,\n                             size_t nsocks,\n                             int auth,\n                             virNetTLSContextPtr tls,\n                             bool readonly,\n                             size_t max_queued_clients,\n                             size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc;\n    size_t i;\n\n    if (virNetServerServiceInitialize() < 0)\n        return NULL;\n\n    if (!(svc = virObjectNew(virNetServerServiceClass)))\n        return NULL;\n\n    if (VIR_ALLOC_N(svc->socks, nsocks) < 0)\n        goto error;\n    svc->nsocks = nsocks;\n    for (i = 0; i < svc->nsocks; i++) {\n        svc->socks[i] = socks[i];\n        virObjectRef(svc->socks[i]);\n    }\n    svc->auth = auth;\n    svc->readonly = readonly;\n    svc->nrequests_client_max = nrequests_client_max;\n    svc->tls = virObjectRef(tls);\n\n    for (i = 0; i < svc->nsocks; i++) {\n        if (virNetSocketListen(svc->socks[i], max_queued_clients) < 0)\n            goto error;\n\n        /* IO callback is initially disabled, until we're ready\n         * to deal with incoming clients */\n        virObjectRef(svc);\n        if (virNetSocketAddIOCallback(svc->socks[i],\n                                      0,\n                                      virNetServerServiceAccept,\n                                      svc,\n                                      virObjectFreeCallback) < 0) {\n            virObjectUnref(svc);\n            goto error;\n        }\n    }\n\n\n    return svc;\n\n error:\n    virObjectUnref(svc);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include \"virnetserverservice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetServerServiceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nstatic virClassPtr virNetServerServiceClass;\n\nstatic virNetServerServicePtr\nvirNetServerServiceNewSocket(virNetSocketPtr *socks,\n                             size_t nsocks,\n                             int auth,\n                             virNetTLSContextPtr tls,\n                             bool readonly,\n                             size_t max_queued_clients,\n                             size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc;\n    size_t i;\n\n    if (virNetServerServiceInitialize() < 0)\n        return NULL;\n\n    if (!(svc = virObjectNew(virNetServerServiceClass)))\n        return NULL;\n\n    if (VIR_ALLOC_N(svc->socks, nsocks) < 0)\n        goto error;\n    svc->nsocks = nsocks;\n    for (i = 0; i < svc->nsocks; i++) {\n        svc->socks[i] = socks[i];\n        virObjectRef(svc->socks[i]);\n    }\n    svc->auth = auth;\n    svc->readonly = readonly;\n    svc->nrequests_client_max = nrequests_client_max;\n    svc->tls = virObjectRef(tls);\n\n    for (i = 0; i < svc->nsocks; i++) {\n        if (virNetSocketListen(svc->socks[i], max_queued_clients) < 0)\n            goto error;\n\n        /* IO callback is initially disabled, until we're ready\n         * to deal with incoming clients */\n        virObjectRef(svc);\n        if (virNetSocketAddIOCallback(svc->socks[i],\n                                      0,\n                                      virNetServerServiceAccept,\n                                      svc,\n                                      virObjectFreeCallback) < 0) {\n            virObjectUnref(svc);\n            goto error;\n        }\n    }\n\n\n    return svc;\n\n error:\n    virObjectUnref(svc);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketNewListenUNIX",
          "args": [
            "path",
            "mask",
            "-1",
            "grp",
            "&sock"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNewListenUNIX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "524-533",
          "snippet": "int virNetSocketNewListenUNIX(const char *path G_GNUC_UNUSED,\n                              mode_t mask G_GNUC_UNUSED,\n                              uid_t user G_GNUC_UNUSED,\n                              gid_t grp G_GNUC_UNUSED,\n                              virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"UNIX sockets are not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewListenUNIX(const char *path G_GNUC_UNUSED,\n                              mode_t mask G_GNUC_UNUSED,\n                              uid_t user G_GNUC_UNUSED,\n                              gid_t grp G_GNUC_UNUSED,\n                              virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"UNIX sockets are not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Creating new UNIX server path='%s' mask=%o gid=%u\"",
            "path",
            "mask",
            "grp"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nvirNetServerServicePtr virNetServerServiceNewUNIX(const char *path,\n                                                  mode_t mask,\n                                                  gid_t grp,\n                                                  int auth,\n                                                  virNetTLSContextPtr tls,\n                                                  bool readonly,\n                                                  size_t max_queued_clients,\n                                                  size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc;\n    virNetSocketPtr sock;\n\n    VIR_DEBUG(\"Creating new UNIX server path='%s' mask=%o gid=%u\",\n              path, mask, grp);\n    if (virNetSocketNewListenUNIX(path,\n                                  mask,\n                                  -1,\n                                  grp,\n                                  &sock) < 0)\n        return NULL;\n\n    svc = virNetServerServiceNewSocket(&sock,\n                                       1,\n                                       auth,\n                                       tls,\n                                       readonly,\n                                       max_queued_clients,\n                                       nrequests_client_max);\n\n    virObjectUnref(sock);\n\n    return svc;\n}"
  },
  {
    "function_name": "virNetServerServiceNewTCP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
    "lines": "147-183",
    "snippet": "virNetServerServicePtr virNetServerServiceNewTCP(const char *nodename,\n                                                 const char *service,\n                                                 int family,\n                                                 int auth,\n                                                 virNetTLSContextPtr tls,\n                                                 bool readonly,\n                                                 size_t max_queued_clients,\n                                                 size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc;\n    size_t i;\n    virNetSocketPtr *socks;\n    size_t nsocks;\n\n    VIR_DEBUG(\"Creating new TCP server nodename='%s' service='%s'\",\n              NULLSTR(nodename), NULLSTR(service));\n    if (virNetSocketNewListenTCP(nodename,\n                                 service,\n                                 family,\n                                 &socks,\n                                 &nsocks) < 0)\n        return NULL;\n\n    svc = virNetServerServiceNewSocket(socks,\n                                       nsocks,\n                                       auth,\n                                       tls,\n                                       readonly,\n                                       max_queued_clients,\n                                       nrequests_client_max);\n\n    for (i = 0; i < nsocks; i++)\n        virObjectUnref(socks[i]);\n    VIR_FREE(socks);\n\n    return svc;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include \"virnetserverservice.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "socks"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "socks[i]"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerServiceNewSocket",
          "args": [
            "socks",
            "nsocks",
            "auth",
            "tls",
            "readonly",
            "max_queued_clients",
            "nrequests_client_max"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerServiceNewSocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
          "lines": "91-144",
          "snippet": "static virNetServerServicePtr\nvirNetServerServiceNewSocket(virNetSocketPtr *socks,\n                             size_t nsocks,\n                             int auth,\n                             virNetTLSContextPtr tls,\n                             bool readonly,\n                             size_t max_queued_clients,\n                             size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc;\n    size_t i;\n\n    if (virNetServerServiceInitialize() < 0)\n        return NULL;\n\n    if (!(svc = virObjectNew(virNetServerServiceClass)))\n        return NULL;\n\n    if (VIR_ALLOC_N(svc->socks, nsocks) < 0)\n        goto error;\n    svc->nsocks = nsocks;\n    for (i = 0; i < svc->nsocks; i++) {\n        svc->socks[i] = socks[i];\n        virObjectRef(svc->socks[i]);\n    }\n    svc->auth = auth;\n    svc->readonly = readonly;\n    svc->nrequests_client_max = nrequests_client_max;\n    svc->tls = virObjectRef(tls);\n\n    for (i = 0; i < svc->nsocks; i++) {\n        if (virNetSocketListen(svc->socks[i], max_queued_clients) < 0)\n            goto error;\n\n        /* IO callback is initially disabled, until we're ready\n         * to deal with incoming clients */\n        virObjectRef(svc);\n        if (virNetSocketAddIOCallback(svc->socks[i],\n                                      0,\n                                      virNetServerServiceAccept,\n                                      svc,\n                                      virObjectFreeCallback) < 0) {\n            virObjectUnref(svc);\n            goto error;\n        }\n    }\n\n\n    return svc;\n\n error:\n    virObjectUnref(svc);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include \"virnetserverservice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetServerServiceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nstatic virClassPtr virNetServerServiceClass;\n\nstatic virNetServerServicePtr\nvirNetServerServiceNewSocket(virNetSocketPtr *socks,\n                             size_t nsocks,\n                             int auth,\n                             virNetTLSContextPtr tls,\n                             bool readonly,\n                             size_t max_queued_clients,\n                             size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc;\n    size_t i;\n\n    if (virNetServerServiceInitialize() < 0)\n        return NULL;\n\n    if (!(svc = virObjectNew(virNetServerServiceClass)))\n        return NULL;\n\n    if (VIR_ALLOC_N(svc->socks, nsocks) < 0)\n        goto error;\n    svc->nsocks = nsocks;\n    for (i = 0; i < svc->nsocks; i++) {\n        svc->socks[i] = socks[i];\n        virObjectRef(svc->socks[i]);\n    }\n    svc->auth = auth;\n    svc->readonly = readonly;\n    svc->nrequests_client_max = nrequests_client_max;\n    svc->tls = virObjectRef(tls);\n\n    for (i = 0; i < svc->nsocks; i++) {\n        if (virNetSocketListen(svc->socks[i], max_queued_clients) < 0)\n            goto error;\n\n        /* IO callback is initially disabled, until we're ready\n         * to deal with incoming clients */\n        virObjectRef(svc);\n        if (virNetSocketAddIOCallback(svc->socks[i],\n                                      0,\n                                      virNetServerServiceAccept,\n                                      svc,\n                                      virObjectFreeCallback) < 0) {\n            virObjectUnref(svc);\n            goto error;\n        }\n    }\n\n\n    return svc;\n\n error:\n    virObjectUnref(svc);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketNewListenTCP",
          "args": [
            "nodename",
            "service",
            "family",
            "&socks",
            "&nsocks"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNewListenTCP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "292-454",
          "snippet": "int virNetSocketNewListenTCP(const char *nodename,\n                             const char *service,\n                             int family,\n                             virNetSocketPtr **retsocks,\n                             size_t *nretsocks)\n{\n    virNetSocketPtr *socks = NULL;\n    size_t nsocks = 0;\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    size_t i;\n    int socketErrno = 0;\n    int bindErrno = 0;\n    virSocketAddr tmp_addr;\n    int port = 0;\n\n    *retsocks = NULL;\n    *nretsocks = 0;\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE;\n    hints.ai_socktype = SOCK_STREAM;\n\n    /* Don't use ADDRCONFIG for binding to the wildcard address.\n     * Just catch the error returned by socket() if the system has\n     * no IPv6 support.\n     *\n     * This allows libvirtd to be started in parallel with the network\n     * startup in most cases.\n     */\n    if (nodename &&\n        !(virSocketAddrParseAny(&tmp_addr, nodename, AF_UNSPEC, false) > 0 &&\n          virSocketAddrIsWildcard(&tmp_addr)))\n        hints.ai_flags |= AI_ADDRCONFIG;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    struct addrinfo *runp = ai;\n    while (runp) {\n        virSocketAddr addr;\n\n        memset(&addr, 0, sizeof(addr));\n\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            if (errno == EAFNOSUPPORT) {\n                socketErrno = errno;\n                runp = runp->ai_next;\n                continue;\n            }\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, true) < 0)\n            goto error;\n\n#ifdef IPV6_V6ONLY\n        if (runp->ai_family == PF_INET6) {\n            int on = 1;\n            /*\n             * Normally on Linux an INET6 socket will bind to the INET4\n             * address too. If getaddrinfo returns results with INET4\n             * first though, this will result in INET6 binding failing.\n             * We can trivially cope with multiple server sockets, so\n             * we force it to only listen on IPv6\n             */\n            if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY,\n                           (void*)&on, sizeof(on)) < 0) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"Unable to force bind to IPv6 only\"));\n                goto error;\n            }\n        }\n#endif\n\n        addr.len = runp->ai_addrlen;\n        memcpy(&addr.data.sa, runp->ai_addr, runp->ai_addrlen);\n\n        /* When service is NULL, we let the kernel auto-select the\n         * port. Once we've selected a port for one IP protocol\n         * though, we want to ensure we pick the same port for the\n         * other IP protocol\n         */\n        if (port != 0 && service == NULL) {\n            if (addr.data.sa.sa_family == AF_INET) {\n                addr.data.inet4.sin_port = port;\n            } else if (addr.data.sa.sa_family == AF_INET6) {\n                addr.data.inet6.sin6_port = port;\n            }\n            VIR_DEBUG(\"Used saved port %d\", port);\n        }\n\n        if (bind(fd, &addr.data.sa, addr.len) < 0) {\n            if (errno != EADDRINUSE && errno != EADDRNOTAVAIL) {\n                virReportSystemError(errno, \"%s\", _(\"Unable to bind to port\"));\n                goto error;\n            }\n            bindErrno = errno;\n            closesocket(fd);\n            fd = -1;\n            runp = runp->ai_next;\n            continue;\n        }\n\n        addr.len = sizeof(addr.data);\n        if (getsockname(fd, &addr.data.sa, &addr.len) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n            goto error;\n        }\n\n        if (port == 0 && service == NULL) {\n            if (addr.data.sa.sa_family == AF_INET)\n                port = addr.data.inet4.sin_port;\n            else if (addr.data.sa.sa_family == AF_INET6)\n                port = addr.data.inet6.sin6_port;\n            VIR_DEBUG(\"Saved port %d\", port);\n        }\n\n        VIR_DEBUG(\"%p f=%d f=%d\", &addr, runp->ai_family, addr.data.sa.sa_family);\n\n        if (VIR_EXPAND_N(socks, nsocks, 1) < 0)\n            goto error;\n\n        if (!(socks[nsocks-1] = virNetSocketNew(&addr, NULL, false, fd, -1, 0, false)))\n            goto error;\n        runp = runp->ai_next;\n        fd = -1;\n    }\n\n    if (nsocks == 0) {\n        if (bindErrno)\n            virReportSystemError(bindErrno, \"%s\", _(\"Unable to bind to port\"));\n        else if (socketErrno)\n            virReportSystemError(socketErrno, \"%s\", _(\"Unable to create socket\"));\n        else\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"No addresses to bind to\"));\n        goto error;\n    }\n\n    freeaddrinfo(ai);\n\n    *retsocks = socks;\n    *nretsocks = nsocks;\n    return 0;\n\n error:\n    for (i = 0; i < nsocks; i++)\n        virObjectUnref(socks[i]);\n    VIR_FREE(socks);\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewListenTCP(const char *nodename,\n                             const char *service,\n                             int family,\n                             virNetSocketPtr **retsocks,\n                             size_t *nretsocks)\n{\n    virNetSocketPtr *socks = NULL;\n    size_t nsocks = 0;\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    size_t i;\n    int socketErrno = 0;\n    int bindErrno = 0;\n    virSocketAddr tmp_addr;\n    int port = 0;\n\n    *retsocks = NULL;\n    *nretsocks = 0;\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE;\n    hints.ai_socktype = SOCK_STREAM;\n\n    /* Don't use ADDRCONFIG for binding to the wildcard address.\n     * Just catch the error returned by socket() if the system has\n     * no IPv6 support.\n     *\n     * This allows libvirtd to be started in parallel with the network\n     * startup in most cases.\n     */\n    if (nodename &&\n        !(virSocketAddrParseAny(&tmp_addr, nodename, AF_UNSPEC, false) > 0 &&\n          virSocketAddrIsWildcard(&tmp_addr)))\n        hints.ai_flags |= AI_ADDRCONFIG;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    struct addrinfo *runp = ai;\n    while (runp) {\n        virSocketAddr addr;\n\n        memset(&addr, 0, sizeof(addr));\n\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            if (errno == EAFNOSUPPORT) {\n                socketErrno = errno;\n                runp = runp->ai_next;\n                continue;\n            }\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, true) < 0)\n            goto error;\n\n#ifdef IPV6_V6ONLY\n        if (runp->ai_family == PF_INET6) {\n            int on = 1;\n            /*\n             * Normally on Linux an INET6 socket will bind to the INET4\n             * address too. If getaddrinfo returns results with INET4\n             * first though, this will result in INET6 binding failing.\n             * We can trivially cope with multiple server sockets, so\n             * we force it to only listen on IPv6\n             */\n            if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY,\n                           (void*)&on, sizeof(on)) < 0) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"Unable to force bind to IPv6 only\"));\n                goto error;\n            }\n        }\n#endif\n\n        addr.len = runp->ai_addrlen;\n        memcpy(&addr.data.sa, runp->ai_addr, runp->ai_addrlen);\n\n        /* When service is NULL, we let the kernel auto-select the\n         * port. Once we've selected a port for one IP protocol\n         * though, we want to ensure we pick the same port for the\n         * other IP protocol\n         */\n        if (port != 0 && service == NULL) {\n            if (addr.data.sa.sa_family == AF_INET) {\n                addr.data.inet4.sin_port = port;\n            } else if (addr.data.sa.sa_family == AF_INET6) {\n                addr.data.inet6.sin6_port = port;\n            }\n            VIR_DEBUG(\"Used saved port %d\", port);\n        }\n\n        if (bind(fd, &addr.data.sa, addr.len) < 0) {\n            if (errno != EADDRINUSE && errno != EADDRNOTAVAIL) {\n                virReportSystemError(errno, \"%s\", _(\"Unable to bind to port\"));\n                goto error;\n            }\n            bindErrno = errno;\n            closesocket(fd);\n            fd = -1;\n            runp = runp->ai_next;\n            continue;\n        }\n\n        addr.len = sizeof(addr.data);\n        if (getsockname(fd, &addr.data.sa, &addr.len) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n            goto error;\n        }\n\n        if (port == 0 && service == NULL) {\n            if (addr.data.sa.sa_family == AF_INET)\n                port = addr.data.inet4.sin_port;\n            else if (addr.data.sa.sa_family == AF_INET6)\n                port = addr.data.inet6.sin6_port;\n            VIR_DEBUG(\"Saved port %d\", port);\n        }\n\n        VIR_DEBUG(\"%p f=%d f=%d\", &addr, runp->ai_family, addr.data.sa.sa_family);\n\n        if (VIR_EXPAND_N(socks, nsocks, 1) < 0)\n            goto error;\n\n        if (!(socks[nsocks-1] = virNetSocketNew(&addr, NULL, false, fd, -1, 0, false)))\n            goto error;\n        runp = runp->ai_next;\n        fd = -1;\n    }\n\n    if (nsocks == 0) {\n        if (bindErrno)\n            virReportSystemError(bindErrno, \"%s\", _(\"Unable to bind to port\"));\n        else if (socketErrno)\n            virReportSystemError(socketErrno, \"%s\", _(\"Unable to create socket\"));\n        else\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"No addresses to bind to\"));\n        goto error;\n    }\n\n    freeaddrinfo(ai);\n\n    *retsocks = socks;\n    *nretsocks = nsocks;\n    return 0;\n\n error:\n    for (i = 0; i < nsocks; i++)\n        virObjectUnref(socks[i]);\n    VIR_FREE(socks);\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Creating new TCP server nodename='%s' service='%s'\"",
            "NULLSTR(nodename)",
            "NULLSTR(service)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "service"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "nodename"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nvirNetServerServicePtr virNetServerServiceNewTCP(const char *nodename,\n                                                 const char *service,\n                                                 int family,\n                                                 int auth,\n                                                 virNetTLSContextPtr tls,\n                                                 bool readonly,\n                                                 size_t max_queued_clients,\n                                                 size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc;\n    size_t i;\n    virNetSocketPtr *socks;\n    size_t nsocks;\n\n    VIR_DEBUG(\"Creating new TCP server nodename='%s' service='%s'\",\n              NULLSTR(nodename), NULLSTR(service));\n    if (virNetSocketNewListenTCP(nodename,\n                                 service,\n                                 family,\n                                 &socks,\n                                 &nsocks) < 0)\n        return NULL;\n\n    svc = virNetServerServiceNewSocket(socks,\n                                       nsocks,\n                                       auth,\n                                       tls,\n                                       readonly,\n                                       max_queued_clients,\n                                       nrequests_client_max);\n\n    for (i = 0; i < nsocks; i++)\n        virObjectUnref(socks[i]);\n    VIR_FREE(socks);\n\n    return svc;\n}"
  },
  {
    "function_name": "virNetServerServiceNewSocket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
    "lines": "91-144",
    "snippet": "static virNetServerServicePtr\nvirNetServerServiceNewSocket(virNetSocketPtr *socks,\n                             size_t nsocks,\n                             int auth,\n                             virNetTLSContextPtr tls,\n                             bool readonly,\n                             size_t max_queued_clients,\n                             size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc;\n    size_t i;\n\n    if (virNetServerServiceInitialize() < 0)\n        return NULL;\n\n    if (!(svc = virObjectNew(virNetServerServiceClass)))\n        return NULL;\n\n    if (VIR_ALLOC_N(svc->socks, nsocks) < 0)\n        goto error;\n    svc->nsocks = nsocks;\n    for (i = 0; i < svc->nsocks; i++) {\n        svc->socks[i] = socks[i];\n        virObjectRef(svc->socks[i]);\n    }\n    svc->auth = auth;\n    svc->readonly = readonly;\n    svc->nrequests_client_max = nrequests_client_max;\n    svc->tls = virObjectRef(tls);\n\n    for (i = 0; i < svc->nsocks; i++) {\n        if (virNetSocketListen(svc->socks[i], max_queued_clients) < 0)\n            goto error;\n\n        /* IO callback is initially disabled, until we're ready\n         * to deal with incoming clients */\n        virObjectRef(svc);\n        if (virNetSocketAddIOCallback(svc->socks[i],\n                                      0,\n                                      virNetServerServiceAccept,\n                                      svc,\n                                      virObjectFreeCallback) < 0) {\n            virObjectUnref(svc);\n            goto error;\n        }\n    }\n\n\n    return svc;\n\n error:\n    virObjectUnref(svc);\n    return NULL;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include \"virnetserverservice.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virNetServerServiceClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "svc"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketAddIOCallback",
          "args": [
            "svc->socks[i]",
            "0",
            "virNetServerServiceAccept",
            "svc",
            "virObjectFreeCallback"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketAddIOCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2186-2220",
          "snippet": "int virNetSocketAddIOCallback(virNetSocketPtr sock,\n                              int events,\n                              virNetSocketIOFunc func,\n                              void *opaque,\n                              virFreeCallback ff)\n{\n    int ret = -1;\n\n    virObjectRef(sock);\n    virObjectLock(sock);\n    if (sock->watch >= 0) {\n        VIR_DEBUG(\"Watch already registered on socket %p\", sock);\n        goto cleanup;\n    }\n\n    if ((sock->watch = virEventAddHandle(sock->fd,\n                                         events,\n                                         virNetSocketEventHandle,\n                                         sock,\n                                         virNetSocketEventFree)) < 0) {\n        VIR_DEBUG(\"Failed to register watch on socket %p\", sock);\n        goto cleanup;\n    }\n    sock->func = func;\n    sock->opaque = opaque;\n    sock->ff = ff;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sock);\n    if (ret != 0)\n        virObjectUnref(sock);\n    return ret;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketAddIOCallback(virNetSocketPtr sock,\n                              int events,\n                              virNetSocketIOFunc func,\n                              void *opaque,\n                              virFreeCallback ff)\n{\n    int ret = -1;\n\n    virObjectRef(sock);\n    virObjectLock(sock);\n    if (sock->watch >= 0) {\n        VIR_DEBUG(\"Watch already registered on socket %p\", sock);\n        goto cleanup;\n    }\n\n    if ((sock->watch = virEventAddHandle(sock->fd,\n                                         events,\n                                         virNetSocketEventHandle,\n                                         sock,\n                                         virNetSocketEventFree)) < 0) {\n        VIR_DEBUG(\"Failed to register watch on socket %p\", sock);\n        goto cleanup;\n    }\n    sock->func = func;\n    sock->opaque = opaque;\n    sock->ff = ff;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sock);\n    if (ret != 0)\n        virObjectUnref(sock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "svc"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketListen",
          "args": [
            "svc->socks[i]",
            "max_queued_clients"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketListen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2084-2094",
          "snippet": "int virNetSocketListen(virNetSocketPtr sock, int backlog)\n{\n    virObjectLock(sock);\n    if (listen(sock->fd, backlog > 0 ? backlog : 30) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to listen on socket\"));\n        virObjectUnlock(sock);\n        return -1;\n    }\n    virObjectUnlock(sock);\n    return 0;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketListen(virNetSocketPtr sock, int backlog)\n{\n    virObjectLock(sock);\n    if (listen(sock->fd, backlog > 0 ? backlog : 30) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to listen on socket\"));\n        virObjectUnlock(sock);\n        return -1;\n    }\n    virObjectUnlock(sock);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "svc->socks",
            "nsocks"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "virNetServerServiceClass"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerServiceInitialize",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nstatic virClassPtr virNetServerServiceClass;\n\nstatic virNetServerServicePtr\nvirNetServerServiceNewSocket(virNetSocketPtr *socks,\n                             size_t nsocks,\n                             int auth,\n                             virNetTLSContextPtr tls,\n                             bool readonly,\n                             size_t max_queued_clients,\n                             size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc;\n    size_t i;\n\n    if (virNetServerServiceInitialize() < 0)\n        return NULL;\n\n    if (!(svc = virObjectNew(virNetServerServiceClass)))\n        return NULL;\n\n    if (VIR_ALLOC_N(svc->socks, nsocks) < 0)\n        goto error;\n    svc->nsocks = nsocks;\n    for (i = 0; i < svc->nsocks; i++) {\n        svc->socks[i] = socks[i];\n        virObjectRef(svc->socks[i]);\n    }\n    svc->auth = auth;\n    svc->readonly = readonly;\n    svc->nrequests_client_max = nrequests_client_max;\n    svc->tls = virObjectRef(tls);\n\n    for (i = 0; i < svc->nsocks; i++) {\n        if (virNetSocketListen(svc->socks[i], max_queued_clients) < 0)\n            goto error;\n\n        /* IO callback is initially disabled, until we're ready\n         * to deal with incoming clients */\n        virObjectRef(svc);\n        if (virNetSocketAddIOCallback(svc->socks[i],\n                                      0,\n                                      virNetServerServiceAccept,\n                                      svc,\n                                      virObjectFreeCallback) < 0) {\n            virObjectUnref(svc);\n            goto error;\n        }\n    }\n\n\n    return svc;\n\n error:\n    virObjectUnref(svc);\n    return NULL;\n}"
  },
  {
    "function_name": "virNetServerServiceAccept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
    "lines": "68-88",
    "snippet": "static void virNetServerServiceAccept(virNetSocketPtr sock,\n                                      int events G_GNUC_UNUSED,\n                                      void *opaque)\n{\n    virNetServerServicePtr svc = opaque;\n    virNetSocketPtr clientsock = NULL;\n\n    if (virNetSocketAccept(sock, &clientsock) < 0)\n        goto cleanup;\n\n    if (!clientsock) /* Connection already went away */\n        goto cleanup;\n\n    if (!svc->dispatchFunc)\n        goto cleanup;\n\n    svc->dispatchFunc(svc, clientsock, svc->dispatchOpaque);\n\n cleanup:\n    virObjectUnref(clientsock);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include \"virnetserverservice.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "clientsock"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc->dispatchFunc",
          "args": [
            "svc",
            "clientsock",
            "svc->dispatchOpaque"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSocketAccept",
          "args": [
            "sock",
            "&clientsock"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketAccept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2096-2144",
          "snippet": "int virNetSocketAccept(virNetSocketPtr sock, virNetSocketPtr *clientsock)\n{\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    int ret = -1;\n\n    virObjectLock(sock);\n\n    *clientsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    remoteAddr.len = sizeof(remoteAddr.data.stor);\n    if ((fd = accept(sock->fd, &remoteAddr.data.sa, &remoteAddr.len)) < 0) {\n        if (errno == ECONNABORTED ||\n            errno == EAGAIN) {\n            ret = 0;\n            goto cleanup;\n        }\n\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to accept client\"));\n        goto cleanup;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto cleanup;\n    }\n\n    if (!(*clientsock = virNetSocketNew(&localAddr,\n                                        &remoteAddr,\n                                        true,\n                                        fd, -1, 0,\n                                        false)))\n        goto cleanup;\n\n    fd = -1;\n    ret = 0;\n\n cleanup:\n    if (fd != -1)\n        closesocket(fd);\n    virObjectUnlock(sock);\n    return ret;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketAccept(virNetSocketPtr sock, virNetSocketPtr *clientsock)\n{\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    int ret = -1;\n\n    virObjectLock(sock);\n\n    *clientsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    remoteAddr.len = sizeof(remoteAddr.data.stor);\n    if ((fd = accept(sock->fd, &remoteAddr.data.sa, &remoteAddr.len)) < 0) {\n        if (errno == ECONNABORTED ||\n            errno == EAGAIN) {\n            ret = 0;\n            goto cleanup;\n        }\n\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to accept client\"));\n        goto cleanup;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto cleanup;\n    }\n\n    if (!(*clientsock = virNetSocketNew(&localAddr,\n                                        &remoteAddr,\n                                        true,\n                                        fd, -1, 0,\n                                        false)))\n        goto cleanup;\n\n    fd = -1;\n    ret = 0;\n\n cleanup:\n    if (fd != -1)\n        closesocket(fd);\n    virObjectUnlock(sock);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nstatic void virNetServerServiceAccept(virNetSocketPtr sock,\n                                      int events G_GNUC_UNUSED,\n                                      void *opaque)\n{\n    virNetServerServicePtr svc = opaque;\n    virNetSocketPtr clientsock = NULL;\n\n    if (virNetSocketAccept(sock, &clientsock) < 0)\n        goto cleanup;\n\n    if (!clientsock) /* Connection already went away */\n        goto cleanup;\n\n    if (!svc->dispatchFunc)\n        goto cleanup;\n\n    svc->dispatchFunc(svc, clientsock, svc->dispatchOpaque);\n\n cleanup:\n    virObjectUnref(clientsock);\n}"
  },
  {
    "function_name": "virNetServerServiceOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
    "lines": "57-63",
    "snippet": "static int virNetServerServiceOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetServerService, virClassForObject()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <unistd.h>",
      "#include \"virnetserverservice.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virNetServerService",
            "virClassForObject()"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObject",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectRWLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "131-138",
          "snippet": "virClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectRWLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectRWLockableClass;\n\nvirClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nstatic int virNetServerServiceOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetServerService, virClassForObject()))\n        return -1;\n\n    return 0;\n}"
  }
]