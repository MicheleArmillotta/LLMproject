[
  {
    "function_name": "virSecretGetSecretString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsecret.c",
    "lines": "143-195",
    "snippet": "int\nvirSecretGetSecretString(virConnectPtr conn,\n                         virSecretLookupTypeDefPtr seclookupdef,\n                         virSecretUsageType secretUsageType,\n                         uint8_t **secret,\n                         size_t *secret_size)\n{\n    virSecretPtr sec = NULL;\n    int ret = -1;\n\n    switch (seclookupdef->type) {\n    case VIR_SECRET_LOOKUP_TYPE_UUID:\n        sec = conn->secretDriver->secretLookupByUUID(conn, seclookupdef->u.uuid);\n        break;\n\n    case VIR_SECRET_LOOKUP_TYPE_USAGE:\n        sec = conn->secretDriver->secretLookupByUsage(conn, secretUsageType,\n                                                      seclookupdef->u.usage);\n        break;\n    }\n\n    if (!sec)\n        goto cleanup;\n\n    /* NB: NONE is a byproduct of the qemuxml2argvtest test mocking\n     * for UUID lookups. Normal secret XML processing would fail if\n     * the usage type was NONE and since we have no way to set the\n     * expected usage in that environment, let's just accept NONE */\n    if (sec->usageType != VIR_SECRET_USAGE_TYPE_NONE &&\n        sec->usageType != secretUsageType) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(seclookupdef->u.uuid, uuidstr);\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"secret with uuid %s is of type '%s' not \"\n                         \"expected '%s' type\"),\n                       uuidstr, virSecretUsageTypeToString(sec->usageType),\n                       virSecretUsageTypeToString(secretUsageType));\n        goto cleanup;\n    }\n\n    *secret = conn->secretDriver->secretGetValue(sec, secret_size, 0,\n                                                 VIR_SECRET_GET_VALUE_INTERNAL_CALL);\n\n    if (!*secret)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(sec);\n    return ret;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virstring.h\"",
      "#include \"virsecret.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "sec"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "conn->secretDriver->secretGetValue",
          "args": [
            "sec",
            "secret_size",
            "0",
            "VIR_SECRET_GET_VALUE_INTERNAL_CALL"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "secretGetValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/secret/secret_driver.c",
          "lines": "353-388",
          "snippet": "static unsigned char *\nsecretGetValue(virSecretPtr secret,\n               size_t *value_size,\n               unsigned int flags,\n               unsigned int internalFlags)\n{\n    unsigned char *ret = NULL;\n    virSecretObjPtr obj;\n    virSecretDefPtr def;\n\n    virCheckFlags(0, NULL);\n\n    if (!(obj = secretObjFromSecret(secret)))\n        goto cleanup;\n\n    def = virSecretObjGetDef(obj);\n    if (virSecretGetValueEnsureACL(secret->conn, def) < 0)\n        goto cleanup;\n\n    if ((internalFlags & VIR_SECRET_GET_VALUE_INTERNAL_CALL) == 0 &&\n        def->isprivate) {\n        virReportError(VIR_ERR_INVALID_SECRET, \"%s\",\n                       _(\"secret is private\"));\n        goto cleanup;\n    }\n\n    if (!(ret = virSecretObjGetValue(obj)))\n        goto cleanup;\n\n    *value_size = virSecretObjGetValueSize(obj);\n\n cleanup:\n    virSecretObjEndAPI(&obj);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"secret_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virthread.h\"",
            "#include \"secret_driver.h\"",
            "#include \"virsecretobj.h\"",
            "#include \"secret_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"secret_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virthread.h\"\n#include \"secret_driver.h\"\n#include \"virsecretobj.h\"\n#include \"secret_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic unsigned char *\nsecretGetValue(virSecretPtr secret,\n               size_t *value_size,\n               unsigned int flags,\n               unsigned int internalFlags)\n{\n    unsigned char *ret = NULL;\n    virSecretObjPtr obj;\n    virSecretDefPtr def;\n\n    virCheckFlags(0, NULL);\n\n    if (!(obj = secretObjFromSecret(secret)))\n        goto cleanup;\n\n    def = virSecretObjGetDef(obj);\n    if (virSecretGetValueEnsureACL(secret->conn, def) < 0)\n        goto cleanup;\n\n    if ((internalFlags & VIR_SECRET_GET_VALUE_INTERNAL_CALL) == 0 &&\n        def->isprivate) {\n        virReportError(VIR_ERR_INVALID_SECRET, \"%s\",\n                       _(\"secret is private\"));\n        goto cleanup;\n    }\n\n    if (!(ret = virSecretObjGetValue(obj)))\n        goto cleanup;\n\n    *value_size = virSecretObjGetValueSize(obj);\n\n cleanup:\n    virSecretObjEndAPI(&obj);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"secret with uuid %s is of type '%s' not \"\n                         \"expected '%s' type\")",
            "uuidstr",
            "virSecretUsageTypeToString(sec->usageType)",
            "virSecretUsageTypeToString(secretUsageType)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecretUsageTypeToString",
          "args": [
            "secretUsageType"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecretUsageTypeToString",
          "args": [
            "sec->usageType"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"secret with uuid %s is of type '%s' not \"\n                         \"expected '%s' type\""
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "seclookupdef->u.uuid",
            "uuidstr"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "conn->secretDriver->secretLookupByUsage",
          "args": [
            "conn",
            "secretUsageType",
            "seclookupdef->u.usage"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "secretLookupByUsage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/secret/secret_driver.c",
          "lines": "180-208",
          "snippet": "static virSecretPtr\nsecretLookupByUsage(virConnectPtr conn,\n                    int usageType,\n                    const char *usageID)\n{\n    virSecretPtr ret = NULL;\n    virSecretObjPtr obj;\n    virSecretDefPtr def;\n\n    if (!(obj = virSecretObjListFindByUsage(driver->secrets,\n                                            usageType, usageID))) {\n        virReportError(VIR_ERR_NO_SECRET,\n                       _(\"no secret with matching usage '%s'\"), usageID);\n        goto cleanup;\n    }\n\n    def = virSecretObjGetDef(obj);\n    if (virSecretLookupByUsageEnsureACL(conn, def) < 0)\n        goto cleanup;\n\n    ret = virGetSecret(conn,\n                       def->uuid,\n                       def->usage_type,\n                       def->usage_id);\n\n cleanup:\n    virSecretObjEndAPI(&obj);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"secret_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virthread.h\"",
            "#include \"secret_driver.h\"",
            "#include \"virsecretobj.h\"",
            "#include \"secret_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virSecretDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"secret_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virthread.h\"\n#include \"secret_driver.h\"\n#include \"virsecretobj.h\"\n#include \"secret_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virSecretDriverStatePtr driver;\n\nstatic virSecretPtr\nsecretLookupByUsage(virConnectPtr conn,\n                    int usageType,\n                    const char *usageID)\n{\n    virSecretPtr ret = NULL;\n    virSecretObjPtr obj;\n    virSecretDefPtr def;\n\n    if (!(obj = virSecretObjListFindByUsage(driver->secrets,\n                                            usageType, usageID))) {\n        virReportError(VIR_ERR_NO_SECRET,\n                       _(\"no secret with matching usage '%s'\"), usageID);\n        goto cleanup;\n    }\n\n    def = virSecretObjGetDef(obj);\n    if (virSecretLookupByUsageEnsureACL(conn, def) < 0)\n        goto cleanup;\n\n    ret = virGetSecret(conn,\n                       def->uuid,\n                       def->usage_type,\n                       def->usage_id);\n\n cleanup:\n    virSecretObjEndAPI(&obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "conn->secretDriver->secretLookupByUUID",
          "args": [
            "conn",
            "seclookupdef->u.uuid"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "secretLookupByUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/secret/secret_driver.c",
          "lines": "149-177",
          "snippet": "static virSecretPtr\nsecretLookupByUUID(virConnectPtr conn,\n                   const unsigned char *uuid)\n{\n    virSecretPtr ret = NULL;\n    virSecretObjPtr obj;\n    virSecretDefPtr def;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(uuid, uuidstr);\n    if (!(obj = virSecretObjListFindByUUID(driver->secrets, uuidstr))) {\n        virReportError(VIR_ERR_NO_SECRET,\n                       _(\"no secret with matching uuid '%s'\"), uuidstr);\n        goto cleanup;\n    }\n\n    def = virSecretObjGetDef(obj);\n    if (virSecretLookupByUUIDEnsureACL(conn, def) < 0)\n        goto cleanup;\n\n    ret = virGetSecret(conn,\n                       def->uuid,\n                       def->usage_type,\n                       def->usage_id);\n\n cleanup:\n    virSecretObjEndAPI(&obj);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"secret_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virthread.h\"",
            "#include \"secret_driver.h\"",
            "#include \"virsecretobj.h\"",
            "#include \"secret_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virSecretDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"secret_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virthread.h\"\n#include \"secret_driver.h\"\n#include \"virsecretobj.h\"\n#include \"secret_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virSecretDriverStatePtr driver;\n\nstatic virSecretPtr\nsecretLookupByUUID(virConnectPtr conn,\n                   const unsigned char *uuid)\n{\n    virSecretPtr ret = NULL;\n    virSecretObjPtr obj;\n    virSecretDefPtr def;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(uuid, uuidstr);\n    if (!(obj = virSecretObjListFindByUUID(driver->secrets, uuidstr))) {\n        virReportError(VIR_ERR_NO_SECRET,\n                       _(\"no secret with matching uuid '%s'\"), uuidstr);\n        goto cleanup;\n    }\n\n    def = virSecretObjGetDef(obj);\n    if (virSecretLookupByUUIDEnsureACL(conn, def) < 0)\n        goto cleanup;\n\n    ret = virGetSecret(conn,\n                       def->uuid,\n                       def->usage_type,\n                       def->usage_id);\n\n cleanup:\n    virSecretObjEndAPI(&obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirSecretGetSecretString(virConnectPtr conn,\n                         virSecretLookupTypeDefPtr seclookupdef,\n                         virSecretUsageType secretUsageType,\n                         uint8_t **secret,\n                         size_t *secret_size)\n{\n    virSecretPtr sec = NULL;\n    int ret = -1;\n\n    switch (seclookupdef->type) {\n    case VIR_SECRET_LOOKUP_TYPE_UUID:\n        sec = conn->secretDriver->secretLookupByUUID(conn, seclookupdef->u.uuid);\n        break;\n\n    case VIR_SECRET_LOOKUP_TYPE_USAGE:\n        sec = conn->secretDriver->secretLookupByUsage(conn, secretUsageType,\n                                                      seclookupdef->u.usage);\n        break;\n    }\n\n    if (!sec)\n        goto cleanup;\n\n    /* NB: NONE is a byproduct of the qemuxml2argvtest test mocking\n     * for UUID lookups. Normal secret XML processing would fail if\n     * the usage type was NONE and since we have no way to set the\n     * expected usage in that environment, let's just accept NONE */\n    if (sec->usageType != VIR_SECRET_USAGE_TYPE_NONE &&\n        sec->usageType != secretUsageType) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(seclookupdef->u.uuid, uuidstr);\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"secret with uuid %s is of type '%s' not \"\n                         \"expected '%s' type\"),\n                       uuidstr, virSecretUsageTypeToString(sec->usageType),\n                       virSecretUsageTypeToString(secretUsageType));\n        goto cleanup;\n    }\n\n    *secret = conn->secretDriver->secretGetValue(sec, secret_size, 0,\n                                                 VIR_SECRET_GET_VALUE_INTERNAL_CALL);\n\n    if (!*secret)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(sec);\n    return ret;\n}"
  },
  {
    "function_name": "virSecretLookupFormatSecret",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsecret.c",
    "lines": "107-127",
    "snippet": "void\nvirSecretLookupFormatSecret(virBufferPtr buf,\n                            const char *secrettype,\n                            virSecretLookupTypeDefPtr def)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (secrettype)\n        virBufferAsprintf(buf, \"<secret type='%s'\", secrettype);\n    else\n        virBufferAddLit(buf, \"<secret\");\n\n    if (def->type == VIR_SECRET_LOOKUP_TYPE_UUID) {\n        virUUIDFormat(def->u.uuid, uuidstr);\n        virBufferAsprintf(buf, \" uuid='%s'/>\\n\", uuidstr);\n    } else if (def->type == VIR_SECRET_LOOKUP_TYPE_USAGE) {\n        virBufferEscapeString(buf, \" usage='%s'/>\\n\", def->u.usage);\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virstring.h\"",
      "#include \"virsecret.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\" usage='%s'/>\\n\"",
            "def->u.usage"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\" uuid='%s'/>\\n\"",
            "uuidstr"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "def->u.uuid",
            "uuidstr"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<secret\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirSecretLookupFormatSecret(virBufferPtr buf,\n                            const char *secrettype,\n                            virSecretLookupTypeDefPtr def)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (secrettype)\n        virBufferAsprintf(buf, \"<secret type='%s'\", secrettype);\n    else\n        virBufferAddLit(buf, \"<secret\");\n\n    if (def->type == VIR_SECRET_LOOKUP_TYPE_UUID) {\n        virUUIDFormat(def->u.uuid, uuidstr);\n        virBufferAsprintf(buf, \" uuid='%s'/>\\n\", uuidstr);\n    } else if (def->type == VIR_SECRET_LOOKUP_TYPE_USAGE) {\n        virBufferEscapeString(buf, \" usage='%s'/>\\n\", def->u.usage);\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n}"
  },
  {
    "function_name": "virSecretLookupParseSecret",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsecret.c",
    "lines": "64-104",
    "snippet": "int\nvirSecretLookupParseSecret(xmlNodePtr secretnode,\n                           virSecretLookupTypeDefPtr def)\n{\n    char *uuid;\n    char *usage;\n    int ret = -1;\n\n    uuid = virXMLPropString(secretnode, \"uuid\");\n    usage = virXMLPropString(secretnode, \"usage\");\n    if (uuid == NULL && usage == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing secret uuid or usage attribute\"));\n        goto cleanup;\n    }\n\n    if (uuid && usage) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"either secret uuid or usage expected\"));\n        goto cleanup;\n    }\n\n    if (uuid) {\n        if (virUUIDParse(uuid, def->u.uuid) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"invalid secret uuid '%s'\"), uuid);\n            goto cleanup;\n        }\n        def->type = VIR_SECRET_LOOKUP_TYPE_UUID;\n    } else {\n        def->u.usage = usage;\n        usage = NULL;\n        def->type = VIR_SECRET_LOOKUP_TYPE_USAGE;\n    }\n    ret = 0;\n\n cleanup:\n    VIR_FREE(uuid);\n    VIR_FREE(usage);\n    return ret;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virstring.h\"",
      "#include \"virsecret.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "usage"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"invalid secret uuid '%s'\")",
            "uuid"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid secret uuid '%s'\""
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "uuid",
            "def->u.uuid"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"either secret uuid or usage expected\")"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing secret uuid or usage attribute\")"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "secretnode",
            "\"usage\""
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirSecretLookupParseSecret(xmlNodePtr secretnode,\n                           virSecretLookupTypeDefPtr def)\n{\n    char *uuid;\n    char *usage;\n    int ret = -1;\n\n    uuid = virXMLPropString(secretnode, \"uuid\");\n    usage = virXMLPropString(secretnode, \"usage\");\n    if (uuid == NULL && usage == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing secret uuid or usage attribute\"));\n        goto cleanup;\n    }\n\n    if (uuid && usage) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"either secret uuid or usage expected\"));\n        goto cleanup;\n    }\n\n    if (uuid) {\n        if (virUUIDParse(uuid, def->u.uuid) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"invalid secret uuid '%s'\"), uuid);\n            goto cleanup;\n        }\n        def->type = VIR_SECRET_LOOKUP_TYPE_UUID;\n    } else {\n        def->u.usage = usage;\n        usage = NULL;\n        def->type = VIR_SECRET_LOOKUP_TYPE_USAGE;\n    }\n    ret = 0;\n\n cleanup:\n    VIR_FREE(uuid);\n    VIR_FREE(usage);\n    return ret;\n}"
  },
  {
    "function_name": "virSecretLookupDefCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsecret.c",
    "lines": "51-61",
    "snippet": "void\nvirSecretLookupDefCopy(virSecretLookupTypeDefPtr dst,\n                       const virSecretLookupTypeDef *src)\n{\n    dst->type = src->type;\n    if (dst->type == VIR_SECRET_LOOKUP_TYPE_UUID) {\n        memcpy(dst->u.uuid, src->u.uuid, VIR_UUID_BUFLEN);\n    } else if (dst->type == VIR_SECRET_LOOKUP_TYPE_USAGE) {\n        dst->u.usage = g_strdup(src->u.usage);\n    }\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virstring.h\"",
      "#include \"virsecret.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "src->u.usage"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst->u.uuid",
            "src->u.uuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirSecretLookupDefCopy(virSecretLookupTypeDefPtr dst,\n                       const virSecretLookupTypeDef *src)\n{\n    dst->type = src->type;\n    if (dst->type == VIR_SECRET_LOOKUP_TYPE_UUID) {\n        memcpy(dst->u.uuid, src->u.uuid, VIR_UUID_BUFLEN);\n    } else if (dst->type == VIR_SECRET_LOOKUP_TYPE_USAGE) {\n        dst->u.usage = g_strdup(src->u.usage);\n    }\n}"
  },
  {
    "function_name": "virSecretLookupDefClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsecret.c",
    "lines": "41-48",
    "snippet": "void\nvirSecretLookupDefClear(virSecretLookupTypeDefPtr def)\n{\n    if (def->type == VIR_SECRET_LOOKUP_TYPE_USAGE)\n        VIR_FREE(def->u.usage);\n    else if (def->type == VIR_SECRET_LOOKUP_TYPE_UUID)\n        memset(&def->u.uuid, 0, VIR_UUID_BUFLEN);\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virstring.h\"",
      "#include \"virsecret.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&def->u.uuid",
            "0",
            "VIR_UUID_BUFLEN"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->u.usage"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirSecretLookupDefClear(virSecretLookupTypeDefPtr def)\n{\n    if (def->type == VIR_SECRET_LOOKUP_TYPE_USAGE)\n        VIR_FREE(def->u.usage);\n    else if (def->type == VIR_SECRET_LOOKUP_TYPE_UUID)\n        memset(&def->u.uuid, 0, VIR_UUID_BUFLEN);\n}"
  }
]