[
  {
    "function_name": "qemuDomainEnsureVirtioAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "3260-3302",
    "snippet": "int\nqemuDomainEnsureVirtioAddress(bool *releaseAddr,\n                              virDomainObjPtr vm,\n                              virDomainDeviceDefPtr dev,\n                              const char *devicename)\n{\n    virDomainDeviceInfoPtr info = virDomainDeviceGetInfo(dev);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainCCWAddressSetPtr ccwaddrs = NULL;\n    virQEMUDriverPtr driver = priv->driver;\n    int ret = -1;\n\n    if (!info->type) {\n        if (qemuDomainIsS390CCW(vm->def) &&\n            virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_CCW))\n            info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW;\n        else if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_VIRTIO_S390))\n            info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_S390;\n    } else {\n        if (!qemuDomainCheckCCWS390AddressSupport(vm->def, info, priv->qemuCaps,\n                                                  devicename))\n            return -1;\n    }\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW) {\n        if (!(ccwaddrs = virDomainCCWAddressSetCreateFromDomain(vm->def)))\n            goto cleanup;\n        if (virDomainCCWAddressAssign(info, ccwaddrs,\n                                      !info->addr.ccw.assigned) < 0)\n            goto cleanup;\n    } else if (!info->type ||\n               info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI) {\n        if (qemuDomainEnsurePCIAddress(vm, dev, driver) < 0)\n            goto cleanup;\n        *releaseAddr = true;\n    }\n\n    ret = 0;\n\n cleanup:\n    virDomainCCWAddressSetFree(ccwaddrs);\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainCCWAddressSetFree",
          "args": [
            "ccwaddrs"
          ],
          "line": 3300
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCCWAddressSetFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1463-1470",
          "snippet": "void virDomainCCWAddressSetFree(virDomainCCWAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virHashFree(addrs->defined);\n    VIR_FREE(addrs);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid virDomainCCWAddressSetFree(virDomainCCWAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virHashFree(addrs->defined);\n    VIR_FREE(addrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainEnsurePCIAddress",
          "args": [
            "vm",
            "dev",
            "driver"
          ],
          "line": 3292
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainEnsurePCIAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "3226-3243",
          "snippet": "int\nqemuDomainEnsurePCIAddress(virDomainObjPtr obj,\n                           virDomainDeviceDefPtr dev,\n                           virQEMUDriverPtr driver)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n    virDomainDeviceInfoPtr info = virDomainDeviceGetInfo(dev);\n\n    if (!info)\n        return 0;\n\n    qemuDomainFillDevicePCIConnectFlags(obj->def, dev, priv->qemuCaps, driver);\n\n    qemuDomainFillDevicePCIExtensionFlags(dev, info, priv->qemuCaps);\n\n    return virDomainPCIAddressEnsureAddr(priv->pciaddrs, info,\n                                         info->pciConnectFlags);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nint\nqemuDomainEnsurePCIAddress(virDomainObjPtr obj,\n                           virDomainDeviceDefPtr dev,\n                           virQEMUDriverPtr driver)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n    virDomainDeviceInfoPtr info = virDomainDeviceGetInfo(dev);\n\n    if (!info)\n        return 0;\n\n    qemuDomainFillDevicePCIConnectFlags(obj->def, dev, priv->qemuCaps, driver);\n\n    qemuDomainFillDevicePCIExtensionFlags(dev, info, priv->qemuCaps);\n\n    return virDomainPCIAddressEnsureAddr(priv->pciaddrs, info,\n                                         info->pciConnectFlags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainCCWAddressAssign",
          "args": [
            "info",
            "ccwaddrs",
            "!info->addr.ccw.assigned"
          ],
          "line": 3287
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCCWAddressAssign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1397-1443",
          "snippet": "int\nvirDomainCCWAddressAssign(virDomainDeviceInfoPtr dev,\n                          virDomainCCWAddressSetPtr addrs,\n                          bool autoassign)\n{\n    g_autofree char *addr = NULL;\n\n    if (dev->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW)\n        return 0;\n\n    if (!autoassign && dev->addr.ccw.assigned) {\n        if (!(addr = virDomainCCWAddressAsString(&dev->addr.ccw)))\n            return -1;\n\n        if (virHashLookup(addrs->defined, addr)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"The CCW devno '%s' is in use already \"),\n                           addr);\n            return -1;\n        }\n    } else if (autoassign && !dev->addr.ccw.assigned) {\n        if (!(addr = virDomainCCWAddressAsString(&addrs->next)))\n            return -1;\n\n        while (virHashLookup(addrs->defined, addr)) {\n            if (virDomainCCWAddressIncrement(&addrs->next) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"There are no more free CCW devnos.\"));\n                return -1;\n            }\n            VIR_FREE(addr);\n            if (!(addr = virDomainCCWAddressAsString(&addrs->next)))\n                return -1;\n        }\n        dev->addr.ccw = addrs->next;\n        dev->addr.ccw.assigned = true;\n    } else {\n        return 0;\n    }\n\n    if (virHashAddEntry(addrs->defined, addr, addr) < 0)\n        return -1;\n    else\n        addr = NULL; /* memory will be freed by hash table */\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainCCWAddressAssign(virDomainDeviceInfoPtr dev,\n                          virDomainCCWAddressSetPtr addrs,\n                          bool autoassign)\n{\n    g_autofree char *addr = NULL;\n\n    if (dev->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW)\n        return 0;\n\n    if (!autoassign && dev->addr.ccw.assigned) {\n        if (!(addr = virDomainCCWAddressAsString(&dev->addr.ccw)))\n            return -1;\n\n        if (virHashLookup(addrs->defined, addr)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"The CCW devno '%s' is in use already \"),\n                           addr);\n            return -1;\n        }\n    } else if (autoassign && !dev->addr.ccw.assigned) {\n        if (!(addr = virDomainCCWAddressAsString(&addrs->next)))\n            return -1;\n\n        while (virHashLookup(addrs->defined, addr)) {\n            if (virDomainCCWAddressIncrement(&addrs->next) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"There are no more free CCW devnos.\"));\n                return -1;\n            }\n            VIR_FREE(addr);\n            if (!(addr = virDomainCCWAddressAsString(&addrs->next)))\n                return -1;\n        }\n        dev->addr.ccw = addrs->next;\n        dev->addr.ccw.assigned = true;\n    } else {\n        return 0;\n    }\n\n    if (virHashAddEntry(addrs->defined, addr, addr) < 0)\n        return -1;\n    else\n        addr = NULL; /* memory will be freed by hash table */\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainCCWAddressSetCreateFromDomain",
          "args": [
            "vm->def"
          ],
          "line": 3285
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCCWAddressSetCreateFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1496-1517",
          "snippet": "virDomainCCWAddressSetPtr\nvirDomainCCWAddressSetCreateFromDomain(virDomainDefPtr def)\n{\n    virDomainCCWAddressSetPtr addrs = NULL;\n\n    if (!(addrs = virDomainCCWAddressSetCreate()))\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def, virDomainCCWAddressValidate,\n                                   addrs) < 0)\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def, virDomainCCWAddressAllocate,\n                                   addrs) < 0)\n        goto error;\n\n    return addrs;\n\n error:\n    virDomainCCWAddressSetFree(addrs);\n    return NULL;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvirDomainCCWAddressSetPtr\nvirDomainCCWAddressSetCreateFromDomain(virDomainDefPtr def)\n{\n    virDomainCCWAddressSetPtr addrs = NULL;\n\n    if (!(addrs = virDomainCCWAddressSetCreate()))\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def, virDomainCCWAddressValidate,\n                                   addrs) < 0)\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def, virDomainCCWAddressAllocate,\n                                   addrs) < 0)\n        goto error;\n\n    return addrs;\n\n error:\n    virDomainCCWAddressSetFree(addrs);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainCheckCCWS390AddressSupport",
          "args": [
            "vm->def",
            "info",
            "priv->qemuCaps",
            "devicename"
          ],
          "line": 3279
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainCheckCCWS390AddressSupport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "16462-16490",
          "snippet": "bool\nqemuDomainCheckCCWS390AddressSupport(const virDomainDef *def,\n                                     const virDomainDeviceInfo *info,\n                                     virQEMUCapsPtr qemuCaps,\n                                     const char *devicename)\n{\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW) {\n        if (!qemuDomainIsS390CCW(def)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"cannot use CCW address type for device \"\n                             \"'%s' using machine type '%s'\"),\n                       devicename, def->os.machine);\n            return false;\n        } else if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_CCW)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"CCW address type is not supported by \"\n                             \"this QEMU\"));\n            return false;\n        }\n    } else if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_S390) {\n        if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_S390)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"virtio S390 address type is not supported by \"\n                             \"this QEMU\"));\n            return false;\n        }\n    }\n    return true;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainCheckCCWS390AddressSupport(const virDomainDef *def,\n                                     const virDomainDeviceInfo *info,\n                                     virQEMUCapsPtr qemuCaps,\n                                     const char *devicename)\n{\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW) {\n        if (!qemuDomainIsS390CCW(def)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"cannot use CCW address type for device \"\n                             \"'%s' using machine type '%s'\"),\n                       devicename, def->os.machine);\n            return false;\n        } else if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_CCW)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"CCW address type is not supported by \"\n                             \"this QEMU\"));\n            return false;\n        }\n    } else if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_S390) {\n        if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_S390)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"virtio S390 address type is not supported by \"\n                             \"this QEMU\"));\n            return false;\n        }\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "priv->qemuCaps",
            "QEMU_CAPS_VIRTIO_S390"
          ],
          "line": 3276
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainIsS390CCW",
          "args": [
            "vm->def"
          ],
          "line": 3273
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainIsS390CCW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12891-12895",
          "snippet": "bool\nqemuDomainIsS390CCW(const virDomainDef *def)\n{\n    return qemuDomainMachineIsS390CCW(def->os.machine, def->os.arch);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainIsS390CCW(const virDomainDef *def)\n{\n    return qemuDomainMachineIsS390CCW(def->os.machine, def->os.arch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDeviceGetInfo",
          "args": [
            "dev"
          ],
          "line": 3266
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceGetInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3933-3989",
          "snippet": "virDomainDeviceInfoPtr\nvirDomainDeviceGetInfo(virDomainDeviceDefPtr device)\n{\n    switch ((virDomainDeviceType) device->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        return &device->data.disk->info;\n    case VIR_DOMAIN_DEVICE_FS:\n        return &device->data.fs->info;\n    case VIR_DOMAIN_DEVICE_NET:\n        return &device->data.net->info;\n    case VIR_DOMAIN_DEVICE_INPUT:\n        return &device->data.input->info;\n    case VIR_DOMAIN_DEVICE_SOUND:\n        return &device->data.sound->info;\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        return &device->data.video->info;\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n        return device->data.hostdev->info;\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        return &device->data.watchdog->info;\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n        return &device->data.controller->info;\n    case VIR_DOMAIN_DEVICE_HUB:\n        return &device->data.hub->info;\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n        return &device->data.redirdev->info;\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        return &device->data.smartcard->info;\n    case VIR_DOMAIN_DEVICE_CHR:\n        return &device->data.chr->info;\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        return &device->data.memballoon->info;\n    case VIR_DOMAIN_DEVICE_NVRAM:\n        return &device->data.nvram->info;\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        return &device->data.shmem->info;\n    case VIR_DOMAIN_DEVICE_RNG:\n        return &device->data.rng->info;\n    case VIR_DOMAIN_DEVICE_TPM:\n        return &device->data.tpm->info;\n    case VIR_DOMAIN_DEVICE_PANIC:\n        return &device->data.panic->info;\n    case VIR_DOMAIN_DEVICE_MEMORY:\n        return &device->data.memory->info;\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        return &device->data.vsock->info;\n\n    /* The following devices do not contain virDomainDeviceInfo */\n    case VIR_DOMAIN_DEVICE_LEASE:\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n    case VIR_DOMAIN_DEVICE_IOMMU:\n    case VIR_DOMAIN_DEVICE_LAST:\n    case VIR_DOMAIN_DEVICE_NONE:\n        break;\n    }\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDeviceInfoPtr\nvirDomainDeviceGetInfo(virDomainDeviceDefPtr device)\n{\n    switch ((virDomainDeviceType) device->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        return &device->data.disk->info;\n    case VIR_DOMAIN_DEVICE_FS:\n        return &device->data.fs->info;\n    case VIR_DOMAIN_DEVICE_NET:\n        return &device->data.net->info;\n    case VIR_DOMAIN_DEVICE_INPUT:\n        return &device->data.input->info;\n    case VIR_DOMAIN_DEVICE_SOUND:\n        return &device->data.sound->info;\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        return &device->data.video->info;\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n        return device->data.hostdev->info;\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        return &device->data.watchdog->info;\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n        return &device->data.controller->info;\n    case VIR_DOMAIN_DEVICE_HUB:\n        return &device->data.hub->info;\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n        return &device->data.redirdev->info;\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        return &device->data.smartcard->info;\n    case VIR_DOMAIN_DEVICE_CHR:\n        return &device->data.chr->info;\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        return &device->data.memballoon->info;\n    case VIR_DOMAIN_DEVICE_NVRAM:\n        return &device->data.nvram->info;\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        return &device->data.shmem->info;\n    case VIR_DOMAIN_DEVICE_RNG:\n        return &device->data.rng->info;\n    case VIR_DOMAIN_DEVICE_TPM:\n        return &device->data.tpm->info;\n    case VIR_DOMAIN_DEVICE_PANIC:\n        return &device->data.panic->info;\n    case VIR_DOMAIN_DEVICE_MEMORY:\n        return &device->data.memory->info;\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        return &device->data.vsock->info;\n\n    /* The following devices do not contain virDomainDeviceInfo */\n    case VIR_DOMAIN_DEVICE_LEASE:\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n    case VIR_DOMAIN_DEVICE_IOMMU:\n    case VIR_DOMAIN_DEVICE_LAST:\n    case VIR_DOMAIN_DEVICE_NONE:\n        break;\n    }\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nint\nqemuDomainEnsureVirtioAddress(bool *releaseAddr,\n                              virDomainObjPtr vm,\n                              virDomainDeviceDefPtr dev,\n                              const char *devicename)\n{\n    virDomainDeviceInfoPtr info = virDomainDeviceGetInfo(dev);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainCCWAddressSetPtr ccwaddrs = NULL;\n    virQEMUDriverPtr driver = priv->driver;\n    int ret = -1;\n\n    if (!info->type) {\n        if (qemuDomainIsS390CCW(vm->def) &&\n            virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_CCW))\n            info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW;\n        else if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_VIRTIO_S390))\n            info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_S390;\n    } else {\n        if (!qemuDomainCheckCCWS390AddressSupport(vm->def, info, priv->qemuCaps,\n                                                  devicename))\n            return -1;\n    }\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW) {\n        if (!(ccwaddrs = virDomainCCWAddressSetCreateFromDomain(vm->def)))\n            goto cleanup;\n        if (virDomainCCWAddressAssign(info, ccwaddrs,\n                                      !info->addr.ccw.assigned) < 0)\n            goto cleanup;\n    } else if (!info->type ||\n               info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI) {\n        if (qemuDomainEnsurePCIAddress(vm, dev, driver) < 0)\n            goto cleanup;\n        *releaseAddr = true;\n    }\n\n    ret = 0;\n\n cleanup:\n    virDomainCCWAddressSetFree(ccwaddrs);\n    return ret;\n}"
  },
  {
    "function_name": "qemuDomainReleaseDeviceAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "3245-3257",
    "snippet": "void\nqemuDomainReleaseDeviceAddress(virDomainObjPtr vm,\n                               virDomainDeviceInfoPtr info)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (virDeviceInfoPCIAddressIsPresent(info)) {\n        virDomainPCIAddressReleaseAddr(priv->pciaddrs, &info->addr.pci);\n        virDomainPCIAddressExtensionReleaseAddr(priv->pciaddrs, &info->addr.pci);\n    }\n\n    virDomainUSBAddressRelease(priv->usbaddrs, info);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainUSBAddressRelease",
          "args": [
            "priv->usbaddrs",
            "info"
          ],
          "line": 3256
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2453-2475",
          "snippet": "int\nvirDomainUSBAddressRelease(virDomainUSBAddressSetPtr addrs,\n                           virDomainDeviceInfoPtr info)\n{\n    virDomainUSBAddressHubPtr targetHub = NULL;\n    g_autofree char *portStr = NULL;\n    int targetPort;\n\n    if (!addrs || info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB ||\n        !virDomainUSBAddressPortIsValid(info->addr.usb.port))\n        return 0;\n\n    portStr = virDomainUSBAddressPortFormat(info->addr.usb.port);\n    VIR_DEBUG(\"Releasing USB addr bus=%u port=%s\", info->addr.usb.bus, portStr);\n\n    if (!(targetHub = virDomainUSBAddressFindPort(addrs, info, &targetPort,\n                                                  portStr)))\n        return -1;\n\n    ignore_value(virBitmapClearBit(targetHub->portmap, targetPort));\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainUSBAddressRelease(virDomainUSBAddressSetPtr addrs,\n                           virDomainDeviceInfoPtr info)\n{\n    virDomainUSBAddressHubPtr targetHub = NULL;\n    g_autofree char *portStr = NULL;\n    int targetPort;\n\n    if (!addrs || info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB ||\n        !virDomainUSBAddressPortIsValid(info->addr.usb.port))\n        return 0;\n\n    portStr = virDomainUSBAddressPortFormat(info->addr.usb.port);\n    VIR_DEBUG(\"Releasing USB addr bus=%u port=%s\", info->addr.usb.bus, portStr);\n\n    if (!(targetHub = virDomainUSBAddressFindPort(addrs, info, &targetPort,\n                                                  portStr)))\n        return -1;\n\n    ignore_value(virBitmapClearBit(targetHub->portmap, targetPort));\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressExtensionReleaseAddr",
          "args": [
            "priv->pciaddrs",
            "&info->addr.pci"
          ],
          "line": 3253
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressExtensionReleaseAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "954-960",
          "snippet": "void\nvirDomainPCIAddressExtensionReleaseAddr(virDomainPCIAddressSetPtr addrs,\n                                        virPCIDeviceAddressPtr addr)\n{\n    if (addr->extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI)\n        virDomainZPCIAddressReleaseIds(addrs->zpciIds, &addr->zpci);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainPCIAddressExtensionReleaseAddr(virDomainPCIAddressSetPtr addrs,\n                                        virPCIDeviceAddressPtr addr)\n{\n    if (addr->extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI)\n        virDomainZPCIAddressReleaseIds(addrs->zpciIds, &addr->zpci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressReleaseAddr",
          "args": [
            "priv->pciaddrs",
            "&info->addr.pci"
          ],
          "line": 3252
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressReleaseAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "963-968",
          "snippet": "void\nvirDomainPCIAddressReleaseAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr)\n{\n    addrs->buses[addr->bus].slot[addr->slot].functions &= ~(1 << addr->function);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainPCIAddressReleaseAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr)\n{\n    addrs->buses[addr->bus].slot[addr->slot].functions &= ~(1 << addr->function);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDeviceInfoPCIAddressIsPresent",
          "args": [
            "info"
          ],
          "line": 3251
        },
        "resolved": true,
        "details": {
          "function_name": "virDeviceInfoPCIAddressIsPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "191-196",
          "snippet": "bool\nvirDeviceInfoPCIAddressIsPresent(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n           !virPCIDeviceAddressIsEmpty(&info->addr.pci);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool\nvirDeviceInfoPCIAddressIsPresent(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n           !virPCIDeviceAddressIsEmpty(&info->addr.pci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nvoid\nqemuDomainReleaseDeviceAddress(virDomainObjPtr vm,\n                               virDomainDeviceInfoPtr info)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (virDeviceInfoPCIAddressIsPresent(info)) {\n        virDomainPCIAddressReleaseAddr(priv->pciaddrs, &info->addr.pci);\n        virDomainPCIAddressExtensionReleaseAddr(priv->pciaddrs, &info->addr.pci);\n    }\n\n    virDomainUSBAddressRelease(priv->usbaddrs, info);\n}"
  },
  {
    "function_name": "qemuDomainEnsurePCIAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "3226-3243",
    "snippet": "int\nqemuDomainEnsurePCIAddress(virDomainObjPtr obj,\n                           virDomainDeviceDefPtr dev,\n                           virQEMUDriverPtr driver)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n    virDomainDeviceInfoPtr info = virDomainDeviceGetInfo(dev);\n\n    if (!info)\n        return 0;\n\n    qemuDomainFillDevicePCIConnectFlags(obj->def, dev, priv->qemuCaps, driver);\n\n    qemuDomainFillDevicePCIExtensionFlags(dev, info, priv->qemuCaps);\n\n    return virDomainPCIAddressEnsureAddr(priv->pciaddrs, info,\n                                         info->pciConnectFlags);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressEnsureAddr",
          "args": [
            "priv->pciaddrs",
            "info",
            "info->pciConnectFlags"
          ],
          "line": 3241
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressEnsureAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "905-951",
          "snippet": "int\nvirDomainPCIAddressEnsureAddr(virDomainPCIAddressSetPtr addrs,\n                              virDomainDeviceInfoPtr dev,\n                              virDomainPCIConnectFlags flags)\n{\n    g_autofree char *addrStr = NULL;\n\n    /* if flags is 0, the particular model of this device on this\n     * machinetype doesn't need a PCI address, so we're done.\n     */\n    if (!flags)\n       return 0;\n\n    if (!(addrStr = virPCIDeviceAddressAsString(&dev->addr.pci)))\n        return -1;\n\n    if (virDeviceInfoPCIAddressIsPresent(dev)) {\n        /* We do not support hotplug multi-function PCI device now, so we should\n         * reserve the whole slot. The function of the PCI device must be 0.\n         */\n        if (dev->addr.pci.function != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Only PCI device addresses with function=0\"\n                             \" are supported\"));\n            return -1;\n        }\n\n        if (!virDomainPCIAddressValidate(addrs, &dev->addr.pci,\n                                         addrStr, flags, true))\n            return -1;\n\n        if (virDomainPCIAddressReserveAddrInternal(addrs, &dev->addr.pci,\n                                                   flags, dev->isolationGroup,\n                                                   true) < 0) {\n            return -1;\n        }\n    } else {\n        if (virDomainPCIAddressReserveNextAddr(addrs, dev, flags, -1) < 0)\n            return -1;\n    }\n\n    dev->addr.pci.extFlags = dev->pciAddrExtFlags;\n    if (virDomainPCIAddressExtensionEnsureAddr(addrs, &dev->addr.pci) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressEnsureAddr(virDomainPCIAddressSetPtr addrs,\n                              virDomainDeviceInfoPtr dev,\n                              virDomainPCIConnectFlags flags)\n{\n    g_autofree char *addrStr = NULL;\n\n    /* if flags is 0, the particular model of this device on this\n     * machinetype doesn't need a PCI address, so we're done.\n     */\n    if (!flags)\n       return 0;\n\n    if (!(addrStr = virPCIDeviceAddressAsString(&dev->addr.pci)))\n        return -1;\n\n    if (virDeviceInfoPCIAddressIsPresent(dev)) {\n        /* We do not support hotplug multi-function PCI device now, so we should\n         * reserve the whole slot. The function of the PCI device must be 0.\n         */\n        if (dev->addr.pci.function != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Only PCI device addresses with function=0\"\n                             \" are supported\"));\n            return -1;\n        }\n\n        if (!virDomainPCIAddressValidate(addrs, &dev->addr.pci,\n                                         addrStr, flags, true))\n            return -1;\n\n        if (virDomainPCIAddressReserveAddrInternal(addrs, &dev->addr.pci,\n                                                   flags, dev->isolationGroup,\n                                                   true) < 0) {\n            return -1;\n        }\n    } else {\n        if (virDomainPCIAddressReserveNextAddr(addrs, dev, flags, -1) < 0)\n            return -1;\n    }\n\n    dev->addr.pci.extFlags = dev->pciAddrExtFlags;\n    if (virDomainPCIAddressExtensionEnsureAddr(addrs, &dev->addr.pci) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainFillDevicePCIExtensionFlags",
          "args": [
            "dev",
            "info",
            "priv->qemuCaps"
          ],
          "line": 3239
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainFillDevicePCIExtensionFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "1474-1481",
          "snippet": "static void\nqemuDomainFillDevicePCIExtensionFlags(virDomainDeviceDefPtr dev,\n                                      virDomainDeviceInfoPtr info,\n                                      virQEMUCapsPtr qemuCaps)\n{\n    info->pciAddrExtFlags =\n        qemuDomainDeviceCalculatePCIAddressExtensionFlags(qemuCaps, dev);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic void\nqemuDomainFillDevicePCIExtensionFlags(virDomainDeviceDefPtr dev,\n                                      virDomainDeviceInfoPtr info,\n                                      virQEMUCapsPtr qemuCaps)\n{\n    info->pciAddrExtFlags =\n        qemuDomainDeviceCalculatePCIAddressExtensionFlags(qemuCaps, dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainFillDevicePCIConnectFlags",
          "args": [
            "obj->def",
            "dev",
            "priv->qemuCaps",
            "driver"
          ],
          "line": 3237
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainFillDevicePCIConnectFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "1433-1460",
          "snippet": "static void\nqemuDomainFillDevicePCIConnectFlags(virDomainDefPtr def,\n                                    virDomainDeviceDefPtr dev,\n                                    virQEMUCapsPtr qemuCaps,\n                                    virQEMUDriverPtr driver)\n{\n    virDomainDeviceInfoPtr info = virDomainDeviceGetInfo(dev);\n\n    if (info) {\n        /* qemuDomainDeviceCalculatePCIConnectFlags() is called with\n         * the data setup in the ...IterData by ...IterInit() rather\n         * than setting the values directly here.  It may seem like\n         * pointless posturing, but it's done this way to eliminate\n         * duplicated setup code while allowing more efficient\n         * operation when it's being done repeatedly with the device\n         * iterator (since qemuDomainFillAllPCIConnectFlags() only\n         * calls ...IterInit() once for all devices).\n         */\n        qemuDomainFillDevicePCIConnectFlagsIterData data;\n\n        qemuDomainFillDevicePCIConnectFlagsIterInit(def, qemuCaps, driver, &data);\n\n        info->pciConnectFlags\n            = qemuDomainDeviceCalculatePCIConnectFlags(dev, data.driver,\n                                                       data.pcieFlags,\n                                                       data.virtioFlags);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic void\nqemuDomainFillDevicePCIConnectFlags(virDomainDefPtr def,\n                                    virDomainDeviceDefPtr dev,\n                                    virQEMUCapsPtr qemuCaps,\n                                    virQEMUDriverPtr driver)\n{\n    virDomainDeviceInfoPtr info = virDomainDeviceGetInfo(dev);\n\n    if (info) {\n        /* qemuDomainDeviceCalculatePCIConnectFlags() is called with\n         * the data setup in the ...IterData by ...IterInit() rather\n         * than setting the values directly here.  It may seem like\n         * pointless posturing, but it's done this way to eliminate\n         * duplicated setup code while allowing more efficient\n         * operation when it's being done repeatedly with the device\n         * iterator (since qemuDomainFillAllPCIConnectFlags() only\n         * calls ...IterInit() once for all devices).\n         */\n        qemuDomainFillDevicePCIConnectFlagsIterData data;\n\n        qemuDomainFillDevicePCIConnectFlagsIterInit(def, qemuCaps, driver, &data);\n\n        info->pciConnectFlags\n            = qemuDomainDeviceCalculatePCIConnectFlags(dev, data.driver,\n                                                       data.pcieFlags,\n                                                       data.virtioFlags);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDeviceGetInfo",
          "args": [
            "dev"
          ],
          "line": 3232
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceGetInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3933-3989",
          "snippet": "virDomainDeviceInfoPtr\nvirDomainDeviceGetInfo(virDomainDeviceDefPtr device)\n{\n    switch ((virDomainDeviceType) device->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        return &device->data.disk->info;\n    case VIR_DOMAIN_DEVICE_FS:\n        return &device->data.fs->info;\n    case VIR_DOMAIN_DEVICE_NET:\n        return &device->data.net->info;\n    case VIR_DOMAIN_DEVICE_INPUT:\n        return &device->data.input->info;\n    case VIR_DOMAIN_DEVICE_SOUND:\n        return &device->data.sound->info;\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        return &device->data.video->info;\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n        return device->data.hostdev->info;\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        return &device->data.watchdog->info;\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n        return &device->data.controller->info;\n    case VIR_DOMAIN_DEVICE_HUB:\n        return &device->data.hub->info;\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n        return &device->data.redirdev->info;\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        return &device->data.smartcard->info;\n    case VIR_DOMAIN_DEVICE_CHR:\n        return &device->data.chr->info;\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        return &device->data.memballoon->info;\n    case VIR_DOMAIN_DEVICE_NVRAM:\n        return &device->data.nvram->info;\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        return &device->data.shmem->info;\n    case VIR_DOMAIN_DEVICE_RNG:\n        return &device->data.rng->info;\n    case VIR_DOMAIN_DEVICE_TPM:\n        return &device->data.tpm->info;\n    case VIR_DOMAIN_DEVICE_PANIC:\n        return &device->data.panic->info;\n    case VIR_DOMAIN_DEVICE_MEMORY:\n        return &device->data.memory->info;\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        return &device->data.vsock->info;\n\n    /* The following devices do not contain virDomainDeviceInfo */\n    case VIR_DOMAIN_DEVICE_LEASE:\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n    case VIR_DOMAIN_DEVICE_IOMMU:\n    case VIR_DOMAIN_DEVICE_LAST:\n    case VIR_DOMAIN_DEVICE_NONE:\n        break;\n    }\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDeviceInfoPtr\nvirDomainDeviceGetInfo(virDomainDeviceDefPtr device)\n{\n    switch ((virDomainDeviceType) device->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        return &device->data.disk->info;\n    case VIR_DOMAIN_DEVICE_FS:\n        return &device->data.fs->info;\n    case VIR_DOMAIN_DEVICE_NET:\n        return &device->data.net->info;\n    case VIR_DOMAIN_DEVICE_INPUT:\n        return &device->data.input->info;\n    case VIR_DOMAIN_DEVICE_SOUND:\n        return &device->data.sound->info;\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        return &device->data.video->info;\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n        return device->data.hostdev->info;\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        return &device->data.watchdog->info;\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n        return &device->data.controller->info;\n    case VIR_DOMAIN_DEVICE_HUB:\n        return &device->data.hub->info;\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n        return &device->data.redirdev->info;\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        return &device->data.smartcard->info;\n    case VIR_DOMAIN_DEVICE_CHR:\n        return &device->data.chr->info;\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        return &device->data.memballoon->info;\n    case VIR_DOMAIN_DEVICE_NVRAM:\n        return &device->data.nvram->info;\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        return &device->data.shmem->info;\n    case VIR_DOMAIN_DEVICE_RNG:\n        return &device->data.rng->info;\n    case VIR_DOMAIN_DEVICE_TPM:\n        return &device->data.tpm->info;\n    case VIR_DOMAIN_DEVICE_PANIC:\n        return &device->data.panic->info;\n    case VIR_DOMAIN_DEVICE_MEMORY:\n        return &device->data.memory->info;\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        return &device->data.vsock->info;\n\n    /* The following devices do not contain virDomainDeviceInfo */\n    case VIR_DOMAIN_DEVICE_LEASE:\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n    case VIR_DOMAIN_DEVICE_IOMMU:\n    case VIR_DOMAIN_DEVICE_LAST:\n    case VIR_DOMAIN_DEVICE_NONE:\n        break;\n    }\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nint\nqemuDomainEnsurePCIAddress(virDomainObjPtr obj,\n                           virDomainDeviceDefPtr dev,\n                           virQEMUDriverPtr driver)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n    virDomainDeviceInfoPtr info = virDomainDeviceGetInfo(dev);\n\n    if (!info)\n        return 0;\n\n    qemuDomainFillDevicePCIConnectFlags(obj->def, dev, priv->qemuCaps, driver);\n\n    qemuDomainFillDevicePCIExtensionFlags(dev, info, priv->qemuCaps);\n\n    return virDomainPCIAddressEnsureAddr(priv->pciaddrs, info,\n                                         info->pciConnectFlags);\n}"
  },
  {
    "function_name": "qemuDomainAssignAddresses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "3181-3209",
    "snippet": "int\nqemuDomainAssignAddresses(virDomainDefPtr def,\n                          virQEMUCapsPtr qemuCaps,\n                          virQEMUDriverPtr driver,\n                          virDomainObjPtr obj,\n                          bool newDomain)\n{\n    if (qemuDomainAssignVirtioSerialAddresses(def) < 0)\n        return -1;\n\n    if (qemuDomainAssignSpaprVIOAddresses(def) < 0)\n        return -1;\n\n    if (qemuDomainAssignS390Addresses(def, qemuCaps) < 0)\n        return -1;\n\n    qemuDomainAssignVirtioMMIOAddresses(def, qemuCaps);\n\n    if (qemuDomainAssignPCIAddresses(def, qemuCaps, driver, obj) < 0)\n        return -1;\n\n    if (qemuDomainAssignUSBAddresses(def, obj, newDomain) < 0)\n        return -1;\n\n    if (qemuDomainAssignMemorySlots(def) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainAssignMemorySlots",
          "args": [
            "def"
          ],
          "line": 3205
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainAssignMemorySlots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "3098-3122",
          "snippet": "static int\nqemuDomainAssignMemorySlots(virDomainDefPtr def)\n{\n    virBitmapPtr slotmap = NULL;\n    int ret = -1;\n    size_t i;\n\n    if (!virDomainDefHasMemoryHotplug(def))\n        return 0;\n\n    if (!(slotmap = qemuDomainGetMemorySlotMap(def)))\n        return -1;\n\n    for (i = 0; i < def->nmems; i++) {\n        if (qemuAssignMemoryDeviceSlot(def->mems[i], slotmap) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virBitmapFree(slotmap);\n    return ret;\n\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignMemorySlots(virDomainDefPtr def)\n{\n    virBitmapPtr slotmap = NULL;\n    int ret = -1;\n    size_t i;\n\n    if (!virDomainDefHasMemoryHotplug(def))\n        return 0;\n\n    if (!(slotmap = qemuDomainGetMemorySlotMap(def)))\n        return -1;\n\n    for (i = 0; i < def->nmems; i++) {\n        if (qemuAssignMemoryDeviceSlot(def->mems[i], slotmap) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virBitmapFree(slotmap);\n    return ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainAssignUSBAddresses",
          "args": [
            "def",
            "obj",
            "newDomain"
          ],
          "line": 3202
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainAssignUSBAddresses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "3125-3178",
          "snippet": "static int\nqemuDomainAssignUSBAddresses(virDomainDefPtr def,\n                             virDomainObjPtr obj,\n                             bool newDomain)\n{\n    int ret = -1;\n    virDomainUSBAddressSetPtr addrs = NULL;\n    qemuDomainObjPrivatePtr priv = NULL;\n\n    if (!newDomain) {\n        /* only create the address cache for:\n         *  new domains\n         *  domains that already have all the addresses specified\n         * otherwise libvirt's attempt to recreate the USB topology via\n         * QEMU command line might fail */\n        if (virDomainUSBDeviceDefForeach(def, virDomainUSBAddressPresent, NULL,\n                                         false) < 0)\n            return 0;\n    }\n\n    if (!(addrs = virDomainUSBAddressSetCreate()))\n        goto cleanup;\n\n    if (qemuDomainUSBAddressAddHubs(def) < 0)\n        goto cleanup;\n\n    if (virDomainUSBAddressSetAddControllers(addrs, def) < 0)\n        goto cleanup;\n\n    if (virDomainUSBDeviceDefForeach(def, virDomainUSBAddressReserve, addrs,\n                                     true) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Existing USB addresses have been reserved\");\n\n    if (qemuDomainAssignUSBHubs(addrs, def) < 0)\n        goto cleanup;\n\n    if (qemuDomainAssignUSBPorts(addrs, def) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Finished assigning USB ports\");\n\n    if (obj && obj->privateData) {\n        priv = obj->privateData;\n        priv->usbaddrs = addrs;\n        addrs = NULL;\n    }\n    ret = 0;\n\n cleanup:\n    virDomainUSBAddressSetFree(addrs);\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignUSBAddresses(virDomainDefPtr def,\n                             virDomainObjPtr obj,\n                             bool newDomain)\n{\n    int ret = -1;\n    virDomainUSBAddressSetPtr addrs = NULL;\n    qemuDomainObjPrivatePtr priv = NULL;\n\n    if (!newDomain) {\n        /* only create the address cache for:\n         *  new domains\n         *  domains that already have all the addresses specified\n         * otherwise libvirt's attempt to recreate the USB topology via\n         * QEMU command line might fail */\n        if (virDomainUSBDeviceDefForeach(def, virDomainUSBAddressPresent, NULL,\n                                         false) < 0)\n            return 0;\n    }\n\n    if (!(addrs = virDomainUSBAddressSetCreate()))\n        goto cleanup;\n\n    if (qemuDomainUSBAddressAddHubs(def) < 0)\n        goto cleanup;\n\n    if (virDomainUSBAddressSetAddControllers(addrs, def) < 0)\n        goto cleanup;\n\n    if (virDomainUSBDeviceDefForeach(def, virDomainUSBAddressReserve, addrs,\n                                     true) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Existing USB addresses have been reserved\");\n\n    if (qemuDomainAssignUSBHubs(addrs, def) < 0)\n        goto cleanup;\n\n    if (qemuDomainAssignUSBPorts(addrs, def) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Finished assigning USB ports\");\n\n    if (obj && obj->privateData) {\n        priv = obj->privateData;\n        priv->usbaddrs = addrs;\n        addrs = NULL;\n    }\n    ret = 0;\n\n cleanup:\n    virDomainUSBAddressSetFree(addrs);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainAssignPCIAddresses",
          "args": [
            "def",
            "qemuCaps",
            "driver",
            "obj"
          ],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainAssignPCIAddresses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "2607-2915",
          "snippet": "static int\nqemuDomainAssignPCIAddresses(virDomainDefPtr def,\n                             virQEMUCapsPtr qemuCaps,\n                             virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    int ret = -1;\n    virDomainPCIAddressSetPtr addrs = NULL;\n    qemuDomainObjPrivatePtr priv = NULL;\n    int max_idx = -1;\n    int nbuses = 0;\n    size_t i;\n    int rv;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI) {\n            if ((int)cont->idx > max_idx)\n                max_idx = cont->idx;\n        }\n    }\n\n    nbuses = max_idx + 1;\n\n    /* set the connect type flags (pci vs. pcie) in the DeviceInfo\n     * of all devices. This will be used to pick an appropriate\n     * bus when assigning addresses.\n     */\n    if (qemuDomainFillAllPCIConnectFlags(def, qemuCaps, driver) < 0)\n        goto cleanup;\n\n    if (qemuDomainFillAllPCIExtensionFlags(def, qemuCaps) < 0)\n        goto cleanup;\n\n    if (qemuDomainSetupIsolationGroups(def) < 0)\n        goto cleanup;\n\n    if (nbuses > 0) {\n        /* 1st pass to figure out how many PCI bridges we need */\n        if (!(addrs = qemuDomainPCIAddressSetCreate(def, qemuCaps, nbuses, true)))\n            goto cleanup;\n\n        if (qemuDomainValidateDevicePCISlotsChipsets(def, qemuCaps,\n                                                     addrs) < 0)\n            goto cleanup;\n\n        /* For domains that have pci-root, reserve 1 extra slot for a\n         * (potential) bridge (for future expansion) only if buses are\n         * not fully reserved yet (if all buses are fully reserved\n         * with manually/previously assigned addresses, any attempt to\n         * reserve an extra slot would fail anyway. But if all buses\n         * are *not* fully reserved, this extra reservation might push\n         * the config to add a new pci-bridge to plug into the final\n         * available slot, thus preserving the ability to expand)\n         *\n         * We only do this for those domains that have pci-root, since\n         * those with pcie-root will usually want to expand using PCIe\n         * controllers, which we will do after assigning addresses for\n         * all *actual* devices.\n         */\n\n        if (qemuDomainHasPCIRoot(def)) {\n            /* This is a dummy info used to reserve a slot for a\n             * legacy PCI device that doesn't exist, but may in the\n             * future, e.g.  if another device is hotplugged into the\n             * domain.\n             */\n            virDomainDeviceInfo info = {\n                .pciConnectFlags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                                    VIR_PCI_CONNECT_TYPE_PCI_DEVICE),\n                .pciAddrExtFlags = VIR_PCI_ADDRESS_EXTENSION_NONE\n            };\n            bool buses_reserved = true;\n\n            for (i = 0; i < addrs->nbuses; i++) {\n                if (!virDomainPCIAddressBusIsFullyReserved(&addrs->buses[i])) {\n                    buses_reserved = false;\n                    break;\n                }\n            }\n            if (!buses_reserved &&\n                qemuDomainPCIAddressReserveNextAddr(addrs, &info) < 0)\n                goto cleanup;\n        }\n\n        if (qemuDomainAssignDevicePCISlots(def, qemuCaps, addrs) < 0)\n            goto cleanup;\n\n        if (virDomainDeviceInfoIterate(def, qemuDomainAssignPCIAddressExtension, addrs) < 0)\n            goto cleanup;\n\n        /* Only for *new* domains with pcie-root (and no other\n         * manually specified PCI controllers in the definition): If,\n         * after assigning addresses/reserving slots for all devices,\n         * we see that any extra buses have been auto-added, we\n         * understand that the application has left management of PCI\n         * addresses and controllers up to libvirt. In order to allow\n         * such applications to easily support hotplug, we will do a\n         * \"one time\" reservation of one extra PCIE|HOTPLUGGABLE\n         * slots, which should cause us to auto-add 1 extra\n         * pcie-root-port. The single slot in this root-port will be\n         * available for hotplug, or may also be used when a device is\n         * added to the config offline.\n         */\n\n        if (max_idx <= 0 &&\n            addrs->nbuses > max_idx + 1 &&\n            qemuDomainHasPCIeRoot(def)) {\n            virDomainDeviceInfo info = {\n                .pciConnectFlags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                                    VIR_PCI_CONNECT_TYPE_PCIE_DEVICE),\n                .pciAddrExtFlags = VIR_PCI_ADDRESS_EXTENSION_NONE\n            };\n\n            /* if there isn't an empty pcie-root-port, this will\n             * cause one to be added\n             */\n            if (qemuDomainPCIAddressReserveNextAddr(addrs, &info) < 0)\n               goto cleanup;\n        }\n\n        /* now reflect any controllers auto-added to addrs into the\n         * domain controllers list\n         */\n        for (i = 1; i < addrs->nbuses; i++) {\n            virDomainDeviceDef dev;\n            int contIndex;\n            virDomainPCIAddressBusPtr bus = &addrs->buses[i];\n\n            if ((rv = virDomainDefMaybeAddController(\n                     def, VIR_DOMAIN_CONTROLLER_TYPE_PCI,\n                     i, bus->model)) < 0)\n                goto cleanup;\n\n            if (rv == 0)\n                continue; /* no new controller added */\n\n            /* We did add a new controller, so we will need one more\n             * address (and we need to set the new controller's\n             * pciConnectFlags)\n             */\n            contIndex = virDomainControllerFind(def,\n                                                VIR_DOMAIN_CONTROLLER_TYPE_PCI,\n                                                i);\n            if (contIndex < 0) {\n                /* this should never happen - we just added it */\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find auto-added %s controller \"\n                                 \"with index %zu\"),\n                               virDomainControllerModelPCITypeToString(bus->model),\n                               i);\n                goto cleanup;\n            }\n            dev.type = VIR_DOMAIN_DEVICE_CONTROLLER;\n            dev.data.controller = def->controllers[contIndex];\n            /* set connect flags so it will be properly addressed */\n            qemuDomainFillDevicePCIConnectFlags(def, &dev, qemuCaps, driver);\n\n            /* Reserve an address for the controller. pci-root and pcie-root\n             * controllers don't plug into any other PCI controller, hence\n             * they should skip this step */\n            if (bus->model != VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT &&\n                bus->model != VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT &&\n                qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                    &dev.data.controller->info) < 0) {\n                goto cleanup;\n            }\n        }\n\n        nbuses = addrs->nbuses;\n        virDomainPCIAddressSetFree(addrs);\n        addrs = NULL;\n    }\n\n    if (!(addrs = qemuDomainPCIAddressSetCreate(def, qemuCaps, nbuses, false)))\n        goto cleanup;\n\n    if (qemuDomainSupportsPCI(def, qemuCaps)) {\n        if (qemuDomainValidateDevicePCISlotsChipsets(def, qemuCaps,\n                                                     addrs) < 0)\n            goto cleanup;\n\n        if (qemuDomainAssignDevicePCISlots(def, qemuCaps, addrs) < 0)\n            goto cleanup;\n\n        if (virDomainDeviceInfoIterate(def, qemuDomainAssignPCIAddressExtension, addrs) < 0)\n            goto cleanup;\n\n        /* set multi attribute for devices at function 0 of\n         * any slot that has multiple functions in use\n         */\n        virDomainPCIAddressSetAllMulti(def);\n\n        for (i = 0; i < def->ncontrollers; i++) {\n            virDomainControllerDefPtr cont = def->controllers[i];\n            int idx = cont->idx;\n            virPCIDeviceAddressPtr addr;\n            virDomainPCIControllerOptsPtr options;\n\n            if (cont->type != VIR_DOMAIN_CONTROLLER_TYPE_PCI)\n                continue;\n\n            addr = &cont->info.addr.pci;\n            options = &cont->opts.pciopts;\n\n            /* set default model name (the actual name of the\n             * device in qemu) for any controller that doesn't yet\n             * have it set.\n             */\n            qemuDomainPCIControllerSetDefaultModelName(cont, def, qemuCaps);\n\n            /* set defaults for any other auto-generated config\n             * options for this controller that haven't been\n             * specified in config.\n             */\n            switch ((virDomainControllerModelPCI)cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n                if (options->chassisNr == -1)\n                    options->chassisNr = cont->idx;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n                if (options->chassis == -1)\n                   options->chassis = cont->idx;\n                if (options->port == -1)\n                   options->port = (addr->slot << 3) + addr->function;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n                if (options->chassis == -1)\n                   options->chassis = cont->idx;\n                if (options->port == -1)\n                   options->port = addr->slot;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n                if (options->busNr == -1)\n                    options->busNr = qemuDomainAddressFindNewBusNr(def);\n                if (options->busNr == -1) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"No free busNr lower than current \"\n                                     \"lowest busNr is available to \"\n                                     \"auto-assign to bus %d. Must be \"\n                                     \"manually assigned\"),\n                                   addr->bus);\n                    goto cleanup;\n                }\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n                if (!qemuDomainIsPSeries(def))\n                    break;\n                if (options->targetIndex == -1) {\n                    if (cont->idx == 0) {\n                        /* The pci-root controller with controller index 0\n                         * must always be assigned target index 0, because\n                         * it represents the implicit PHB which is treated\n                         * differently than all other PHBs */\n                        options->targetIndex = 0;\n                    } else {\n                        /* For all other PHBs the target index doesn't need\n                         * to match the controller index or have any\n                         * particular value, really */\n                        options->targetIndex = qemuDomainAddressFindNewTargetIndex(def);\n                    }\n                }\n                if (options->targetIndex == -1) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"No usable target index found for %d\"),\n                                   addr->bus);\n                    goto cleanup;\n                }\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n                break;\n            }\n\n            /* check if every PCI bridge controller's index is larger than\n             * the bus it is placed onto\n             */\n            if (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE &&\n                idx <= addr->bus) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"PCI controller at index %d (0x%02x) has \"\n                                 \"bus='0x%02x', but index must be \"\n                                 \"larger than bus\"),\n                               idx, idx, addr->bus);\n                goto cleanup;\n            }\n        }\n    }\n\n    if (obj && obj->privateData) {\n        priv = obj->privateData;\n        /* if this is the live domain object, we persist the PCI addresses */\n        priv->pciaddrs = addrs;\n        addrs = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virDomainPCIAddressSetFree(addrs);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignPCIAddresses(virDomainDefPtr def,\n                             virQEMUCapsPtr qemuCaps,\n                             virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    int ret = -1;\n    virDomainPCIAddressSetPtr addrs = NULL;\n    qemuDomainObjPrivatePtr priv = NULL;\n    int max_idx = -1;\n    int nbuses = 0;\n    size_t i;\n    int rv;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI) {\n            if ((int)cont->idx > max_idx)\n                max_idx = cont->idx;\n        }\n    }\n\n    nbuses = max_idx + 1;\n\n    /* set the connect type flags (pci vs. pcie) in the DeviceInfo\n     * of all devices. This will be used to pick an appropriate\n     * bus when assigning addresses.\n     */\n    if (qemuDomainFillAllPCIConnectFlags(def, qemuCaps, driver) < 0)\n        goto cleanup;\n\n    if (qemuDomainFillAllPCIExtensionFlags(def, qemuCaps) < 0)\n        goto cleanup;\n\n    if (qemuDomainSetupIsolationGroups(def) < 0)\n        goto cleanup;\n\n    if (nbuses > 0) {\n        /* 1st pass to figure out how many PCI bridges we need */\n        if (!(addrs = qemuDomainPCIAddressSetCreate(def, qemuCaps, nbuses, true)))\n            goto cleanup;\n\n        if (qemuDomainValidateDevicePCISlotsChipsets(def, qemuCaps,\n                                                     addrs) < 0)\n            goto cleanup;\n\n        /* For domains that have pci-root, reserve 1 extra slot for a\n         * (potential) bridge (for future expansion) only if buses are\n         * not fully reserved yet (if all buses are fully reserved\n         * with manually/previously assigned addresses, any attempt to\n         * reserve an extra slot would fail anyway. But if all buses\n         * are *not* fully reserved, this extra reservation might push\n         * the config to add a new pci-bridge to plug into the final\n         * available slot, thus preserving the ability to expand)\n         *\n         * We only do this for those domains that have pci-root, since\n         * those with pcie-root will usually want to expand using PCIe\n         * controllers, which we will do after assigning addresses for\n         * all *actual* devices.\n         */\n\n        if (qemuDomainHasPCIRoot(def)) {\n            /* This is a dummy info used to reserve a slot for a\n             * legacy PCI device that doesn't exist, but may in the\n             * future, e.g.  if another device is hotplugged into the\n             * domain.\n             */\n            virDomainDeviceInfo info = {\n                .pciConnectFlags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                                    VIR_PCI_CONNECT_TYPE_PCI_DEVICE),\n                .pciAddrExtFlags = VIR_PCI_ADDRESS_EXTENSION_NONE\n            };\n            bool buses_reserved = true;\n\n            for (i = 0; i < addrs->nbuses; i++) {\n                if (!virDomainPCIAddressBusIsFullyReserved(&addrs->buses[i])) {\n                    buses_reserved = false;\n                    break;\n                }\n            }\n            if (!buses_reserved &&\n                qemuDomainPCIAddressReserveNextAddr(addrs, &info) < 0)\n                goto cleanup;\n        }\n\n        if (qemuDomainAssignDevicePCISlots(def, qemuCaps, addrs) < 0)\n            goto cleanup;\n\n        if (virDomainDeviceInfoIterate(def, qemuDomainAssignPCIAddressExtension, addrs) < 0)\n            goto cleanup;\n\n        /* Only for *new* domains with pcie-root (and no other\n         * manually specified PCI controllers in the definition): If,\n         * after assigning addresses/reserving slots for all devices,\n         * we see that any extra buses have been auto-added, we\n         * understand that the application has left management of PCI\n         * addresses and controllers up to libvirt. In order to allow\n         * such applications to easily support hotplug, we will do a\n         * \"one time\" reservation of one extra PCIE|HOTPLUGGABLE\n         * slots, which should cause us to auto-add 1 extra\n         * pcie-root-port. The single slot in this root-port will be\n         * available for hotplug, or may also be used when a device is\n         * added to the config offline.\n         */\n\n        if (max_idx <= 0 &&\n            addrs->nbuses > max_idx + 1 &&\n            qemuDomainHasPCIeRoot(def)) {\n            virDomainDeviceInfo info = {\n                .pciConnectFlags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                                    VIR_PCI_CONNECT_TYPE_PCIE_DEVICE),\n                .pciAddrExtFlags = VIR_PCI_ADDRESS_EXTENSION_NONE\n            };\n\n            /* if there isn't an empty pcie-root-port, this will\n             * cause one to be added\n             */\n            if (qemuDomainPCIAddressReserveNextAddr(addrs, &info) < 0)\n               goto cleanup;\n        }\n\n        /* now reflect any controllers auto-added to addrs into the\n         * domain controllers list\n         */\n        for (i = 1; i < addrs->nbuses; i++) {\n            virDomainDeviceDef dev;\n            int contIndex;\n            virDomainPCIAddressBusPtr bus = &addrs->buses[i];\n\n            if ((rv = virDomainDefMaybeAddController(\n                     def, VIR_DOMAIN_CONTROLLER_TYPE_PCI,\n                     i, bus->model)) < 0)\n                goto cleanup;\n\n            if (rv == 0)\n                continue; /* no new controller added */\n\n            /* We did add a new controller, so we will need one more\n             * address (and we need to set the new controller's\n             * pciConnectFlags)\n             */\n            contIndex = virDomainControllerFind(def,\n                                                VIR_DOMAIN_CONTROLLER_TYPE_PCI,\n                                                i);\n            if (contIndex < 0) {\n                /* this should never happen - we just added it */\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find auto-added %s controller \"\n                                 \"with index %zu\"),\n                               virDomainControllerModelPCITypeToString(bus->model),\n                               i);\n                goto cleanup;\n            }\n            dev.type = VIR_DOMAIN_DEVICE_CONTROLLER;\n            dev.data.controller = def->controllers[contIndex];\n            /* set connect flags so it will be properly addressed */\n            qemuDomainFillDevicePCIConnectFlags(def, &dev, qemuCaps, driver);\n\n            /* Reserve an address for the controller. pci-root and pcie-root\n             * controllers don't plug into any other PCI controller, hence\n             * they should skip this step */\n            if (bus->model != VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT &&\n                bus->model != VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT &&\n                qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                    &dev.data.controller->info) < 0) {\n                goto cleanup;\n            }\n        }\n\n        nbuses = addrs->nbuses;\n        virDomainPCIAddressSetFree(addrs);\n        addrs = NULL;\n    }\n\n    if (!(addrs = qemuDomainPCIAddressSetCreate(def, qemuCaps, nbuses, false)))\n        goto cleanup;\n\n    if (qemuDomainSupportsPCI(def, qemuCaps)) {\n        if (qemuDomainValidateDevicePCISlotsChipsets(def, qemuCaps,\n                                                     addrs) < 0)\n            goto cleanup;\n\n        if (qemuDomainAssignDevicePCISlots(def, qemuCaps, addrs) < 0)\n            goto cleanup;\n\n        if (virDomainDeviceInfoIterate(def, qemuDomainAssignPCIAddressExtension, addrs) < 0)\n            goto cleanup;\n\n        /* set multi attribute for devices at function 0 of\n         * any slot that has multiple functions in use\n         */\n        virDomainPCIAddressSetAllMulti(def);\n\n        for (i = 0; i < def->ncontrollers; i++) {\n            virDomainControllerDefPtr cont = def->controllers[i];\n            int idx = cont->idx;\n            virPCIDeviceAddressPtr addr;\n            virDomainPCIControllerOptsPtr options;\n\n            if (cont->type != VIR_DOMAIN_CONTROLLER_TYPE_PCI)\n                continue;\n\n            addr = &cont->info.addr.pci;\n            options = &cont->opts.pciopts;\n\n            /* set default model name (the actual name of the\n             * device in qemu) for any controller that doesn't yet\n             * have it set.\n             */\n            qemuDomainPCIControllerSetDefaultModelName(cont, def, qemuCaps);\n\n            /* set defaults for any other auto-generated config\n             * options for this controller that haven't been\n             * specified in config.\n             */\n            switch ((virDomainControllerModelPCI)cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n                if (options->chassisNr == -1)\n                    options->chassisNr = cont->idx;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n                if (options->chassis == -1)\n                   options->chassis = cont->idx;\n                if (options->port == -1)\n                   options->port = (addr->slot << 3) + addr->function;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n                if (options->chassis == -1)\n                   options->chassis = cont->idx;\n                if (options->port == -1)\n                   options->port = addr->slot;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n                if (options->busNr == -1)\n                    options->busNr = qemuDomainAddressFindNewBusNr(def);\n                if (options->busNr == -1) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"No free busNr lower than current \"\n                                     \"lowest busNr is available to \"\n                                     \"auto-assign to bus %d. Must be \"\n                                     \"manually assigned\"),\n                                   addr->bus);\n                    goto cleanup;\n                }\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n                if (!qemuDomainIsPSeries(def))\n                    break;\n                if (options->targetIndex == -1) {\n                    if (cont->idx == 0) {\n                        /* The pci-root controller with controller index 0\n                         * must always be assigned target index 0, because\n                         * it represents the implicit PHB which is treated\n                         * differently than all other PHBs */\n                        options->targetIndex = 0;\n                    } else {\n                        /* For all other PHBs the target index doesn't need\n                         * to match the controller index or have any\n                         * particular value, really */\n                        options->targetIndex = qemuDomainAddressFindNewTargetIndex(def);\n                    }\n                }\n                if (options->targetIndex == -1) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"No usable target index found for %d\"),\n                                   addr->bus);\n                    goto cleanup;\n                }\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n                break;\n            }\n\n            /* check if every PCI bridge controller's index is larger than\n             * the bus it is placed onto\n             */\n            if (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE &&\n                idx <= addr->bus) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"PCI controller at index %d (0x%02x) has \"\n                                 \"bus='0x%02x', but index must be \"\n                                 \"larger than bus\"),\n                               idx, idx, addr->bus);\n                goto cleanup;\n            }\n        }\n    }\n\n    if (obj && obj->privateData) {\n        priv = obj->privateData;\n        /* if this is the live domain object, we persist the PCI addresses */\n        priv->pciaddrs = addrs;\n        addrs = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virDomainPCIAddressSetFree(addrs);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainAssignVirtioMMIOAddresses",
          "args": [
            "def",
            "qemuCaps"
          ],
          "line": 3197
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainAssignVirtioMMIOAddresses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "467-498",
          "snippet": "static void\nqemuDomainAssignVirtioMMIOAddresses(virDomainDefPtr def,\n                                    virQEMUCapsPtr qemuCaps)\n{\n    if (def->os.arch != VIR_ARCH_ARMV6L &&\n        def->os.arch != VIR_ARCH_ARMV7L &&\n        def->os.arch != VIR_ARCH_AARCH64 &&\n        !ARCH_IS_RISCV(def->os.arch)) {\n        return;\n    }\n\n    if (!(STRPREFIX(def->os.machine, \"vexpress-\") ||\n          qemuDomainIsARMVirt(def) ||\n          qemuDomainIsRISCVVirt(def))) {\n        return;\n    }\n\n    /* We use virtio-mmio by default on virt guests only if they already\n     * have at least one virtio-mmio device: in all other cases, assuming\n     * the QEMU binary supports all necessary capabilities (PCIe Root plus\n     * some kind of PCIe Root Port), we prefer virtio-pci */\n    if (qemuDomainHasPCIeRoot(def) &&\n        (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_PCIE_ROOT_PORT) ||\n         virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_IOH3420)) &&\n        !qemuDomainHasVirtioMMIODevices(def)) {\n        qemuDomainPrimeVirtioDeviceAddresses(def,\n                                             VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI);\n    } else if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIRTIO_MMIO)) {\n        qemuDomainPrimeVirtioDeviceAddresses(def,\n                                             VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_MMIO);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic void\nqemuDomainAssignVirtioMMIOAddresses(virDomainDefPtr def,\n                                    virQEMUCapsPtr qemuCaps)\n{\n    if (def->os.arch != VIR_ARCH_ARMV6L &&\n        def->os.arch != VIR_ARCH_ARMV7L &&\n        def->os.arch != VIR_ARCH_AARCH64 &&\n        !ARCH_IS_RISCV(def->os.arch)) {\n        return;\n    }\n\n    if (!(STRPREFIX(def->os.machine, \"vexpress-\") ||\n          qemuDomainIsARMVirt(def) ||\n          qemuDomainIsRISCVVirt(def))) {\n        return;\n    }\n\n    /* We use virtio-mmio by default on virt guests only if they already\n     * have at least one virtio-mmio device: in all other cases, assuming\n     * the QEMU binary supports all necessary capabilities (PCIe Root plus\n     * some kind of PCIe Root Port), we prefer virtio-pci */\n    if (qemuDomainHasPCIeRoot(def) &&\n        (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_PCIE_ROOT_PORT) ||\n         virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_IOH3420)) &&\n        !qemuDomainHasVirtioMMIODevices(def)) {\n        qemuDomainPrimeVirtioDeviceAddresses(def,\n                                             VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI);\n    } else if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIRTIO_MMIO)) {\n        qemuDomainPrimeVirtioDeviceAddresses(def,\n                                             VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_MMIO);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainAssignS390Addresses",
          "args": [
            "def",
            "qemuCaps"
          ],
          "line": 3194
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainAssignS390Addresses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "396-426",
          "snippet": "static int\nqemuDomainAssignS390Addresses(virDomainDefPtr def,\n                              virQEMUCapsPtr qemuCaps)\n{\n    int ret = -1;\n    virDomainCCWAddressSetPtr addrs = NULL;\n\n    if (qemuDomainIsS390CCW(def) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_CCW)) {\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VFIO_CCW))\n            qemuDomainPrimeVfioDeviceAddresses(\n                def, VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW);\n        qemuDomainPrimeVirtioDeviceAddresses(\n            def, VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW);\n\n        if (!(addrs = virDomainCCWAddressSetCreateFromDomain(def)))\n            goto cleanup;\n\n    } else if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_S390)) {\n        /* deal with legacy virtio-s390 */\n        qemuDomainPrimeVirtioDeviceAddresses(\n            def, VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_S390);\n    }\n\n    ret = 0;\n\n cleanup:\n    virDomainCCWAddressSetFree(addrs);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignS390Addresses(virDomainDefPtr def,\n                              virQEMUCapsPtr qemuCaps)\n{\n    int ret = -1;\n    virDomainCCWAddressSetPtr addrs = NULL;\n\n    if (qemuDomainIsS390CCW(def) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_CCW)) {\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VFIO_CCW))\n            qemuDomainPrimeVfioDeviceAddresses(\n                def, VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW);\n        qemuDomainPrimeVirtioDeviceAddresses(\n            def, VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW);\n\n        if (!(addrs = virDomainCCWAddressSetCreateFromDomain(def)))\n            goto cleanup;\n\n    } else if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_S390)) {\n        /* deal with legacy virtio-s390 */\n        qemuDomainPrimeVirtioDeviceAddresses(\n            def, VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_S390);\n    }\n\n    ret = 0;\n\n cleanup:\n    virDomainCCWAddressSetFree(addrs);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainAssignSpaprVIOAddresses",
          "args": [
            "def"
          ],
          "line": 3191
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainAssignSpaprVIOAddresses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "223-282",
          "snippet": "static int\nqemuDomainAssignSpaprVIOAddresses(virDomainDefPtr def)\n{\n    size_t i;\n\n    /* Default values match QEMU. See spapr_(llan|vscsi|vty).c */\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_SPAPR_VLAN)\n            net->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n\n        if (qemuDomainAssignSpaprVIOAddress(def, &net->info, VIO_ADDR_NET) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI &&\n            cont->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI) {\n            cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n        }\n        if (qemuDomainAssignSpaprVIOAddress(def, &cont->info,\n                                            VIO_ADDR_SCSI) < 0) {\n            return -1;\n        }\n    }\n\n    for (i = 0; i < def->nserials; i++) {\n        if (def->serials[i]->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL &&\n            def->serials[i]->targetType == VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SPAPR_VIO) {\n            def->serials[i]->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n        }\n        if (qemuDomainAssignSpaprVIOAddress(def, &def->serials[i]->info,\n                                            VIO_ADDR_SERIAL) < 0)\n            return -1;\n    }\n\n    if (def->nvram) {\n        if (qemuDomainIsPSeries(def))\n            def->nvram->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n        if (qemuDomainAssignSpaprVIOAddress(def, &def->nvram->info,\n                                            VIO_ADDR_NVRAM) < 0)\n            return -1;\n    }\n\n    if (def->tpm) {\n        if (qemuDomainIsPSeries(def))\n            def->tpm->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n        if (qemuDomainAssignSpaprVIOAddress(def, &def->tpm->info,\n                                            VIO_ADDR_TPM) < 0)\n            return -1;\n    }\n\n    /* No other devices are currently supported on spapr-vio */\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIO_ADDR_TPM 0x4000ul",
            "#define VIO_ADDR_NVRAM 0x3000ul",
            "#define VIO_ADDR_SERIAL 0x30000000ul",
            "#define VIO_ADDR_SCSI 0x2000ul",
            "#define VIO_ADDR_NET 0x1000ul"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\n#define VIO_ADDR_TPM 0x4000ul\n#define VIO_ADDR_NVRAM 0x3000ul\n#define VIO_ADDR_SERIAL 0x30000000ul\n#define VIO_ADDR_SCSI 0x2000ul\n#define VIO_ADDR_NET 0x1000ul\n\nstatic int\nqemuDomainAssignSpaprVIOAddresses(virDomainDefPtr def)\n{\n    size_t i;\n\n    /* Default values match QEMU. See spapr_(llan|vscsi|vty).c */\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_SPAPR_VLAN)\n            net->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n\n        if (qemuDomainAssignSpaprVIOAddress(def, &net->info, VIO_ADDR_NET) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI &&\n            cont->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI) {\n            cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n        }\n        if (qemuDomainAssignSpaprVIOAddress(def, &cont->info,\n                                            VIO_ADDR_SCSI) < 0) {\n            return -1;\n        }\n    }\n\n    for (i = 0; i < def->nserials; i++) {\n        if (def->serials[i]->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL &&\n            def->serials[i]->targetType == VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SPAPR_VIO) {\n            def->serials[i]->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n        }\n        if (qemuDomainAssignSpaprVIOAddress(def, &def->serials[i]->info,\n                                            VIO_ADDR_SERIAL) < 0)\n            return -1;\n    }\n\n    if (def->nvram) {\n        if (qemuDomainIsPSeries(def))\n            def->nvram->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n        if (qemuDomainAssignSpaprVIOAddress(def, &def->nvram->info,\n                                            VIO_ADDR_NVRAM) < 0)\n            return -1;\n    }\n\n    if (def->tpm) {\n        if (qemuDomainIsPSeries(def))\n            def->tpm->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n        if (qemuDomainAssignSpaprVIOAddress(def, &def->tpm->info,\n                                            VIO_ADDR_TPM) < 0)\n            return -1;\n    }\n\n    /* No other devices are currently supported on spapr-vio */\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainAssignVirtioSerialAddresses",
          "args": [
            "def"
          ],
          "line": 3188
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainAssignVirtioSerialAddresses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "126-163",
          "snippet": "static int\nqemuDomainAssignVirtioSerialAddresses(virDomainDefPtr def)\n{\n    int ret = -1;\n    size_t i;\n    virDomainVirtioSerialAddrSetPtr addrs = NULL;\n\n    if (!(addrs = virDomainVirtioSerialAddrSetCreateFromDomain(def)))\n        goto cleanup;\n\n    VIR_DEBUG(\"Finished reserving existing ports\");\n\n    for (i = 0; i < def->nconsoles; i++) {\n        virDomainChrDefPtr chr = def->consoles[i];\n        if (chr->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE &&\n            chr->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_VIRTIO &&\n            !virDomainVirtioSerialAddrIsComplete(&chr->info) &&\n            virDomainVirtioSerialAddrAutoAssignFromCache(def, addrs,\n                                                         &chr->info, true) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < def->nchannels; i++) {\n        virDomainChrDefPtr chr = def->channels[i];\n        if (chr->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL &&\n            chr->targetType == VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO &&\n            !virDomainVirtioSerialAddrIsComplete(&chr->info) &&\n            virDomainVirtioSerialAddrAutoAssignFromCache(def, addrs,\n                                                         &chr->info, false) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virDomainVirtioSerialAddrSetFree(addrs);\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignVirtioSerialAddresses(virDomainDefPtr def)\n{\n    int ret = -1;\n    size_t i;\n    virDomainVirtioSerialAddrSetPtr addrs = NULL;\n\n    if (!(addrs = virDomainVirtioSerialAddrSetCreateFromDomain(def)))\n        goto cleanup;\n\n    VIR_DEBUG(\"Finished reserving existing ports\");\n\n    for (i = 0; i < def->nconsoles; i++) {\n        virDomainChrDefPtr chr = def->consoles[i];\n        if (chr->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE &&\n            chr->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_VIRTIO &&\n            !virDomainVirtioSerialAddrIsComplete(&chr->info) &&\n            virDomainVirtioSerialAddrAutoAssignFromCache(def, addrs,\n                                                         &chr->info, true) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < def->nchannels; i++) {\n        virDomainChrDefPtr chr = def->channels[i];\n        if (chr->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL &&\n            chr->targetType == VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO &&\n            !virDomainVirtioSerialAddrIsComplete(&chr->info) &&\n            virDomainVirtioSerialAddrAutoAssignFromCache(def, addrs,\n                                                         &chr->info, false) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virDomainVirtioSerialAddrSetFree(addrs);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nint\nqemuDomainAssignAddresses(virDomainDefPtr def,\n                          virQEMUCapsPtr qemuCaps,\n                          virQEMUDriverPtr driver,\n                          virDomainObjPtr obj,\n                          bool newDomain)\n{\n    if (qemuDomainAssignVirtioSerialAddresses(def) < 0)\n        return -1;\n\n    if (qemuDomainAssignSpaprVIOAddresses(def) < 0)\n        return -1;\n\n    if (qemuDomainAssignS390Addresses(def, qemuCaps) < 0)\n        return -1;\n\n    qemuDomainAssignVirtioMMIOAddresses(def, qemuCaps);\n\n    if (qemuDomainAssignPCIAddresses(def, qemuCaps, driver, obj) < 0)\n        return -1;\n\n    if (qemuDomainAssignUSBAddresses(def, obj, newDomain) < 0)\n        return -1;\n\n    if (qemuDomainAssignMemorySlots(def) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainAssignUSBAddresses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "3125-3178",
    "snippet": "static int\nqemuDomainAssignUSBAddresses(virDomainDefPtr def,\n                             virDomainObjPtr obj,\n                             bool newDomain)\n{\n    int ret = -1;\n    virDomainUSBAddressSetPtr addrs = NULL;\n    qemuDomainObjPrivatePtr priv = NULL;\n\n    if (!newDomain) {\n        /* only create the address cache for:\n         *  new domains\n         *  domains that already have all the addresses specified\n         * otherwise libvirt's attempt to recreate the USB topology via\n         * QEMU command line might fail */\n        if (virDomainUSBDeviceDefForeach(def, virDomainUSBAddressPresent, NULL,\n                                         false) < 0)\n            return 0;\n    }\n\n    if (!(addrs = virDomainUSBAddressSetCreate()))\n        goto cleanup;\n\n    if (qemuDomainUSBAddressAddHubs(def) < 0)\n        goto cleanup;\n\n    if (virDomainUSBAddressSetAddControllers(addrs, def) < 0)\n        goto cleanup;\n\n    if (virDomainUSBDeviceDefForeach(def, virDomainUSBAddressReserve, addrs,\n                                     true) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Existing USB addresses have been reserved\");\n\n    if (qemuDomainAssignUSBHubs(addrs, def) < 0)\n        goto cleanup;\n\n    if (qemuDomainAssignUSBPorts(addrs, def) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Finished assigning USB ports\");\n\n    if (obj && obj->privateData) {\n        priv = obj->privateData;\n        priv->usbaddrs = addrs;\n        addrs = NULL;\n    }\n    ret = 0;\n\n cleanup:\n    virDomainUSBAddressSetFree(addrs);\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainUSBAddressSetFree",
          "args": [
            "addrs"
          ],
          "line": 3176
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressSetFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1987-1999",
          "snippet": "void\nvirDomainUSBAddressSetFree(virDomainUSBAddressSetPtr addrs)\n{\n    size_t i;\n\n    if (!addrs)\n        return;\n\n    for (i = 0; i < addrs->nbuses; i++)\n        virDomainUSBAddressHubFree(addrs->buses[i]);\n    VIR_FREE(addrs->buses);\n    VIR_FREE(addrs);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainUSBAddressSetFree(virDomainUSBAddressSetPtr addrs)\n{\n    size_t i;\n\n    if (!addrs)\n        return;\n\n    for (i = 0; i < addrs->nbuses; i++)\n        virDomainUSBAddressHubFree(addrs->buses[i]);\n    VIR_FREE(addrs->buses);\n    VIR_FREE(addrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Finished assigning USB ports\""
          ],
          "line": 3166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainAssignUSBPorts",
          "args": [
            "addrs",
            "def"
          ],
          "line": 3163
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainAssignUSBPortsCounter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "2980-2988",
          "snippet": "static int\nqemuDomainAssignUSBPortsCounter(virDomainDeviceInfoPtr info G_GNUC_UNUSED,\n                                void *opaque)\n{\n    struct qemuAssignUSBIteratorInfo *data = opaque;\n\n    data->count++;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignUSBPortsCounter(virDomainDeviceInfoPtr info G_GNUC_UNUSED,\n                                void *opaque)\n{\n    struct qemuAssignUSBIteratorInfo *data = opaque;\n\n    data->count++;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainAssignUSBHubs",
          "args": [
            "addrs",
            "def"
          ],
          "line": 3160
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainAssignUSBHubs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "2942-2964",
          "snippet": "static int\nqemuDomainAssignUSBHubs(virDomainUSBAddressSetPtr addrs,\n                        virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nhubs; i++) {\n        virDomainHubDefPtr hub = def->hubs[i];\n        if (hub->type != VIR_DOMAIN_HUB_TYPE_USB)\n            continue;\n\n        if (hub->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB &&\n            virDomainUSBAddressPortIsValid(hub->info.addr.usb.port))\n            continue;\n        if (virDomainUSBAddressAssign(addrs, &hub->info) < 0)\n            return -1;\n\n        if (virDomainUSBAddressSetAddHub(addrs, hub) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignUSBHubs(virDomainUSBAddressSetPtr addrs,\n                        virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nhubs; i++) {\n        virDomainHubDefPtr hub = def->hubs[i];\n        if (hub->type != VIR_DOMAIN_HUB_TYPE_USB)\n            continue;\n\n        if (hub->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB &&\n            virDomainUSBAddressPortIsValid(hub->info.addr.usb.port))\n            continue;\n        if (virDomainUSBAddressAssign(addrs, &hub->info) < 0)\n            return -1;\n\n        if (virDomainUSBAddressSetAddHub(addrs, hub) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Existing USB addresses have been reserved\""
          ],
          "line": 3158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainUSBDeviceDefForeach",
          "args": [
            "def",
            "virDomainUSBAddressReserve",
            "addrs",
            "true"
          ],
          "line": 3154
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBDeviceDefForeach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29912-29998",
          "snippet": "int\nvirDomainUSBDeviceDefForeach(virDomainDefPtr def,\n                             virDomainUSBDeviceDefIterator iter,\n                             void *opaque,\n                             bool skipHubs)\n{\n    size_t i;\n\n    /* usb-hub */\n    if (!skipHubs) {\n        for (i = 0; i < def->nhubs; i++) {\n            virDomainHubDefPtr hub = def->hubs[i];\n            if (hub->type == VIR_DOMAIN_HUB_TYPE_USB) {\n                if (iter(&hub->info, opaque) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    /* usb-host */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = def->hostdevs[i];\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n            if (iter(hostdev->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-storage */\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n        if (disk->bus == VIR_DOMAIN_DISK_BUS_USB) {\n            if (iter(&disk->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* TODO: add def->nets here when libvirt starts supporting usb-net */\n\n    /* usb-ccid */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_CCID) {\n            if (iter(&cont->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-kbd, usb-mouse, usb-tablet */\n    for (i = 0; i < def->ninputs; i++) {\n        virDomainInputDefPtr input = def->inputs[i];\n\n        if (input->bus == VIR_DOMAIN_INPUT_BUS_USB) {\n            if (iter(&input->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-serial */\n    for (i = 0; i < def->nserials; i++) {\n        virDomainChrDefPtr serial = def->serials[i];\n        if (serial->targetType == VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_USB) {\n            if (iter(&serial->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-audio model=usb */\n    for (i = 0; i < def->nsounds; i++) {\n        virDomainSoundDefPtr sound = def->sounds[i];\n        if (sound->model == VIR_DOMAIN_SOUND_MODEL_USB) {\n            if (iter(&sound->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-redir */\n    for (i = 0; i < def->nredirdevs; i++) {\n        virDomainRedirdevDefPtr redirdev = def->redirdevs[i];\n        if (redirdev->bus == VIR_DOMAIN_REDIRDEV_BUS_USB) {\n            if (iter(&redirdev->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainUSBDeviceDefForeach(virDomainDefPtr def,\n                             virDomainUSBDeviceDefIterator iter,\n                             void *opaque,\n                             bool skipHubs)\n{\n    size_t i;\n\n    /* usb-hub */\n    if (!skipHubs) {\n        for (i = 0; i < def->nhubs; i++) {\n            virDomainHubDefPtr hub = def->hubs[i];\n            if (hub->type == VIR_DOMAIN_HUB_TYPE_USB) {\n                if (iter(&hub->info, opaque) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    /* usb-host */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = def->hostdevs[i];\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n            if (iter(hostdev->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-storage */\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n        if (disk->bus == VIR_DOMAIN_DISK_BUS_USB) {\n            if (iter(&disk->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* TODO: add def->nets here when libvirt starts supporting usb-net */\n\n    /* usb-ccid */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_CCID) {\n            if (iter(&cont->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-kbd, usb-mouse, usb-tablet */\n    for (i = 0; i < def->ninputs; i++) {\n        virDomainInputDefPtr input = def->inputs[i];\n\n        if (input->bus == VIR_DOMAIN_INPUT_BUS_USB) {\n            if (iter(&input->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-serial */\n    for (i = 0; i < def->nserials; i++) {\n        virDomainChrDefPtr serial = def->serials[i];\n        if (serial->targetType == VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_USB) {\n            if (iter(&serial->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-audio model=usb */\n    for (i = 0; i < def->nsounds; i++) {\n        virDomainSoundDefPtr sound = def->sounds[i];\n        if (sound->model == VIR_DOMAIN_SOUND_MODEL_USB) {\n            if (iter(&sound->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-redir */\n    for (i = 0; i < def->nredirdevs; i++) {\n        virDomainRedirdevDefPtr redirdev = def->redirdevs[i];\n        if (redirdev->bus == VIR_DOMAIN_REDIRDEV_BUS_USB) {\n            if (iter(&redirdev->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressSetAddControllers",
          "args": [
            "addrs",
            "def"
          ],
          "line": 3151
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressSetAddControllers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2224-2250",
          "snippet": "int\nvirDomainUSBAddressSetAddControllers(virDomainUSBAddressSetPtr addrs,\n                                     virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB) {\n            if (virDomainUSBAddressSetAddController(addrs, cont) < 0)\n                return -1;\n        }\n    }\n\n    for (i = 0; i < def->nhubs; i++) {\n        virDomainHubDefPtr hub = def->hubs[i];\n        if (hub->type == VIR_DOMAIN_HUB_TYPE_USB &&\n            hub->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB &&\n            virDomainUSBAddressPortIsValid(hub->info.addr.usb.port)) {\n            /* USB hubs that do not yet have an USB address have to be\n             * dealt with later */\n            if (virDomainUSBAddressSetAddHub(addrs, hub) < 0)\n                return -1;\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainUSBAddressSetAddControllers(virDomainUSBAddressSetPtr addrs,\n                                     virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB) {\n            if (virDomainUSBAddressSetAddController(addrs, cont) < 0)\n                return -1;\n        }\n    }\n\n    for (i = 0; i < def->nhubs; i++) {\n        virDomainHubDefPtr hub = def->hubs[i];\n        if (hub->type == VIR_DOMAIN_HUB_TYPE_USB &&\n            hub->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB &&\n            virDomainUSBAddressPortIsValid(hub->info.addr.usb.port)) {\n            /* USB hubs that do not yet have an USB address have to be\n             * dealt with later */\n            if (virDomainUSBAddressSetAddHub(addrs, hub) < 0)\n                return -1;\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainUSBAddressAddHubs",
          "args": [
            "def"
          ],
          "line": 3148
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainUSBAddressAddHubs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "2991-3034",
          "snippet": "static int\nqemuDomainUSBAddressAddHubs(virDomainDefPtr def)\n{\n    struct qemuAssignUSBIteratorInfo data = { .count = 0 };\n    virDomainHubDefPtr hub = NULL;\n    size_t available_ports;\n    size_t hubs_needed = 0;\n    int ret = -1;\n    size_t i;\n\n    available_ports = virDomainUSBAddressCountAllPorts(def);\n    ignore_value(virDomainUSBDeviceDefForeach(def,\n                                              qemuDomainAssignUSBPortsCounter,\n                                              &data,\n                                              false));\n\n    if (data.count > 0 && !virDomainDefHasUSB(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"USB is disabled for this domain, but USB devices \"\n                         \"are present in the domain XML\"));\n        return -1;\n    }\n\n    if (data.count > available_ports)\n        hubs_needed = VIR_DIV_UP(data.count - available_ports + 1,\n                                 VIR_DOMAIN_USB_HUB_PORTS - 1);\n\n    VIR_DEBUG(\"Found %zu USB devices and %zu provided USB ports; adding %zu hubs\",\n              data.count, available_ports, hubs_needed);\n\n    for (i = 0; i < hubs_needed; i++) {\n        if (VIR_ALLOC(hub) < 0)\n            return -1;\n        hub->type = VIR_DOMAIN_HUB_TYPE_USB;\n\n        if (VIR_APPEND_ELEMENT(def->hubs, def->nhubs, hub) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(hub);\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainUSBAddressAddHubs(virDomainDefPtr def)\n{\n    struct qemuAssignUSBIteratorInfo data = { .count = 0 };\n    virDomainHubDefPtr hub = NULL;\n    size_t available_ports;\n    size_t hubs_needed = 0;\n    int ret = -1;\n    size_t i;\n\n    available_ports = virDomainUSBAddressCountAllPorts(def);\n    ignore_value(virDomainUSBDeviceDefForeach(def,\n                                              qemuDomainAssignUSBPortsCounter,\n                                              &data,\n                                              false));\n\n    if (data.count > 0 && !virDomainDefHasUSB(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"USB is disabled for this domain, but USB devices \"\n                         \"are present in the domain XML\"));\n        return -1;\n    }\n\n    if (data.count > available_ports)\n        hubs_needed = VIR_DIV_UP(data.count - available_ports + 1,\n                                 VIR_DOMAIN_USB_HUB_PORTS - 1);\n\n    VIR_DEBUG(\"Found %zu USB devices and %zu provided USB ports; adding %zu hubs\",\n              data.count, available_ports, hubs_needed);\n\n    for (i = 0; i < hubs_needed; i++) {\n        if (VIR_ALLOC(hub) < 0)\n            return -1;\n        hub->type = VIR_DOMAIN_HUB_TYPE_USB;\n\n        if (VIR_APPEND_ELEMENT(def->hubs, def->nhubs, hub) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(hub);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressSetCreate",
          "args": [],
          "line": 3145
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressSetCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1959-1968",
          "snippet": "virDomainUSBAddressSetPtr\nvirDomainUSBAddressSetCreate(void)\n{\n    virDomainUSBAddressSetPtr addrs;\n\n    if (VIR_ALLOC(addrs) < 0)\n        return NULL;\n\n    return addrs;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvirDomainUSBAddressSetPtr\nvirDomainUSBAddressSetCreate(void)\n{\n    virDomainUSBAddressSetPtr addrs;\n\n    if (VIR_ALLOC(addrs) < 0)\n        return NULL;\n\n    return addrs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignUSBAddresses(virDomainDefPtr def,\n                             virDomainObjPtr obj,\n                             bool newDomain)\n{\n    int ret = -1;\n    virDomainUSBAddressSetPtr addrs = NULL;\n    qemuDomainObjPrivatePtr priv = NULL;\n\n    if (!newDomain) {\n        /* only create the address cache for:\n         *  new domains\n         *  domains that already have all the addresses specified\n         * otherwise libvirt's attempt to recreate the USB topology via\n         * QEMU command line might fail */\n        if (virDomainUSBDeviceDefForeach(def, virDomainUSBAddressPresent, NULL,\n                                         false) < 0)\n            return 0;\n    }\n\n    if (!(addrs = virDomainUSBAddressSetCreate()))\n        goto cleanup;\n\n    if (qemuDomainUSBAddressAddHubs(def) < 0)\n        goto cleanup;\n\n    if (virDomainUSBAddressSetAddControllers(addrs, def) < 0)\n        goto cleanup;\n\n    if (virDomainUSBDeviceDefForeach(def, virDomainUSBAddressReserve, addrs,\n                                     true) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Existing USB addresses have been reserved\");\n\n    if (qemuDomainAssignUSBHubs(addrs, def) < 0)\n        goto cleanup;\n\n    if (qemuDomainAssignUSBPorts(addrs, def) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Finished assigning USB ports\");\n\n    if (obj && obj->privateData) {\n        priv = obj->privateData;\n        priv->usbaddrs = addrs;\n        addrs = NULL;\n    }\n    ret = 0;\n\n cleanup:\n    virDomainUSBAddressSetFree(addrs);\n    return ret;\n}"
  },
  {
    "function_name": "qemuDomainAssignMemorySlots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "3098-3122",
    "snippet": "static int\nqemuDomainAssignMemorySlots(virDomainDefPtr def)\n{\n    virBitmapPtr slotmap = NULL;\n    int ret = -1;\n    size_t i;\n\n    if (!virDomainDefHasMemoryHotplug(def))\n        return 0;\n\n    if (!(slotmap = qemuDomainGetMemorySlotMap(def)))\n        return -1;\n\n    for (i = 0; i < def->nmems; i++) {\n        if (qemuAssignMemoryDeviceSlot(def->mems[i], slotmap) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virBitmapFree(slotmap);\n    return ret;\n\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "slotmap"
          ],
          "line": 3119
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuAssignMemoryDeviceSlot",
          "args": [
            "def->mems[i]",
            "slotmap"
          ],
          "line": 3112
        },
        "resolved": true,
        "details": {
          "function_name": "qemuAssignMemoryDeviceSlot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "3058-3078",
          "snippet": "static int\nqemuAssignMemoryDeviceSlot(virDomainMemoryDefPtr mem,\n                           virBitmapPtr slotmap)\n{\n    ssize_t nextslot = -1;\n\n    if (mem->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM)\n        return 0;\n\n    if ((nextslot = virBitmapNextClearBit(slotmap, -1)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to find an empty memory slot\"));\n        return -1;\n    }\n\n    ignore_value(virBitmapSetBit(slotmap, nextslot));\n    mem->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM;\n    mem->info.addr.dimm.slot = nextslot;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuAssignMemoryDeviceSlot(virDomainMemoryDefPtr mem,\n                           virBitmapPtr slotmap)\n{\n    ssize_t nextslot = -1;\n\n    if (mem->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM)\n        return 0;\n\n    if ((nextslot = virBitmapNextClearBit(slotmap, -1)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to find an empty memory slot\"));\n        return -1;\n    }\n\n    ignore_value(virBitmapSetBit(slotmap, nextslot));\n    mem->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM;\n    mem->info.addr.dimm.slot = nextslot;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainGetMemorySlotMap",
          "args": [
            "def"
          ],
          "line": 3108
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainGetMemorySlotMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "3037-3055",
          "snippet": "static virBitmapPtr\nqemuDomainGetMemorySlotMap(const virDomainDef *def)\n{\n    virBitmapPtr ret;\n    virDomainMemoryDefPtr mem;\n    size_t i;\n\n    if (!(ret = virBitmapNew(def->mem.memory_slots)))\n        return NULL;\n\n    for (i = 0; i < def->nmems; i++) {\n        mem = def->mems[i];\n\n        if (mem->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM)\n            ignore_value(virBitmapSetBit(ret, mem->info.addr.dimm.slot));\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic virBitmapPtr\nqemuDomainGetMemorySlotMap(const virDomainDef *def)\n{\n    virBitmapPtr ret;\n    virDomainMemoryDefPtr mem;\n    size_t i;\n\n    if (!(ret = virBitmapNew(def->mem.memory_slots)))\n        return NULL;\n\n    for (i = 0; i < def->nmems; i++) {\n        mem = def->mems[i];\n\n        if (mem->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM)\n            ignore_value(virBitmapSetBit(ret, mem->info.addr.dimm.slot));\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefHasMemoryHotplug",
          "args": [
            "def"
          ],
          "line": 3105
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefHasMemoryHotplug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10896-10900",
          "snippet": "bool\nvirDomainDefHasMemoryHotplug(const virDomainDef *def)\n{\n    return def->mem.memory_slots > 0 || def->mem.max_memory > 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainDefHasMemoryHotplug(const virDomainDef *def)\n{\n    return def->mem.memory_slots > 0 || def->mem.max_memory > 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignMemorySlots(virDomainDefPtr def)\n{\n    virBitmapPtr slotmap = NULL;\n    int ret = -1;\n    size_t i;\n\n    if (!virDomainDefHasMemoryHotplug(def))\n        return 0;\n\n    if (!(slotmap = qemuDomainGetMemorySlotMap(def)))\n        return -1;\n\n    for (i = 0; i < def->nmems; i++) {\n        if (qemuAssignMemoryDeviceSlot(def->mems[i], slotmap) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virBitmapFree(slotmap);\n    return ret;\n\n}"
  },
  {
    "function_name": "qemuDomainAssignMemoryDeviceSlot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "3081-3095",
    "snippet": "int\nqemuDomainAssignMemoryDeviceSlot(virDomainDefPtr def,\n                                 virDomainMemoryDefPtr mem)\n{\n    virBitmapPtr slotmap = NULL;\n    int ret;\n\n    if (!(slotmap = qemuDomainGetMemorySlotMap(def)))\n        return -1;\n\n    ret = qemuAssignMemoryDeviceSlot(mem, slotmap);\n\n    virBitmapFree(slotmap);\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "slotmap"
          ],
          "line": 3093
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuAssignMemoryDeviceSlot",
          "args": [
            "mem",
            "slotmap"
          ],
          "line": 3091
        },
        "resolved": true,
        "details": {
          "function_name": "qemuAssignMemoryDeviceSlot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "3058-3078",
          "snippet": "static int\nqemuAssignMemoryDeviceSlot(virDomainMemoryDefPtr mem,\n                           virBitmapPtr slotmap)\n{\n    ssize_t nextslot = -1;\n\n    if (mem->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM)\n        return 0;\n\n    if ((nextslot = virBitmapNextClearBit(slotmap, -1)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to find an empty memory slot\"));\n        return -1;\n    }\n\n    ignore_value(virBitmapSetBit(slotmap, nextslot));\n    mem->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM;\n    mem->info.addr.dimm.slot = nextslot;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuAssignMemoryDeviceSlot(virDomainMemoryDefPtr mem,\n                           virBitmapPtr slotmap)\n{\n    ssize_t nextslot = -1;\n\n    if (mem->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM)\n        return 0;\n\n    if ((nextslot = virBitmapNextClearBit(slotmap, -1)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to find an empty memory slot\"));\n        return -1;\n    }\n\n    ignore_value(virBitmapSetBit(slotmap, nextslot));\n    mem->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM;\n    mem->info.addr.dimm.slot = nextslot;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainGetMemorySlotMap",
          "args": [
            "def"
          ],
          "line": 3088
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainGetMemorySlotMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "3037-3055",
          "snippet": "static virBitmapPtr\nqemuDomainGetMemorySlotMap(const virDomainDef *def)\n{\n    virBitmapPtr ret;\n    virDomainMemoryDefPtr mem;\n    size_t i;\n\n    if (!(ret = virBitmapNew(def->mem.memory_slots)))\n        return NULL;\n\n    for (i = 0; i < def->nmems; i++) {\n        mem = def->mems[i];\n\n        if (mem->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM)\n            ignore_value(virBitmapSetBit(ret, mem->info.addr.dimm.slot));\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic virBitmapPtr\nqemuDomainGetMemorySlotMap(const virDomainDef *def)\n{\n    virBitmapPtr ret;\n    virDomainMemoryDefPtr mem;\n    size_t i;\n\n    if (!(ret = virBitmapNew(def->mem.memory_slots)))\n        return NULL;\n\n    for (i = 0; i < def->nmems; i++) {\n        mem = def->mems[i];\n\n        if (mem->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM)\n            ignore_value(virBitmapSetBit(ret, mem->info.addr.dimm.slot));\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nint\nqemuDomainAssignMemoryDeviceSlot(virDomainDefPtr def,\n                                 virDomainMemoryDefPtr mem)\n{\n    virBitmapPtr slotmap = NULL;\n    int ret;\n\n    if (!(slotmap = qemuDomainGetMemorySlotMap(def)))\n        return -1;\n\n    ret = qemuAssignMemoryDeviceSlot(mem, slotmap);\n\n    virBitmapFree(slotmap);\n    return ret;\n}"
  },
  {
    "function_name": "qemuAssignMemoryDeviceSlot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "3058-3078",
    "snippet": "static int\nqemuAssignMemoryDeviceSlot(virDomainMemoryDefPtr mem,\n                           virBitmapPtr slotmap)\n{\n    ssize_t nextslot = -1;\n\n    if (mem->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM)\n        return 0;\n\n    if ((nextslot = virBitmapNextClearBit(slotmap, -1)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to find an empty memory slot\"));\n        return -1;\n    }\n\n    ignore_value(virBitmapSetBit(slotmap, nextslot));\n    mem->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM;\n    mem->info.addr.dimm.slot = nextslot;\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(slotmap, nextslot)"
          ],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "slotmap",
            "nextslot"
          ],
          "line": 3073
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to find an empty memory slot\")"
          ],
          "line": 3068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to find an empty memory slot\""
          ],
          "line": 3069
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNextClearBit",
          "args": [
            "slotmap",
            "-1"
          ],
          "line": 3067
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNextClearBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1078-1113",
          "snippet": "ssize_t\nvirBitmapNextClearBit(virBitmapPtr bitmap,\n                      ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = ~bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = ~bitmap->map[nl];\n\n    if (nl == bitmap->map_len - 1) {\n        /* Ensure tail bits are ignored.  */\n        int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n        if (tail)\n            bits &= -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n    }\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapNextClearBit(virBitmapPtr bitmap,\n                      ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = ~bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = ~bitmap->map[nl];\n\n    if (nl == bitmap->map_len - 1) {\n        /* Ensure tail bits are ignored.  */\n        int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n        if (tail)\n            bits &= -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n    }\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuAssignMemoryDeviceSlot(virDomainMemoryDefPtr mem,\n                           virBitmapPtr slotmap)\n{\n    ssize_t nextslot = -1;\n\n    if (mem->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM)\n        return 0;\n\n    if ((nextslot = virBitmapNextClearBit(slotmap, -1)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to find an empty memory slot\"));\n        return -1;\n    }\n\n    ignore_value(virBitmapSetBit(slotmap, nextslot));\n    mem->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM;\n    mem->info.addr.dimm.slot = nextslot;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainGetMemorySlotMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "3037-3055",
    "snippet": "static virBitmapPtr\nqemuDomainGetMemorySlotMap(const virDomainDef *def)\n{\n    virBitmapPtr ret;\n    virDomainMemoryDefPtr mem;\n    size_t i;\n\n    if (!(ret = virBitmapNew(def->mem.memory_slots)))\n        return NULL;\n\n    for (i = 0; i < def->nmems; i++) {\n        mem = def->mems[i];\n\n        if (mem->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM)\n            ignore_value(virBitmapSetBit(ret, mem->info.addr.dimm.slot));\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(ret, mem->info.addr.dimm.slot)"
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "ret",
            "mem->info.addr.dimm.slot"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "def->mem.memory_slots"
          ],
          "line": 3044
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic virBitmapPtr\nqemuDomainGetMemorySlotMap(const virDomainDef *def)\n{\n    virBitmapPtr ret;\n    virDomainMemoryDefPtr mem;\n    size_t i;\n\n    if (!(ret = virBitmapNew(def->mem.memory_slots)))\n        return NULL;\n\n    for (i = 0; i < def->nmems; i++) {\n        mem = def->mems[i];\n\n        if (mem->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM)\n            ignore_value(virBitmapSetBit(ret, mem->info.addr.dimm.slot));\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuDomainUSBAddressAddHubs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "2991-3034",
    "snippet": "static int\nqemuDomainUSBAddressAddHubs(virDomainDefPtr def)\n{\n    struct qemuAssignUSBIteratorInfo data = { .count = 0 };\n    virDomainHubDefPtr hub = NULL;\n    size_t available_ports;\n    size_t hubs_needed = 0;\n    int ret = -1;\n    size_t i;\n\n    available_ports = virDomainUSBAddressCountAllPorts(def);\n    ignore_value(virDomainUSBDeviceDefForeach(def,\n                                              qemuDomainAssignUSBPortsCounter,\n                                              &data,\n                                              false));\n\n    if (data.count > 0 && !virDomainDefHasUSB(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"USB is disabled for this domain, but USB devices \"\n                         \"are present in the domain XML\"));\n        return -1;\n    }\n\n    if (data.count > available_ports)\n        hubs_needed = VIR_DIV_UP(data.count - available_ports + 1,\n                                 VIR_DOMAIN_USB_HUB_PORTS - 1);\n\n    VIR_DEBUG(\"Found %zu USB devices and %zu provided USB ports; adding %zu hubs\",\n              data.count, available_ports, hubs_needed);\n\n    for (i = 0; i < hubs_needed; i++) {\n        if (VIR_ALLOC(hub) < 0)\n            return -1;\n        hub->type = VIR_DOMAIN_HUB_TYPE_USB;\n\n        if (VIR_APPEND_ELEMENT(def->hubs, def->nhubs, hub) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(hub);\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "hub"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->hubs",
            "def->nhubs",
            "hub"
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "hub"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Found %zu USB devices and %zu provided USB ports; adding %zu hubs\"",
            "data.count",
            "available_ports",
            "hubs_needed"
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "data.count - available_ports + 1",
            "VIR_DOMAIN_USB_HUB_PORTS - 1"
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"USB is disabled for this domain, but USB devices \"\n                         \"are present in the domain XML\")"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"USB is disabled for this domain, but USB devices \"\n                         \"are present in the domain XML\""
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefHasUSB",
          "args": [
            "def"
          ],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefHasUSB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "6108-6120",
          "snippet": "bool\nvirDomainDefHasUSB(const virDomainDef *def)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB &&\n            def->controllers[i]->model != VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE)\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainDefHasUSB(const virDomainDef *def)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB &&\n            def->controllers[i]->model != VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE)\n            return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virDomainUSBDeviceDefForeach(def,\n                                              qemuDomainAssignUSBPortsCounter,\n                                              &data,\n                                              false)"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainUSBDeviceDefForeach",
          "args": [
            "def",
            "qemuDomainAssignUSBPortsCounter",
            "&data",
            "false"
          ],
          "line": 3002
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBDeviceDefForeach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29912-29998",
          "snippet": "int\nvirDomainUSBDeviceDefForeach(virDomainDefPtr def,\n                             virDomainUSBDeviceDefIterator iter,\n                             void *opaque,\n                             bool skipHubs)\n{\n    size_t i;\n\n    /* usb-hub */\n    if (!skipHubs) {\n        for (i = 0; i < def->nhubs; i++) {\n            virDomainHubDefPtr hub = def->hubs[i];\n            if (hub->type == VIR_DOMAIN_HUB_TYPE_USB) {\n                if (iter(&hub->info, opaque) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    /* usb-host */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = def->hostdevs[i];\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n            if (iter(hostdev->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-storage */\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n        if (disk->bus == VIR_DOMAIN_DISK_BUS_USB) {\n            if (iter(&disk->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* TODO: add def->nets here when libvirt starts supporting usb-net */\n\n    /* usb-ccid */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_CCID) {\n            if (iter(&cont->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-kbd, usb-mouse, usb-tablet */\n    for (i = 0; i < def->ninputs; i++) {\n        virDomainInputDefPtr input = def->inputs[i];\n\n        if (input->bus == VIR_DOMAIN_INPUT_BUS_USB) {\n            if (iter(&input->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-serial */\n    for (i = 0; i < def->nserials; i++) {\n        virDomainChrDefPtr serial = def->serials[i];\n        if (serial->targetType == VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_USB) {\n            if (iter(&serial->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-audio model=usb */\n    for (i = 0; i < def->nsounds; i++) {\n        virDomainSoundDefPtr sound = def->sounds[i];\n        if (sound->model == VIR_DOMAIN_SOUND_MODEL_USB) {\n            if (iter(&sound->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-redir */\n    for (i = 0; i < def->nredirdevs; i++) {\n        virDomainRedirdevDefPtr redirdev = def->redirdevs[i];\n        if (redirdev->bus == VIR_DOMAIN_REDIRDEV_BUS_USB) {\n            if (iter(&redirdev->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainUSBDeviceDefForeach(virDomainDefPtr def,\n                             virDomainUSBDeviceDefIterator iter,\n                             void *opaque,\n                             bool skipHubs)\n{\n    size_t i;\n\n    /* usb-hub */\n    if (!skipHubs) {\n        for (i = 0; i < def->nhubs; i++) {\n            virDomainHubDefPtr hub = def->hubs[i];\n            if (hub->type == VIR_DOMAIN_HUB_TYPE_USB) {\n                if (iter(&hub->info, opaque) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    /* usb-host */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = def->hostdevs[i];\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n            if (iter(hostdev->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-storage */\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n        if (disk->bus == VIR_DOMAIN_DISK_BUS_USB) {\n            if (iter(&disk->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* TODO: add def->nets here when libvirt starts supporting usb-net */\n\n    /* usb-ccid */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_CCID) {\n            if (iter(&cont->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-kbd, usb-mouse, usb-tablet */\n    for (i = 0; i < def->ninputs; i++) {\n        virDomainInputDefPtr input = def->inputs[i];\n\n        if (input->bus == VIR_DOMAIN_INPUT_BUS_USB) {\n            if (iter(&input->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-serial */\n    for (i = 0; i < def->nserials; i++) {\n        virDomainChrDefPtr serial = def->serials[i];\n        if (serial->targetType == VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_USB) {\n            if (iter(&serial->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-audio model=usb */\n    for (i = 0; i < def->nsounds; i++) {\n        virDomainSoundDefPtr sound = def->sounds[i];\n        if (sound->model == VIR_DOMAIN_SOUND_MODEL_USB) {\n            if (iter(&sound->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-redir */\n    for (i = 0; i < def->nredirdevs; i++) {\n        virDomainRedirdevDefPtr redirdev = def->redirdevs[i];\n        if (redirdev->bus == VIR_DOMAIN_REDIRDEV_BUS_USB) {\n            if (iter(&redirdev->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressCountAllPorts",
          "args": [
            "def"
          ],
          "line": 3001
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressCountAllPorts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2293-2310",
          "snippet": "size_t\nvirDomainUSBAddressCountAllPorts(virDomainDefPtr def)\n{\n    size_t i, ret = 0;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            ret += virDomainUSBAddressControllerModelToPorts(cont);\n    }\n\n    for (i = 0; i < def->nhubs; i++) {\n        virDomainHubDefPtr hub = def->hubs[i];\n        if (hub->type == VIR_DOMAIN_HUB_TYPE_USB)\n            ret += VIR_DOMAIN_USB_HUB_PORTS;\n    }\n    return ret;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nsize_t\nvirDomainUSBAddressCountAllPorts(virDomainDefPtr def)\n{\n    size_t i, ret = 0;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB)\n            ret += virDomainUSBAddressControllerModelToPorts(cont);\n    }\n\n    for (i = 0; i < def->nhubs; i++) {\n        virDomainHubDefPtr hub = def->hubs[i];\n        if (hub->type == VIR_DOMAIN_HUB_TYPE_USB)\n            ret += VIR_DOMAIN_USB_HUB_PORTS;\n    }\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainUSBAddressAddHubs(virDomainDefPtr def)\n{\n    struct qemuAssignUSBIteratorInfo data = { .count = 0 };\n    virDomainHubDefPtr hub = NULL;\n    size_t available_ports;\n    size_t hubs_needed = 0;\n    int ret = -1;\n    size_t i;\n\n    available_ports = virDomainUSBAddressCountAllPorts(def);\n    ignore_value(virDomainUSBDeviceDefForeach(def,\n                                              qemuDomainAssignUSBPortsCounter,\n                                              &data,\n                                              false));\n\n    if (data.count > 0 && !virDomainDefHasUSB(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"USB is disabled for this domain, but USB devices \"\n                         \"are present in the domain XML\"));\n        return -1;\n    }\n\n    if (data.count > available_ports)\n        hubs_needed = VIR_DIV_UP(data.count - available_ports + 1,\n                                 VIR_DOMAIN_USB_HUB_PORTS - 1);\n\n    VIR_DEBUG(\"Found %zu USB devices and %zu provided USB ports; adding %zu hubs\",\n              data.count, available_ports, hubs_needed);\n\n    for (i = 0; i < hubs_needed; i++) {\n        if (VIR_ALLOC(hub) < 0)\n            return -1;\n        hub->type = VIR_DOMAIN_HUB_TYPE_USB;\n\n        if (VIR_APPEND_ELEMENT(def->hubs, def->nhubs, hub) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(hub);\n    return ret;\n}"
  },
  {
    "function_name": "qemuDomainAssignUSBPortsCounter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "2980-2988",
    "snippet": "static int\nqemuDomainAssignUSBPortsCounter(virDomainDeviceInfoPtr info G_GNUC_UNUSED,\n                                void *opaque)\n{\n    struct qemuAssignUSBIteratorInfo *data = opaque;\n\n    data->count++;\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignUSBPortsCounter(virDomainDeviceInfoPtr info G_GNUC_UNUSED,\n                                void *opaque)\n{\n    struct qemuAssignUSBIteratorInfo *data = opaque;\n\n    data->count++;\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainAssignUSBPorts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "2967-2977",
    "snippet": "static int\nqemuDomainAssignUSBPorts(virDomainUSBAddressSetPtr addrs,\n                         virDomainDefPtr def)\n{\n    struct qemuAssignUSBIteratorInfo data = { .addrs = addrs };\n\n    return virDomainUSBDeviceDefForeach(def,\n                                        qemuDomainAssignUSBPortsIterator,\n                                        &data,\n                                        true);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainUSBDeviceDefForeach",
          "args": [
            "def",
            "qemuDomainAssignUSBPortsIterator",
            "&data",
            "true"
          ],
          "line": 2973
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBDeviceDefForeach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29912-29998",
          "snippet": "int\nvirDomainUSBDeviceDefForeach(virDomainDefPtr def,\n                             virDomainUSBDeviceDefIterator iter,\n                             void *opaque,\n                             bool skipHubs)\n{\n    size_t i;\n\n    /* usb-hub */\n    if (!skipHubs) {\n        for (i = 0; i < def->nhubs; i++) {\n            virDomainHubDefPtr hub = def->hubs[i];\n            if (hub->type == VIR_DOMAIN_HUB_TYPE_USB) {\n                if (iter(&hub->info, opaque) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    /* usb-host */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = def->hostdevs[i];\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n            if (iter(hostdev->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-storage */\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n        if (disk->bus == VIR_DOMAIN_DISK_BUS_USB) {\n            if (iter(&disk->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* TODO: add def->nets here when libvirt starts supporting usb-net */\n\n    /* usb-ccid */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_CCID) {\n            if (iter(&cont->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-kbd, usb-mouse, usb-tablet */\n    for (i = 0; i < def->ninputs; i++) {\n        virDomainInputDefPtr input = def->inputs[i];\n\n        if (input->bus == VIR_DOMAIN_INPUT_BUS_USB) {\n            if (iter(&input->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-serial */\n    for (i = 0; i < def->nserials; i++) {\n        virDomainChrDefPtr serial = def->serials[i];\n        if (serial->targetType == VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_USB) {\n            if (iter(&serial->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-audio model=usb */\n    for (i = 0; i < def->nsounds; i++) {\n        virDomainSoundDefPtr sound = def->sounds[i];\n        if (sound->model == VIR_DOMAIN_SOUND_MODEL_USB) {\n            if (iter(&sound->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-redir */\n    for (i = 0; i < def->nredirdevs; i++) {\n        virDomainRedirdevDefPtr redirdev = def->redirdevs[i];\n        if (redirdev->bus == VIR_DOMAIN_REDIRDEV_BUS_USB) {\n            if (iter(&redirdev->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainUSBDeviceDefForeach(virDomainDefPtr def,\n                             virDomainUSBDeviceDefIterator iter,\n                             void *opaque,\n                             bool skipHubs)\n{\n    size_t i;\n\n    /* usb-hub */\n    if (!skipHubs) {\n        for (i = 0; i < def->nhubs; i++) {\n            virDomainHubDefPtr hub = def->hubs[i];\n            if (hub->type == VIR_DOMAIN_HUB_TYPE_USB) {\n                if (iter(&hub->info, opaque) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    /* usb-host */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = def->hostdevs[i];\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n            if (iter(hostdev->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-storage */\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n        if (disk->bus == VIR_DOMAIN_DISK_BUS_USB) {\n            if (iter(&disk->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* TODO: add def->nets here when libvirt starts supporting usb-net */\n\n    /* usb-ccid */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_CCID) {\n            if (iter(&cont->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-kbd, usb-mouse, usb-tablet */\n    for (i = 0; i < def->ninputs; i++) {\n        virDomainInputDefPtr input = def->inputs[i];\n\n        if (input->bus == VIR_DOMAIN_INPUT_BUS_USB) {\n            if (iter(&input->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-serial */\n    for (i = 0; i < def->nserials; i++) {\n        virDomainChrDefPtr serial = def->serials[i];\n        if (serial->targetType == VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_USB) {\n            if (iter(&serial->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-audio model=usb */\n    for (i = 0; i < def->nsounds; i++) {\n        virDomainSoundDefPtr sound = def->sounds[i];\n        if (sound->model == VIR_DOMAIN_SOUND_MODEL_USB) {\n            if (iter(&sound->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    /* usb-redir */\n    for (i = 0; i < def->nredirdevs; i++) {\n        virDomainRedirdevDefPtr redirdev = def->redirdevs[i];\n        if (redirdev->bus == VIR_DOMAIN_REDIRDEV_BUS_USB) {\n            if (iter(&redirdev->info, opaque) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignUSBPorts(virDomainUSBAddressSetPtr addrs,\n                         virDomainDefPtr def)\n{\n    struct qemuAssignUSBIteratorInfo data = { .addrs = addrs };\n\n    return virDomainUSBDeviceDefForeach(def,\n                                        qemuDomainAssignUSBPortsIterator,\n                                        &data,\n                                        true);\n}"
  },
  {
    "function_name": "qemuDomainAssignUSBHubs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "2942-2964",
    "snippet": "static int\nqemuDomainAssignUSBHubs(virDomainUSBAddressSetPtr addrs,\n                        virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nhubs; i++) {\n        virDomainHubDefPtr hub = def->hubs[i];\n        if (hub->type != VIR_DOMAIN_HUB_TYPE_USB)\n            continue;\n\n        if (hub->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB &&\n            virDomainUSBAddressPortIsValid(hub->info.addr.usb.port))\n            continue;\n        if (virDomainUSBAddressAssign(addrs, &hub->info) < 0)\n            return -1;\n\n        if (virDomainUSBAddressSetAddHub(addrs, hub) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainUSBAddressSetAddHub",
          "args": [
            "addrs",
            "hub"
          ],
          "line": 2959
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressSetAddHub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2179-2221",
          "snippet": "int\nvirDomainUSBAddressSetAddHub(virDomainUSBAddressSetPtr addrs,\n                             virDomainHubDefPtr hub)\n{\n    virDomainUSBAddressHubPtr targetHub = NULL, newHub = NULL;\n    int ret = -1;\n    int targetPort;\n    g_autofree char *portStr = NULL;\n\n    if (hub->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Wrong address type for USB hub\"));\n        goto cleanup;\n    }\n\n    if (!(portStr = virDomainUSBAddressPortFormat(hub->info.addr.usb.port)))\n        goto cleanup;\n\n    VIR_DEBUG(\"Adding a USB hub with 8 ports on bus=%u port=%s\",\n              hub->info.addr.usb.bus, portStr);\n\n    if (!(newHub = virDomainUSBAddressHubNew(VIR_DOMAIN_USB_HUB_PORTS)))\n        goto cleanup;\n\n    if (!(targetHub = virDomainUSBAddressFindPort(addrs, &(hub->info), &targetPort,\n                                                  portStr)))\n        goto cleanup;\n\n    if (targetHub->ports[targetPort]) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Duplicate USB hub on bus %u port %s\"),\n                       hub->info.addr.usb.bus, portStr);\n        goto cleanup;\n    }\n    ignore_value(virBitmapSetBit(targetHub->portmap, targetPort));\n    targetHub->ports[targetPort] = newHub;\n    newHub = NULL;\n\n    ret = 0;\n cleanup:\n    virDomainUSBAddressHubFree(newHub);\n    return ret;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainUSBAddressSetAddHub(virDomainUSBAddressSetPtr addrs,\n                             virDomainHubDefPtr hub)\n{\n    virDomainUSBAddressHubPtr targetHub = NULL, newHub = NULL;\n    int ret = -1;\n    int targetPort;\n    g_autofree char *portStr = NULL;\n\n    if (hub->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Wrong address type for USB hub\"));\n        goto cleanup;\n    }\n\n    if (!(portStr = virDomainUSBAddressPortFormat(hub->info.addr.usb.port)))\n        goto cleanup;\n\n    VIR_DEBUG(\"Adding a USB hub with 8 ports on bus=%u port=%s\",\n              hub->info.addr.usb.bus, portStr);\n\n    if (!(newHub = virDomainUSBAddressHubNew(VIR_DOMAIN_USB_HUB_PORTS)))\n        goto cleanup;\n\n    if (!(targetHub = virDomainUSBAddressFindPort(addrs, &(hub->info), &targetPort,\n                                                  portStr)))\n        goto cleanup;\n\n    if (targetHub->ports[targetPort]) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Duplicate USB hub on bus %u port %s\"),\n                       hub->info.addr.usb.bus, portStr);\n        goto cleanup;\n    }\n    ignore_value(virBitmapSetBit(targetHub->portmap, targetPort));\n    targetHub->ports[targetPort] = newHub;\n    newHub = NULL;\n\n    ret = 0;\n cleanup:\n    virDomainUSBAddressHubFree(newHub);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressAssign",
          "args": [
            "addrs",
            "&hub->info"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressAssign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2350-2380",
          "snippet": "int\nvirDomainUSBAddressAssign(virDomainUSBAddressSetPtr addrs,\n                          virDomainDeviceInfoPtr info)\n{\n    size_t i;\n    int rc;\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB) {\n        VIR_DEBUG(\"A USBport on bus %u was requested\", info->addr.usb.bus);\n        if (info->addr.usb.bus >= addrs->nbuses ||\n            !addrs->buses[info->addr.usb.bus]) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"USB bus %u requested but no controller \"\n                             \"with that index is present\"), info->addr.usb.bus);\n            return -1;\n        }\n        rc = virDomainUSBAddressAssignFromBus(addrs, info, info->addr.usb.bus);\n        if (rc >= -1)\n            return rc;\n    } else {\n        VIR_DEBUG(\"Looking for a free USB port on all the buses\");\n        for (i = 0; i < addrs->nbuses; i++) {\n            rc = virDomainUSBAddressAssignFromBus(addrs, info, i);\n            if (rc >= -1)\n                return rc;\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"No free USB ports\"));\n    return -1;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainUSBAddressAssign(virDomainUSBAddressSetPtr addrs,\n                          virDomainDeviceInfoPtr info)\n{\n    size_t i;\n    int rc;\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB) {\n        VIR_DEBUG(\"A USBport on bus %u was requested\", info->addr.usb.bus);\n        if (info->addr.usb.bus >= addrs->nbuses ||\n            !addrs->buses[info->addr.usb.bus]) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"USB bus %u requested but no controller \"\n                             \"with that index is present\"), info->addr.usb.bus);\n            return -1;\n        }\n        rc = virDomainUSBAddressAssignFromBus(addrs, info, info->addr.usb.bus);\n        if (rc >= -1)\n            return rc;\n    } else {\n        VIR_DEBUG(\"Looking for a free USB port on all the buses\");\n        for (i = 0; i < addrs->nbuses; i++) {\n            rc = virDomainUSBAddressAssignFromBus(addrs, info, i);\n            if (rc >= -1)\n                return rc;\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"No free USB ports\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressPortIsValid",
          "args": [
            "hub->info.addr.usb.port"
          ],
          "line": 2954
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressPortIsValid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1928-1932",
          "snippet": "bool\nvirDomainUSBAddressPortIsValid(unsigned int *port)\n{\n    return port[0] != 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainUSBAddressPortIsValid(unsigned int *port)\n{\n    return port[0] != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignUSBHubs(virDomainUSBAddressSetPtr addrs,\n                        virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nhubs; i++) {\n        virDomainHubDefPtr hub = def->hubs[i];\n        if (hub->type != VIR_DOMAIN_HUB_TYPE_USB)\n            continue;\n\n        if (hub->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB &&\n            virDomainUSBAddressPortIsValid(hub->info.addr.usb.port))\n            continue;\n        if (virDomainUSBAddressAssign(addrs, &hub->info) < 0)\n            return -1;\n\n        if (virDomainUSBAddressSetAddHub(addrs, hub) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainAssignUSBPortsIterator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "2924-2939",
    "snippet": "static int\nqemuDomainAssignUSBPortsIterator(virDomainDeviceInfoPtr info,\n                                 void *opaque)\n{\n    struct qemuAssignUSBIteratorInfo *data = opaque;\n\n    if (info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE &&\n        info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB)\n        return 0;\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB &&\n        virDomainUSBAddressPortIsValid(info->addr.usb.port))\n        return 0;\n\n    return virDomainUSBAddressAssign(data->addrs, info);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainUSBAddressAssign",
          "args": [
            "data->addrs",
            "info"
          ],
          "line": 2938
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressAssign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "2350-2380",
          "snippet": "int\nvirDomainUSBAddressAssign(virDomainUSBAddressSetPtr addrs,\n                          virDomainDeviceInfoPtr info)\n{\n    size_t i;\n    int rc;\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB) {\n        VIR_DEBUG(\"A USBport on bus %u was requested\", info->addr.usb.bus);\n        if (info->addr.usb.bus >= addrs->nbuses ||\n            !addrs->buses[info->addr.usb.bus]) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"USB bus %u requested but no controller \"\n                             \"with that index is present\"), info->addr.usb.bus);\n            return -1;\n        }\n        rc = virDomainUSBAddressAssignFromBus(addrs, info, info->addr.usb.bus);\n        if (rc >= -1)\n            return rc;\n    } else {\n        VIR_DEBUG(\"Looking for a free USB port on all the buses\");\n        for (i = 0; i < addrs->nbuses; i++) {\n            rc = virDomainUSBAddressAssignFromBus(addrs, info, i);\n            if (rc >= -1)\n                return rc;\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"No free USB ports\"));\n    return -1;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainUSBAddressAssign(virDomainUSBAddressSetPtr addrs,\n                          virDomainDeviceInfoPtr info)\n{\n    size_t i;\n    int rc;\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB) {\n        VIR_DEBUG(\"A USBport on bus %u was requested\", info->addr.usb.bus);\n        if (info->addr.usb.bus >= addrs->nbuses ||\n            !addrs->buses[info->addr.usb.bus]) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"USB bus %u requested but no controller \"\n                             \"with that index is present\"), info->addr.usb.bus);\n            return -1;\n        }\n        rc = virDomainUSBAddressAssignFromBus(addrs, info, info->addr.usb.bus);\n        if (rc >= -1)\n            return rc;\n    } else {\n        VIR_DEBUG(\"Looking for a free USB port on all the buses\");\n        for (i = 0; i < addrs->nbuses; i++) {\n            rc = virDomainUSBAddressAssignFromBus(addrs, info, i);\n            if (rc >= -1)\n                return rc;\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"No free USB ports\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainUSBAddressPortIsValid",
          "args": [
            "info->addr.usb.port"
          ],
          "line": 2935
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainUSBAddressPortIsValid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1928-1932",
          "snippet": "bool\nvirDomainUSBAddressPortIsValid(unsigned int *port)\n{\n    return port[0] != 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainUSBAddressPortIsValid(unsigned int *port)\n{\n    return port[0] != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignUSBPortsIterator(virDomainDeviceInfoPtr info,\n                                 void *opaque)\n{\n    struct qemuAssignUSBIteratorInfo *data = opaque;\n\n    if (info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE &&\n        info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB)\n        return 0;\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_USB &&\n        virDomainUSBAddressPortIsValid(info->addr.usb.port))\n        return 0;\n\n    return virDomainUSBAddressAssign(data->addrs, info);\n}"
  },
  {
    "function_name": "qemuDomainAssignPCIAddresses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "2607-2915",
    "snippet": "static int\nqemuDomainAssignPCIAddresses(virDomainDefPtr def,\n                             virQEMUCapsPtr qemuCaps,\n                             virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    int ret = -1;\n    virDomainPCIAddressSetPtr addrs = NULL;\n    qemuDomainObjPrivatePtr priv = NULL;\n    int max_idx = -1;\n    int nbuses = 0;\n    size_t i;\n    int rv;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI) {\n            if ((int)cont->idx > max_idx)\n                max_idx = cont->idx;\n        }\n    }\n\n    nbuses = max_idx + 1;\n\n    /* set the connect type flags (pci vs. pcie) in the DeviceInfo\n     * of all devices. This will be used to pick an appropriate\n     * bus when assigning addresses.\n     */\n    if (qemuDomainFillAllPCIConnectFlags(def, qemuCaps, driver) < 0)\n        goto cleanup;\n\n    if (qemuDomainFillAllPCIExtensionFlags(def, qemuCaps) < 0)\n        goto cleanup;\n\n    if (qemuDomainSetupIsolationGroups(def) < 0)\n        goto cleanup;\n\n    if (nbuses > 0) {\n        /* 1st pass to figure out how many PCI bridges we need */\n        if (!(addrs = qemuDomainPCIAddressSetCreate(def, qemuCaps, nbuses, true)))\n            goto cleanup;\n\n        if (qemuDomainValidateDevicePCISlotsChipsets(def, qemuCaps,\n                                                     addrs) < 0)\n            goto cleanup;\n\n        /* For domains that have pci-root, reserve 1 extra slot for a\n         * (potential) bridge (for future expansion) only if buses are\n         * not fully reserved yet (if all buses are fully reserved\n         * with manually/previously assigned addresses, any attempt to\n         * reserve an extra slot would fail anyway. But if all buses\n         * are *not* fully reserved, this extra reservation might push\n         * the config to add a new pci-bridge to plug into the final\n         * available slot, thus preserving the ability to expand)\n         *\n         * We only do this for those domains that have pci-root, since\n         * those with pcie-root will usually want to expand using PCIe\n         * controllers, which we will do after assigning addresses for\n         * all *actual* devices.\n         */\n\n        if (qemuDomainHasPCIRoot(def)) {\n            /* This is a dummy info used to reserve a slot for a\n             * legacy PCI device that doesn't exist, but may in the\n             * future, e.g.  if another device is hotplugged into the\n             * domain.\n             */\n            virDomainDeviceInfo info = {\n                .pciConnectFlags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                                    VIR_PCI_CONNECT_TYPE_PCI_DEVICE),\n                .pciAddrExtFlags = VIR_PCI_ADDRESS_EXTENSION_NONE\n            };\n            bool buses_reserved = true;\n\n            for (i = 0; i < addrs->nbuses; i++) {\n                if (!virDomainPCIAddressBusIsFullyReserved(&addrs->buses[i])) {\n                    buses_reserved = false;\n                    break;\n                }\n            }\n            if (!buses_reserved &&\n                qemuDomainPCIAddressReserveNextAddr(addrs, &info) < 0)\n                goto cleanup;\n        }\n\n        if (qemuDomainAssignDevicePCISlots(def, qemuCaps, addrs) < 0)\n            goto cleanup;\n\n        if (virDomainDeviceInfoIterate(def, qemuDomainAssignPCIAddressExtension, addrs) < 0)\n            goto cleanup;\n\n        /* Only for *new* domains with pcie-root (and no other\n         * manually specified PCI controllers in the definition): If,\n         * after assigning addresses/reserving slots for all devices,\n         * we see that any extra buses have been auto-added, we\n         * understand that the application has left management of PCI\n         * addresses and controllers up to libvirt. In order to allow\n         * such applications to easily support hotplug, we will do a\n         * \"one time\" reservation of one extra PCIE|HOTPLUGGABLE\n         * slots, which should cause us to auto-add 1 extra\n         * pcie-root-port. The single slot in this root-port will be\n         * available for hotplug, or may also be used when a device is\n         * added to the config offline.\n         */\n\n        if (max_idx <= 0 &&\n            addrs->nbuses > max_idx + 1 &&\n            qemuDomainHasPCIeRoot(def)) {\n            virDomainDeviceInfo info = {\n                .pciConnectFlags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                                    VIR_PCI_CONNECT_TYPE_PCIE_DEVICE),\n                .pciAddrExtFlags = VIR_PCI_ADDRESS_EXTENSION_NONE\n            };\n\n            /* if there isn't an empty pcie-root-port, this will\n             * cause one to be added\n             */\n            if (qemuDomainPCIAddressReserveNextAddr(addrs, &info) < 0)\n               goto cleanup;\n        }\n\n        /* now reflect any controllers auto-added to addrs into the\n         * domain controllers list\n         */\n        for (i = 1; i < addrs->nbuses; i++) {\n            virDomainDeviceDef dev;\n            int contIndex;\n            virDomainPCIAddressBusPtr bus = &addrs->buses[i];\n\n            if ((rv = virDomainDefMaybeAddController(\n                     def, VIR_DOMAIN_CONTROLLER_TYPE_PCI,\n                     i, bus->model)) < 0)\n                goto cleanup;\n\n            if (rv == 0)\n                continue; /* no new controller added */\n\n            /* We did add a new controller, so we will need one more\n             * address (and we need to set the new controller's\n             * pciConnectFlags)\n             */\n            contIndex = virDomainControllerFind(def,\n                                                VIR_DOMAIN_CONTROLLER_TYPE_PCI,\n                                                i);\n            if (contIndex < 0) {\n                /* this should never happen - we just added it */\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find auto-added %s controller \"\n                                 \"with index %zu\"),\n                               virDomainControllerModelPCITypeToString(bus->model),\n                               i);\n                goto cleanup;\n            }\n            dev.type = VIR_DOMAIN_DEVICE_CONTROLLER;\n            dev.data.controller = def->controllers[contIndex];\n            /* set connect flags so it will be properly addressed */\n            qemuDomainFillDevicePCIConnectFlags(def, &dev, qemuCaps, driver);\n\n            /* Reserve an address for the controller. pci-root and pcie-root\n             * controllers don't plug into any other PCI controller, hence\n             * they should skip this step */\n            if (bus->model != VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT &&\n                bus->model != VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT &&\n                qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                    &dev.data.controller->info) < 0) {\n                goto cleanup;\n            }\n        }\n\n        nbuses = addrs->nbuses;\n        virDomainPCIAddressSetFree(addrs);\n        addrs = NULL;\n    }\n\n    if (!(addrs = qemuDomainPCIAddressSetCreate(def, qemuCaps, nbuses, false)))\n        goto cleanup;\n\n    if (qemuDomainSupportsPCI(def, qemuCaps)) {\n        if (qemuDomainValidateDevicePCISlotsChipsets(def, qemuCaps,\n                                                     addrs) < 0)\n            goto cleanup;\n\n        if (qemuDomainAssignDevicePCISlots(def, qemuCaps, addrs) < 0)\n            goto cleanup;\n\n        if (virDomainDeviceInfoIterate(def, qemuDomainAssignPCIAddressExtension, addrs) < 0)\n            goto cleanup;\n\n        /* set multi attribute for devices at function 0 of\n         * any slot that has multiple functions in use\n         */\n        virDomainPCIAddressSetAllMulti(def);\n\n        for (i = 0; i < def->ncontrollers; i++) {\n            virDomainControllerDefPtr cont = def->controllers[i];\n            int idx = cont->idx;\n            virPCIDeviceAddressPtr addr;\n            virDomainPCIControllerOptsPtr options;\n\n            if (cont->type != VIR_DOMAIN_CONTROLLER_TYPE_PCI)\n                continue;\n\n            addr = &cont->info.addr.pci;\n            options = &cont->opts.pciopts;\n\n            /* set default model name (the actual name of the\n             * device in qemu) for any controller that doesn't yet\n             * have it set.\n             */\n            qemuDomainPCIControllerSetDefaultModelName(cont, def, qemuCaps);\n\n            /* set defaults for any other auto-generated config\n             * options for this controller that haven't been\n             * specified in config.\n             */\n            switch ((virDomainControllerModelPCI)cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n                if (options->chassisNr == -1)\n                    options->chassisNr = cont->idx;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n                if (options->chassis == -1)\n                   options->chassis = cont->idx;\n                if (options->port == -1)\n                   options->port = (addr->slot << 3) + addr->function;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n                if (options->chassis == -1)\n                   options->chassis = cont->idx;\n                if (options->port == -1)\n                   options->port = addr->slot;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n                if (options->busNr == -1)\n                    options->busNr = qemuDomainAddressFindNewBusNr(def);\n                if (options->busNr == -1) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"No free busNr lower than current \"\n                                     \"lowest busNr is available to \"\n                                     \"auto-assign to bus %d. Must be \"\n                                     \"manually assigned\"),\n                                   addr->bus);\n                    goto cleanup;\n                }\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n                if (!qemuDomainIsPSeries(def))\n                    break;\n                if (options->targetIndex == -1) {\n                    if (cont->idx == 0) {\n                        /* The pci-root controller with controller index 0\n                         * must always be assigned target index 0, because\n                         * it represents the implicit PHB which is treated\n                         * differently than all other PHBs */\n                        options->targetIndex = 0;\n                    } else {\n                        /* For all other PHBs the target index doesn't need\n                         * to match the controller index or have any\n                         * particular value, really */\n                        options->targetIndex = qemuDomainAddressFindNewTargetIndex(def);\n                    }\n                }\n                if (options->targetIndex == -1) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"No usable target index found for %d\"),\n                                   addr->bus);\n                    goto cleanup;\n                }\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n                break;\n            }\n\n            /* check if every PCI bridge controller's index is larger than\n             * the bus it is placed onto\n             */\n            if (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE &&\n                idx <= addr->bus) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"PCI controller at index %d (0x%02x) has \"\n                                 \"bus='0x%02x', but index must be \"\n                                 \"larger than bus\"),\n                               idx, idx, addr->bus);\n                goto cleanup;\n            }\n        }\n    }\n\n    if (obj && obj->privateData) {\n        priv = obj->privateData;\n        /* if this is the live domain object, we persist the PCI addresses */\n        priv->pciaddrs = addrs;\n        addrs = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virDomainPCIAddressSetFree(addrs);\n\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressSetFree",
          "args": [
            "addrs"
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressSetFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1079-1088",
          "snippet": "void\nvirDomainPCIAddressSetFree(virDomainPCIAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virDomainPCIAddressSetExtensionFree(addrs);\n    VIR_FREE(addrs->buses);\n    VIR_FREE(addrs);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainPCIAddressSetFree(virDomainPCIAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virDomainPCIAddressSetExtensionFree(addrs);\n    VIR_FREE(addrs->buses);\n    VIR_FREE(addrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"PCI controller at index %d (0x%02x) has \"\n                                 \"bus='0x%02x', but index must be \"\n                                 \"larger than bus\")",
            "idx",
            "idx",
            "addr->bus"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"PCI controller at index %d (0x%02x) has \"\n                                 \"bus='0x%02x', but index must be \"\n                                 \"larger than bus\""
          ],
          "line": 2893
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"No usable target index found for %d\")",
            "addr->bus"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainAddressFindNewTargetIndex",
          "args": [
            "def"
          ],
          "line": 2868
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainAddressFindNewTargetIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "2497-2533",
          "snippet": "static int\nqemuDomainAddressFindNewTargetIndex(virDomainDefPtr def)\n{\n    int targetIndex;\n    int ret = -1;\n\n    /* Try all indexes between 1 and 31 - QEMU only supports 32\n     * PHBs, and 0 is reserved for the default, implicit one */\n    for (targetIndex = 1; targetIndex <= 31; targetIndex++) {\n        bool found = false;\n        size_t i;\n\n        for (i = 0; i < def->ncontrollers; i++) {\n            virDomainControllerDefPtr cont = def->controllers[i];\n\n            /* Skip everything but PHBs */\n            if (!virDomainControllerIsPSeriesPHB(cont))\n                continue;\n\n            /* Stop looking as soon as we find a PHB that's\n             * already using this specific target index */\n            if (cont->opts.pciopts.targetIndex == targetIndex) {\n                found = true;\n                break;\n            }\n        }\n\n        /* If no existing PCI controller uses this index, great,\n         * it means it's free and we can return it to the caller */\n        if (!found) {\n            ret = targetIndex;\n            break;\n        }\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAddressFindNewTargetIndex(virDomainDefPtr def)\n{\n    int targetIndex;\n    int ret = -1;\n\n    /* Try all indexes between 1 and 31 - QEMU only supports 32\n     * PHBs, and 0 is reserved for the default, implicit one */\n    for (targetIndex = 1; targetIndex <= 31; targetIndex++) {\n        bool found = false;\n        size_t i;\n\n        for (i = 0; i < def->ncontrollers; i++) {\n            virDomainControllerDefPtr cont = def->controllers[i];\n\n            /* Skip everything but PHBs */\n            if (!virDomainControllerIsPSeriesPHB(cont))\n                continue;\n\n            /* Stop looking as soon as we find a PHB that's\n             * already using this specific target index */\n            if (cont->opts.pciopts.targetIndex == targetIndex) {\n                found = true;\n                break;\n            }\n        }\n\n        /* If no existing PCI controller uses this index, great,\n         * it means it's free and we can return it to the caller */\n        if (!found) {\n            ret = targetIndex;\n            break;\n        }\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainIsPSeries",
          "args": [
            "def"
          ],
          "line": 2855
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainIsPSeries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12912-12916",
          "snippet": "bool\nqemuDomainIsPSeries(const virDomainDef *def)\n{\n    return qemuDomainMachineIsPSeries(def->os.machine, def->os.arch);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainIsPSeries(const virDomainDef *def)\n{\n    return qemuDomainMachineIsPSeries(def->os.machine, def->os.arch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"No free busNr lower than current \"\n                                     \"lowest busNr is available to \"\n                                     \"auto-assign to bus %d. Must be \"\n                                     \"manually assigned\")",
            "addr->bus"
          ],
          "line": 2845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainAddressFindNewBusNr",
          "args": [
            "def"
          ],
          "line": 2843
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainAddressFindNewBusNr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "2536-2604",
          "snippet": "static int\nqemuDomainAddressFindNewBusNr(virDomainDefPtr def)\n{\n    /* Try to find a nice default for busNr for a new pci-expander-bus.\n     * This is a bit tricky, since you need to satisfy the following:\n     *\n     * 1) There need to be enough unused bus numbers between busNr of this\n     *    bus and busNr of the next highest bus for the guest to assign a\n     *    unique bus number to each PCI bus that is a child of this\n     *    bus. Each PCI controller. On top of this, the pxb device (which\n     *    implements the pci-expander-bus) includes a pci-bridge within\n     *    it, and that bridge also uses one bus number (so each pxb device\n     *    requires at least 2 bus numbers).\n     *\n     * 2) There need to be enough bus numbers *below* this for all the\n     *    child controllers of the pci-expander-bus with the next lower\n     *    busNr (or the pci-root bus if there are no lower\n     *    pci-expander-buses).\n     *\n     * 3) If at all possible, we want to avoid needing to change the busNr\n     *    of a bus in the future, as that changes the guest's device ABI,\n     *    which could potentially lead to issues with a guest OS that is\n     *    picky about such things.\n     *\n     *  Due to the impossibility of predicting what might be added to the\n     *  config in the future, we can't make a foolproof choice, but since\n     *  a pci-expander-bus (pxb) has slots for 32 devices, and the only\n     *  practical use for it is to assign real devices on a particular\n     *  NUMA node in the host, it's reasonably safe to assume it should\n     *  never need any additional child buses (probably only a few of the\n     *  32 will ever be used). So for pci-expander-bus we find the lowest\n     *  existing busNr, and set this one to the current lowest - 2 (one\n     *  for the pxb, one for the intergrated pci-bridge), thus leaving the\n     *  maximum possible bus numbers available for other buses plugged\n     *  into pci-root (i.e. pci-bridges and other\n     *  pci-expander-buses). Anyone who needs more than 32 devices\n     *  descended from one pci-expander-bus should set the busNr manually\n     *  in the config.\n     *\n     *  There is room for more error checking here - in particular we\n     *  can/should determine the ultimate parent (root-bus) of each PCI\n     *  controller and determine if there is enough space for all the\n     *  buses within the current range allotted to the bus just prior to\n     *  this one.\n     */\n\n    size_t i;\n    int lowestBusNr = 256;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI) {\n            int thisBusNr = cont->opts.pciopts.busNr;\n\n            if (thisBusNr >= 0 && thisBusNr < lowestBusNr)\n                lowestBusNr = thisBusNr;\n        }\n    }\n\n    /* If we already have a busNR = 1, then we can't auto-assign (0 is\n     * the pci[e]-root, and the others may have been assigned\n     * purposefully).\n     */\n    if (lowestBusNr <= 2)\n        return -1;\n\n    return lowestBusNr - 2;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAddressFindNewBusNr(virDomainDefPtr def)\n{\n    /* Try to find a nice default for busNr for a new pci-expander-bus.\n     * This is a bit tricky, since you need to satisfy the following:\n     *\n     * 1) There need to be enough unused bus numbers between busNr of this\n     *    bus and busNr of the next highest bus for the guest to assign a\n     *    unique bus number to each PCI bus that is a child of this\n     *    bus. Each PCI controller. On top of this, the pxb device (which\n     *    implements the pci-expander-bus) includes a pci-bridge within\n     *    it, and that bridge also uses one bus number (so each pxb device\n     *    requires at least 2 bus numbers).\n     *\n     * 2) There need to be enough bus numbers *below* this for all the\n     *    child controllers of the pci-expander-bus with the next lower\n     *    busNr (or the pci-root bus if there are no lower\n     *    pci-expander-buses).\n     *\n     * 3) If at all possible, we want to avoid needing to change the busNr\n     *    of a bus in the future, as that changes the guest's device ABI,\n     *    which could potentially lead to issues with a guest OS that is\n     *    picky about such things.\n     *\n     *  Due to the impossibility of predicting what might be added to the\n     *  config in the future, we can't make a foolproof choice, but since\n     *  a pci-expander-bus (pxb) has slots for 32 devices, and the only\n     *  practical use for it is to assign real devices on a particular\n     *  NUMA node in the host, it's reasonably safe to assume it should\n     *  never need any additional child buses (probably only a few of the\n     *  32 will ever be used). So for pci-expander-bus we find the lowest\n     *  existing busNr, and set this one to the current lowest - 2 (one\n     *  for the pxb, one for the intergrated pci-bridge), thus leaving the\n     *  maximum possible bus numbers available for other buses plugged\n     *  into pci-root (i.e. pci-bridges and other\n     *  pci-expander-buses). Anyone who needs more than 32 devices\n     *  descended from one pci-expander-bus should set the busNr manually\n     *  in the config.\n     *\n     *  There is room for more error checking here - in particular we\n     *  can/should determine the ultimate parent (root-bus) of each PCI\n     *  controller and determine if there is enough space for all the\n     *  buses within the current range allotted to the bus just prior to\n     *  this one.\n     */\n\n    size_t i;\n    int lowestBusNr = 256;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI) {\n            int thisBusNr = cont->opts.pciopts.busNr;\n\n            if (thisBusNr >= 0 && thisBusNr < lowestBusNr)\n                lowestBusNr = thisBusNr;\n        }\n    }\n\n    /* If we already have a busNR = 1, then we can't auto-assign (0 is\n     * the pci[e]-root, and the others may have been assigned\n     * purposefully).\n     */\n    if (lowestBusNr <= 2)\n        return -1;\n\n    return lowestBusNr - 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainPCIControllerSetDefaultModelName",
          "args": [
            "cont",
            "def",
            "qemuCaps"
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainPCIControllerSetDefaultModelName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "2435-2485",
          "snippet": "static void\nqemuDomainPCIControllerSetDefaultModelName(virDomainControllerDefPtr cont,\n                                           virDomainDefPtr def,\n                                           virQEMUCapsPtr qemuCaps)\n{\n    int *modelName = &cont->opts.pciopts.modelName;\n\n    /* make sure it's not already set */\n    if (*modelName != VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_NONE)\n        return;\n\n    switch ((virDomainControllerModelPCI)cont->model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PCI_BRIDGE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_I82801B11_BRIDGE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PCIE_PCI_BRIDGE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n        /* Use generic PCIe Root Ports if available, falling back to\n         * ioh3420 otherwise */\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_PCIE_ROOT_PORT))\n            *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PCIE_ROOT_PORT;\n        else\n            *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_IOH3420;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_X3130_UPSTREAM;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_XIO3130_DOWNSTREAM;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PXB;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PXB_PCIE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n        if (qemuDomainIsPSeries(def))\n            *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_SPAPR_PCI_HOST_BRIDGE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n        break;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic void\nqemuDomainPCIControllerSetDefaultModelName(virDomainControllerDefPtr cont,\n                                           virDomainDefPtr def,\n                                           virQEMUCapsPtr qemuCaps)\n{\n    int *modelName = &cont->opts.pciopts.modelName;\n\n    /* make sure it's not already set */\n    if (*modelName != VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_NONE)\n        return;\n\n    switch ((virDomainControllerModelPCI)cont->model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PCI_BRIDGE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_I82801B11_BRIDGE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PCIE_PCI_BRIDGE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n        /* Use generic PCIe Root Ports if available, falling back to\n         * ioh3420 otherwise */\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_PCIE_ROOT_PORT))\n            *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PCIE_ROOT_PORT;\n        else\n            *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_IOH3420;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_X3130_UPSTREAM;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_XIO3130_DOWNSTREAM;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PXB;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PXB_PCIE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n        if (qemuDomainIsPSeries(def))\n            *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_SPAPR_PCI_HOST_BRIDGE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressSetAllMulti",
          "args": [
            "def"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressSetAllMulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1356-1368",
          "snippet": "void\nvirDomainPCIAddressSetAllMulti(virDomainDefPtr def)\n{\n    /* Use nested iterators over all the devices - the outer iterator\n     * scans through all the devices looking for those whose address\n     * has a non-0 function; when one is found, the inner iterator looks\n     * for the device that uses function 0 on the same slot and marks\n     * it as multi = ON\n     */\n    ignore_value(virDomainDeviceInfoIterate(def,\n                                            virDomainPCIAddressSetAllMultiIter,\n                                            NULL));\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainPCIAddressSetAllMulti(virDomainDefPtr def)\n{\n    /* Use nested iterators over all the devices - the outer iterator\n     * scans through all the devices looking for those whose address\n     * has a non-0 function; when one is found, the inner iterator looks\n     * for the device that uses function 0 on the same slot and marks\n     * it as multi = ON\n     */\n    ignore_value(virDomainDeviceInfoIterate(def,\n                                            virDomainPCIAddressSetAllMultiIter,\n                                            NULL));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDeviceInfoIterate",
          "args": [
            "def",
            "qemuDomainAssignPCIAddressExtension",
            "addrs"
          ],
          "line": 2793
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceInfoIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "4352-4358",
          "snippet": "int\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainAssignDevicePCISlots",
          "args": [
            "def",
            "qemuCaps",
            "addrs"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainAssignDevicePCISlots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "2137-2432",
          "snippet": "static int\nqemuDomainAssignDevicePCISlots(virDomainDefPtr def,\n                               virQEMUCapsPtr qemuCaps,\n                               virDomainPCIAddressSetPtr addrs)\n{\n    size_t i, j;\n\n    /* PCI controllers */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI) {\n            virDomainControllerModelPCI model = cont->model;\n\n            if (model == VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT ||\n                model == VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT ||\n                !virDeviceInfoPCIAddressIsWanted(&cont->info))\n                continue;\n\n            if (qemuDomainPCIAddressReserveNextAddr(addrs, &cont->info) < 0)\n                return -1;\n        }\n    }\n\n    for (i = 0; i < def->nfss; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->fss[i]->info))\n            continue;\n\n        /* Only support VirtIO-9p-pci so far. If that changes,\n         * we might need to skip devices here */\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->fss[i]->info) < 0)\n            return -1;\n    }\n\n    /* Network interfaces */\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n\n        /* type='hostdev' network devices might be USB, and are also\n         * in hostdevs list anyway, so handle them with other hostdevs\n         * instead of here.\n         */\n        if ((net->type == VIR_DOMAIN_NET_TYPE_HOSTDEV) ||\n            !virDeviceInfoPCIAddressIsWanted(&net->info)) {\n            continue;\n        }\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &net->info) < 0)\n            return -1;\n    }\n\n    /* Sound cards */\n    for (i = 0; i < def->nsounds; i++) {\n        virDomainSoundDefPtr sound = def->sounds[i];\n\n        if (!virDeviceInfoPCIAddressIsWanted(&sound->info))\n            continue;\n\n        /* Skip ISA sound card, PCSPK and usb-audio */\n        if (sound->model == VIR_DOMAIN_SOUND_MODEL_SB16 ||\n            sound->model == VIR_DOMAIN_SOUND_MODEL_PCSPK ||\n            sound->model == VIR_DOMAIN_SOUND_MODEL_USB) {\n            continue;\n        }\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &sound->info) < 0)\n            return -1;\n    }\n\n    /* Device controllers (SCSI, USB, but not IDE, FDC or CCID) */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        /* PCI controllers have been dealt with earlier */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI)\n            continue;\n\n        /* USB controller model 'none' doesn't need a PCI address */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB &&\n            cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE)\n            continue;\n\n        /* FDC lives behind the ISA bridge; CCID is a usb device */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_FDC ||\n            cont->type == VIR_DOMAIN_CONTROLLER_TYPE_CCID)\n            continue;\n\n        /* First IDE controller lives on the PIIX3 at slot=1, function=1,\n           dealt with earlier on */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_IDE &&\n            cont->idx == 0)\n            continue;\n\n        if (!virDeviceInfoPCIAddressIsWanted(&cont->info))\n            continue;\n\n        /* USB2 needs special handling to put all companions in the same slot */\n        if (IS_USB2_CONTROLLER(cont)) {\n            virPCIDeviceAddress addr = {0};\n            bool foundAddr = false;\n\n            for (j = 0; j < def->ncontrollers; j++) {\n                if (IS_USB2_CONTROLLER(def->controllers[j]) &&\n                    def->controllers[j]->idx == cont->idx &&\n                    virDeviceInfoPCIAddressIsPresent(&def->controllers[j]->info)) {\n                    addr = def->controllers[j]->info.addr.pci;\n                    foundAddr = true;\n                    break;\n                }\n            }\n\n            switch (cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_EHCI1:\n                addr.function = 7;\n                addr.multi = VIR_TRISTATE_SWITCH_ABSENT;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1:\n                addr.function = 0;\n                addr.multi = VIR_TRISTATE_SWITCH_ON;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI2:\n                addr.function = 1;\n                addr.multi = VIR_TRISTATE_SWITCH_ABSENT;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI3:\n                addr.function = 2;\n                addr.multi = VIR_TRISTATE_SWITCH_ABSENT;\n                break;\n            }\n\n            if (foundAddr) {\n                /* Reserve this function on the slot we found */\n                if (virDomainPCIAddressReserveAddr(addrs, &addr,\n                                                   cont->info.pciConnectFlags,\n                                                   cont->info.isolationGroup) < 0) {\n                    return -1;\n                }\n\n                cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                cont->info.addr.pci = addr;\n            } else {\n                /* This is the first part of the controller, so need\n                 * to find a free slot & then reserve this function */\n                if (virDomainPCIAddressReserveNextAddr(addrs, &cont->info,\n                                                       cont->info.pciConnectFlags,\n                                                       addr.function) < 0) {\n                    return -1;\n                }\n\n                cont->info.addr.pci.multi = addr.multi;\n            }\n        } else {\n            if (qemuDomainPCIAddressReserveNextAddr(addrs, &cont->info) < 0)\n                 return -1;\n        }\n    }\n\n    /* Disks (VirtIO only for now) */\n    for (i = 0; i < def->ndisks; i++) {\n        /* Only VirtIO disks use PCI addrs */\n        if (def->disks[i]->bus != VIR_DOMAIN_DISK_BUS_VIRTIO)\n            continue;\n\n        /* don't touch s390 devices */\n        if (virDeviceInfoPCIAddressIsPresent(&def->disks[i]->info) ||\n            def->disks[i]->info.type ==\n            VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_S390 ||\n            def->disks[i]->info.type ==\n            VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW)\n            continue;\n\n        /* Also ignore virtio-mmio disks if our machine allows them */\n        if (def->disks[i]->info.type ==\n            VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_MMIO &&\n            virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIRTIO_MMIO))\n            continue;\n\n        if (!virDeviceInfoPCIAddressIsWanted(&def->disks[i]->info)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"virtio disk cannot have an address of type '%s'\"),\n                           virDomainDeviceAddressTypeToString(def->disks[i]->info.type));\n            return -1;\n        }\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->disks[i]->info) < 0)\n            return -1;\n    }\n\n    /* Host PCI devices */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevSubsysPtr subsys = &def->hostdevs[i]->source.subsys;\n        if (!virDeviceInfoPCIAddressIsWanted(def->hostdevs[i]->info))\n            continue;\n        if (def->hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (subsys->type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n            subsys->type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST &&\n            !(subsys->type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV &&\n              subsys->u.mdev.model == VIR_MDEV_MODEL_TYPE_VFIO_PCI)) {\n            continue;\n        }\n\n        /* do not reserve address for info->type='unassigned' */\n        if (def->hostdevs[i]->info->type ==\n            VIR_DOMAIN_DEVICE_ADDRESS_TYPE_UNASSIGNED)\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                def->hostdevs[i]->info) < 0)\n            return -1;\n    }\n\n    /* memballoon. the qemu driver only accepts virtio memballoon devices */\n    if (virDomainDefHasMemballoon(def) &&\n        virDeviceInfoPCIAddressIsWanted(&def->memballoon->info)) {\n        if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                &def->memballoon->info) < 0)\n            return -1;\n    }\n\n    /* the qemu driver only accepts virtio rng devices */\n    for (i = 0; i < def->nrngs; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->rngs[i]->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->rngs[i]->info) < 0)\n            return -1;\n    }\n\n    /* A watchdog - check if it is a PCI device */\n    if (def->watchdog &&\n        def->watchdog->model == VIR_DOMAIN_WATCHDOG_MODEL_I6300ESB &&\n        virDeviceInfoPCIAddressIsWanted(&def->watchdog->info)) {\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->watchdog->info) < 0)\n            return -1;\n    }\n\n    /* Video devices */\n    for (i = 0; i < def->nvideos; i++) {\n        if (def->videos[i]->type == VIR_DOMAIN_VIDEO_TYPE_NONE ||\n            def->videos[i]->type == VIR_DOMAIN_VIDEO_TYPE_RAMFB)\n            continue;\n\n        if (!virDeviceInfoPCIAddressIsWanted(&def->videos[i]->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->videos[i]->info) < 0)\n            return -1;\n    }\n\n    /* Shared Memory */\n    for (i = 0; i < def->nshmems; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->shmems[i]->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->shmems[i]->info) < 0)\n            return -1;\n    }\n    for (i = 0; i < def->ninputs; i++) {\n        if (def->inputs[i]->bus != VIR_DOMAIN_INPUT_BUS_VIRTIO ||\n            !virDeviceInfoPCIAddressIsWanted(&def->inputs[i]->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->inputs[i]->info) < 0)\n            return -1;\n    }\n    for (i = 0; i < def->nparallels; i++) {\n        /* Nada - none are PCI based (yet) */\n    }\n    for (i = 0; i < def->nserials; i++) {\n        virDomainChrDefPtr chr = def->serials[i];\n\n        if (chr->targetType != VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_PCI ||\n            !virDeviceInfoPCIAddressIsWanted(&chr->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &chr->info) < 0)\n            return -1;\n    }\n    for (i = 0; i < def->nchannels; i++) {\n        /* Nada - none are PCI based (yet) */\n    }\n    for (i = 0; i < def->nhubs; i++) {\n        /* Nada - none are PCI based (yet) */\n    }\n\n    if (def->vsock &&\n        virDeviceInfoPCIAddressIsWanted(&def->vsock->info)) {\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                &def->vsock->info) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignDevicePCISlots(virDomainDefPtr def,\n                               virQEMUCapsPtr qemuCaps,\n                               virDomainPCIAddressSetPtr addrs)\n{\n    size_t i, j;\n\n    /* PCI controllers */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI) {\n            virDomainControllerModelPCI model = cont->model;\n\n            if (model == VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT ||\n                model == VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT ||\n                !virDeviceInfoPCIAddressIsWanted(&cont->info))\n                continue;\n\n            if (qemuDomainPCIAddressReserveNextAddr(addrs, &cont->info) < 0)\n                return -1;\n        }\n    }\n\n    for (i = 0; i < def->nfss; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->fss[i]->info))\n            continue;\n\n        /* Only support VirtIO-9p-pci so far. If that changes,\n         * we might need to skip devices here */\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->fss[i]->info) < 0)\n            return -1;\n    }\n\n    /* Network interfaces */\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n\n        /* type='hostdev' network devices might be USB, and are also\n         * in hostdevs list anyway, so handle them with other hostdevs\n         * instead of here.\n         */\n        if ((net->type == VIR_DOMAIN_NET_TYPE_HOSTDEV) ||\n            !virDeviceInfoPCIAddressIsWanted(&net->info)) {\n            continue;\n        }\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &net->info) < 0)\n            return -1;\n    }\n\n    /* Sound cards */\n    for (i = 0; i < def->nsounds; i++) {\n        virDomainSoundDefPtr sound = def->sounds[i];\n\n        if (!virDeviceInfoPCIAddressIsWanted(&sound->info))\n            continue;\n\n        /* Skip ISA sound card, PCSPK and usb-audio */\n        if (sound->model == VIR_DOMAIN_SOUND_MODEL_SB16 ||\n            sound->model == VIR_DOMAIN_SOUND_MODEL_PCSPK ||\n            sound->model == VIR_DOMAIN_SOUND_MODEL_USB) {\n            continue;\n        }\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &sound->info) < 0)\n            return -1;\n    }\n\n    /* Device controllers (SCSI, USB, but not IDE, FDC or CCID) */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        /* PCI controllers have been dealt with earlier */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI)\n            continue;\n\n        /* USB controller model 'none' doesn't need a PCI address */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB &&\n            cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE)\n            continue;\n\n        /* FDC lives behind the ISA bridge; CCID is a usb device */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_FDC ||\n            cont->type == VIR_DOMAIN_CONTROLLER_TYPE_CCID)\n            continue;\n\n        /* First IDE controller lives on the PIIX3 at slot=1, function=1,\n           dealt with earlier on */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_IDE &&\n            cont->idx == 0)\n            continue;\n\n        if (!virDeviceInfoPCIAddressIsWanted(&cont->info))\n            continue;\n\n        /* USB2 needs special handling to put all companions in the same slot */\n        if (IS_USB2_CONTROLLER(cont)) {\n            virPCIDeviceAddress addr = {0};\n            bool foundAddr = false;\n\n            for (j = 0; j < def->ncontrollers; j++) {\n                if (IS_USB2_CONTROLLER(def->controllers[j]) &&\n                    def->controllers[j]->idx == cont->idx &&\n                    virDeviceInfoPCIAddressIsPresent(&def->controllers[j]->info)) {\n                    addr = def->controllers[j]->info.addr.pci;\n                    foundAddr = true;\n                    break;\n                }\n            }\n\n            switch (cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_EHCI1:\n                addr.function = 7;\n                addr.multi = VIR_TRISTATE_SWITCH_ABSENT;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1:\n                addr.function = 0;\n                addr.multi = VIR_TRISTATE_SWITCH_ON;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI2:\n                addr.function = 1;\n                addr.multi = VIR_TRISTATE_SWITCH_ABSENT;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI3:\n                addr.function = 2;\n                addr.multi = VIR_TRISTATE_SWITCH_ABSENT;\n                break;\n            }\n\n            if (foundAddr) {\n                /* Reserve this function on the slot we found */\n                if (virDomainPCIAddressReserveAddr(addrs, &addr,\n                                                   cont->info.pciConnectFlags,\n                                                   cont->info.isolationGroup) < 0) {\n                    return -1;\n                }\n\n                cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                cont->info.addr.pci = addr;\n            } else {\n                /* This is the first part of the controller, so need\n                 * to find a free slot & then reserve this function */\n                if (virDomainPCIAddressReserveNextAddr(addrs, &cont->info,\n                                                       cont->info.pciConnectFlags,\n                                                       addr.function) < 0) {\n                    return -1;\n                }\n\n                cont->info.addr.pci.multi = addr.multi;\n            }\n        } else {\n            if (qemuDomainPCIAddressReserveNextAddr(addrs, &cont->info) < 0)\n                 return -1;\n        }\n    }\n\n    /* Disks (VirtIO only for now) */\n    for (i = 0; i < def->ndisks; i++) {\n        /* Only VirtIO disks use PCI addrs */\n        if (def->disks[i]->bus != VIR_DOMAIN_DISK_BUS_VIRTIO)\n            continue;\n\n        /* don't touch s390 devices */\n        if (virDeviceInfoPCIAddressIsPresent(&def->disks[i]->info) ||\n            def->disks[i]->info.type ==\n            VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_S390 ||\n            def->disks[i]->info.type ==\n            VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW)\n            continue;\n\n        /* Also ignore virtio-mmio disks if our machine allows them */\n        if (def->disks[i]->info.type ==\n            VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_MMIO &&\n            virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIRTIO_MMIO))\n            continue;\n\n        if (!virDeviceInfoPCIAddressIsWanted(&def->disks[i]->info)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"virtio disk cannot have an address of type '%s'\"),\n                           virDomainDeviceAddressTypeToString(def->disks[i]->info.type));\n            return -1;\n        }\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->disks[i]->info) < 0)\n            return -1;\n    }\n\n    /* Host PCI devices */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevSubsysPtr subsys = &def->hostdevs[i]->source.subsys;\n        if (!virDeviceInfoPCIAddressIsWanted(def->hostdevs[i]->info))\n            continue;\n        if (def->hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (subsys->type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n            subsys->type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST &&\n            !(subsys->type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV &&\n              subsys->u.mdev.model == VIR_MDEV_MODEL_TYPE_VFIO_PCI)) {\n            continue;\n        }\n\n        /* do not reserve address for info->type='unassigned' */\n        if (def->hostdevs[i]->info->type ==\n            VIR_DOMAIN_DEVICE_ADDRESS_TYPE_UNASSIGNED)\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                def->hostdevs[i]->info) < 0)\n            return -1;\n    }\n\n    /* memballoon. the qemu driver only accepts virtio memballoon devices */\n    if (virDomainDefHasMemballoon(def) &&\n        virDeviceInfoPCIAddressIsWanted(&def->memballoon->info)) {\n        if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                &def->memballoon->info) < 0)\n            return -1;\n    }\n\n    /* the qemu driver only accepts virtio rng devices */\n    for (i = 0; i < def->nrngs; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->rngs[i]->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->rngs[i]->info) < 0)\n            return -1;\n    }\n\n    /* A watchdog - check if it is a PCI device */\n    if (def->watchdog &&\n        def->watchdog->model == VIR_DOMAIN_WATCHDOG_MODEL_I6300ESB &&\n        virDeviceInfoPCIAddressIsWanted(&def->watchdog->info)) {\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->watchdog->info) < 0)\n            return -1;\n    }\n\n    /* Video devices */\n    for (i = 0; i < def->nvideos; i++) {\n        if (def->videos[i]->type == VIR_DOMAIN_VIDEO_TYPE_NONE ||\n            def->videos[i]->type == VIR_DOMAIN_VIDEO_TYPE_RAMFB)\n            continue;\n\n        if (!virDeviceInfoPCIAddressIsWanted(&def->videos[i]->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->videos[i]->info) < 0)\n            return -1;\n    }\n\n    /* Shared Memory */\n    for (i = 0; i < def->nshmems; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->shmems[i]->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->shmems[i]->info) < 0)\n            return -1;\n    }\n    for (i = 0; i < def->ninputs; i++) {\n        if (def->inputs[i]->bus != VIR_DOMAIN_INPUT_BUS_VIRTIO ||\n            !virDeviceInfoPCIAddressIsWanted(&def->inputs[i]->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->inputs[i]->info) < 0)\n            return -1;\n    }\n    for (i = 0; i < def->nparallels; i++) {\n        /* Nada - none are PCI based (yet) */\n    }\n    for (i = 0; i < def->nserials; i++) {\n        virDomainChrDefPtr chr = def->serials[i];\n\n        if (chr->targetType != VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_PCI ||\n            !virDeviceInfoPCIAddressIsWanted(&chr->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &chr->info) < 0)\n            return -1;\n    }\n    for (i = 0; i < def->nchannels; i++) {\n        /* Nada - none are PCI based (yet) */\n    }\n    for (i = 0; i < def->nhubs; i++) {\n        /* Nada - none are PCI based (yet) */\n    }\n\n    if (def->vsock &&\n        virDeviceInfoPCIAddressIsWanted(&def->vsock->info)) {\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                &def->vsock->info) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainValidateDevicePCISlotsChipsets",
          "args": [
            "def",
            "qemuCaps",
            "addrs"
          ],
          "line": 2786
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainValidateDevicePCISlotsChipsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "2082-2098",
          "snippet": "static int\nqemuDomainValidateDevicePCISlotsChipsets(virDomainDefPtr def,\n                                         virQEMUCapsPtr qemuCaps,\n                                         virDomainPCIAddressSetPtr addrs)\n{\n    if (qemuDomainIsI440FX(def) &&\n        qemuDomainValidateDevicePCISlotsPIIX3(def, qemuCaps, addrs) < 0) {\n        return -1;\n    }\n\n    if (qemuDomainIsQ35(def) &&\n        qemuDomainValidateDevicePCISlotsQ35(def, qemuCaps, addrs) < 0) {\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainValidateDevicePCISlotsChipsets(virDomainDefPtr def,\n                                         virQEMUCapsPtr qemuCaps,\n                                         virDomainPCIAddressSetPtr addrs)\n{\n    if (qemuDomainIsI440FX(def) &&\n        qemuDomainValidateDevicePCISlotsPIIX3(def, qemuCaps, addrs) < 0) {\n        return -1;\n    }\n\n    if (qemuDomainIsQ35(def) &&\n        qemuDomainValidateDevicePCISlotsQ35(def, qemuCaps, addrs) < 0) {\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainSupportsPCI",
          "args": [
            "def",
            "qemuCaps"
          ],
          "line": 2785
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainSupportsPCI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12963-12984",
          "snippet": "bool\nqemuDomainSupportsPCI(virDomainDefPtr def,\n                      virQEMUCapsPtr qemuCaps)\n{\n    if (def->os.arch != VIR_ARCH_ARMV6L &&\n        def->os.arch != VIR_ARCH_ARMV7L &&\n        def->os.arch != VIR_ARCH_AARCH64 &&\n        !ARCH_IS_RISCV(def->os.arch)) {\n        return true;\n    }\n\n    if (STREQ(def->os.machine, \"versatilepb\"))\n        return true;\n\n    if ((qemuDomainIsARMVirt(def) ||\n         qemuDomainIsRISCVVirt(def)) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_OBJECT_GPEX)) {\n        return true;\n    }\n\n    return false;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainSupportsPCI(virDomainDefPtr def,\n                      virQEMUCapsPtr qemuCaps)\n{\n    if (def->os.arch != VIR_ARCH_ARMV6L &&\n        def->os.arch != VIR_ARCH_ARMV7L &&\n        def->os.arch != VIR_ARCH_AARCH64 &&\n        !ARCH_IS_RISCV(def->os.arch)) {\n        return true;\n    }\n\n    if (STREQ(def->os.machine, \"versatilepb\"))\n        return true;\n\n    if ((qemuDomainIsARMVirt(def) ||\n         qemuDomainIsRISCVVirt(def)) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_OBJECT_GPEX)) {\n        return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainPCIAddressSetCreate",
          "args": [
            "def",
            "qemuCaps",
            "nbuses",
            "false"
          ],
          "line": 2782
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainPCIAddressSetCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "1625-1727",
          "snippet": "static virDomainPCIAddressSetPtr\nqemuDomainPCIAddressSetCreate(virDomainDefPtr def,\n                              virQEMUCapsPtr qemuCaps,\n                              unsigned int nbuses,\n                              bool dryRun)\n{\n    virDomainPCIAddressSetPtr addrs;\n    size_t i;\n    bool hasPCIeRoot = false;\n    virDomainControllerModelPCI defaultModel;\n    virPCIDeviceAddressExtensionFlags extFlags = VIR_PCI_ADDRESS_EXTENSION_NONE;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_ZPCI))\n        extFlags |= VIR_PCI_ADDRESS_EXTENSION_ZPCI;\n\n    if ((addrs = virDomainPCIAddressSetAlloc(nbuses, extFlags)) == NULL)\n        return NULL;\n\n    addrs->dryRun = dryRun;\n\n    /* pSeries domains support multiple pci-root controllers */\n    if (qemuDomainIsPSeries(def))\n        addrs->areMultipleRootsSupported = true;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_PCIE_PCI_BRIDGE))\n        addrs->isPCIeToPCIBridgeSupported = true;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        size_t idx = cont->idx;\n\n        if (cont->type != VIR_DOMAIN_CONTROLLER_TYPE_PCI)\n            continue;\n\n        if (idx >= addrs->nbuses) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Inappropriate new pci controller index %zu \"\n                             \"exceeds addrs array length\"), idx);\n            goto error;\n        }\n\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[idx], cont->model) < 0)\n            goto error;\n\n        /* Forward the information about isolation groups */\n        addrs->buses[idx].isolationGroup = cont->info.isolationGroup;\n        addrs->buses[idx].isolationGroupLocked = cont->info.isolationGroupLocked;\n\n        if (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT)\n            hasPCIeRoot = true;\n    }\n\n    if (nbuses > 0 && !addrs->buses[0].model) {\n        /* This is just here to replicate a safety measure already in\n         * an older version of this code. In practice, the root bus\n         * should have already been added at index 0 prior to\n         * assigning addresses to devices.\n         */\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[0],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT) < 0)\n            goto error;\n    }\n\n    /* Now fill in a reasonable model for all the buses in the set\n     * that don't yet have a corresponding controller in the domain\n     * config.\n     */\n    if (qemuDomainIsPSeries(def)) {\n        /* pSeries guests should use PHBs (pci-root controllers) */\n        defaultModel = VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT;\n    } else if (hasPCIeRoot) {\n        defaultModel = VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT;\n    } else {\n        defaultModel = VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE;\n    }\n\n    for (i = 1; i < addrs->nbuses; i++) {\n\n        if (addrs->buses[i].model)\n            continue;\n\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i], defaultModel) < 0)\n            goto error;\n\n        VIR_DEBUG(\"Auto-adding <controller type='pci' model='%s' index='%zu'/>\",\n                  virDomainControllerModelPCITypeToString(defaultModel), i);\n    }\n\n    if (virDomainDeviceInfoIterate(def, qemuDomainCollectPCIAddress, addrs) < 0)\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def,\n                                   qemuDomainCollectPCIAddressExtension,\n                                   addrs) < 0) {\n        goto error;\n    }\n\n    return addrs;\n\n error:\n    virDomainPCIAddressSetFree(addrs);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic virDomainPCIAddressSetPtr\nqemuDomainPCIAddressSetCreate(virDomainDefPtr def,\n                              virQEMUCapsPtr qemuCaps,\n                              unsigned int nbuses,\n                              bool dryRun)\n{\n    virDomainPCIAddressSetPtr addrs;\n    size_t i;\n    bool hasPCIeRoot = false;\n    virDomainControllerModelPCI defaultModel;\n    virPCIDeviceAddressExtensionFlags extFlags = VIR_PCI_ADDRESS_EXTENSION_NONE;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_ZPCI))\n        extFlags |= VIR_PCI_ADDRESS_EXTENSION_ZPCI;\n\n    if ((addrs = virDomainPCIAddressSetAlloc(nbuses, extFlags)) == NULL)\n        return NULL;\n\n    addrs->dryRun = dryRun;\n\n    /* pSeries domains support multiple pci-root controllers */\n    if (qemuDomainIsPSeries(def))\n        addrs->areMultipleRootsSupported = true;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_PCIE_PCI_BRIDGE))\n        addrs->isPCIeToPCIBridgeSupported = true;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        size_t idx = cont->idx;\n\n        if (cont->type != VIR_DOMAIN_CONTROLLER_TYPE_PCI)\n            continue;\n\n        if (idx >= addrs->nbuses) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Inappropriate new pci controller index %zu \"\n                             \"exceeds addrs array length\"), idx);\n            goto error;\n        }\n\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[idx], cont->model) < 0)\n            goto error;\n\n        /* Forward the information about isolation groups */\n        addrs->buses[idx].isolationGroup = cont->info.isolationGroup;\n        addrs->buses[idx].isolationGroupLocked = cont->info.isolationGroupLocked;\n\n        if (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT)\n            hasPCIeRoot = true;\n    }\n\n    if (nbuses > 0 && !addrs->buses[0].model) {\n        /* This is just here to replicate a safety measure already in\n         * an older version of this code. In practice, the root bus\n         * should have already been added at index 0 prior to\n         * assigning addresses to devices.\n         */\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[0],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT) < 0)\n            goto error;\n    }\n\n    /* Now fill in a reasonable model for all the buses in the set\n     * that don't yet have a corresponding controller in the domain\n     * config.\n     */\n    if (qemuDomainIsPSeries(def)) {\n        /* pSeries guests should use PHBs (pci-root controllers) */\n        defaultModel = VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT;\n    } else if (hasPCIeRoot) {\n        defaultModel = VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT;\n    } else {\n        defaultModel = VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE;\n    }\n\n    for (i = 1; i < addrs->nbuses; i++) {\n\n        if (addrs->buses[i].model)\n            continue;\n\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i], defaultModel) < 0)\n            goto error;\n\n        VIR_DEBUG(\"Auto-adding <controller type='pci' model='%s' index='%zu'/>\",\n                  virDomainControllerModelPCITypeToString(defaultModel), i);\n    }\n\n    if (virDomainDeviceInfoIterate(def, qemuDomainCollectPCIAddress, addrs) < 0)\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def,\n                                   qemuDomainCollectPCIAddressExtension,\n                                   addrs) < 0) {\n        goto error;\n    }\n\n    return addrs;\n\n error:\n    virDomainPCIAddressSetFree(addrs);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainPCIAddressReserveNextAddr",
          "args": [
            "addrs",
            "&dev.data.controller->info"
          ],
          "line": 2771
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainPCIAddressReserveNextAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "1484-1490",
          "snippet": "static int\nqemuDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                    virDomainDeviceInfoPtr dev)\n{\n    return virDomainPCIAddressReserveNextAddr(addrs, dev,\n                                              dev->pciConnectFlags, -1);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                    virDomainDeviceInfoPtr dev)\n{\n    return virDomainPCIAddressReserveNextAddr(addrs, dev,\n                                              dev->pciConnectFlags, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainFillDevicePCIConnectFlags",
          "args": [
            "def",
            "&dev",
            "qemuCaps",
            "driver"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainFillDevicePCIConnectFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "1433-1460",
          "snippet": "static void\nqemuDomainFillDevicePCIConnectFlags(virDomainDefPtr def,\n                                    virDomainDeviceDefPtr dev,\n                                    virQEMUCapsPtr qemuCaps,\n                                    virQEMUDriverPtr driver)\n{\n    virDomainDeviceInfoPtr info = virDomainDeviceGetInfo(dev);\n\n    if (info) {\n        /* qemuDomainDeviceCalculatePCIConnectFlags() is called with\n         * the data setup in the ...IterData by ...IterInit() rather\n         * than setting the values directly here.  It may seem like\n         * pointless posturing, but it's done this way to eliminate\n         * duplicated setup code while allowing more efficient\n         * operation when it's being done repeatedly with the device\n         * iterator (since qemuDomainFillAllPCIConnectFlags() only\n         * calls ...IterInit() once for all devices).\n         */\n        qemuDomainFillDevicePCIConnectFlagsIterData data;\n\n        qemuDomainFillDevicePCIConnectFlagsIterInit(def, qemuCaps, driver, &data);\n\n        info->pciConnectFlags\n            = qemuDomainDeviceCalculatePCIConnectFlags(dev, data.driver,\n                                                       data.pcieFlags,\n                                                       data.virtioFlags);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic void\nqemuDomainFillDevicePCIConnectFlags(virDomainDefPtr def,\n                                    virDomainDeviceDefPtr dev,\n                                    virQEMUCapsPtr qemuCaps,\n                                    virQEMUDriverPtr driver)\n{\n    virDomainDeviceInfoPtr info = virDomainDeviceGetInfo(dev);\n\n    if (info) {\n        /* qemuDomainDeviceCalculatePCIConnectFlags() is called with\n         * the data setup in the ...IterData by ...IterInit() rather\n         * than setting the values directly here.  It may seem like\n         * pointless posturing, but it's done this way to eliminate\n         * duplicated setup code while allowing more efficient\n         * operation when it's being done repeatedly with the device\n         * iterator (since qemuDomainFillAllPCIConnectFlags() only\n         * calls ...IterInit() once for all devices).\n         */\n        qemuDomainFillDevicePCIConnectFlagsIterData data;\n\n        qemuDomainFillDevicePCIConnectFlagsIterInit(def, qemuCaps, driver, &data);\n\n        info->pciConnectFlags\n            = qemuDomainDeviceCalculatePCIConnectFlags(dev, data.driver,\n                                                       data.pcieFlags,\n                                                       data.virtioFlags);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not find auto-added %s controller \"\n                                 \"with index %zu\")",
            "virDomainControllerModelPCITypeToString(bus->model)",
            "i"
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainControllerModelPCITypeToString",
          "args": [
            "bus->model"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainControllerFind",
          "args": [
            "def",
            "VIR_DOMAIN_CONTROLLER_TYPE_PCI",
            "i"
          ],
          "line": 2749
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainControllerFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17803-17818",
          "snippet": "int\nvirDomainControllerFind(const virDomainDef *def,\n                        int type,\n                        int idx)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if ((def->controllers[i]->type == type) &&\n            (def->controllers[i]->idx == idx)) {\n            return i;\n        }\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainControllerFind(const virDomainDef *def,\n                        int type,\n                        int idx)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if ((def->controllers[i]->type == type) &&\n            (def->controllers[i]->idx == idx)) {\n            return i;\n        }\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefMaybeAddController",
          "args": [
            "def",
            "VIR_DOMAIN_CONTROLLER_TYPE_PCI",
            "i",
            "bus->model"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefMaybeAddController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "19009-19024",
          "snippet": "int\nvirDomainDefMaybeAddController(virDomainDefPtr def,\n                               int type,\n                               int idx,\n                               int model)\n{\n    /* skip if a specific index was given and it is already\n     * in use for that type of controller\n     */\n    if (idx >= 0 && virDomainControllerFind(def, type, idx) >= 0)\n        return 0;\n\n    if (virDomainDefAddController(def, type, idx, model))\n        return 1;\n    return -1;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefMaybeAddController(virDomainDefPtr def,\n                               int type,\n                               int idx,\n                               int model)\n{\n    /* skip if a specific index was given and it is already\n     * in use for that type of controller\n     */\n    if (idx >= 0 && virDomainControllerFind(def, type, idx) >= 0)\n        return 0;\n\n    if (virDomainDefAddController(def, type, idx, model))\n        return 1;\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainHasPCIeRoot",
          "args": [
            "def"
          ],
          "line": 2715
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainHasPCIeRoot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12934-12946",
          "snippet": "bool\nqemuDomainHasPCIeRoot(const virDomainDef *def)\n{\n    int root = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_PCI, 0);\n\n    if (root < 0)\n        return false;\n\n    if (def->controllers[root]->model != VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT)\n        return false;\n\n    return true;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainHasPCIeRoot(const virDomainDef *def)\n{\n    int root = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_PCI, 0);\n\n    if (root < 0)\n        return false;\n\n    if (def->controllers[root]->model != VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT)\n        return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressBusIsFullyReserved",
          "args": [
            "&addrs->buses[i]"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressBusIsFullyReserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "606-617",
          "snippet": "bool\nvirDomainPCIAddressBusIsFullyReserved(virDomainPCIAddressBusPtr bus)\n{\n    size_t i;\n\n    for (i = bus->minSlot; i <= bus->maxSlot; i++) {\n        if (!bus->slot[i].functions)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainPCIAddressBusIsFullyReserved(virDomainPCIAddressBusPtr bus)\n{\n    size_t i;\n\n    for (i = bus->minSlot; i <= bus->maxSlot; i++) {\n        if (!bus->slot[i].functions)\n            return false;\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainHasPCIRoot",
          "args": [
            "def"
          ],
          "line": 2669
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainHasPCIRoot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12919-12931",
          "snippet": "bool\nqemuDomainHasPCIRoot(const virDomainDef *def)\n{\n    int root = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_PCI, 0);\n\n    if (root < 0)\n        return false;\n\n    if (def->controllers[root]->model != VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT)\n        return false;\n\n    return true;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainHasPCIRoot(const virDomainDef *def)\n{\n    int root = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_PCI, 0);\n\n    if (root < 0)\n        return false;\n\n    if (def->controllers[root]->model != VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT)\n        return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainSetupIsolationGroups",
          "args": [
            "def"
          ],
          "line": 2642
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainSetupIsolationGroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "1394-1419",
          "snippet": "static int\nqemuDomainSetupIsolationGroups(virDomainDefPtr def)\n{\n    int idx;\n\n    /* Only pSeries guests care about isolation groups at the moment */\n    if (!qemuDomainIsPSeries(def))\n        return 0;\n\n    idx = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_PCI, 0);\n    if (idx < 0)\n        return -1;\n\n    /* We want to prevent hostdevs from being plugged into the default PHB:\n     * we can make sure that doesn't happen by locking its isolation group */\n    def->controllers[idx]->info.isolationGroupLocked = true;\n\n    /* Fill in isolation groups for all other devices */\n    if (virDomainDeviceInfoIterate(def,\n                                   qemuDomainFillDeviceIsolationGroupIter,\n                                   NULL) < 0) {\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainSetupIsolationGroups(virDomainDefPtr def)\n{\n    int idx;\n\n    /* Only pSeries guests care about isolation groups at the moment */\n    if (!qemuDomainIsPSeries(def))\n        return 0;\n\n    idx = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_PCI, 0);\n    if (idx < 0)\n        return -1;\n\n    /* We want to prevent hostdevs from being plugged into the default PHB:\n     * we can make sure that doesn't happen by locking its isolation group */\n    def->controllers[idx]->info.isolationGroupLocked = true;\n\n    /* Fill in isolation groups for all other devices */\n    if (virDomainDeviceInfoIterate(def,\n                                   qemuDomainFillDeviceIsolationGroupIter,\n                                   NULL) < 0) {\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainFillAllPCIExtensionFlags",
          "args": [
            "def",
            "qemuCaps"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainFillAllPCIExtensionFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "1186-1193",
          "snippet": "static int\nqemuDomainFillAllPCIExtensionFlags(virDomainDefPtr def,\n                                   virQEMUCapsPtr qemuCaps)\n{\n    return virDomainDeviceInfoIterate(def,\n                                      qemuDomainFillDevicePCIExtensionFlagsIter,\n                                      qemuCaps);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainFillAllPCIExtensionFlags(virDomainDefPtr def,\n                                   virQEMUCapsPtr qemuCaps)\n{\n    return virDomainDeviceInfoIterate(def,\n                                      qemuDomainFillDevicePCIExtensionFlagsIter,\n                                      qemuCaps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainFillAllPCIConnectFlags",
          "args": [
            "def",
            "qemuCaps",
            "driver"
          ],
          "line": 2636
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainFillAllPCIConnectFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "1131-1143",
          "snippet": "static int\nqemuDomainFillAllPCIConnectFlags(virDomainDefPtr def,\n                                 virQEMUCapsPtr qemuCaps,\n                                 virQEMUDriverPtr driver)\n{\n    qemuDomainFillDevicePCIConnectFlagsIterData data;\n\n    qemuDomainFillDevicePCIConnectFlagsIterInit(def, qemuCaps, driver, &data);\n\n    return virDomainDeviceInfoIterate(def,\n                                      qemuDomainFillDevicePCIConnectFlagsIter,\n                                      &data);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainFillAllPCIConnectFlags(virDomainDefPtr def,\n                                 virQEMUCapsPtr qemuCaps,\n                                 virQEMUDriverPtr driver)\n{\n    qemuDomainFillDevicePCIConnectFlagsIterData data;\n\n    qemuDomainFillDevicePCIConnectFlagsIterInit(def, qemuCaps, driver, &data);\n\n    return virDomainDeviceInfoIterate(def,\n                                      qemuDomainFillDevicePCIConnectFlagsIter,\n                                      &data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignPCIAddresses(virDomainDefPtr def,\n                             virQEMUCapsPtr qemuCaps,\n                             virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    int ret = -1;\n    virDomainPCIAddressSetPtr addrs = NULL;\n    qemuDomainObjPrivatePtr priv = NULL;\n    int max_idx = -1;\n    int nbuses = 0;\n    size_t i;\n    int rv;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI) {\n            if ((int)cont->idx > max_idx)\n                max_idx = cont->idx;\n        }\n    }\n\n    nbuses = max_idx + 1;\n\n    /* set the connect type flags (pci vs. pcie) in the DeviceInfo\n     * of all devices. This will be used to pick an appropriate\n     * bus when assigning addresses.\n     */\n    if (qemuDomainFillAllPCIConnectFlags(def, qemuCaps, driver) < 0)\n        goto cleanup;\n\n    if (qemuDomainFillAllPCIExtensionFlags(def, qemuCaps) < 0)\n        goto cleanup;\n\n    if (qemuDomainSetupIsolationGroups(def) < 0)\n        goto cleanup;\n\n    if (nbuses > 0) {\n        /* 1st pass to figure out how many PCI bridges we need */\n        if (!(addrs = qemuDomainPCIAddressSetCreate(def, qemuCaps, nbuses, true)))\n            goto cleanup;\n\n        if (qemuDomainValidateDevicePCISlotsChipsets(def, qemuCaps,\n                                                     addrs) < 0)\n            goto cleanup;\n\n        /* For domains that have pci-root, reserve 1 extra slot for a\n         * (potential) bridge (for future expansion) only if buses are\n         * not fully reserved yet (if all buses are fully reserved\n         * with manually/previously assigned addresses, any attempt to\n         * reserve an extra slot would fail anyway. But if all buses\n         * are *not* fully reserved, this extra reservation might push\n         * the config to add a new pci-bridge to plug into the final\n         * available slot, thus preserving the ability to expand)\n         *\n         * We only do this for those domains that have pci-root, since\n         * those with pcie-root will usually want to expand using PCIe\n         * controllers, which we will do after assigning addresses for\n         * all *actual* devices.\n         */\n\n        if (qemuDomainHasPCIRoot(def)) {\n            /* This is a dummy info used to reserve a slot for a\n             * legacy PCI device that doesn't exist, but may in the\n             * future, e.g.  if another device is hotplugged into the\n             * domain.\n             */\n            virDomainDeviceInfo info = {\n                .pciConnectFlags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                                    VIR_PCI_CONNECT_TYPE_PCI_DEVICE),\n                .pciAddrExtFlags = VIR_PCI_ADDRESS_EXTENSION_NONE\n            };\n            bool buses_reserved = true;\n\n            for (i = 0; i < addrs->nbuses; i++) {\n                if (!virDomainPCIAddressBusIsFullyReserved(&addrs->buses[i])) {\n                    buses_reserved = false;\n                    break;\n                }\n            }\n            if (!buses_reserved &&\n                qemuDomainPCIAddressReserveNextAddr(addrs, &info) < 0)\n                goto cleanup;\n        }\n\n        if (qemuDomainAssignDevicePCISlots(def, qemuCaps, addrs) < 0)\n            goto cleanup;\n\n        if (virDomainDeviceInfoIterate(def, qemuDomainAssignPCIAddressExtension, addrs) < 0)\n            goto cleanup;\n\n        /* Only for *new* domains with pcie-root (and no other\n         * manually specified PCI controllers in the definition): If,\n         * after assigning addresses/reserving slots for all devices,\n         * we see that any extra buses have been auto-added, we\n         * understand that the application has left management of PCI\n         * addresses and controllers up to libvirt. In order to allow\n         * such applications to easily support hotplug, we will do a\n         * \"one time\" reservation of one extra PCIE|HOTPLUGGABLE\n         * slots, which should cause us to auto-add 1 extra\n         * pcie-root-port. The single slot in this root-port will be\n         * available for hotplug, or may also be used when a device is\n         * added to the config offline.\n         */\n\n        if (max_idx <= 0 &&\n            addrs->nbuses > max_idx + 1 &&\n            qemuDomainHasPCIeRoot(def)) {\n            virDomainDeviceInfo info = {\n                .pciConnectFlags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                                    VIR_PCI_CONNECT_TYPE_PCIE_DEVICE),\n                .pciAddrExtFlags = VIR_PCI_ADDRESS_EXTENSION_NONE\n            };\n\n            /* if there isn't an empty pcie-root-port, this will\n             * cause one to be added\n             */\n            if (qemuDomainPCIAddressReserveNextAddr(addrs, &info) < 0)\n               goto cleanup;\n        }\n\n        /* now reflect any controllers auto-added to addrs into the\n         * domain controllers list\n         */\n        for (i = 1; i < addrs->nbuses; i++) {\n            virDomainDeviceDef dev;\n            int contIndex;\n            virDomainPCIAddressBusPtr bus = &addrs->buses[i];\n\n            if ((rv = virDomainDefMaybeAddController(\n                     def, VIR_DOMAIN_CONTROLLER_TYPE_PCI,\n                     i, bus->model)) < 0)\n                goto cleanup;\n\n            if (rv == 0)\n                continue; /* no new controller added */\n\n            /* We did add a new controller, so we will need one more\n             * address (and we need to set the new controller's\n             * pciConnectFlags)\n             */\n            contIndex = virDomainControllerFind(def,\n                                                VIR_DOMAIN_CONTROLLER_TYPE_PCI,\n                                                i);\n            if (contIndex < 0) {\n                /* this should never happen - we just added it */\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find auto-added %s controller \"\n                                 \"with index %zu\"),\n                               virDomainControllerModelPCITypeToString(bus->model),\n                               i);\n                goto cleanup;\n            }\n            dev.type = VIR_DOMAIN_DEVICE_CONTROLLER;\n            dev.data.controller = def->controllers[contIndex];\n            /* set connect flags so it will be properly addressed */\n            qemuDomainFillDevicePCIConnectFlags(def, &dev, qemuCaps, driver);\n\n            /* Reserve an address for the controller. pci-root and pcie-root\n             * controllers don't plug into any other PCI controller, hence\n             * they should skip this step */\n            if (bus->model != VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT &&\n                bus->model != VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT &&\n                qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                    &dev.data.controller->info) < 0) {\n                goto cleanup;\n            }\n        }\n\n        nbuses = addrs->nbuses;\n        virDomainPCIAddressSetFree(addrs);\n        addrs = NULL;\n    }\n\n    if (!(addrs = qemuDomainPCIAddressSetCreate(def, qemuCaps, nbuses, false)))\n        goto cleanup;\n\n    if (qemuDomainSupportsPCI(def, qemuCaps)) {\n        if (qemuDomainValidateDevicePCISlotsChipsets(def, qemuCaps,\n                                                     addrs) < 0)\n            goto cleanup;\n\n        if (qemuDomainAssignDevicePCISlots(def, qemuCaps, addrs) < 0)\n            goto cleanup;\n\n        if (virDomainDeviceInfoIterate(def, qemuDomainAssignPCIAddressExtension, addrs) < 0)\n            goto cleanup;\n\n        /* set multi attribute for devices at function 0 of\n         * any slot that has multiple functions in use\n         */\n        virDomainPCIAddressSetAllMulti(def);\n\n        for (i = 0; i < def->ncontrollers; i++) {\n            virDomainControllerDefPtr cont = def->controllers[i];\n            int idx = cont->idx;\n            virPCIDeviceAddressPtr addr;\n            virDomainPCIControllerOptsPtr options;\n\n            if (cont->type != VIR_DOMAIN_CONTROLLER_TYPE_PCI)\n                continue;\n\n            addr = &cont->info.addr.pci;\n            options = &cont->opts.pciopts;\n\n            /* set default model name (the actual name of the\n             * device in qemu) for any controller that doesn't yet\n             * have it set.\n             */\n            qemuDomainPCIControllerSetDefaultModelName(cont, def, qemuCaps);\n\n            /* set defaults for any other auto-generated config\n             * options for this controller that haven't been\n             * specified in config.\n             */\n            switch ((virDomainControllerModelPCI)cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n                if (options->chassisNr == -1)\n                    options->chassisNr = cont->idx;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n                if (options->chassis == -1)\n                   options->chassis = cont->idx;\n                if (options->port == -1)\n                   options->port = (addr->slot << 3) + addr->function;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n                if (options->chassis == -1)\n                   options->chassis = cont->idx;\n                if (options->port == -1)\n                   options->port = addr->slot;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n                if (options->busNr == -1)\n                    options->busNr = qemuDomainAddressFindNewBusNr(def);\n                if (options->busNr == -1) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"No free busNr lower than current \"\n                                     \"lowest busNr is available to \"\n                                     \"auto-assign to bus %d. Must be \"\n                                     \"manually assigned\"),\n                                   addr->bus);\n                    goto cleanup;\n                }\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n                if (!qemuDomainIsPSeries(def))\n                    break;\n                if (options->targetIndex == -1) {\n                    if (cont->idx == 0) {\n                        /* The pci-root controller with controller index 0\n                         * must always be assigned target index 0, because\n                         * it represents the implicit PHB which is treated\n                         * differently than all other PHBs */\n                        options->targetIndex = 0;\n                    } else {\n                        /* For all other PHBs the target index doesn't need\n                         * to match the controller index or have any\n                         * particular value, really */\n                        options->targetIndex = qemuDomainAddressFindNewTargetIndex(def);\n                    }\n                }\n                if (options->targetIndex == -1) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"No usable target index found for %d\"),\n                                   addr->bus);\n                    goto cleanup;\n                }\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n            case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n                break;\n            }\n\n            /* check if every PCI bridge controller's index is larger than\n             * the bus it is placed onto\n             */\n            if (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE &&\n                idx <= addr->bus) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"PCI controller at index %d (0x%02x) has \"\n                                 \"bus='0x%02x', but index must be \"\n                                 \"larger than bus\"),\n                               idx, idx, addr->bus);\n                goto cleanup;\n            }\n        }\n    }\n\n    if (obj && obj->privateData) {\n        priv = obj->privateData;\n        /* if this is the live domain object, we persist the PCI addresses */\n        priv->pciaddrs = addrs;\n        addrs = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virDomainPCIAddressSetFree(addrs);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuDomainAddressFindNewBusNr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "2536-2604",
    "snippet": "static int\nqemuDomainAddressFindNewBusNr(virDomainDefPtr def)\n{\n    /* Try to find a nice default for busNr for a new pci-expander-bus.\n     * This is a bit tricky, since you need to satisfy the following:\n     *\n     * 1) There need to be enough unused bus numbers between busNr of this\n     *    bus and busNr of the next highest bus for the guest to assign a\n     *    unique bus number to each PCI bus that is a child of this\n     *    bus. Each PCI controller. On top of this, the pxb device (which\n     *    implements the pci-expander-bus) includes a pci-bridge within\n     *    it, and that bridge also uses one bus number (so each pxb device\n     *    requires at least 2 bus numbers).\n     *\n     * 2) There need to be enough bus numbers *below* this for all the\n     *    child controllers of the pci-expander-bus with the next lower\n     *    busNr (or the pci-root bus if there are no lower\n     *    pci-expander-buses).\n     *\n     * 3) If at all possible, we want to avoid needing to change the busNr\n     *    of a bus in the future, as that changes the guest's device ABI,\n     *    which could potentially lead to issues with a guest OS that is\n     *    picky about such things.\n     *\n     *  Due to the impossibility of predicting what might be added to the\n     *  config in the future, we can't make a foolproof choice, but since\n     *  a pci-expander-bus (pxb) has slots for 32 devices, and the only\n     *  practical use for it is to assign real devices on a particular\n     *  NUMA node in the host, it's reasonably safe to assume it should\n     *  never need any additional child buses (probably only a few of the\n     *  32 will ever be used). So for pci-expander-bus we find the lowest\n     *  existing busNr, and set this one to the current lowest - 2 (one\n     *  for the pxb, one for the intergrated pci-bridge), thus leaving the\n     *  maximum possible bus numbers available for other buses plugged\n     *  into pci-root (i.e. pci-bridges and other\n     *  pci-expander-buses). Anyone who needs more than 32 devices\n     *  descended from one pci-expander-bus should set the busNr manually\n     *  in the config.\n     *\n     *  There is room for more error checking here - in particular we\n     *  can/should determine the ultimate parent (root-bus) of each PCI\n     *  controller and determine if there is enough space for all the\n     *  buses within the current range allotted to the bus just prior to\n     *  this one.\n     */\n\n    size_t i;\n    int lowestBusNr = 256;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI) {\n            int thisBusNr = cont->opts.pciopts.busNr;\n\n            if (thisBusNr >= 0 && thisBusNr < lowestBusNr)\n                lowestBusNr = thisBusNr;\n        }\n    }\n\n    /* If we already have a busNR = 1, then we can't auto-assign (0 is\n     * the pci[e]-root, and the others may have been assigned\n     * purposefully).\n     */\n    if (lowestBusNr <= 2)\n        return -1;\n\n    return lowestBusNr - 2;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAddressFindNewBusNr(virDomainDefPtr def)\n{\n    /* Try to find a nice default for busNr for a new pci-expander-bus.\n     * This is a bit tricky, since you need to satisfy the following:\n     *\n     * 1) There need to be enough unused bus numbers between busNr of this\n     *    bus and busNr of the next highest bus for the guest to assign a\n     *    unique bus number to each PCI bus that is a child of this\n     *    bus. Each PCI controller. On top of this, the pxb device (which\n     *    implements the pci-expander-bus) includes a pci-bridge within\n     *    it, and that bridge also uses one bus number (so each pxb device\n     *    requires at least 2 bus numbers).\n     *\n     * 2) There need to be enough bus numbers *below* this for all the\n     *    child controllers of the pci-expander-bus with the next lower\n     *    busNr (or the pci-root bus if there are no lower\n     *    pci-expander-buses).\n     *\n     * 3) If at all possible, we want to avoid needing to change the busNr\n     *    of a bus in the future, as that changes the guest's device ABI,\n     *    which could potentially lead to issues with a guest OS that is\n     *    picky about such things.\n     *\n     *  Due to the impossibility of predicting what might be added to the\n     *  config in the future, we can't make a foolproof choice, but since\n     *  a pci-expander-bus (pxb) has slots for 32 devices, and the only\n     *  practical use for it is to assign real devices on a particular\n     *  NUMA node in the host, it's reasonably safe to assume it should\n     *  never need any additional child buses (probably only a few of the\n     *  32 will ever be used). So for pci-expander-bus we find the lowest\n     *  existing busNr, and set this one to the current lowest - 2 (one\n     *  for the pxb, one for the intergrated pci-bridge), thus leaving the\n     *  maximum possible bus numbers available for other buses plugged\n     *  into pci-root (i.e. pci-bridges and other\n     *  pci-expander-buses). Anyone who needs more than 32 devices\n     *  descended from one pci-expander-bus should set the busNr manually\n     *  in the config.\n     *\n     *  There is room for more error checking here - in particular we\n     *  can/should determine the ultimate parent (root-bus) of each PCI\n     *  controller and determine if there is enough space for all the\n     *  buses within the current range allotted to the bus just prior to\n     *  this one.\n     */\n\n    size_t i;\n    int lowestBusNr = 256;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI) {\n            int thisBusNr = cont->opts.pciopts.busNr;\n\n            if (thisBusNr >= 0 && thisBusNr < lowestBusNr)\n                lowestBusNr = thisBusNr;\n        }\n    }\n\n    /* If we already have a busNR = 1, then we can't auto-assign (0 is\n     * the pci[e]-root, and the others may have been assigned\n     * purposefully).\n     */\n    if (lowestBusNr <= 2)\n        return -1;\n\n    return lowestBusNr - 2;\n}"
  },
  {
    "function_name": "qemuDomainAddressFindNewTargetIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "2497-2533",
    "snippet": "static int\nqemuDomainAddressFindNewTargetIndex(virDomainDefPtr def)\n{\n    int targetIndex;\n    int ret = -1;\n\n    /* Try all indexes between 1 and 31 - QEMU only supports 32\n     * PHBs, and 0 is reserved for the default, implicit one */\n    for (targetIndex = 1; targetIndex <= 31; targetIndex++) {\n        bool found = false;\n        size_t i;\n\n        for (i = 0; i < def->ncontrollers; i++) {\n            virDomainControllerDefPtr cont = def->controllers[i];\n\n            /* Skip everything but PHBs */\n            if (!virDomainControllerIsPSeriesPHB(cont))\n                continue;\n\n            /* Stop looking as soon as we find a PHB that's\n             * already using this specific target index */\n            if (cont->opts.pciopts.targetIndex == targetIndex) {\n                found = true;\n                break;\n            }\n        }\n\n        /* If no existing PCI controller uses this index, great,\n         * it means it's free and we can return it to the caller */\n        if (!found) {\n            ret = targetIndex;\n            break;\n        }\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainControllerIsPSeriesPHB",
          "args": [
            "cont"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainControllerIsPSeriesPHB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2283-2301",
          "snippet": "bool\nvirDomainControllerIsPSeriesPHB(const virDomainControllerDef *cont)\n{\n    virDomainControllerPCIModelName name;\n\n    /* PHBs are pci-root controllers */\n    if (cont->type != VIR_DOMAIN_CONTROLLER_TYPE_PCI ||\n        cont->model != VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT) {\n        return false;\n    }\n\n    name = cont->opts.pciopts.modelName;\n\n    /* The actual device used for PHBs is spapr-pci-host-bridge */\n    if (name != VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_SPAPR_PCI_HOST_BRIDGE)\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainControllerIsPSeriesPHB(const virDomainControllerDef *cont)\n{\n    virDomainControllerPCIModelName name;\n\n    /* PHBs are pci-root controllers */\n    if (cont->type != VIR_DOMAIN_CONTROLLER_TYPE_PCI ||\n        cont->model != VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT) {\n        return false;\n    }\n\n    name = cont->opts.pciopts.modelName;\n\n    /* The actual device used for PHBs is spapr-pci-host-bridge */\n    if (name != VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_SPAPR_PCI_HOST_BRIDGE)\n        return false;\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAddressFindNewTargetIndex(virDomainDefPtr def)\n{\n    int targetIndex;\n    int ret = -1;\n\n    /* Try all indexes between 1 and 31 - QEMU only supports 32\n     * PHBs, and 0 is reserved for the default, implicit one */\n    for (targetIndex = 1; targetIndex <= 31; targetIndex++) {\n        bool found = false;\n        size_t i;\n\n        for (i = 0; i < def->ncontrollers; i++) {\n            virDomainControllerDefPtr cont = def->controllers[i];\n\n            /* Skip everything but PHBs */\n            if (!virDomainControllerIsPSeriesPHB(cont))\n                continue;\n\n            /* Stop looking as soon as we find a PHB that's\n             * already using this specific target index */\n            if (cont->opts.pciopts.targetIndex == targetIndex) {\n                found = true;\n                break;\n            }\n        }\n\n        /* If no existing PCI controller uses this index, great,\n         * it means it's free and we can return it to the caller */\n        if (!found) {\n            ret = targetIndex;\n            break;\n        }\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuDomainPCIControllerSetDefaultModelName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "2435-2485",
    "snippet": "static void\nqemuDomainPCIControllerSetDefaultModelName(virDomainControllerDefPtr cont,\n                                           virDomainDefPtr def,\n                                           virQEMUCapsPtr qemuCaps)\n{\n    int *modelName = &cont->opts.pciopts.modelName;\n\n    /* make sure it's not already set */\n    if (*modelName != VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_NONE)\n        return;\n\n    switch ((virDomainControllerModelPCI)cont->model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PCI_BRIDGE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_I82801B11_BRIDGE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PCIE_PCI_BRIDGE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n        /* Use generic PCIe Root Ports if available, falling back to\n         * ioh3420 otherwise */\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_PCIE_ROOT_PORT))\n            *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PCIE_ROOT_PORT;\n        else\n            *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_IOH3420;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_X3130_UPSTREAM;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_XIO3130_DOWNSTREAM;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PXB;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PXB_PCIE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n        if (qemuDomainIsPSeries(def))\n            *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_SPAPR_PCI_HOST_BRIDGE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n        break;\n    }\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainIsPSeries",
          "args": [
            "def"
          ],
          "line": 2477
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainIsPSeries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12912-12916",
          "snippet": "bool\nqemuDomainIsPSeries(const virDomainDef *def)\n{\n    return qemuDomainMachineIsPSeries(def->os.machine, def->os.arch);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainIsPSeries(const virDomainDef *def)\n{\n    return qemuDomainMachineIsPSeries(def->os.machine, def->os.arch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_DEVICE_PCIE_ROOT_PORT"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic void\nqemuDomainPCIControllerSetDefaultModelName(virDomainControllerDefPtr cont,\n                                           virDomainDefPtr def,\n                                           virQEMUCapsPtr qemuCaps)\n{\n    int *modelName = &cont->opts.pciopts.modelName;\n\n    /* make sure it's not already set */\n    if (*modelName != VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_NONE)\n        return;\n\n    switch ((virDomainControllerModelPCI)cont->model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PCI_BRIDGE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_I82801B11_BRIDGE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PCIE_PCI_BRIDGE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n        /* Use generic PCIe Root Ports if available, falling back to\n         * ioh3420 otherwise */\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_PCIE_ROOT_PORT))\n            *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PCIE_ROOT_PORT;\n        else\n            *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_IOH3420;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_X3130_UPSTREAM;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_XIO3130_DOWNSTREAM;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PXB;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n        *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_PXB_PCIE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n        if (qemuDomainIsPSeries(def))\n            *modelName = VIR_DOMAIN_CONTROLLER_PCI_MODEL_NAME_SPAPR_PCI_HOST_BRIDGE;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n        break;\n    }\n}"
  },
  {
    "function_name": "qemuDomainAssignDevicePCISlots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "2137-2432",
    "snippet": "static int\nqemuDomainAssignDevicePCISlots(virDomainDefPtr def,\n                               virQEMUCapsPtr qemuCaps,\n                               virDomainPCIAddressSetPtr addrs)\n{\n    size_t i, j;\n\n    /* PCI controllers */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI) {\n            virDomainControllerModelPCI model = cont->model;\n\n            if (model == VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT ||\n                model == VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT ||\n                !virDeviceInfoPCIAddressIsWanted(&cont->info))\n                continue;\n\n            if (qemuDomainPCIAddressReserveNextAddr(addrs, &cont->info) < 0)\n                return -1;\n        }\n    }\n\n    for (i = 0; i < def->nfss; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->fss[i]->info))\n            continue;\n\n        /* Only support VirtIO-9p-pci so far. If that changes,\n         * we might need to skip devices here */\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->fss[i]->info) < 0)\n            return -1;\n    }\n\n    /* Network interfaces */\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n\n        /* type='hostdev' network devices might be USB, and are also\n         * in hostdevs list anyway, so handle them with other hostdevs\n         * instead of here.\n         */\n        if ((net->type == VIR_DOMAIN_NET_TYPE_HOSTDEV) ||\n            !virDeviceInfoPCIAddressIsWanted(&net->info)) {\n            continue;\n        }\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &net->info) < 0)\n            return -1;\n    }\n\n    /* Sound cards */\n    for (i = 0; i < def->nsounds; i++) {\n        virDomainSoundDefPtr sound = def->sounds[i];\n\n        if (!virDeviceInfoPCIAddressIsWanted(&sound->info))\n            continue;\n\n        /* Skip ISA sound card, PCSPK and usb-audio */\n        if (sound->model == VIR_DOMAIN_SOUND_MODEL_SB16 ||\n            sound->model == VIR_DOMAIN_SOUND_MODEL_PCSPK ||\n            sound->model == VIR_DOMAIN_SOUND_MODEL_USB) {\n            continue;\n        }\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &sound->info) < 0)\n            return -1;\n    }\n\n    /* Device controllers (SCSI, USB, but not IDE, FDC or CCID) */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        /* PCI controllers have been dealt with earlier */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI)\n            continue;\n\n        /* USB controller model 'none' doesn't need a PCI address */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB &&\n            cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE)\n            continue;\n\n        /* FDC lives behind the ISA bridge; CCID is a usb device */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_FDC ||\n            cont->type == VIR_DOMAIN_CONTROLLER_TYPE_CCID)\n            continue;\n\n        /* First IDE controller lives on the PIIX3 at slot=1, function=1,\n           dealt with earlier on */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_IDE &&\n            cont->idx == 0)\n            continue;\n\n        if (!virDeviceInfoPCIAddressIsWanted(&cont->info))\n            continue;\n\n        /* USB2 needs special handling to put all companions in the same slot */\n        if (IS_USB2_CONTROLLER(cont)) {\n            virPCIDeviceAddress addr = {0};\n            bool foundAddr = false;\n\n            for (j = 0; j < def->ncontrollers; j++) {\n                if (IS_USB2_CONTROLLER(def->controllers[j]) &&\n                    def->controllers[j]->idx == cont->idx &&\n                    virDeviceInfoPCIAddressIsPresent(&def->controllers[j]->info)) {\n                    addr = def->controllers[j]->info.addr.pci;\n                    foundAddr = true;\n                    break;\n                }\n            }\n\n            switch (cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_EHCI1:\n                addr.function = 7;\n                addr.multi = VIR_TRISTATE_SWITCH_ABSENT;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1:\n                addr.function = 0;\n                addr.multi = VIR_TRISTATE_SWITCH_ON;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI2:\n                addr.function = 1;\n                addr.multi = VIR_TRISTATE_SWITCH_ABSENT;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI3:\n                addr.function = 2;\n                addr.multi = VIR_TRISTATE_SWITCH_ABSENT;\n                break;\n            }\n\n            if (foundAddr) {\n                /* Reserve this function on the slot we found */\n                if (virDomainPCIAddressReserveAddr(addrs, &addr,\n                                                   cont->info.pciConnectFlags,\n                                                   cont->info.isolationGroup) < 0) {\n                    return -1;\n                }\n\n                cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                cont->info.addr.pci = addr;\n            } else {\n                /* This is the first part of the controller, so need\n                 * to find a free slot & then reserve this function */\n                if (virDomainPCIAddressReserveNextAddr(addrs, &cont->info,\n                                                       cont->info.pciConnectFlags,\n                                                       addr.function) < 0) {\n                    return -1;\n                }\n\n                cont->info.addr.pci.multi = addr.multi;\n            }\n        } else {\n            if (qemuDomainPCIAddressReserveNextAddr(addrs, &cont->info) < 0)\n                 return -1;\n        }\n    }\n\n    /* Disks (VirtIO only for now) */\n    for (i = 0; i < def->ndisks; i++) {\n        /* Only VirtIO disks use PCI addrs */\n        if (def->disks[i]->bus != VIR_DOMAIN_DISK_BUS_VIRTIO)\n            continue;\n\n        /* don't touch s390 devices */\n        if (virDeviceInfoPCIAddressIsPresent(&def->disks[i]->info) ||\n            def->disks[i]->info.type ==\n            VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_S390 ||\n            def->disks[i]->info.type ==\n            VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW)\n            continue;\n\n        /* Also ignore virtio-mmio disks if our machine allows them */\n        if (def->disks[i]->info.type ==\n            VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_MMIO &&\n            virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIRTIO_MMIO))\n            continue;\n\n        if (!virDeviceInfoPCIAddressIsWanted(&def->disks[i]->info)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"virtio disk cannot have an address of type '%s'\"),\n                           virDomainDeviceAddressTypeToString(def->disks[i]->info.type));\n            return -1;\n        }\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->disks[i]->info) < 0)\n            return -1;\n    }\n\n    /* Host PCI devices */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevSubsysPtr subsys = &def->hostdevs[i]->source.subsys;\n        if (!virDeviceInfoPCIAddressIsWanted(def->hostdevs[i]->info))\n            continue;\n        if (def->hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (subsys->type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n            subsys->type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST &&\n            !(subsys->type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV &&\n              subsys->u.mdev.model == VIR_MDEV_MODEL_TYPE_VFIO_PCI)) {\n            continue;\n        }\n\n        /* do not reserve address for info->type='unassigned' */\n        if (def->hostdevs[i]->info->type ==\n            VIR_DOMAIN_DEVICE_ADDRESS_TYPE_UNASSIGNED)\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                def->hostdevs[i]->info) < 0)\n            return -1;\n    }\n\n    /* memballoon. the qemu driver only accepts virtio memballoon devices */\n    if (virDomainDefHasMemballoon(def) &&\n        virDeviceInfoPCIAddressIsWanted(&def->memballoon->info)) {\n        if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                &def->memballoon->info) < 0)\n            return -1;\n    }\n\n    /* the qemu driver only accepts virtio rng devices */\n    for (i = 0; i < def->nrngs; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->rngs[i]->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->rngs[i]->info) < 0)\n            return -1;\n    }\n\n    /* A watchdog - check if it is a PCI device */\n    if (def->watchdog &&\n        def->watchdog->model == VIR_DOMAIN_WATCHDOG_MODEL_I6300ESB &&\n        virDeviceInfoPCIAddressIsWanted(&def->watchdog->info)) {\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->watchdog->info) < 0)\n            return -1;\n    }\n\n    /* Video devices */\n    for (i = 0; i < def->nvideos; i++) {\n        if (def->videos[i]->type == VIR_DOMAIN_VIDEO_TYPE_NONE ||\n            def->videos[i]->type == VIR_DOMAIN_VIDEO_TYPE_RAMFB)\n            continue;\n\n        if (!virDeviceInfoPCIAddressIsWanted(&def->videos[i]->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->videos[i]->info) < 0)\n            return -1;\n    }\n\n    /* Shared Memory */\n    for (i = 0; i < def->nshmems; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->shmems[i]->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->shmems[i]->info) < 0)\n            return -1;\n    }\n    for (i = 0; i < def->ninputs; i++) {\n        if (def->inputs[i]->bus != VIR_DOMAIN_INPUT_BUS_VIRTIO ||\n            !virDeviceInfoPCIAddressIsWanted(&def->inputs[i]->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->inputs[i]->info) < 0)\n            return -1;\n    }\n    for (i = 0; i < def->nparallels; i++) {\n        /* Nada - none are PCI based (yet) */\n    }\n    for (i = 0; i < def->nserials; i++) {\n        virDomainChrDefPtr chr = def->serials[i];\n\n        if (chr->targetType != VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_PCI ||\n            !virDeviceInfoPCIAddressIsWanted(&chr->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &chr->info) < 0)\n            return -1;\n    }\n    for (i = 0; i < def->nchannels; i++) {\n        /* Nada - none are PCI based (yet) */\n    }\n    for (i = 0; i < def->nhubs; i++) {\n        /* Nada - none are PCI based (yet) */\n    }\n\n    if (def->vsock &&\n        virDeviceInfoPCIAddressIsWanted(&def->vsock->info)) {\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                &def->vsock->info) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainPCIAddressReserveNextAddr",
          "args": [
            "addrs",
            "&def->vsock->info"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainPCIAddressReserveNextAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "1484-1490",
          "snippet": "static int\nqemuDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                    virDomainDeviceInfoPtr dev)\n{\n    return virDomainPCIAddressReserveNextAddr(addrs, dev,\n                                              dev->pciConnectFlags, -1);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                    virDomainDeviceInfoPtr dev)\n{\n    return virDomainPCIAddressReserveNextAddr(addrs, dev,\n                                              dev->pciConnectFlags, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDeviceInfoPCIAddressIsWanted",
          "args": [
            "&def->vsock->info"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "virDeviceInfoPCIAddressIsWanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "183-189",
          "snippet": "bool\nvirDeviceInfoPCIAddressIsWanted(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE ||\n           (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n            virPCIDeviceAddressIsEmpty(&info->addr.pci));\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool\nvirDeviceInfoPCIAddressIsWanted(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE ||\n           (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n            virPCIDeviceAddressIsEmpty(&info->addr.pci));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefHasMemballoon",
          "args": [
            "def"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefHasMemballoon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30883-30888",
          "snippet": "bool\nvirDomainDefHasMemballoon(const virDomainDef *def)\n{\n    return def->memballoon &&\n           def->memballoon->model != VIR_DOMAIN_MEMBALLOON_MODEL_NONE;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainDefHasMemballoon(const virDomainDef *def)\n{\n    return def->memballoon &&\n           def->memballoon->model != VIR_DOMAIN_MEMBALLOON_MODEL_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"virtio disk cannot have an address of type '%s'\")",
            "virDomainDeviceAddressTypeToString(def->disks[i]->info.type)"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDeviceAddressTypeToString",
          "args": [
            "def->disks[i]->info.type"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"virtio disk cannot have an address of type '%s'\""
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_DEVICE_VIRTIO_MMIO"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDeviceInfoPCIAddressIsPresent",
          "args": [
            "&def->disks[i]->info"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "virDeviceInfoPCIAddressIsPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "191-196",
          "snippet": "bool\nvirDeviceInfoPCIAddressIsPresent(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n           !virPCIDeviceAddressIsEmpty(&info->addr.pci);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool\nvirDeviceInfoPCIAddressIsPresent(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n           !virPCIDeviceAddressIsEmpty(&info->addr.pci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressReserveNextAddr",
          "args": [
            "addrs",
            "&cont->info",
            "cont->info.pciConnectFlags",
            "addr.function"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressReserveNextAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1260-1285",
          "snippet": "int\nvirDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                   virDomainDeviceInfoPtr dev,\n                                   virDomainPCIConnectFlags flags,\n                                   int function)\n{\n    virPCIDeviceAddress addr;\n\n    if (virDomainPCIAddressGetNextAddr(addrs, &addr, flags,\n                                       dev->isolationGroup, function) < 0)\n        return -1;\n\n    if (virDomainPCIAddressReserveAddrInternal(addrs, &addr, flags,\n                                               dev->isolationGroup, false) < 0)\n        return -1;\n\n    addr.extFlags = dev->addr.pci.extFlags;\n    addr.zpci = dev->addr.pci.zpci;\n\n    if (!addrs->dryRun) {\n        dev->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n        dev->addr.pci = addr;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                   virDomainDeviceInfoPtr dev,\n                                   virDomainPCIConnectFlags flags,\n                                   int function)\n{\n    virPCIDeviceAddress addr;\n\n    if (virDomainPCIAddressGetNextAddr(addrs, &addr, flags,\n                                       dev->isolationGroup, function) < 0)\n        return -1;\n\n    if (virDomainPCIAddressReserveAddrInternal(addrs, &addr, flags,\n                                               dev->isolationGroup, false) < 0)\n        return -1;\n\n    addr.extFlags = dev->addr.pci.extFlags;\n    addr.zpci = dev->addr.pci.zpci;\n\n    if (!addrs->dryRun) {\n        dev->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n        dev->addr.pci = addr;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressReserveAddr",
          "args": [
            "addrs",
            "&addr",
            "cont->info.pciConnectFlags",
            "cont->info.isolationGroup"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressReserveAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "895-903",
          "snippet": "int\nvirDomainPCIAddressReserveAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr,\n                               virDomainPCIConnectFlags flags,\n                               unsigned int isolationGroup)\n{\n    return virDomainPCIAddressReserveAddrInternal(addrs, addr, flags,\n                                                  isolationGroup, true);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressReserveAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr,\n                               virDomainPCIConnectFlags flags,\n                               unsigned int isolationGroup)\n{\n    return virDomainPCIAddressReserveAddrInternal(addrs, addr, flags,\n                                                  isolationGroup, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_USB2_CONTROLLER",
          "args": [
            "def->controllers[j]"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_USB2_CONTROLLER",
          "args": [
            "cont"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignDevicePCISlots(virDomainDefPtr def,\n                               virQEMUCapsPtr qemuCaps,\n                               virDomainPCIAddressSetPtr addrs)\n{\n    size_t i, j;\n\n    /* PCI controllers */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI) {\n            virDomainControllerModelPCI model = cont->model;\n\n            if (model == VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT ||\n                model == VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT ||\n                !virDeviceInfoPCIAddressIsWanted(&cont->info))\n                continue;\n\n            if (qemuDomainPCIAddressReserveNextAddr(addrs, &cont->info) < 0)\n                return -1;\n        }\n    }\n\n    for (i = 0; i < def->nfss; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->fss[i]->info))\n            continue;\n\n        /* Only support VirtIO-9p-pci so far. If that changes,\n         * we might need to skip devices here */\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->fss[i]->info) < 0)\n            return -1;\n    }\n\n    /* Network interfaces */\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n\n        /* type='hostdev' network devices might be USB, and are also\n         * in hostdevs list anyway, so handle them with other hostdevs\n         * instead of here.\n         */\n        if ((net->type == VIR_DOMAIN_NET_TYPE_HOSTDEV) ||\n            !virDeviceInfoPCIAddressIsWanted(&net->info)) {\n            continue;\n        }\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &net->info) < 0)\n            return -1;\n    }\n\n    /* Sound cards */\n    for (i = 0; i < def->nsounds; i++) {\n        virDomainSoundDefPtr sound = def->sounds[i];\n\n        if (!virDeviceInfoPCIAddressIsWanted(&sound->info))\n            continue;\n\n        /* Skip ISA sound card, PCSPK and usb-audio */\n        if (sound->model == VIR_DOMAIN_SOUND_MODEL_SB16 ||\n            sound->model == VIR_DOMAIN_SOUND_MODEL_PCSPK ||\n            sound->model == VIR_DOMAIN_SOUND_MODEL_USB) {\n            continue;\n        }\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &sound->info) < 0)\n            return -1;\n    }\n\n    /* Device controllers (SCSI, USB, but not IDE, FDC or CCID) */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        /* PCI controllers have been dealt with earlier */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_PCI)\n            continue;\n\n        /* USB controller model 'none' doesn't need a PCI address */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB &&\n            cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE)\n            continue;\n\n        /* FDC lives behind the ISA bridge; CCID is a usb device */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_FDC ||\n            cont->type == VIR_DOMAIN_CONTROLLER_TYPE_CCID)\n            continue;\n\n        /* First IDE controller lives on the PIIX3 at slot=1, function=1,\n           dealt with earlier on */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_IDE &&\n            cont->idx == 0)\n            continue;\n\n        if (!virDeviceInfoPCIAddressIsWanted(&cont->info))\n            continue;\n\n        /* USB2 needs special handling to put all companions in the same slot */\n        if (IS_USB2_CONTROLLER(cont)) {\n            virPCIDeviceAddress addr = {0};\n            bool foundAddr = false;\n\n            for (j = 0; j < def->ncontrollers; j++) {\n                if (IS_USB2_CONTROLLER(def->controllers[j]) &&\n                    def->controllers[j]->idx == cont->idx &&\n                    virDeviceInfoPCIAddressIsPresent(&def->controllers[j]->info)) {\n                    addr = def->controllers[j]->info.addr.pci;\n                    foundAddr = true;\n                    break;\n                }\n            }\n\n            switch (cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_EHCI1:\n                addr.function = 7;\n                addr.multi = VIR_TRISTATE_SWITCH_ABSENT;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1:\n                addr.function = 0;\n                addr.multi = VIR_TRISTATE_SWITCH_ON;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI2:\n                addr.function = 1;\n                addr.multi = VIR_TRISTATE_SWITCH_ABSENT;\n                break;\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI3:\n                addr.function = 2;\n                addr.multi = VIR_TRISTATE_SWITCH_ABSENT;\n                break;\n            }\n\n            if (foundAddr) {\n                /* Reserve this function on the slot we found */\n                if (virDomainPCIAddressReserveAddr(addrs, &addr,\n                                                   cont->info.pciConnectFlags,\n                                                   cont->info.isolationGroup) < 0) {\n                    return -1;\n                }\n\n                cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                cont->info.addr.pci = addr;\n            } else {\n                /* This is the first part of the controller, so need\n                 * to find a free slot & then reserve this function */\n                if (virDomainPCIAddressReserveNextAddr(addrs, &cont->info,\n                                                       cont->info.pciConnectFlags,\n                                                       addr.function) < 0) {\n                    return -1;\n                }\n\n                cont->info.addr.pci.multi = addr.multi;\n            }\n        } else {\n            if (qemuDomainPCIAddressReserveNextAddr(addrs, &cont->info) < 0)\n                 return -1;\n        }\n    }\n\n    /* Disks (VirtIO only for now) */\n    for (i = 0; i < def->ndisks; i++) {\n        /* Only VirtIO disks use PCI addrs */\n        if (def->disks[i]->bus != VIR_DOMAIN_DISK_BUS_VIRTIO)\n            continue;\n\n        /* don't touch s390 devices */\n        if (virDeviceInfoPCIAddressIsPresent(&def->disks[i]->info) ||\n            def->disks[i]->info.type ==\n            VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_S390 ||\n            def->disks[i]->info.type ==\n            VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW)\n            continue;\n\n        /* Also ignore virtio-mmio disks if our machine allows them */\n        if (def->disks[i]->info.type ==\n            VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_MMIO &&\n            virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIRTIO_MMIO))\n            continue;\n\n        if (!virDeviceInfoPCIAddressIsWanted(&def->disks[i]->info)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"virtio disk cannot have an address of type '%s'\"),\n                           virDomainDeviceAddressTypeToString(def->disks[i]->info.type));\n            return -1;\n        }\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->disks[i]->info) < 0)\n            return -1;\n    }\n\n    /* Host PCI devices */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevSubsysPtr subsys = &def->hostdevs[i]->source.subsys;\n        if (!virDeviceInfoPCIAddressIsWanted(def->hostdevs[i]->info))\n            continue;\n        if (def->hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (subsys->type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n            subsys->type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST &&\n            !(subsys->type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV &&\n              subsys->u.mdev.model == VIR_MDEV_MODEL_TYPE_VFIO_PCI)) {\n            continue;\n        }\n\n        /* do not reserve address for info->type='unassigned' */\n        if (def->hostdevs[i]->info->type ==\n            VIR_DOMAIN_DEVICE_ADDRESS_TYPE_UNASSIGNED)\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                def->hostdevs[i]->info) < 0)\n            return -1;\n    }\n\n    /* memballoon. the qemu driver only accepts virtio memballoon devices */\n    if (virDomainDefHasMemballoon(def) &&\n        virDeviceInfoPCIAddressIsWanted(&def->memballoon->info)) {\n        if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                &def->memballoon->info) < 0)\n            return -1;\n    }\n\n    /* the qemu driver only accepts virtio rng devices */\n    for (i = 0; i < def->nrngs; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->rngs[i]->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->rngs[i]->info) < 0)\n            return -1;\n    }\n\n    /* A watchdog - check if it is a PCI device */\n    if (def->watchdog &&\n        def->watchdog->model == VIR_DOMAIN_WATCHDOG_MODEL_I6300ESB &&\n        virDeviceInfoPCIAddressIsWanted(&def->watchdog->info)) {\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->watchdog->info) < 0)\n            return -1;\n    }\n\n    /* Video devices */\n    for (i = 0; i < def->nvideos; i++) {\n        if (def->videos[i]->type == VIR_DOMAIN_VIDEO_TYPE_NONE ||\n            def->videos[i]->type == VIR_DOMAIN_VIDEO_TYPE_RAMFB)\n            continue;\n\n        if (!virDeviceInfoPCIAddressIsWanted(&def->videos[i]->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->videos[i]->info) < 0)\n            return -1;\n    }\n\n    /* Shared Memory */\n    for (i = 0; i < def->nshmems; i++) {\n        if (!virDeviceInfoPCIAddressIsWanted(&def->shmems[i]->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->shmems[i]->info) < 0)\n            return -1;\n    }\n    for (i = 0; i < def->ninputs; i++) {\n        if (def->inputs[i]->bus != VIR_DOMAIN_INPUT_BUS_VIRTIO ||\n            !virDeviceInfoPCIAddressIsWanted(&def->inputs[i]->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &def->inputs[i]->info) < 0)\n            return -1;\n    }\n    for (i = 0; i < def->nparallels; i++) {\n        /* Nada - none are PCI based (yet) */\n    }\n    for (i = 0; i < def->nserials; i++) {\n        virDomainChrDefPtr chr = def->serials[i];\n\n        if (chr->targetType != VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_PCI ||\n            !virDeviceInfoPCIAddressIsWanted(&chr->info))\n            continue;\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs, &chr->info) < 0)\n            return -1;\n    }\n    for (i = 0; i < def->nchannels; i++) {\n        /* Nada - none are PCI based (yet) */\n    }\n    for (i = 0; i < def->nhubs; i++) {\n        /* Nada - none are PCI based (yet) */\n    }\n\n    if (def->vsock &&\n        virDeviceInfoPCIAddressIsWanted(&def->vsock->info)) {\n\n        if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                &def->vsock->info) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainValidateDevicePCISlotsChipsets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "2082-2098",
    "snippet": "static int\nqemuDomainValidateDevicePCISlotsChipsets(virDomainDefPtr def,\n                                         virQEMUCapsPtr qemuCaps,\n                                         virDomainPCIAddressSetPtr addrs)\n{\n    if (qemuDomainIsI440FX(def) &&\n        qemuDomainValidateDevicePCISlotsPIIX3(def, qemuCaps, addrs) < 0) {\n        return -1;\n    }\n\n    if (qemuDomainIsQ35(def) &&\n        qemuDomainValidateDevicePCISlotsQ35(def, qemuCaps, addrs) < 0) {\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainValidateDevicePCISlotsQ35",
          "args": [
            "def",
            "qemuCaps",
            "addrs"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainValidateDevicePCISlotsQ35",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "1871-2079",
          "snippet": "static int\nqemuDomainValidateDevicePCISlotsQ35(virDomainDefPtr def,\n                                    virQEMUCapsPtr qemuCaps,\n                                    virDomainPCIAddressSetPtr addrs)\n{\n    size_t i;\n    virPCIDeviceAddress tmp_addr;\n    bool qemuDeviceVideoUsable = virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIDEO_PRIMARY);\n    g_autofree char *addrStr = NULL;\n    virDomainPCIConnectFlags flags = VIR_PCI_CONNECT_TYPE_PCIE_DEVICE;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        virPCIDeviceAddress primarySATAAddr = {.domain = 0, .bus = 0,\n                                               .slot = 0x1F, .function = 2};\n\n        switch (cont->type) {\n        case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n            /* Verify that the first SATA controller is at 00:1F.2 the\n             * q35 machine type *always* has a SATA controller at this\n             * address.\n             */\n            if (cont->idx == 0) {\n                if (virDeviceInfoPCIAddressIsPresent(&cont->info)) {\n                    if (!virPCIDeviceAddressEqual(&cont->info.addr.pci,\n                                                  &primarySATAAddr)) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                       _(\"Primary SATA controller must have \"\n                                         \"PCI address 0:0:1f.2\"));\n                        return -1;\n                    }\n                } else {\n                    cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                    cont->info.addr.pci = primarySATAAddr;\n                }\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n            if ((cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1) &&\n                (cont->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)) {\n                /* Try to assign the first found USB2 controller to\n                 * 00:1D.0 and 2nd to 00:1A.0 (because that is their\n                 * standard location on real Q35 hardware) unless they\n                 * are already taken, but don't insist on it.\n                 *\n                 * (NB: all other controllers at the same index will\n                 * get assigned to the same slot as the UHCI1 when\n                 * addresses are later assigned to all devices.)\n                 */\n                bool assign = false;\n\n                memset(&tmp_addr, 0, sizeof(tmp_addr));\n                tmp_addr.slot = 0x1D;\n                if (!virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n                    assign = true;\n                } else {\n                    tmp_addr.slot = 0x1A;\n                    if (!virDomainPCIAddressSlotInUse(addrs, &tmp_addr))\n                        assign = true;\n                }\n                if (assign) {\n                    if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                        return -1;\n\n                    cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                    cont->info.addr.pci.domain = 0;\n                    cont->info.addr.pci.bus = 0;\n                    cont->info.addr.pci.slot = tmp_addr.slot;\n                    cont->info.addr.pci.function = 0;\n                    cont->info.addr.pci.multi = VIR_TRISTATE_SWITCH_ON;\n                }\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n            if (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE &&\n                cont->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n                /* Try to assign this bridge to 00:1E.0 (because that\n                * is its standard location on real hardware) unless\n                * it's already taken, but don't insist on it.\n                */\n                memset(&tmp_addr, 0, sizeof(tmp_addr));\n                tmp_addr.slot = 0x1E;\n                if (!virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n                    if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                        return -1;\n\n                    cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                    cont->info.addr.pci.domain = 0;\n                    cont->info.addr.pci.bus = 0;\n                    cont->info.addr.pci.slot = 0x1E;\n                    cont->info.addr.pci.function = 0;\n                }\n            }\n            break;\n        }\n    }\n\n    /* Reserve slot 0x1F function 0 (ISA bridge, not in config model)\n     * and function 3 (SMBus, also not (yet) in config model). As with\n     * the SATA controller, these devices are always present in a q35\n     * machine; there is no way to not have them.\n     */\n    if (addrs->nbuses) {\n        memset(&tmp_addr, 0, sizeof(tmp_addr));\n        tmp_addr.slot = 0x1F;\n        tmp_addr.function = 0;\n        tmp_addr.multi = VIR_TRISTATE_SWITCH_ON;\n        if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n           return -1;\n\n        tmp_addr.function = 3;\n        tmp_addr.multi = VIR_TRISTATE_SWITCH_ABSENT;\n        if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n           return -1;\n    }\n\n    /* ramfb is not a PCI device */\n    if (def->nvideos > 0 &&\n        def->videos[0]->type != VIR_DOMAIN_VIDEO_TYPE_NONE &&\n        def->videos[0]->type != VIR_DOMAIN_VIDEO_TYPE_RAMFB) {\n        /* NB: unlike the pc machinetypes, on q35 machinetypes the\n         * integrated devices are at slot 0x1f, so when qemu looks for\n         * the first free slot for the first VGA, it will always be at\n         * slot 1 (which was used up by the integrated PIIX3 devices\n         * on pc machinetypes).\n         */\n        virDomainVideoDefPtr primaryVideo = def->videos[0];\n        if (virDeviceInfoPCIAddressIsWanted(&primaryVideo->info)) {\n            memset(&tmp_addr, 0, sizeof(tmp_addr));\n            tmp_addr.slot = 1;\n\n            if (!(addrStr = virPCIDeviceAddressAsString(&tmp_addr)))\n                return -1;\n            if (!virDomainPCIAddressValidate(addrs, &tmp_addr,\n                                             addrStr, flags, true))\n                return -1;\n\n            if (virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n                if (qemuDeviceVideoUsable) {\n                    if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                            &primaryVideo->info) < 0)\n                        return -1;\n                } else {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"PCI address 0:0:1.0 is in use, \"\n                                     \"QEMU needs it for primary video\"));\n                    return -1;\n                }\n            } else {\n                if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                    return -1;\n                primaryVideo->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                primaryVideo->info.addr.pci = tmp_addr;\n            }\n        } else if (!qemuDeviceVideoUsable) {\n            if (primaryVideo->info.addr.pci.domain != 0 ||\n                primaryVideo->info.addr.pci.bus != 0 ||\n                primaryVideo->info.addr.pci.slot != 1 ||\n                primaryVideo->info.addr.pci.function != 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Primary video card must have PCI address 0:0:1.0\"));\n                return -1;\n            }\n            /* If TYPE == PCI, then qemuDomainCollectPCIAddress() function\n             * has already reserved the address, so we must skip */\n        }\n    } else if (addrs->nbuses && !qemuDeviceVideoUsable) {\n        memset(&tmp_addr, 0, sizeof(tmp_addr));\n        tmp_addr.slot = 1;\n\n        if (virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n            VIR_DEBUG(\"PCI address 0:0:1.0 in use, future addition of a video\"\n                      \" device will not be possible without manual\"\n                      \" intervention\");\n            virResetLastError();\n        } else if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0) {\n            return -1;\n        }\n    }\n\n    memset(&tmp_addr, 0, sizeof(tmp_addr));\n    tmp_addr.slot = 0x1B;\n    if (!virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n        /* Since real Q35 hardware has an ICH9 chip that has an\n         * integrated HD audio device at 0000:00:1B.0 put any\n         * unaddressed ICH9 audio device at that address if it's not\n         * already taken. If there's something already there, let the\n         * normal device addressing assign something later.\n         */\n        for (i = 0; i < def->nsounds; i++) {\n            virDomainSoundDefPtr sound = def->sounds[i];\n\n            if (sound->model != VIR_DOMAIN_SOUND_MODEL_ICH9 ||\n                !virDeviceInfoPCIAddressIsWanted(&sound->info)) {\n                continue;\n            }\n            if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                return -1;\n\n            sound->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n            sound->info.addr.pci = tmp_addr;\n            break;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainValidateDevicePCISlotsQ35(virDomainDefPtr def,\n                                    virQEMUCapsPtr qemuCaps,\n                                    virDomainPCIAddressSetPtr addrs)\n{\n    size_t i;\n    virPCIDeviceAddress tmp_addr;\n    bool qemuDeviceVideoUsable = virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIDEO_PRIMARY);\n    g_autofree char *addrStr = NULL;\n    virDomainPCIConnectFlags flags = VIR_PCI_CONNECT_TYPE_PCIE_DEVICE;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        virPCIDeviceAddress primarySATAAddr = {.domain = 0, .bus = 0,\n                                               .slot = 0x1F, .function = 2};\n\n        switch (cont->type) {\n        case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n            /* Verify that the first SATA controller is at 00:1F.2 the\n             * q35 machine type *always* has a SATA controller at this\n             * address.\n             */\n            if (cont->idx == 0) {\n                if (virDeviceInfoPCIAddressIsPresent(&cont->info)) {\n                    if (!virPCIDeviceAddressEqual(&cont->info.addr.pci,\n                                                  &primarySATAAddr)) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                       _(\"Primary SATA controller must have \"\n                                         \"PCI address 0:0:1f.2\"));\n                        return -1;\n                    }\n                } else {\n                    cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                    cont->info.addr.pci = primarySATAAddr;\n                }\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n            if ((cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1) &&\n                (cont->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)) {\n                /* Try to assign the first found USB2 controller to\n                 * 00:1D.0 and 2nd to 00:1A.0 (because that is their\n                 * standard location on real Q35 hardware) unless they\n                 * are already taken, but don't insist on it.\n                 *\n                 * (NB: all other controllers at the same index will\n                 * get assigned to the same slot as the UHCI1 when\n                 * addresses are later assigned to all devices.)\n                 */\n                bool assign = false;\n\n                memset(&tmp_addr, 0, sizeof(tmp_addr));\n                tmp_addr.slot = 0x1D;\n                if (!virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n                    assign = true;\n                } else {\n                    tmp_addr.slot = 0x1A;\n                    if (!virDomainPCIAddressSlotInUse(addrs, &tmp_addr))\n                        assign = true;\n                }\n                if (assign) {\n                    if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                        return -1;\n\n                    cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                    cont->info.addr.pci.domain = 0;\n                    cont->info.addr.pci.bus = 0;\n                    cont->info.addr.pci.slot = tmp_addr.slot;\n                    cont->info.addr.pci.function = 0;\n                    cont->info.addr.pci.multi = VIR_TRISTATE_SWITCH_ON;\n                }\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n            if (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE &&\n                cont->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n                /* Try to assign this bridge to 00:1E.0 (because that\n                * is its standard location on real hardware) unless\n                * it's already taken, but don't insist on it.\n                */\n                memset(&tmp_addr, 0, sizeof(tmp_addr));\n                tmp_addr.slot = 0x1E;\n                if (!virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n                    if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                        return -1;\n\n                    cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                    cont->info.addr.pci.domain = 0;\n                    cont->info.addr.pci.bus = 0;\n                    cont->info.addr.pci.slot = 0x1E;\n                    cont->info.addr.pci.function = 0;\n                }\n            }\n            break;\n        }\n    }\n\n    /* Reserve slot 0x1F function 0 (ISA bridge, not in config model)\n     * and function 3 (SMBus, also not (yet) in config model). As with\n     * the SATA controller, these devices are always present in a q35\n     * machine; there is no way to not have them.\n     */\n    if (addrs->nbuses) {\n        memset(&tmp_addr, 0, sizeof(tmp_addr));\n        tmp_addr.slot = 0x1F;\n        tmp_addr.function = 0;\n        tmp_addr.multi = VIR_TRISTATE_SWITCH_ON;\n        if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n           return -1;\n\n        tmp_addr.function = 3;\n        tmp_addr.multi = VIR_TRISTATE_SWITCH_ABSENT;\n        if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n           return -1;\n    }\n\n    /* ramfb is not a PCI device */\n    if (def->nvideos > 0 &&\n        def->videos[0]->type != VIR_DOMAIN_VIDEO_TYPE_NONE &&\n        def->videos[0]->type != VIR_DOMAIN_VIDEO_TYPE_RAMFB) {\n        /* NB: unlike the pc machinetypes, on q35 machinetypes the\n         * integrated devices are at slot 0x1f, so when qemu looks for\n         * the first free slot for the first VGA, it will always be at\n         * slot 1 (which was used up by the integrated PIIX3 devices\n         * on pc machinetypes).\n         */\n        virDomainVideoDefPtr primaryVideo = def->videos[0];\n        if (virDeviceInfoPCIAddressIsWanted(&primaryVideo->info)) {\n            memset(&tmp_addr, 0, sizeof(tmp_addr));\n            tmp_addr.slot = 1;\n\n            if (!(addrStr = virPCIDeviceAddressAsString(&tmp_addr)))\n                return -1;\n            if (!virDomainPCIAddressValidate(addrs, &tmp_addr,\n                                             addrStr, flags, true))\n                return -1;\n\n            if (virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n                if (qemuDeviceVideoUsable) {\n                    if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                            &primaryVideo->info) < 0)\n                        return -1;\n                } else {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"PCI address 0:0:1.0 is in use, \"\n                                     \"QEMU needs it for primary video\"));\n                    return -1;\n                }\n            } else {\n                if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                    return -1;\n                primaryVideo->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                primaryVideo->info.addr.pci = tmp_addr;\n            }\n        } else if (!qemuDeviceVideoUsable) {\n            if (primaryVideo->info.addr.pci.domain != 0 ||\n                primaryVideo->info.addr.pci.bus != 0 ||\n                primaryVideo->info.addr.pci.slot != 1 ||\n                primaryVideo->info.addr.pci.function != 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Primary video card must have PCI address 0:0:1.0\"));\n                return -1;\n            }\n            /* If TYPE == PCI, then qemuDomainCollectPCIAddress() function\n             * has already reserved the address, so we must skip */\n        }\n    } else if (addrs->nbuses && !qemuDeviceVideoUsable) {\n        memset(&tmp_addr, 0, sizeof(tmp_addr));\n        tmp_addr.slot = 1;\n\n        if (virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n            VIR_DEBUG(\"PCI address 0:0:1.0 in use, future addition of a video\"\n                      \" device will not be possible without manual\"\n                      \" intervention\");\n            virResetLastError();\n        } else if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0) {\n            return -1;\n        }\n    }\n\n    memset(&tmp_addr, 0, sizeof(tmp_addr));\n    tmp_addr.slot = 0x1B;\n    if (!virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n        /* Since real Q35 hardware has an ICH9 chip that has an\n         * integrated HD audio device at 0000:00:1B.0 put any\n         * unaddressed ICH9 audio device at that address if it's not\n         * already taken. If there's something already there, let the\n         * normal device addressing assign something later.\n         */\n        for (i = 0; i < def->nsounds; i++) {\n            virDomainSoundDefPtr sound = def->sounds[i];\n\n            if (sound->model != VIR_DOMAIN_SOUND_MODEL_ICH9 ||\n                !virDeviceInfoPCIAddressIsWanted(&sound->info)) {\n                continue;\n            }\n            if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                return -1;\n\n            sound->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n            sound->info.addr.pci = tmp_addr;\n            break;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainIsQ35",
          "args": [
            "def"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainIsQ35",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12877-12881",
          "snippet": "bool\nqemuDomainIsQ35(const virDomainDef *def)\n{\n    return qemuDomainMachineIsQ35(def->os.machine, def->os.arch);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainIsQ35(const virDomainDef *def)\n{\n    return qemuDomainMachineIsQ35(def->os.machine, def->os.arch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainValidateDevicePCISlotsPIIX3",
          "args": [
            "def",
            "qemuCaps",
            "addrs"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainValidateDevicePCISlotsPIIX3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "1730-1868",
          "snippet": "static int\nqemuDomainValidateDevicePCISlotsPIIX3(virDomainDefPtr def,\n                                      virQEMUCapsPtr qemuCaps,\n                                      virDomainPCIAddressSetPtr addrs)\n{\n    size_t i;\n    virPCIDeviceAddress tmp_addr;\n    bool qemuDeviceVideoUsable = virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIDEO_PRIMARY);\n    g_autofree char *addrStr = NULL;\n    virDomainPCIConnectFlags flags = (VIR_PCI_CONNECT_HOTPLUGGABLE\n                                      | VIR_PCI_CONNECT_TYPE_PCI_DEVICE);\n\n    /* Verify that first IDE and USB controllers (if any) is on the PIIX3, fn 1 */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        virPCIDeviceAddress primaryIDEAddr = {.domain = 0, .bus = 0,\n                                              .slot = 1, .function = 1};\n        virPCIDeviceAddress piix3USBAddr = {.domain = 0, .bus = 0,\n                                            .slot = 1, .function = 2};\n\n        /* First IDE controller lives on the PIIX3 at slot=1, function=1 */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_IDE &&\n            cont->idx == 0) {\n            if (virDeviceInfoPCIAddressIsPresent(&cont->info)) {\n                if (!virPCIDeviceAddressEqual(&cont->info.addr.pci,\n                                              &primaryIDEAddr)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Primary IDE controller must have PCI \"\n                                     \"address 0:0:1.1\"));\n                    return -1;\n                }\n            } else {\n                cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                cont->info.addr.pci = primaryIDEAddr;\n            }\n        } else if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB &&\n                   cont->idx == 0 &&\n                   (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI ||\n                    cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT)) {\n            if (virDeviceInfoPCIAddressIsPresent(&cont->info)) {\n                if (!virPCIDeviceAddressEqual(&cont->info.addr.pci,\n                                              &piix3USBAddr)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"PIIX3 USB controller at index 0 must \"\n                                     \"have PCI address 0:0:1.2\"));\n                    return -1;\n                }\n            } else {\n                cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                cont->info.addr.pci = piix3USBAddr;\n            }\n        } else {\n            /* this controller is not skipped in qemuDomainCollectPCIAddress */\n            continue;\n        }\n        if (addrs->nbuses &&\n            virDomainPCIAddressReserveAddr(addrs, &cont->info.addr.pci, flags, 0) < 0)\n            return -1;\n    }\n\n    /* Implicit PIIX3 devices living on slot 1 not handled above */\n    if (addrs->nbuses) {\n        memset(&tmp_addr, 0, sizeof(tmp_addr));\n        tmp_addr.slot = 1;\n        /* ISA Bridge at 00:01.0 */\n        if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n            return -1;\n        /* Bridge at 00:01.3 */\n        tmp_addr.function = 3;\n        if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n            return -1;\n    }\n\n    /* ramfb is not a PCI device */\n    if (def->nvideos > 0 &&\n        def->videos[0]->type != VIR_DOMAIN_VIDEO_TYPE_NONE &&\n        def->videos[0]->type != VIR_DOMAIN_VIDEO_TYPE_RAMFB) {\n        /* Because the PIIX3 integrated IDE/USB controllers are\n         * already at slot 1, when qemu looks for the first free slot\n         * to place the VGA controller (which is always the first\n         * device added after integrated devices), it *always* ends up\n         * at slot 2.\n         */\n        virDomainVideoDefPtr primaryVideo = def->videos[0];\n        virPCIDeviceAddress primaryCardAddr = {.domain = 0, .bus = 0,\n                                               .slot = 2, .function = 0};\n\n        if (virDeviceInfoPCIAddressIsWanted(&primaryVideo->info)) {\n            memset(&tmp_addr, 0, sizeof(tmp_addr));\n            tmp_addr.slot = 2;\n\n            if (!(addrStr = virPCIDeviceAddressAsString(&tmp_addr)))\n                return -1;\n            if (!virDomainPCIAddressValidate(addrs, &tmp_addr,\n                                             addrStr, flags, true))\n                return -1;\n\n            if (virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n                if (qemuDeviceVideoUsable) {\n                    if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                            &primaryVideo->info) < 0) {\n                        return -1;\n                    }\n                } else {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"PCI address 0:0:2.0 is in use, \"\n                                     \"QEMU needs it for primary video\"));\n                    return -1;\n                }\n            } else {\n                if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                    return -1;\n                primaryVideo->info.addr.pci = tmp_addr;\n                primaryVideo->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n            }\n        } else if (!qemuDeviceVideoUsable) {\n            if (!virPCIDeviceAddressEqual(&primaryVideo->info.addr.pci,\n                                          &primaryCardAddr)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Primary video card must have PCI address 0:0:2.0\"));\n                return -1;\n            }\n            /* If TYPE == PCI, then qemuDomainCollectPCIAddress() function\n             * has already reserved the address, so we must skip */\n        }\n    } else if (addrs->nbuses && !qemuDeviceVideoUsable) {\n        memset(&tmp_addr, 0, sizeof(tmp_addr));\n        tmp_addr.slot = 2;\n\n        if (virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n            VIR_DEBUG(\"PCI address 0:0:2.0 in use, future addition of a video\"\n                      \" device will not be possible without manual\"\n                      \" intervention\");\n        } else if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0) {\n            return -1;\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainValidateDevicePCISlotsPIIX3(virDomainDefPtr def,\n                                      virQEMUCapsPtr qemuCaps,\n                                      virDomainPCIAddressSetPtr addrs)\n{\n    size_t i;\n    virPCIDeviceAddress tmp_addr;\n    bool qemuDeviceVideoUsable = virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIDEO_PRIMARY);\n    g_autofree char *addrStr = NULL;\n    virDomainPCIConnectFlags flags = (VIR_PCI_CONNECT_HOTPLUGGABLE\n                                      | VIR_PCI_CONNECT_TYPE_PCI_DEVICE);\n\n    /* Verify that first IDE and USB controllers (if any) is on the PIIX3, fn 1 */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        virPCIDeviceAddress primaryIDEAddr = {.domain = 0, .bus = 0,\n                                              .slot = 1, .function = 1};\n        virPCIDeviceAddress piix3USBAddr = {.domain = 0, .bus = 0,\n                                            .slot = 1, .function = 2};\n\n        /* First IDE controller lives on the PIIX3 at slot=1, function=1 */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_IDE &&\n            cont->idx == 0) {\n            if (virDeviceInfoPCIAddressIsPresent(&cont->info)) {\n                if (!virPCIDeviceAddressEqual(&cont->info.addr.pci,\n                                              &primaryIDEAddr)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Primary IDE controller must have PCI \"\n                                     \"address 0:0:1.1\"));\n                    return -1;\n                }\n            } else {\n                cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                cont->info.addr.pci = primaryIDEAddr;\n            }\n        } else if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB &&\n                   cont->idx == 0 &&\n                   (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI ||\n                    cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT)) {\n            if (virDeviceInfoPCIAddressIsPresent(&cont->info)) {\n                if (!virPCIDeviceAddressEqual(&cont->info.addr.pci,\n                                              &piix3USBAddr)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"PIIX3 USB controller at index 0 must \"\n                                     \"have PCI address 0:0:1.2\"));\n                    return -1;\n                }\n            } else {\n                cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                cont->info.addr.pci = piix3USBAddr;\n            }\n        } else {\n            /* this controller is not skipped in qemuDomainCollectPCIAddress */\n            continue;\n        }\n        if (addrs->nbuses &&\n            virDomainPCIAddressReserveAddr(addrs, &cont->info.addr.pci, flags, 0) < 0)\n            return -1;\n    }\n\n    /* Implicit PIIX3 devices living on slot 1 not handled above */\n    if (addrs->nbuses) {\n        memset(&tmp_addr, 0, sizeof(tmp_addr));\n        tmp_addr.slot = 1;\n        /* ISA Bridge at 00:01.0 */\n        if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n            return -1;\n        /* Bridge at 00:01.3 */\n        tmp_addr.function = 3;\n        if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n            return -1;\n    }\n\n    /* ramfb is not a PCI device */\n    if (def->nvideos > 0 &&\n        def->videos[0]->type != VIR_DOMAIN_VIDEO_TYPE_NONE &&\n        def->videos[0]->type != VIR_DOMAIN_VIDEO_TYPE_RAMFB) {\n        /* Because the PIIX3 integrated IDE/USB controllers are\n         * already at slot 1, when qemu looks for the first free slot\n         * to place the VGA controller (which is always the first\n         * device added after integrated devices), it *always* ends up\n         * at slot 2.\n         */\n        virDomainVideoDefPtr primaryVideo = def->videos[0];\n        virPCIDeviceAddress primaryCardAddr = {.domain = 0, .bus = 0,\n                                               .slot = 2, .function = 0};\n\n        if (virDeviceInfoPCIAddressIsWanted(&primaryVideo->info)) {\n            memset(&tmp_addr, 0, sizeof(tmp_addr));\n            tmp_addr.slot = 2;\n\n            if (!(addrStr = virPCIDeviceAddressAsString(&tmp_addr)))\n                return -1;\n            if (!virDomainPCIAddressValidate(addrs, &tmp_addr,\n                                             addrStr, flags, true))\n                return -1;\n\n            if (virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n                if (qemuDeviceVideoUsable) {\n                    if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                            &primaryVideo->info) < 0) {\n                        return -1;\n                    }\n                } else {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"PCI address 0:0:2.0 is in use, \"\n                                     \"QEMU needs it for primary video\"));\n                    return -1;\n                }\n            } else {\n                if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                    return -1;\n                primaryVideo->info.addr.pci = tmp_addr;\n                primaryVideo->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n            }\n        } else if (!qemuDeviceVideoUsable) {\n            if (!virPCIDeviceAddressEqual(&primaryVideo->info.addr.pci,\n                                          &primaryCardAddr)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Primary video card must have PCI address 0:0:2.0\"));\n                return -1;\n            }\n            /* If TYPE == PCI, then qemuDomainCollectPCIAddress() function\n             * has already reserved the address, so we must skip */\n        }\n    } else if (addrs->nbuses && !qemuDeviceVideoUsable) {\n        memset(&tmp_addr, 0, sizeof(tmp_addr));\n        tmp_addr.slot = 2;\n\n        if (virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n            VIR_DEBUG(\"PCI address 0:0:2.0 in use, future addition of a video\"\n                      \" device will not be possible without manual\"\n                      \" intervention\");\n        } else if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0) {\n            return -1;\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainIsI440FX",
          "args": [
            "def"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainIsI440FX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12884-12888",
          "snippet": "bool\nqemuDomainIsI440FX(const virDomainDef *def)\n{\n    return qemuDomainMachineIsI440FX(def->os.machine, def->os.arch);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainIsI440FX(const virDomainDef *def)\n{\n    return qemuDomainMachineIsI440FX(def->os.machine, def->os.arch);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainValidateDevicePCISlotsChipsets(virDomainDefPtr def,\n                                         virQEMUCapsPtr qemuCaps,\n                                         virDomainPCIAddressSetPtr addrs)\n{\n    if (qemuDomainIsI440FX(def) &&\n        qemuDomainValidateDevicePCISlotsPIIX3(def, qemuCaps, addrs) < 0) {\n        return -1;\n    }\n\n    if (qemuDomainIsQ35(def) &&\n        qemuDomainValidateDevicePCISlotsQ35(def, qemuCaps, addrs) < 0) {\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainValidateDevicePCISlotsQ35",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1871-2079",
    "snippet": "static int\nqemuDomainValidateDevicePCISlotsQ35(virDomainDefPtr def,\n                                    virQEMUCapsPtr qemuCaps,\n                                    virDomainPCIAddressSetPtr addrs)\n{\n    size_t i;\n    virPCIDeviceAddress tmp_addr;\n    bool qemuDeviceVideoUsable = virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIDEO_PRIMARY);\n    g_autofree char *addrStr = NULL;\n    virDomainPCIConnectFlags flags = VIR_PCI_CONNECT_TYPE_PCIE_DEVICE;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        virPCIDeviceAddress primarySATAAddr = {.domain = 0, .bus = 0,\n                                               .slot = 0x1F, .function = 2};\n\n        switch (cont->type) {\n        case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n            /* Verify that the first SATA controller is at 00:1F.2 the\n             * q35 machine type *always* has a SATA controller at this\n             * address.\n             */\n            if (cont->idx == 0) {\n                if (virDeviceInfoPCIAddressIsPresent(&cont->info)) {\n                    if (!virPCIDeviceAddressEqual(&cont->info.addr.pci,\n                                                  &primarySATAAddr)) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                       _(\"Primary SATA controller must have \"\n                                         \"PCI address 0:0:1f.2\"));\n                        return -1;\n                    }\n                } else {\n                    cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                    cont->info.addr.pci = primarySATAAddr;\n                }\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n            if ((cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1) &&\n                (cont->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)) {\n                /* Try to assign the first found USB2 controller to\n                 * 00:1D.0 and 2nd to 00:1A.0 (because that is their\n                 * standard location on real Q35 hardware) unless they\n                 * are already taken, but don't insist on it.\n                 *\n                 * (NB: all other controllers at the same index will\n                 * get assigned to the same slot as the UHCI1 when\n                 * addresses are later assigned to all devices.)\n                 */\n                bool assign = false;\n\n                memset(&tmp_addr, 0, sizeof(tmp_addr));\n                tmp_addr.slot = 0x1D;\n                if (!virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n                    assign = true;\n                } else {\n                    tmp_addr.slot = 0x1A;\n                    if (!virDomainPCIAddressSlotInUse(addrs, &tmp_addr))\n                        assign = true;\n                }\n                if (assign) {\n                    if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                        return -1;\n\n                    cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                    cont->info.addr.pci.domain = 0;\n                    cont->info.addr.pci.bus = 0;\n                    cont->info.addr.pci.slot = tmp_addr.slot;\n                    cont->info.addr.pci.function = 0;\n                    cont->info.addr.pci.multi = VIR_TRISTATE_SWITCH_ON;\n                }\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n            if (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE &&\n                cont->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n                /* Try to assign this bridge to 00:1E.0 (because that\n                * is its standard location on real hardware) unless\n                * it's already taken, but don't insist on it.\n                */\n                memset(&tmp_addr, 0, sizeof(tmp_addr));\n                tmp_addr.slot = 0x1E;\n                if (!virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n                    if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                        return -1;\n\n                    cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                    cont->info.addr.pci.domain = 0;\n                    cont->info.addr.pci.bus = 0;\n                    cont->info.addr.pci.slot = 0x1E;\n                    cont->info.addr.pci.function = 0;\n                }\n            }\n            break;\n        }\n    }\n\n    /* Reserve slot 0x1F function 0 (ISA bridge, not in config model)\n     * and function 3 (SMBus, also not (yet) in config model). As with\n     * the SATA controller, these devices are always present in a q35\n     * machine; there is no way to not have them.\n     */\n    if (addrs->nbuses) {\n        memset(&tmp_addr, 0, sizeof(tmp_addr));\n        tmp_addr.slot = 0x1F;\n        tmp_addr.function = 0;\n        tmp_addr.multi = VIR_TRISTATE_SWITCH_ON;\n        if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n           return -1;\n\n        tmp_addr.function = 3;\n        tmp_addr.multi = VIR_TRISTATE_SWITCH_ABSENT;\n        if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n           return -1;\n    }\n\n    /* ramfb is not a PCI device */\n    if (def->nvideos > 0 &&\n        def->videos[0]->type != VIR_DOMAIN_VIDEO_TYPE_NONE &&\n        def->videos[0]->type != VIR_DOMAIN_VIDEO_TYPE_RAMFB) {\n        /* NB: unlike the pc machinetypes, on q35 machinetypes the\n         * integrated devices are at slot 0x1f, so when qemu looks for\n         * the first free slot for the first VGA, it will always be at\n         * slot 1 (which was used up by the integrated PIIX3 devices\n         * on pc machinetypes).\n         */\n        virDomainVideoDefPtr primaryVideo = def->videos[0];\n        if (virDeviceInfoPCIAddressIsWanted(&primaryVideo->info)) {\n            memset(&tmp_addr, 0, sizeof(tmp_addr));\n            tmp_addr.slot = 1;\n\n            if (!(addrStr = virPCIDeviceAddressAsString(&tmp_addr)))\n                return -1;\n            if (!virDomainPCIAddressValidate(addrs, &tmp_addr,\n                                             addrStr, flags, true))\n                return -1;\n\n            if (virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n                if (qemuDeviceVideoUsable) {\n                    if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                            &primaryVideo->info) < 0)\n                        return -1;\n                } else {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"PCI address 0:0:1.0 is in use, \"\n                                     \"QEMU needs it for primary video\"));\n                    return -1;\n                }\n            } else {\n                if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                    return -1;\n                primaryVideo->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                primaryVideo->info.addr.pci = tmp_addr;\n            }\n        } else if (!qemuDeviceVideoUsable) {\n            if (primaryVideo->info.addr.pci.domain != 0 ||\n                primaryVideo->info.addr.pci.bus != 0 ||\n                primaryVideo->info.addr.pci.slot != 1 ||\n                primaryVideo->info.addr.pci.function != 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Primary video card must have PCI address 0:0:1.0\"));\n                return -1;\n            }\n            /* If TYPE == PCI, then qemuDomainCollectPCIAddress() function\n             * has already reserved the address, so we must skip */\n        }\n    } else if (addrs->nbuses && !qemuDeviceVideoUsable) {\n        memset(&tmp_addr, 0, sizeof(tmp_addr));\n        tmp_addr.slot = 1;\n\n        if (virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n            VIR_DEBUG(\"PCI address 0:0:1.0 in use, future addition of a video\"\n                      \" device will not be possible without manual\"\n                      \" intervention\");\n            virResetLastError();\n        } else if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0) {\n            return -1;\n        }\n    }\n\n    memset(&tmp_addr, 0, sizeof(tmp_addr));\n    tmp_addr.slot = 0x1B;\n    if (!virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n        /* Since real Q35 hardware has an ICH9 chip that has an\n         * integrated HD audio device at 0000:00:1B.0 put any\n         * unaddressed ICH9 audio device at that address if it's not\n         * already taken. If there's something already there, let the\n         * normal device addressing assign something later.\n         */\n        for (i = 0; i < def->nsounds; i++) {\n            virDomainSoundDefPtr sound = def->sounds[i];\n\n            if (sound->model != VIR_DOMAIN_SOUND_MODEL_ICH9 ||\n                !virDeviceInfoPCIAddressIsWanted(&sound->info)) {\n                continue;\n            }\n            if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                return -1;\n\n            sound->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n            sound->info.addr.pci = tmp_addr;\n            break;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressReserveAddr",
          "args": [
            "addrs",
            "&tmp_addr",
            "flags",
            "0"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressReserveAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "895-903",
          "snippet": "int\nvirDomainPCIAddressReserveAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr,\n                               virDomainPCIConnectFlags flags,\n                               unsigned int isolationGroup)\n{\n    return virDomainPCIAddressReserveAddrInternal(addrs, addr, flags,\n                                                  isolationGroup, true);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressReserveAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr,\n                               virDomainPCIConnectFlags flags,\n                               unsigned int isolationGroup)\n{\n    return virDomainPCIAddressReserveAddrInternal(addrs, addr, flags,\n                                                  isolationGroup, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDeviceInfoPCIAddressIsWanted",
          "args": [
            "&sound->info"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "virDeviceInfoPCIAddressIsWanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "183-189",
          "snippet": "bool\nvirDeviceInfoPCIAddressIsWanted(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE ||\n           (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n            virPCIDeviceAddressIsEmpty(&info->addr.pci));\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool\nvirDeviceInfoPCIAddressIsWanted(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE ||\n           (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n            virPCIDeviceAddressIsEmpty(&info->addr.pci));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressSlotInUse",
          "args": [
            "addrs",
            "&tmp_addr"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressSlotInUse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "810-815",
          "snippet": "bool\nvirDomainPCIAddressSlotInUse(virDomainPCIAddressSetPtr addrs,\n                             virPCIDeviceAddressPtr addr)\n{\n    return !!addrs->buses[addr->bus].slot[addr->slot].functions;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainPCIAddressSlotInUse(virDomainPCIAddressSetPtr addrs,\n                             virPCIDeviceAddressPtr addr)\n{\n    return !!addrs->buses[addr->bus].slot[addr->slot].functions;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tmp_addr",
            "0",
            "sizeof(tmp_addr)"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"PCI address 0:0:1.0 in use, future addition of a video\"\n                      \" device will not be possible without manual\"\n                      \" intervention\""
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tmp_addr",
            "0",
            "sizeof(tmp_addr)"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Primary video card must have PCI address 0:0:1.0\")"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Primary video card must have PCI address 0:0:1.0\""
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"PCI address 0:0:1.0 is in use, \"\n                                     \"QEMU needs it for primary video\")"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainPCIAddressReserveNextAddr",
          "args": [
            "addrs",
            "&primaryVideo->info"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainPCIAddressReserveNextAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "1484-1490",
          "snippet": "static int\nqemuDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                    virDomainDeviceInfoPtr dev)\n{\n    return virDomainPCIAddressReserveNextAddr(addrs, dev,\n                                              dev->pciConnectFlags, -1);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                    virDomainDeviceInfoPtr dev)\n{\n    return virDomainPCIAddressReserveNextAddr(addrs, dev,\n                                              dev->pciConnectFlags, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressValidate",
          "args": [
            "addrs",
            "&tmp_addr",
            "addrStr",
            "flags",
            "true"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "441-500",
          "snippet": "bool\nvirDomainPCIAddressValidate(virDomainPCIAddressSetPtr addrs,\n                            virPCIDeviceAddressPtr addr,\n                            const char *addrStr,\n                            virDomainPCIConnectFlags flags,\n                            bool fromConfig)\n{\n    virDomainPCIAddressBusPtr bus;\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (addrs->nbuses == 0) {\n        virReportError(errType, \"%s\", _(\"No PCI buses available\"));\n        return false;\n    }\n    if (addr->domain != 0) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI domain 0 is available\"),\n                       addrStr);\n        return false;\n    }\n    if (addr->bus >= addrs->nbuses) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI buses up to %zu are available\"),\n                       addrStr, addrs->nbuses - 1);\n        return false;\n    }\n\n    bus = &addrs->buses[addr->bus];\n\n    /* assure that at least one of the requested connection types is\n     * provided by this bus\n     */\n    if (!virDomainPCIAddressFlagsCompatible(addr, addrStr, bus->flags,\n                                            flags, true, fromConfig))\n        return false;\n\n    /* some \"buses\" are really just a single port */\n    if (bus->minSlot && addr->slot < bus->minSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be >= %zu\"),\n                       addrStr, bus->minSlot);\n        return false;\n    }\n    if (addr->slot > bus->maxSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be <= %zu\"),\n                       addrStr, bus->maxSlot);\n        return false;\n    }\n    if (addr->function > VIR_PCI_ADDRESS_FUNCTION_LAST) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. function must be <= %u\"),\n                       addrStr, VIR_PCI_ADDRESS_FUNCTION_LAST);\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainPCIAddressValidate(virDomainPCIAddressSetPtr addrs,\n                            virPCIDeviceAddressPtr addr,\n                            const char *addrStr,\n                            virDomainPCIConnectFlags flags,\n                            bool fromConfig)\n{\n    virDomainPCIAddressBusPtr bus;\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (addrs->nbuses == 0) {\n        virReportError(errType, \"%s\", _(\"No PCI buses available\"));\n        return false;\n    }\n    if (addr->domain != 0) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI domain 0 is available\"),\n                       addrStr);\n        return false;\n    }\n    if (addr->bus >= addrs->nbuses) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI buses up to %zu are available\"),\n                       addrStr, addrs->nbuses - 1);\n        return false;\n    }\n\n    bus = &addrs->buses[addr->bus];\n\n    /* assure that at least one of the requested connection types is\n     * provided by this bus\n     */\n    if (!virDomainPCIAddressFlagsCompatible(addr, addrStr, bus->flags,\n                                            flags, true, fromConfig))\n        return false;\n\n    /* some \"buses\" are really just a single port */\n    if (bus->minSlot && addr->slot < bus->minSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be >= %zu\"),\n                       addrStr, bus->minSlot);\n        return false;\n    }\n    if (addr->slot > bus->maxSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be <= %zu\"),\n                       addrStr, bus->maxSlot);\n        return false;\n    }\n    if (addr->function > VIR_PCI_ADDRESS_FUNCTION_LAST) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. function must be <= %u\"),\n                       addrStr, VIR_PCI_ADDRESS_FUNCTION_LAST);\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressAsString",
          "args": [
            "&tmp_addr"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressAsString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1351-1362",
          "snippet": "char *\nvirPCIDeviceAddressAsString(const virPCIDeviceAddress *addr)\n{\n    char *str;\n\n    str = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT,\n                          addr->domain,\n                          addr->bus,\n                          addr->slot,\n                          addr->function);\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceAddressAsString(const virPCIDeviceAddress *addr)\n{\n    char *str;\n\n    str = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT,\n                          addr->domain,\n                          addr->bus,\n                          addr->slot,\n                          addr->function);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tmp_addr",
            "0",
            "sizeof(tmp_addr)"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tmp_addr",
            "0",
            "sizeof(tmp_addr)"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tmp_addr",
            "0",
            "sizeof(tmp_addr)"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tmp_addr",
            "0",
            "sizeof(tmp_addr)"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Primary SATA controller must have \"\n                                         \"PCI address 0:0:1f.2\")"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressEqual",
          "args": [
            "&cont->info.addr.pci",
            "&primarySATAAddr"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1324-1335",
          "snippet": "bool\nvirPCIDeviceAddressEqual(const virPCIDeviceAddress *addr1,\n                         const virPCIDeviceAddress *addr2)\n{\n    if (addr1->domain == addr2->domain &&\n        addr1->bus == addr2->bus &&\n        addr1->slot == addr2->slot &&\n        addr1->function == addr2->function) {\n        return true;\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceAddressEqual(const virPCIDeviceAddress *addr1,\n                         const virPCIDeviceAddress *addr2)\n{\n    if (addr1->domain == addr2->domain &&\n        addr1->bus == addr2->bus &&\n        addr1->slot == addr2->slot &&\n        addr1->function == addr2->function) {\n        return true;\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDeviceInfoPCIAddressIsPresent",
          "args": [
            "&cont->info"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "virDeviceInfoPCIAddressIsPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "191-196",
          "snippet": "bool\nvirDeviceInfoPCIAddressIsPresent(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n           !virPCIDeviceAddressIsEmpty(&info->addr.pci);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool\nvirDeviceInfoPCIAddressIsPresent(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n           !virPCIDeviceAddressIsEmpty(&info->addr.pci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_DEVICE_VIDEO_PRIMARY"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainValidateDevicePCISlotsQ35(virDomainDefPtr def,\n                                    virQEMUCapsPtr qemuCaps,\n                                    virDomainPCIAddressSetPtr addrs)\n{\n    size_t i;\n    virPCIDeviceAddress tmp_addr;\n    bool qemuDeviceVideoUsable = virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIDEO_PRIMARY);\n    g_autofree char *addrStr = NULL;\n    virDomainPCIConnectFlags flags = VIR_PCI_CONNECT_TYPE_PCIE_DEVICE;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        virPCIDeviceAddress primarySATAAddr = {.domain = 0, .bus = 0,\n                                               .slot = 0x1F, .function = 2};\n\n        switch (cont->type) {\n        case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n            /* Verify that the first SATA controller is at 00:1F.2 the\n             * q35 machine type *always* has a SATA controller at this\n             * address.\n             */\n            if (cont->idx == 0) {\n                if (virDeviceInfoPCIAddressIsPresent(&cont->info)) {\n                    if (!virPCIDeviceAddressEqual(&cont->info.addr.pci,\n                                                  &primarySATAAddr)) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                       _(\"Primary SATA controller must have \"\n                                         \"PCI address 0:0:1f.2\"));\n                        return -1;\n                    }\n                } else {\n                    cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                    cont->info.addr.pci = primarySATAAddr;\n                }\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n            if ((cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1) &&\n                (cont->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)) {\n                /* Try to assign the first found USB2 controller to\n                 * 00:1D.0 and 2nd to 00:1A.0 (because that is their\n                 * standard location on real Q35 hardware) unless they\n                 * are already taken, but don't insist on it.\n                 *\n                 * (NB: all other controllers at the same index will\n                 * get assigned to the same slot as the UHCI1 when\n                 * addresses are later assigned to all devices.)\n                 */\n                bool assign = false;\n\n                memset(&tmp_addr, 0, sizeof(tmp_addr));\n                tmp_addr.slot = 0x1D;\n                if (!virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n                    assign = true;\n                } else {\n                    tmp_addr.slot = 0x1A;\n                    if (!virDomainPCIAddressSlotInUse(addrs, &tmp_addr))\n                        assign = true;\n                }\n                if (assign) {\n                    if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                        return -1;\n\n                    cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                    cont->info.addr.pci.domain = 0;\n                    cont->info.addr.pci.bus = 0;\n                    cont->info.addr.pci.slot = tmp_addr.slot;\n                    cont->info.addr.pci.function = 0;\n                    cont->info.addr.pci.multi = VIR_TRISTATE_SWITCH_ON;\n                }\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n            if (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE &&\n                cont->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n                /* Try to assign this bridge to 00:1E.0 (because that\n                * is its standard location on real hardware) unless\n                * it's already taken, but don't insist on it.\n                */\n                memset(&tmp_addr, 0, sizeof(tmp_addr));\n                tmp_addr.slot = 0x1E;\n                if (!virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n                    if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                        return -1;\n\n                    cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                    cont->info.addr.pci.domain = 0;\n                    cont->info.addr.pci.bus = 0;\n                    cont->info.addr.pci.slot = 0x1E;\n                    cont->info.addr.pci.function = 0;\n                }\n            }\n            break;\n        }\n    }\n\n    /* Reserve slot 0x1F function 0 (ISA bridge, not in config model)\n     * and function 3 (SMBus, also not (yet) in config model). As with\n     * the SATA controller, these devices are always present in a q35\n     * machine; there is no way to not have them.\n     */\n    if (addrs->nbuses) {\n        memset(&tmp_addr, 0, sizeof(tmp_addr));\n        tmp_addr.slot = 0x1F;\n        tmp_addr.function = 0;\n        tmp_addr.multi = VIR_TRISTATE_SWITCH_ON;\n        if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n           return -1;\n\n        tmp_addr.function = 3;\n        tmp_addr.multi = VIR_TRISTATE_SWITCH_ABSENT;\n        if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n           return -1;\n    }\n\n    /* ramfb is not a PCI device */\n    if (def->nvideos > 0 &&\n        def->videos[0]->type != VIR_DOMAIN_VIDEO_TYPE_NONE &&\n        def->videos[0]->type != VIR_DOMAIN_VIDEO_TYPE_RAMFB) {\n        /* NB: unlike the pc machinetypes, on q35 machinetypes the\n         * integrated devices are at slot 0x1f, so when qemu looks for\n         * the first free slot for the first VGA, it will always be at\n         * slot 1 (which was used up by the integrated PIIX3 devices\n         * on pc machinetypes).\n         */\n        virDomainVideoDefPtr primaryVideo = def->videos[0];\n        if (virDeviceInfoPCIAddressIsWanted(&primaryVideo->info)) {\n            memset(&tmp_addr, 0, sizeof(tmp_addr));\n            tmp_addr.slot = 1;\n\n            if (!(addrStr = virPCIDeviceAddressAsString(&tmp_addr)))\n                return -1;\n            if (!virDomainPCIAddressValidate(addrs, &tmp_addr,\n                                             addrStr, flags, true))\n                return -1;\n\n            if (virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n                if (qemuDeviceVideoUsable) {\n                    if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                            &primaryVideo->info) < 0)\n                        return -1;\n                } else {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"PCI address 0:0:1.0 is in use, \"\n                                     \"QEMU needs it for primary video\"));\n                    return -1;\n                }\n            } else {\n                if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                    return -1;\n                primaryVideo->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                primaryVideo->info.addr.pci = tmp_addr;\n            }\n        } else if (!qemuDeviceVideoUsable) {\n            if (primaryVideo->info.addr.pci.domain != 0 ||\n                primaryVideo->info.addr.pci.bus != 0 ||\n                primaryVideo->info.addr.pci.slot != 1 ||\n                primaryVideo->info.addr.pci.function != 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Primary video card must have PCI address 0:0:1.0\"));\n                return -1;\n            }\n            /* If TYPE == PCI, then qemuDomainCollectPCIAddress() function\n             * has already reserved the address, so we must skip */\n        }\n    } else if (addrs->nbuses && !qemuDeviceVideoUsable) {\n        memset(&tmp_addr, 0, sizeof(tmp_addr));\n        tmp_addr.slot = 1;\n\n        if (virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n            VIR_DEBUG(\"PCI address 0:0:1.0 in use, future addition of a video\"\n                      \" device will not be possible without manual\"\n                      \" intervention\");\n            virResetLastError();\n        } else if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0) {\n            return -1;\n        }\n    }\n\n    memset(&tmp_addr, 0, sizeof(tmp_addr));\n    tmp_addr.slot = 0x1B;\n    if (!virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n        /* Since real Q35 hardware has an ICH9 chip that has an\n         * integrated HD audio device at 0000:00:1B.0 put any\n         * unaddressed ICH9 audio device at that address if it's not\n         * already taken. If there's something already there, let the\n         * normal device addressing assign something later.\n         */\n        for (i = 0; i < def->nsounds; i++) {\n            virDomainSoundDefPtr sound = def->sounds[i];\n\n            if (sound->model != VIR_DOMAIN_SOUND_MODEL_ICH9 ||\n                !virDeviceInfoPCIAddressIsWanted(&sound->info)) {\n                continue;\n            }\n            if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                return -1;\n\n            sound->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n            sound->info.addr.pci = tmp_addr;\n            break;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainValidateDevicePCISlotsPIIX3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1730-1868",
    "snippet": "static int\nqemuDomainValidateDevicePCISlotsPIIX3(virDomainDefPtr def,\n                                      virQEMUCapsPtr qemuCaps,\n                                      virDomainPCIAddressSetPtr addrs)\n{\n    size_t i;\n    virPCIDeviceAddress tmp_addr;\n    bool qemuDeviceVideoUsable = virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIDEO_PRIMARY);\n    g_autofree char *addrStr = NULL;\n    virDomainPCIConnectFlags flags = (VIR_PCI_CONNECT_HOTPLUGGABLE\n                                      | VIR_PCI_CONNECT_TYPE_PCI_DEVICE);\n\n    /* Verify that first IDE and USB controllers (if any) is on the PIIX3, fn 1 */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        virPCIDeviceAddress primaryIDEAddr = {.domain = 0, .bus = 0,\n                                              .slot = 1, .function = 1};\n        virPCIDeviceAddress piix3USBAddr = {.domain = 0, .bus = 0,\n                                            .slot = 1, .function = 2};\n\n        /* First IDE controller lives on the PIIX3 at slot=1, function=1 */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_IDE &&\n            cont->idx == 0) {\n            if (virDeviceInfoPCIAddressIsPresent(&cont->info)) {\n                if (!virPCIDeviceAddressEqual(&cont->info.addr.pci,\n                                              &primaryIDEAddr)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Primary IDE controller must have PCI \"\n                                     \"address 0:0:1.1\"));\n                    return -1;\n                }\n            } else {\n                cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                cont->info.addr.pci = primaryIDEAddr;\n            }\n        } else if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB &&\n                   cont->idx == 0 &&\n                   (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI ||\n                    cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT)) {\n            if (virDeviceInfoPCIAddressIsPresent(&cont->info)) {\n                if (!virPCIDeviceAddressEqual(&cont->info.addr.pci,\n                                              &piix3USBAddr)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"PIIX3 USB controller at index 0 must \"\n                                     \"have PCI address 0:0:1.2\"));\n                    return -1;\n                }\n            } else {\n                cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                cont->info.addr.pci = piix3USBAddr;\n            }\n        } else {\n            /* this controller is not skipped in qemuDomainCollectPCIAddress */\n            continue;\n        }\n        if (addrs->nbuses &&\n            virDomainPCIAddressReserveAddr(addrs, &cont->info.addr.pci, flags, 0) < 0)\n            return -1;\n    }\n\n    /* Implicit PIIX3 devices living on slot 1 not handled above */\n    if (addrs->nbuses) {\n        memset(&tmp_addr, 0, sizeof(tmp_addr));\n        tmp_addr.slot = 1;\n        /* ISA Bridge at 00:01.0 */\n        if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n            return -1;\n        /* Bridge at 00:01.3 */\n        tmp_addr.function = 3;\n        if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n            return -1;\n    }\n\n    /* ramfb is not a PCI device */\n    if (def->nvideos > 0 &&\n        def->videos[0]->type != VIR_DOMAIN_VIDEO_TYPE_NONE &&\n        def->videos[0]->type != VIR_DOMAIN_VIDEO_TYPE_RAMFB) {\n        /* Because the PIIX3 integrated IDE/USB controllers are\n         * already at slot 1, when qemu looks for the first free slot\n         * to place the VGA controller (which is always the first\n         * device added after integrated devices), it *always* ends up\n         * at slot 2.\n         */\n        virDomainVideoDefPtr primaryVideo = def->videos[0];\n        virPCIDeviceAddress primaryCardAddr = {.domain = 0, .bus = 0,\n                                               .slot = 2, .function = 0};\n\n        if (virDeviceInfoPCIAddressIsWanted(&primaryVideo->info)) {\n            memset(&tmp_addr, 0, sizeof(tmp_addr));\n            tmp_addr.slot = 2;\n\n            if (!(addrStr = virPCIDeviceAddressAsString(&tmp_addr)))\n                return -1;\n            if (!virDomainPCIAddressValidate(addrs, &tmp_addr,\n                                             addrStr, flags, true))\n                return -1;\n\n            if (virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n                if (qemuDeviceVideoUsable) {\n                    if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                            &primaryVideo->info) < 0) {\n                        return -1;\n                    }\n                } else {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"PCI address 0:0:2.0 is in use, \"\n                                     \"QEMU needs it for primary video\"));\n                    return -1;\n                }\n            } else {\n                if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                    return -1;\n                primaryVideo->info.addr.pci = tmp_addr;\n                primaryVideo->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n            }\n        } else if (!qemuDeviceVideoUsable) {\n            if (!virPCIDeviceAddressEqual(&primaryVideo->info.addr.pci,\n                                          &primaryCardAddr)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Primary video card must have PCI address 0:0:2.0\"));\n                return -1;\n            }\n            /* If TYPE == PCI, then qemuDomainCollectPCIAddress() function\n             * has already reserved the address, so we must skip */\n        }\n    } else if (addrs->nbuses && !qemuDeviceVideoUsable) {\n        memset(&tmp_addr, 0, sizeof(tmp_addr));\n        tmp_addr.slot = 2;\n\n        if (virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n            VIR_DEBUG(\"PCI address 0:0:2.0 in use, future addition of a video\"\n                      \" device will not be possible without manual\"\n                      \" intervention\");\n        } else if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0) {\n            return -1;\n        }\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressReserveAddr",
          "args": [
            "addrs",
            "&tmp_addr",
            "flags",
            "0"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressReserveAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "895-903",
          "snippet": "int\nvirDomainPCIAddressReserveAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr,\n                               virDomainPCIConnectFlags flags,\n                               unsigned int isolationGroup)\n{\n    return virDomainPCIAddressReserveAddrInternal(addrs, addr, flags,\n                                                  isolationGroup, true);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressReserveAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr,\n                               virDomainPCIConnectFlags flags,\n                               unsigned int isolationGroup)\n{\n    return virDomainPCIAddressReserveAddrInternal(addrs, addr, flags,\n                                                  isolationGroup, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"PCI address 0:0:2.0 in use, future addition of a video\"\n                      \" device will not be possible without manual\"\n                      \" intervention\""
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressSlotInUse",
          "args": [
            "addrs",
            "&tmp_addr"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressSlotInUse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "810-815",
          "snippet": "bool\nvirDomainPCIAddressSlotInUse(virDomainPCIAddressSetPtr addrs,\n                             virPCIDeviceAddressPtr addr)\n{\n    return !!addrs->buses[addr->bus].slot[addr->slot].functions;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainPCIAddressSlotInUse(virDomainPCIAddressSetPtr addrs,\n                             virPCIDeviceAddressPtr addr)\n{\n    return !!addrs->buses[addr->bus].slot[addr->slot].functions;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tmp_addr",
            "0",
            "sizeof(tmp_addr)"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Primary video card must have PCI address 0:0:2.0\")"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Primary video card must have PCI address 0:0:2.0\""
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressEqual",
          "args": [
            "&primaryVideo->info.addr.pci",
            "&primaryCardAddr"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1324-1335",
          "snippet": "bool\nvirPCIDeviceAddressEqual(const virPCIDeviceAddress *addr1,\n                         const virPCIDeviceAddress *addr2)\n{\n    if (addr1->domain == addr2->domain &&\n        addr1->bus == addr2->bus &&\n        addr1->slot == addr2->slot &&\n        addr1->function == addr2->function) {\n        return true;\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceAddressEqual(const virPCIDeviceAddress *addr1,\n                         const virPCIDeviceAddress *addr2)\n{\n    if (addr1->domain == addr2->domain &&\n        addr1->bus == addr2->bus &&\n        addr1->slot == addr2->slot &&\n        addr1->function == addr2->function) {\n        return true;\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"PCI address 0:0:2.0 is in use, \"\n                                     \"QEMU needs it for primary video\")"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainPCIAddressReserveNextAddr",
          "args": [
            "addrs",
            "&primaryVideo->info"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainPCIAddressReserveNextAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "1484-1490",
          "snippet": "static int\nqemuDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                    virDomainDeviceInfoPtr dev)\n{\n    return virDomainPCIAddressReserveNextAddr(addrs, dev,\n                                              dev->pciConnectFlags, -1);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                    virDomainDeviceInfoPtr dev)\n{\n    return virDomainPCIAddressReserveNextAddr(addrs, dev,\n                                              dev->pciConnectFlags, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressValidate",
          "args": [
            "addrs",
            "&tmp_addr",
            "addrStr",
            "flags",
            "true"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "441-500",
          "snippet": "bool\nvirDomainPCIAddressValidate(virDomainPCIAddressSetPtr addrs,\n                            virPCIDeviceAddressPtr addr,\n                            const char *addrStr,\n                            virDomainPCIConnectFlags flags,\n                            bool fromConfig)\n{\n    virDomainPCIAddressBusPtr bus;\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (addrs->nbuses == 0) {\n        virReportError(errType, \"%s\", _(\"No PCI buses available\"));\n        return false;\n    }\n    if (addr->domain != 0) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI domain 0 is available\"),\n                       addrStr);\n        return false;\n    }\n    if (addr->bus >= addrs->nbuses) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI buses up to %zu are available\"),\n                       addrStr, addrs->nbuses - 1);\n        return false;\n    }\n\n    bus = &addrs->buses[addr->bus];\n\n    /* assure that at least one of the requested connection types is\n     * provided by this bus\n     */\n    if (!virDomainPCIAddressFlagsCompatible(addr, addrStr, bus->flags,\n                                            flags, true, fromConfig))\n        return false;\n\n    /* some \"buses\" are really just a single port */\n    if (bus->minSlot && addr->slot < bus->minSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be >= %zu\"),\n                       addrStr, bus->minSlot);\n        return false;\n    }\n    if (addr->slot > bus->maxSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be <= %zu\"),\n                       addrStr, bus->maxSlot);\n        return false;\n    }\n    if (addr->function > VIR_PCI_ADDRESS_FUNCTION_LAST) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. function must be <= %u\"),\n                       addrStr, VIR_PCI_ADDRESS_FUNCTION_LAST);\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainPCIAddressValidate(virDomainPCIAddressSetPtr addrs,\n                            virPCIDeviceAddressPtr addr,\n                            const char *addrStr,\n                            virDomainPCIConnectFlags flags,\n                            bool fromConfig)\n{\n    virDomainPCIAddressBusPtr bus;\n    virErrorNumber errType = (fromConfig\n                              ? VIR_ERR_XML_ERROR : VIR_ERR_INTERNAL_ERROR);\n\n    if (addrs->nbuses == 0) {\n        virReportError(errType, \"%s\", _(\"No PCI buses available\"));\n        return false;\n    }\n    if (addr->domain != 0) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI domain 0 is available\"),\n                       addrStr);\n        return false;\n    }\n    if (addr->bus >= addrs->nbuses) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. \"\n                         \"Only PCI buses up to %zu are available\"),\n                       addrStr, addrs->nbuses - 1);\n        return false;\n    }\n\n    bus = &addrs->buses[addr->bus];\n\n    /* assure that at least one of the requested connection types is\n     * provided by this bus\n     */\n    if (!virDomainPCIAddressFlagsCompatible(addr, addrStr, bus->flags,\n                                            flags, true, fromConfig))\n        return false;\n\n    /* some \"buses\" are really just a single port */\n    if (bus->minSlot && addr->slot < bus->minSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be >= %zu\"),\n                       addrStr, bus->minSlot);\n        return false;\n    }\n    if (addr->slot > bus->maxSlot) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. slot must be <= %zu\"),\n                       addrStr, bus->maxSlot);\n        return false;\n    }\n    if (addr->function > VIR_PCI_ADDRESS_FUNCTION_LAST) {\n        virReportError(errType,\n                       _(\"Invalid PCI address %s. function must be <= %u\"),\n                       addrStr, VIR_PCI_ADDRESS_FUNCTION_LAST);\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressAsString",
          "args": [
            "&tmp_addr"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressAsString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1351-1362",
          "snippet": "char *\nvirPCIDeviceAddressAsString(const virPCIDeviceAddress *addr)\n{\n    char *str;\n\n    str = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT,\n                          addr->domain,\n                          addr->bus,\n                          addr->slot,\n                          addr->function);\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceAddressAsString(const virPCIDeviceAddress *addr)\n{\n    char *str;\n\n    str = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT,\n                          addr->domain,\n                          addr->bus,\n                          addr->slot,\n                          addr->function);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tmp_addr",
            "0",
            "sizeof(tmp_addr)"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDeviceInfoPCIAddressIsWanted",
          "args": [
            "&primaryVideo->info"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "virDeviceInfoPCIAddressIsWanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "183-189",
          "snippet": "bool\nvirDeviceInfoPCIAddressIsWanted(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE ||\n           (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n            virPCIDeviceAddressIsEmpty(&info->addr.pci));\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool\nvirDeviceInfoPCIAddressIsWanted(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE ||\n           (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n            virPCIDeviceAddressIsEmpty(&info->addr.pci));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tmp_addr",
            "0",
            "sizeof(tmp_addr)"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"PIIX3 USB controller at index 0 must \"\n                                     \"have PCI address 0:0:1.2\")"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDeviceInfoPCIAddressIsPresent",
          "args": [
            "&cont->info"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "virDeviceInfoPCIAddressIsPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "191-196",
          "snippet": "bool\nvirDeviceInfoPCIAddressIsPresent(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n           !virPCIDeviceAddressIsEmpty(&info->addr.pci);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool\nvirDeviceInfoPCIAddressIsPresent(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n           !virPCIDeviceAddressIsEmpty(&info->addr.pci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Primary IDE controller must have PCI \"\n                                     \"address 0:0:1.1\")"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_DEVICE_VIDEO_PRIMARY"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainValidateDevicePCISlotsPIIX3(virDomainDefPtr def,\n                                      virQEMUCapsPtr qemuCaps,\n                                      virDomainPCIAddressSetPtr addrs)\n{\n    size_t i;\n    virPCIDeviceAddress tmp_addr;\n    bool qemuDeviceVideoUsable = virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIDEO_PRIMARY);\n    g_autofree char *addrStr = NULL;\n    virDomainPCIConnectFlags flags = (VIR_PCI_CONNECT_HOTPLUGGABLE\n                                      | VIR_PCI_CONNECT_TYPE_PCI_DEVICE);\n\n    /* Verify that first IDE and USB controllers (if any) is on the PIIX3, fn 1 */\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        virPCIDeviceAddress primaryIDEAddr = {.domain = 0, .bus = 0,\n                                              .slot = 1, .function = 1};\n        virPCIDeviceAddress piix3USBAddr = {.domain = 0, .bus = 0,\n                                            .slot = 1, .function = 2};\n\n        /* First IDE controller lives on the PIIX3 at slot=1, function=1 */\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_IDE &&\n            cont->idx == 0) {\n            if (virDeviceInfoPCIAddressIsPresent(&cont->info)) {\n                if (!virPCIDeviceAddressEqual(&cont->info.addr.pci,\n                                              &primaryIDEAddr)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Primary IDE controller must have PCI \"\n                                     \"address 0:0:1.1\"));\n                    return -1;\n                }\n            } else {\n                cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                cont->info.addr.pci = primaryIDEAddr;\n            }\n        } else if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB &&\n                   cont->idx == 0 &&\n                   (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI ||\n                    cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT)) {\n            if (virDeviceInfoPCIAddressIsPresent(&cont->info)) {\n                if (!virPCIDeviceAddressEqual(&cont->info.addr.pci,\n                                              &piix3USBAddr)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"PIIX3 USB controller at index 0 must \"\n                                     \"have PCI address 0:0:1.2\"));\n                    return -1;\n                }\n            } else {\n                cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n                cont->info.addr.pci = piix3USBAddr;\n            }\n        } else {\n            /* this controller is not skipped in qemuDomainCollectPCIAddress */\n            continue;\n        }\n        if (addrs->nbuses &&\n            virDomainPCIAddressReserveAddr(addrs, &cont->info.addr.pci, flags, 0) < 0)\n            return -1;\n    }\n\n    /* Implicit PIIX3 devices living on slot 1 not handled above */\n    if (addrs->nbuses) {\n        memset(&tmp_addr, 0, sizeof(tmp_addr));\n        tmp_addr.slot = 1;\n        /* ISA Bridge at 00:01.0 */\n        if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n            return -1;\n        /* Bridge at 00:01.3 */\n        tmp_addr.function = 3;\n        if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n            return -1;\n    }\n\n    /* ramfb is not a PCI device */\n    if (def->nvideos > 0 &&\n        def->videos[0]->type != VIR_DOMAIN_VIDEO_TYPE_NONE &&\n        def->videos[0]->type != VIR_DOMAIN_VIDEO_TYPE_RAMFB) {\n        /* Because the PIIX3 integrated IDE/USB controllers are\n         * already at slot 1, when qemu looks for the first free slot\n         * to place the VGA controller (which is always the first\n         * device added after integrated devices), it *always* ends up\n         * at slot 2.\n         */\n        virDomainVideoDefPtr primaryVideo = def->videos[0];\n        virPCIDeviceAddress primaryCardAddr = {.domain = 0, .bus = 0,\n                                               .slot = 2, .function = 0};\n\n        if (virDeviceInfoPCIAddressIsWanted(&primaryVideo->info)) {\n            memset(&tmp_addr, 0, sizeof(tmp_addr));\n            tmp_addr.slot = 2;\n\n            if (!(addrStr = virPCIDeviceAddressAsString(&tmp_addr)))\n                return -1;\n            if (!virDomainPCIAddressValidate(addrs, &tmp_addr,\n                                             addrStr, flags, true))\n                return -1;\n\n            if (virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n                if (qemuDeviceVideoUsable) {\n                    if (qemuDomainPCIAddressReserveNextAddr(addrs,\n                                                            &primaryVideo->info) < 0) {\n                        return -1;\n                    }\n                } else {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"PCI address 0:0:2.0 is in use, \"\n                                     \"QEMU needs it for primary video\"));\n                    return -1;\n                }\n            } else {\n                if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0)\n                    return -1;\n                primaryVideo->info.addr.pci = tmp_addr;\n                primaryVideo->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n            }\n        } else if (!qemuDeviceVideoUsable) {\n            if (!virPCIDeviceAddressEqual(&primaryVideo->info.addr.pci,\n                                          &primaryCardAddr)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Primary video card must have PCI address 0:0:2.0\"));\n                return -1;\n            }\n            /* If TYPE == PCI, then qemuDomainCollectPCIAddress() function\n             * has already reserved the address, so we must skip */\n        }\n    } else if (addrs->nbuses && !qemuDeviceVideoUsable) {\n        memset(&tmp_addr, 0, sizeof(tmp_addr));\n        tmp_addr.slot = 2;\n\n        if (virDomainPCIAddressSlotInUse(addrs, &tmp_addr)) {\n            VIR_DEBUG(\"PCI address 0:0:2.0 in use, future addition of a video\"\n                      \" device will not be possible without manual\"\n                      \" intervention\");\n        } else if (virDomainPCIAddressReserveAddr(addrs, &tmp_addr, flags, 0) < 0) {\n            return -1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainPCIAddressSetCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1625-1727",
    "snippet": "static virDomainPCIAddressSetPtr\nqemuDomainPCIAddressSetCreate(virDomainDefPtr def,\n                              virQEMUCapsPtr qemuCaps,\n                              unsigned int nbuses,\n                              bool dryRun)\n{\n    virDomainPCIAddressSetPtr addrs;\n    size_t i;\n    bool hasPCIeRoot = false;\n    virDomainControllerModelPCI defaultModel;\n    virPCIDeviceAddressExtensionFlags extFlags = VIR_PCI_ADDRESS_EXTENSION_NONE;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_ZPCI))\n        extFlags |= VIR_PCI_ADDRESS_EXTENSION_ZPCI;\n\n    if ((addrs = virDomainPCIAddressSetAlloc(nbuses, extFlags)) == NULL)\n        return NULL;\n\n    addrs->dryRun = dryRun;\n\n    /* pSeries domains support multiple pci-root controllers */\n    if (qemuDomainIsPSeries(def))\n        addrs->areMultipleRootsSupported = true;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_PCIE_PCI_BRIDGE))\n        addrs->isPCIeToPCIBridgeSupported = true;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        size_t idx = cont->idx;\n\n        if (cont->type != VIR_DOMAIN_CONTROLLER_TYPE_PCI)\n            continue;\n\n        if (idx >= addrs->nbuses) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Inappropriate new pci controller index %zu \"\n                             \"exceeds addrs array length\"), idx);\n            goto error;\n        }\n\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[idx], cont->model) < 0)\n            goto error;\n\n        /* Forward the information about isolation groups */\n        addrs->buses[idx].isolationGroup = cont->info.isolationGroup;\n        addrs->buses[idx].isolationGroupLocked = cont->info.isolationGroupLocked;\n\n        if (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT)\n            hasPCIeRoot = true;\n    }\n\n    if (nbuses > 0 && !addrs->buses[0].model) {\n        /* This is just here to replicate a safety measure already in\n         * an older version of this code. In practice, the root bus\n         * should have already been added at index 0 prior to\n         * assigning addresses to devices.\n         */\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[0],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT) < 0)\n            goto error;\n    }\n\n    /* Now fill in a reasonable model for all the buses in the set\n     * that don't yet have a corresponding controller in the domain\n     * config.\n     */\n    if (qemuDomainIsPSeries(def)) {\n        /* pSeries guests should use PHBs (pci-root controllers) */\n        defaultModel = VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT;\n    } else if (hasPCIeRoot) {\n        defaultModel = VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT;\n    } else {\n        defaultModel = VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE;\n    }\n\n    for (i = 1; i < addrs->nbuses; i++) {\n\n        if (addrs->buses[i].model)\n            continue;\n\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i], defaultModel) < 0)\n            goto error;\n\n        VIR_DEBUG(\"Auto-adding <controller type='pci' model='%s' index='%zu'/>\",\n                  virDomainControllerModelPCITypeToString(defaultModel), i);\n    }\n\n    if (virDomainDeviceInfoIterate(def, qemuDomainCollectPCIAddress, addrs) < 0)\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def,\n                                   qemuDomainCollectPCIAddressExtension,\n                                   addrs) < 0) {\n        goto error;\n    }\n\n    return addrs;\n\n error:\n    virDomainPCIAddressSetFree(addrs);\n    return NULL;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressSetFree",
          "args": [
            "addrs"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressSetFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1079-1088",
          "snippet": "void\nvirDomainPCIAddressSetFree(virDomainPCIAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virDomainPCIAddressSetExtensionFree(addrs);\n    VIR_FREE(addrs->buses);\n    VIR_FREE(addrs);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainPCIAddressSetFree(virDomainPCIAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virDomainPCIAddressSetExtensionFree(addrs);\n    VIR_FREE(addrs->buses);\n    VIR_FREE(addrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDeviceInfoIterate",
          "args": [
            "def",
            "qemuDomainCollectPCIAddressExtension",
            "addrs"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceInfoIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "4352-4358",
          "snippet": "int\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Auto-adding <controller type='pci' model='%s' index='%zu'/>\"",
            "virDomainControllerModelPCITypeToString(defaultModel)",
            "i"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainControllerModelPCITypeToString",
          "args": [
            "defaultModel"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressBusSetModel",
          "args": [
            "&addrs->buses[i]",
            "defaultModel"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressBusSetModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "503-603",
          "snippet": "int\nvirDomainPCIAddressBusSetModel(virDomainPCIAddressBusPtr bus,\n                               virDomainControllerModelPCI model)\n{\n    /* set flags for what can be connected *downstream* from each\n     * bus.\n     */\n    switch (model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE |\n                      VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n        /* slots 1 - 31, no hotplug, PCIe endpoint device or\n         * pcie-root-port only, unless the address was specified in\n         * user config *and* the particular device being attached also\n         * allows it.\n         */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT |\n                      VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n        /* slots 0 - 31, standard PCI slots,\n         * but *not* hot-pluggable */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n        /* Same as pci-bridge: 32 hotpluggable traditional PCI slots (0-31),\n         * the first of which is not usable because of the SHPC */\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n        /* provides one slot which is pcie, can be used by endpoint\n         * devices, pcie-switch-upstream-ports or pcie-to-pci-bridges,\n         * and is hotpluggable */\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT |\n                      VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = 0;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n        /* 32 slots, can only accept pcie-switch-downstream-ports,\n         * no hotplug\n         */\n        bus->flags = VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT;\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n        /* 32 slots, no hotplug, only accepts pcie-root-port or\n         * dmi-to-pci-bridge\n         */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT |\n                      VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"PCI controller model was not set correctly\"));\n        return -1;\n    }\n\n    bus->model = model;\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressBusSetModel(virDomainPCIAddressBusPtr bus,\n                               virDomainControllerModelPCI model)\n{\n    /* set flags for what can be connected *downstream* from each\n     * bus.\n     */\n    switch (model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE |\n                      VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n        /* slots 1 - 31, no hotplug, PCIe endpoint device or\n         * pcie-root-port only, unless the address was specified in\n         * user config *and* the particular device being attached also\n         * allows it.\n         */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT |\n                      VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n        /* slots 0 - 31, standard PCI slots,\n         * but *not* hot-pluggable */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n        /* Same as pci-bridge: 32 hotpluggable traditional PCI slots (0-31),\n         * the first of which is not usable because of the SHPC */\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCI_BRIDGE);\n        bus->minSlot = 1;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n        /* provides one slot which is pcie, can be used by endpoint\n         * devices, pcie-switch-upstream-ports or pcie-to-pci-bridges,\n         * and is hotpluggable */\n        bus->flags = (VIR_PCI_CONNECT_HOTPLUGGABLE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                      VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT |\n                      VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = 0;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n        /* 32 slots, can only accept pcie-switch-downstream-ports,\n         * no hotplug\n         */\n        bus->flags = VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT;\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n        /* 32 slots, no hotplug, only accepts pcie-root-port or\n         * dmi-to-pci-bridge\n         */\n        bus->flags = (VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT |\n                      VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE);\n        bus->minSlot = 0;\n        bus->maxSlot = VIR_PCI_ADDRESS_SLOT_LAST;\n        break;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"PCI controller model was not set correctly\"));\n        return -1;\n    }\n\n    bus->model = model;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainIsPSeries",
          "args": [
            "def"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainIsPSeries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12912-12916",
          "snippet": "bool\nqemuDomainIsPSeries(const virDomainDef *def)\n{\n    return qemuDomainMachineIsPSeries(def->os.machine, def->os.arch);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainIsPSeries(const virDomainDef *def)\n{\n    return qemuDomainMachineIsPSeries(def->os.machine, def->os.arch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Inappropriate new pci controller index %zu \"\n                             \"exceeds addrs array length\")",
            "idx"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Inappropriate new pci controller index %zu \"\n                             \"exceeds addrs array length\""
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_DEVICE_PCIE_PCI_BRIDGE"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIAddressSetAlloc",
          "args": [
            "nbuses",
            "extFlags"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressSetAlloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1054-1076",
          "snippet": "virDomainPCIAddressSetPtr\nvirDomainPCIAddressSetAlloc(unsigned int nbuses,\n                            virPCIDeviceAddressExtensionFlags extFlags)\n{\n    virDomainPCIAddressSetPtr addrs;\n\n    if (VIR_ALLOC(addrs) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(addrs->buses, nbuses) < 0)\n        goto error;\n\n    addrs->nbuses = nbuses;\n\n    if (virDomainPCIAddressSetExtensionAlloc(addrs, extFlags) < 0)\n        goto error;\n\n    return addrs;\n\n error:\n    virDomainPCIAddressSetFree(addrs);\n    return NULL;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvirDomainPCIAddressSetPtr\nvirDomainPCIAddressSetAlloc(unsigned int nbuses,\n                            virPCIDeviceAddressExtensionFlags extFlags)\n{\n    virDomainPCIAddressSetPtr addrs;\n\n    if (VIR_ALLOC(addrs) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(addrs->buses, nbuses) < 0)\n        goto error;\n\n    addrs->nbuses = nbuses;\n\n    if (virDomainPCIAddressSetExtensionAlloc(addrs, extFlags) < 0)\n        goto error;\n\n    return addrs;\n\n error:\n    virDomainPCIAddressSetFree(addrs);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic virDomainPCIAddressSetPtr\nqemuDomainPCIAddressSetCreate(virDomainDefPtr def,\n                              virQEMUCapsPtr qemuCaps,\n                              unsigned int nbuses,\n                              bool dryRun)\n{\n    virDomainPCIAddressSetPtr addrs;\n    size_t i;\n    bool hasPCIeRoot = false;\n    virDomainControllerModelPCI defaultModel;\n    virPCIDeviceAddressExtensionFlags extFlags = VIR_PCI_ADDRESS_EXTENSION_NONE;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_ZPCI))\n        extFlags |= VIR_PCI_ADDRESS_EXTENSION_ZPCI;\n\n    if ((addrs = virDomainPCIAddressSetAlloc(nbuses, extFlags)) == NULL)\n        return NULL;\n\n    addrs->dryRun = dryRun;\n\n    /* pSeries domains support multiple pci-root controllers */\n    if (qemuDomainIsPSeries(def))\n        addrs->areMultipleRootsSupported = true;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_PCIE_PCI_BRIDGE))\n        addrs->isPCIeToPCIBridgeSupported = true;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n        size_t idx = cont->idx;\n\n        if (cont->type != VIR_DOMAIN_CONTROLLER_TYPE_PCI)\n            continue;\n\n        if (idx >= addrs->nbuses) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Inappropriate new pci controller index %zu \"\n                             \"exceeds addrs array length\"), idx);\n            goto error;\n        }\n\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[idx], cont->model) < 0)\n            goto error;\n\n        /* Forward the information about isolation groups */\n        addrs->buses[idx].isolationGroup = cont->info.isolationGroup;\n        addrs->buses[idx].isolationGroupLocked = cont->info.isolationGroupLocked;\n\n        if (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT)\n            hasPCIeRoot = true;\n    }\n\n    if (nbuses > 0 && !addrs->buses[0].model) {\n        /* This is just here to replicate a safety measure already in\n         * an older version of this code. In practice, the root bus\n         * should have already been added at index 0 prior to\n         * assigning addresses to devices.\n         */\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[0],\n                                           VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT) < 0)\n            goto error;\n    }\n\n    /* Now fill in a reasonable model for all the buses in the set\n     * that don't yet have a corresponding controller in the domain\n     * config.\n     */\n    if (qemuDomainIsPSeries(def)) {\n        /* pSeries guests should use PHBs (pci-root controllers) */\n        defaultModel = VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT;\n    } else if (hasPCIeRoot) {\n        defaultModel = VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT;\n    } else {\n        defaultModel = VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE;\n    }\n\n    for (i = 1; i < addrs->nbuses; i++) {\n\n        if (addrs->buses[i].model)\n            continue;\n\n        if (virDomainPCIAddressBusSetModel(&addrs->buses[i], defaultModel) < 0)\n            goto error;\n\n        VIR_DEBUG(\"Auto-adding <controller type='pci' model='%s' index='%zu'/>\",\n                  virDomainControllerModelPCITypeToString(defaultModel), i);\n    }\n\n    if (virDomainDeviceInfoIterate(def, qemuDomainCollectPCIAddress, addrs) < 0)\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def,\n                                   qemuDomainCollectPCIAddressExtension,\n                                   addrs) < 0) {\n        goto error;\n    }\n\n    return addrs;\n\n error:\n    virDomainPCIAddressSetFree(addrs);\n    return NULL;\n}"
  },
  {
    "function_name": "qemuDomainCollectPCIAddressExtension",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1600-1623",
    "snippet": "static int\nqemuDomainCollectPCIAddressExtension(virDomainDefPtr def G_GNUC_UNUSED,\n                                     virDomainDeviceDefPtr device,\n                                     virDomainDeviceInfoPtr info,\n                                     void *opaque)\n{\n    virDomainPCIAddressSetPtr addrs = opaque;\n    virPCIDeviceAddressPtr addr = &info->addr.pci;\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI)\n        addr->extFlags = info->pciAddrExtFlags;\n\n    if (!virDeviceInfoPCIAddressExtensionIsPresent(info) ||\n        ((device->type == VIR_DOMAIN_DEVICE_HOSTDEV) &&\n         device->data.hostdev->parentnet)) {\n        /* If a hostdev has a parent, its info will be a part of the\n         * parent, and will have its address collected during the scan\n         * of the parent's device type.\n        */\n        return 0;\n    }\n\n    return virDomainPCIAddressExtensionReserveAddr(addrs, addr);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressExtensionReserveAddr",
          "args": [
            "addrs",
            "addr"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressExtensionReserveAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "217-229",
          "snippet": "int\nvirDomainPCIAddressExtensionReserveAddr(virDomainPCIAddressSetPtr addrs,\n                                        virPCIDeviceAddressPtr addr)\n{\n    if (addr->extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) {\n        /* Reserve uid/fid to ZPCI device which has defined uid/fid\n         * in the domain.\n         */\n        return virDomainZPCIAddressReserveAddr(addrs->zpciIds, &addr->zpci);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressExtensionReserveAddr(virDomainPCIAddressSetPtr addrs,\n                                        virPCIDeviceAddressPtr addr)\n{\n    if (addr->extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) {\n        /* Reserve uid/fid to ZPCI device which has defined uid/fid\n         * in the domain.\n         */\n        return virDomainZPCIAddressReserveAddr(addrs->zpciIds, &addr->zpci);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDeviceInfoPCIAddressExtensionIsPresent",
          "args": [
            "info"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "virDeviceInfoPCIAddressExtensionIsPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "206-211",
          "snippet": "bool\nvirDeviceInfoPCIAddressExtensionIsPresent(const virDomainDeviceInfo *info)\n{\n    return (info->addr.pci.extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) &&\n           !virZPCIDeviceAddressIsEmpty(&info->addr.pci.zpci);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool\nvirDeviceInfoPCIAddressExtensionIsPresent(const virDomainDeviceInfo *info)\n{\n    return (info->addr.pci.extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) &&\n           !virZPCIDeviceAddressIsEmpty(&info->addr.pci.zpci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainCollectPCIAddressExtension(virDomainDefPtr def G_GNUC_UNUSED,\n                                     virDomainDeviceDefPtr device,\n                                     virDomainDeviceInfoPtr info,\n                                     void *opaque)\n{\n    virDomainPCIAddressSetPtr addrs = opaque;\n    virPCIDeviceAddressPtr addr = &info->addr.pci;\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI)\n        addr->extFlags = info->pciAddrExtFlags;\n\n    if (!virDeviceInfoPCIAddressExtensionIsPresent(info) ||\n        ((device->type == VIR_DOMAIN_DEVICE_HOSTDEV) &&\n         device->data.hostdev->parentnet)) {\n        /* If a hostdev has a parent, its info will be a part of the\n         * parent, and will have its address collected during the scan\n         * of the parent's device type.\n        */\n        return 0;\n    }\n\n    return virDomainPCIAddressExtensionReserveAddr(addrs, addr);\n}"
  },
  {
    "function_name": "qemuDomainCollectPCIAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1511-1598",
    "snippet": "static int\nqemuDomainCollectPCIAddress(virDomainDefPtr def G_GNUC_UNUSED,\n                            virDomainDeviceDefPtr device,\n                            virDomainDeviceInfoPtr info,\n                            void *opaque)\n{\n    virDomainPCIAddressSetPtr addrs = opaque;\n    virPCIDeviceAddressPtr addr = &info->addr.pci;\n\n    if (!virDeviceInfoPCIAddressIsPresent(info) ||\n        ((device->type == VIR_DOMAIN_DEVICE_HOSTDEV) &&\n         device->data.hostdev->parentnet)) {\n        /* If a hostdev has a parent, its info will be a part of the\n         * parent, and will have its address collected during the scan\n         * of the parent's device type.\n        */\n        return 0;\n    }\n\n    /* If we get to here, the device has a PCI address assigned in the\n     * config and we should mark it as in-use. But if the\n     * pciConnectFlags are 0, then this device shouldn't have a PCI\n     * address associated with it. *BUT* since there are cases in the\n     * past where we've apparently allowed that, we need to pretend\n     * for now that it's okay, otherwise an existing domain could\n     * \"disappear\" from the list of domains due to a parse failure. We\n     * can fix this by just forcing the pciConnectFlags to be\n     * PCI_DEVICE (and then relying on validation functions to report\n     * inappropriate address types.\n     */\n    if (!info->pciConnectFlags) {\n        g_autofree char *addrStr = virPCIDeviceAddressAsString(&info->addr.pci);\n\n        VIR_WARN(\"qemuDomainDeviceCalculatePCIConnectFlags() thinks that the \"\n                 \"device with PCI address %s should not have a PCI address\",\n                 addrStr ? addrStr : \"(unknown)\");\n\n        info->pciConnectFlags = VIR_PCI_CONNECT_TYPE_PCI_DEVICE;\n    }\n\n    /* Ignore implicit controllers on slot 0:0:1.0:\n     * implicit IDE controller on 0:0:1.1 (no qemu command line)\n     * implicit USB controller on 0:0:1.2 (-usb)\n     *\n     * If the machine does have a PCI bus, they will get reserved\n     * in qemuDomainAssignDevicePCISlots().\n     */\n\n    /* These are the IDE and USB controllers in the PIIX3, hardcoded\n     * to bus 0 slot 1.  They cannot be attached to a PCIe slot, only\n     * PCI.\n     */\n    if (device->type == VIR_DOMAIN_DEVICE_CONTROLLER && addr->domain == 0 &&\n        addr->bus == 0 && addr->slot == 1) {\n        virDomainControllerDefPtr cont = device->data.controller;\n\n        if ((cont->type == VIR_DOMAIN_CONTROLLER_TYPE_IDE && cont->idx == 0 &&\n             addr->function == 1) ||\n            (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB && cont->idx == 0 &&\n             (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI ||\n              cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT) &&\n             addr->function == 2)) {\n            /* Note the check for nbuses > 0 - if there are no PCI\n             * buses, we skip this check. This is a quirk required for\n             * some machinetypes such as s390, which pretend to have a\n             * PCI bus for long enough to generate the \"-usb\" on the\n             * commandline, but that don't really care if a PCI bus\n             * actually exists. */\n            if (addrs->nbuses > 0 &&\n                !(addrs->buses[0].flags & VIR_PCI_CONNECT_TYPE_PCI_DEVICE)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Bus 0 must be PCI for integrated PIIX3 \"\n                                 \"USB or IDE controllers\"));\n                return -1;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    if (virDomainPCIAddressReserveAddr(addrs, addr,\n                                       info->pciConnectFlags,\n                                       info->isolationGroup) < 0) {\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressReserveAddr",
          "args": [
            "addrs",
            "addr",
            "info->pciConnectFlags",
            "info->isolationGroup"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressReserveAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "895-903",
          "snippet": "int\nvirDomainPCIAddressReserveAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr,\n                               virDomainPCIConnectFlags flags,\n                               unsigned int isolationGroup)\n{\n    return virDomainPCIAddressReserveAddrInternal(addrs, addr, flags,\n                                                  isolationGroup, true);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressReserveAddr(virDomainPCIAddressSetPtr addrs,\n                               virPCIDeviceAddressPtr addr,\n                               virDomainPCIConnectFlags flags,\n                               unsigned int isolationGroup)\n{\n    return virDomainPCIAddressReserveAddrInternal(addrs, addr, flags,\n                                                  isolationGroup, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Bus 0 must be PCI for integrated PIIX3 \"\n                                 \"USB or IDE controllers\")"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Bus 0 must be PCI for integrated PIIX3 \"\n                                 \"USB or IDE controllers\""
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"qemuDomainDeviceCalculatePCIConnectFlags() thinks that the \"\n                 \"device with PCI address %s should not have a PCI address\"",
            "addrStr ? addrStr : \"(unknown)\""
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressAsString",
          "args": [
            "&info->addr.pci"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressAsString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1351-1362",
          "snippet": "char *\nvirPCIDeviceAddressAsString(const virPCIDeviceAddress *addr)\n{\n    char *str;\n\n    str = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT,\n                          addr->domain,\n                          addr->bus,\n                          addr->slot,\n                          addr->function);\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceAddressAsString(const virPCIDeviceAddress *addr)\n{\n    char *str;\n\n    str = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT,\n                          addr->domain,\n                          addr->bus,\n                          addr->slot,\n                          addr->function);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDeviceInfoPCIAddressIsPresent",
          "args": [
            "info"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "virDeviceInfoPCIAddressIsPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "191-196",
          "snippet": "bool\nvirDeviceInfoPCIAddressIsPresent(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n           !virPCIDeviceAddressIsEmpty(&info->addr.pci);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool\nvirDeviceInfoPCIAddressIsPresent(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n           !virPCIDeviceAddressIsEmpty(&info->addr.pci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainCollectPCIAddress(virDomainDefPtr def G_GNUC_UNUSED,\n                            virDomainDeviceDefPtr device,\n                            virDomainDeviceInfoPtr info,\n                            void *opaque)\n{\n    virDomainPCIAddressSetPtr addrs = opaque;\n    virPCIDeviceAddressPtr addr = &info->addr.pci;\n\n    if (!virDeviceInfoPCIAddressIsPresent(info) ||\n        ((device->type == VIR_DOMAIN_DEVICE_HOSTDEV) &&\n         device->data.hostdev->parentnet)) {\n        /* If a hostdev has a parent, its info will be a part of the\n         * parent, and will have its address collected during the scan\n         * of the parent's device type.\n        */\n        return 0;\n    }\n\n    /* If we get to here, the device has a PCI address assigned in the\n     * config and we should mark it as in-use. But if the\n     * pciConnectFlags are 0, then this device shouldn't have a PCI\n     * address associated with it. *BUT* since there are cases in the\n     * past where we've apparently allowed that, we need to pretend\n     * for now that it's okay, otherwise an existing domain could\n     * \"disappear\" from the list of domains due to a parse failure. We\n     * can fix this by just forcing the pciConnectFlags to be\n     * PCI_DEVICE (and then relying on validation functions to report\n     * inappropriate address types.\n     */\n    if (!info->pciConnectFlags) {\n        g_autofree char *addrStr = virPCIDeviceAddressAsString(&info->addr.pci);\n\n        VIR_WARN(\"qemuDomainDeviceCalculatePCIConnectFlags() thinks that the \"\n                 \"device with PCI address %s should not have a PCI address\",\n                 addrStr ? addrStr : \"(unknown)\");\n\n        info->pciConnectFlags = VIR_PCI_CONNECT_TYPE_PCI_DEVICE;\n    }\n\n    /* Ignore implicit controllers on slot 0:0:1.0:\n     * implicit IDE controller on 0:0:1.1 (no qemu command line)\n     * implicit USB controller on 0:0:1.2 (-usb)\n     *\n     * If the machine does have a PCI bus, they will get reserved\n     * in qemuDomainAssignDevicePCISlots().\n     */\n\n    /* These are the IDE and USB controllers in the PIIX3, hardcoded\n     * to bus 0 slot 1.  They cannot be attached to a PCIe slot, only\n     * PCI.\n     */\n    if (device->type == VIR_DOMAIN_DEVICE_CONTROLLER && addr->domain == 0 &&\n        addr->bus == 0 && addr->slot == 1) {\n        virDomainControllerDefPtr cont = device->data.controller;\n\n        if ((cont->type == VIR_DOMAIN_CONTROLLER_TYPE_IDE && cont->idx == 0 &&\n             addr->function == 1) ||\n            (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_USB && cont->idx == 0 &&\n             (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI ||\n              cont->model == VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT) &&\n             addr->function == 2)) {\n            /* Note the check for nbuses > 0 - if there are no PCI\n             * buses, we skip this check. This is a quirk required for\n             * some machinetypes such as s390, which pretend to have a\n             * PCI bus for long enough to generate the \"-usb\" on the\n             * commandline, but that don't really care if a PCI bus\n             * actually exists. */\n            if (addrs->nbuses > 0 &&\n                !(addrs->buses[0].flags & VIR_PCI_CONNECT_TYPE_PCI_DEVICE)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Bus 0 must be PCI for integrated PIIX3 \"\n                                 \"USB or IDE controllers\"));\n                return -1;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    if (virDomainPCIAddressReserveAddr(addrs, addr,\n                                       info->pciConnectFlags,\n                                       info->isolationGroup) < 0) {\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainAssignPCIAddressExtension",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1493-1509",
    "snippet": "static int\nqemuDomainAssignPCIAddressExtension(virDomainDefPtr def G_GNUC_UNUSED,\n                                    virDomainDeviceDefPtr device G_GNUC_UNUSED,\n                                    virDomainDeviceInfoPtr info,\n                                    void *opaque)\n{\n    virDomainPCIAddressSetPtr addrs = opaque;\n    virPCIDeviceAddressPtr addr = &info->addr.pci;\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI)\n        addr->extFlags = info->pciAddrExtFlags;\n\n    if (virDeviceInfoPCIAddressExtensionIsWanted(info))\n        return virDomainPCIAddressExtensionReserveNextAddr(addrs, addr);\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressExtensionReserveNextAddr",
          "args": [
            "addrs",
            "addr"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressExtensionReserveNextAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "232-247",
          "snippet": "int\nvirDomainPCIAddressExtensionReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                            virPCIDeviceAddressPtr addr)\n{\n    if (addr->extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) {\n        virZPCIDeviceAddress zpci = { 0 };\n\n        if (virDomainZPCIAddressReserveNextAddr(addrs->zpciIds, &zpci) < 0)\n            return -1;\n\n        if (!addrs->dryRun)\n            addr->zpci = zpci;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressExtensionReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                            virPCIDeviceAddressPtr addr)\n{\n    if (addr->extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) {\n        virZPCIDeviceAddress zpci = { 0 };\n\n        if (virDomainZPCIAddressReserveNextAddr(addrs->zpciIds, &zpci) < 0)\n            return -1;\n\n        if (!addrs->dryRun)\n            addr->zpci = zpci;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDeviceInfoPCIAddressExtensionIsWanted",
          "args": [
            "info"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "virDeviceInfoPCIAddressExtensionIsWanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "199-204",
          "snippet": "bool\nvirDeviceInfoPCIAddressExtensionIsWanted(const virDomainDeviceInfo *info)\n{\n    return (info->addr.pci.extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) &&\n           virZPCIDeviceAddressIsEmpty(&info->addr.pci.zpci);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool\nvirDeviceInfoPCIAddressExtensionIsWanted(const virDomainDeviceInfo *info)\n{\n    return (info->addr.pci.extFlags & VIR_PCI_ADDRESS_EXTENSION_ZPCI) &&\n           virZPCIDeviceAddressIsEmpty(&info->addr.pci.zpci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignPCIAddressExtension(virDomainDefPtr def G_GNUC_UNUSED,\n                                    virDomainDeviceDefPtr device G_GNUC_UNUSED,\n                                    virDomainDeviceInfoPtr info,\n                                    void *opaque)\n{\n    virDomainPCIAddressSetPtr addrs = opaque;\n    virPCIDeviceAddressPtr addr = &info->addr.pci;\n\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI)\n        addr->extFlags = info->pciAddrExtFlags;\n\n    if (virDeviceInfoPCIAddressExtensionIsWanted(info))\n        return virDomainPCIAddressExtensionReserveNextAddr(addrs, addr);\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainPCIAddressReserveNextAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1484-1490",
    "snippet": "static int\nqemuDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                    virDomainDeviceInfoPtr dev)\n{\n    return virDomainPCIAddressReserveNextAddr(addrs, dev,\n                                              dev->pciConnectFlags, -1);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainPCIAddressReserveNextAddr",
          "args": [
            "addrs",
            "dev",
            "dev->pciConnectFlags",
            "-1"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIAddressReserveNextAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1260-1285",
          "snippet": "int\nvirDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                   virDomainDeviceInfoPtr dev,\n                                   virDomainPCIConnectFlags flags,\n                                   int function)\n{\n    virPCIDeviceAddress addr;\n\n    if (virDomainPCIAddressGetNextAddr(addrs, &addr, flags,\n                                       dev->isolationGroup, function) < 0)\n        return -1;\n\n    if (virDomainPCIAddressReserveAddrInternal(addrs, &addr, flags,\n                                               dev->isolationGroup, false) < 0)\n        return -1;\n\n    addr.extFlags = dev->addr.pci.extFlags;\n    addr.zpci = dev->addr.pci.zpci;\n\n    if (!addrs->dryRun) {\n        dev->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n        dev->addr.pci = addr;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                   virDomainDeviceInfoPtr dev,\n                                   virDomainPCIConnectFlags flags,\n                                   int function)\n{\n    virPCIDeviceAddress addr;\n\n    if (virDomainPCIAddressGetNextAddr(addrs, &addr, flags,\n                                       dev->isolationGroup, function) < 0)\n        return -1;\n\n    if (virDomainPCIAddressReserveAddrInternal(addrs, &addr, flags,\n                                               dev->isolationGroup, false) < 0)\n        return -1;\n\n    addr.extFlags = dev->addr.pci.extFlags;\n    addr.zpci = dev->addr.pci.zpci;\n\n    if (!addrs->dryRun) {\n        dev->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n        dev->addr.pci = addr;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainPCIAddressReserveNextAddr(virDomainPCIAddressSetPtr addrs,\n                                    virDomainDeviceInfoPtr dev)\n{\n    return virDomainPCIAddressReserveNextAddr(addrs, dev,\n                                              dev->pciConnectFlags, -1);\n}"
  },
  {
    "function_name": "qemuDomainFillDevicePCIExtensionFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1474-1481",
    "snippet": "static void\nqemuDomainFillDevicePCIExtensionFlags(virDomainDeviceDefPtr dev,\n                                      virDomainDeviceInfoPtr info,\n                                      virQEMUCapsPtr qemuCaps)\n{\n    info->pciAddrExtFlags =\n        qemuDomainDeviceCalculatePCIAddressExtensionFlags(qemuCaps, dev);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainDeviceCalculatePCIAddressExtensionFlags",
          "args": [
            "qemuCaps",
            "dev"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainDeviceCalculatePCIAddressExtensionFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "544-556",
          "snippet": "static virPCIDeviceAddressExtensionFlags\nqemuDomainDeviceCalculatePCIAddressExtensionFlags(virQEMUCapsPtr qemuCaps,\n                                                  virDomainDeviceDefPtr dev)\n{\n    virPCIDeviceAddressExtensionFlags extFlags = 0;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_ZPCI) &&\n        qemuDomainDeviceSupportZPCI(dev)) {\n        extFlags |= VIR_PCI_ADDRESS_EXTENSION_ZPCI;\n    }\n\n    return extFlags;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic virPCIDeviceAddressExtensionFlags\nqemuDomainDeviceCalculatePCIAddressExtensionFlags(virQEMUCapsPtr qemuCaps,\n                                                  virDomainDeviceDefPtr dev)\n{\n    virPCIDeviceAddressExtensionFlags extFlags = 0;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_ZPCI) &&\n        qemuDomainDeviceSupportZPCI(dev)) {\n        extFlags |= VIR_PCI_ADDRESS_EXTENSION_ZPCI;\n    }\n\n    return extFlags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic void\nqemuDomainFillDevicePCIExtensionFlags(virDomainDeviceDefPtr dev,\n                                      virDomainDeviceInfoPtr info,\n                                      virQEMUCapsPtr qemuCaps)\n{\n    info->pciAddrExtFlags =\n        qemuDomainDeviceCalculatePCIAddressExtensionFlags(qemuCaps, dev);\n}"
  },
  {
    "function_name": "qemuDomainFillDevicePCIConnectFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1433-1460",
    "snippet": "static void\nqemuDomainFillDevicePCIConnectFlags(virDomainDefPtr def,\n                                    virDomainDeviceDefPtr dev,\n                                    virQEMUCapsPtr qemuCaps,\n                                    virQEMUDriverPtr driver)\n{\n    virDomainDeviceInfoPtr info = virDomainDeviceGetInfo(dev);\n\n    if (info) {\n        /* qemuDomainDeviceCalculatePCIConnectFlags() is called with\n         * the data setup in the ...IterData by ...IterInit() rather\n         * than setting the values directly here.  It may seem like\n         * pointless posturing, but it's done this way to eliminate\n         * duplicated setup code while allowing more efficient\n         * operation when it's being done repeatedly with the device\n         * iterator (since qemuDomainFillAllPCIConnectFlags() only\n         * calls ...IterInit() once for all devices).\n         */\n        qemuDomainFillDevicePCIConnectFlagsIterData data;\n\n        qemuDomainFillDevicePCIConnectFlagsIterInit(def, qemuCaps, driver, &data);\n\n        info->pciConnectFlags\n            = qemuDomainDeviceCalculatePCIConnectFlags(dev, data.driver,\n                                                       data.pcieFlags,\n                                                       data.virtioFlags);\n    }\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainDeviceCalculatePCIConnectFlags",
          "args": [
            "dev",
            "data.driver",
            "data.pcieFlags",
            "data.virtioFlags"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainDeviceCalculatePCIConnectFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "576-1049",
          "snippet": "static virDomainPCIConnectFlags\nqemuDomainDeviceCalculatePCIConnectFlags(virDomainDeviceDefPtr dev,\n                                         virQEMUDriverPtr driver,\n                                         virDomainPCIConnectFlags pcieFlags,\n                                         virDomainPCIConnectFlags virtioFlags)\n{\n    virDomainPCIConnectFlags pciFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                                         VIR_PCI_CONNECT_HOTPLUGGABLE);\n\n    switch ((virDomainDeviceType)dev->type) {\n    case VIR_DOMAIN_DEVICE_CONTROLLER: {\n        virDomainControllerDefPtr cont = dev->data.controller;\n\n        switch ((virDomainControllerType)cont->type) {\n        case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n            return virDomainPCIControllerModelToConnectType(cont->model);\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n            return pciFlags;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n            switch ((virDomainControllerModelUSB) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT:\n                /* qemuDomainControllerDefPostParse should have\n                 * changed 'model' to an explicit USB model in\n                 * most cases. Since we're still on the default\n                 * though, we must be going to use \"-usb\", which\n                 * is assumed to be a PCI default\n                 */\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QEMU_XHCI:\n                return pcieFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_EHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_EHCI1:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI2:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI3:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_VT82C686B_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX4_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PCI_OHCI:\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1: /* xen only */\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2: /* xen only */\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_IDE:\n            return pciFlags;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_SCSI:\n            switch ((virDomainControllerModelSCSI) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_DEFAULT:\n                return 0;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_NON_TRANSITIONAL:\n                return virtioFlags;\n\n            /* Transitional devices only work in conventional PCI slots */\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_TRANSITIONAL:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_AUTO:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1078:\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL:\n            switch ((virDomainControllerModelVirtioSerial) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO:\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_DEFAULT:\n                return virtioFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_FDC:\n        case VIR_DOMAIN_CONTROLLER_TYPE_CCID:\n        case VIR_DOMAIN_CONTROLLER_TYPE_XENBUS:\n        case VIR_DOMAIN_CONTROLLER_TYPE_LAST:\n            return 0;\n        }\n    }\n        break;\n\n    case VIR_DOMAIN_DEVICE_FS:\n        switch ((virDomainFSDriverType) dev->data.fs->fsdriver) {\n        case VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_PATH:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_HANDLE:\n            /* these drivers are handled by virtio-9p-pci */\n            switch ((virDomainFSModel) dev->data.fs->model) {\n            case VIR_DOMAIN_FS_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_FS_MODEL_VIRTIO:\n            case VIR_DOMAIN_FS_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_FS_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_FS_MODEL_LAST:\n                break;\n            }\n            break;\n\n        case VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS:\n            /* vhost-user-fs-pci */\n            return virtioFlags;\n\n        case VIR_DOMAIN_FS_DRIVER_TYPE_LOOP:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_NBD:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_PLOOP:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_LAST:\n            return 0;\n        }\n\n        return 0;\n\n    case VIR_DOMAIN_DEVICE_NET: {\n        virDomainNetDefPtr net = dev->data.net;\n\n        /* NB: a type='hostdev' will use PCI, but its\n         * address is assigned when we're assigning the\n         * addresses for other hostdev devices.\n         */\n        if (net->type == VIR_DOMAIN_NET_TYPE_HOSTDEV ||\n            net->model == VIR_DOMAIN_NET_MODEL_USB_NET) {\n            return 0;\n        }\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO ||\n            net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_NON_TRANSITIONAL)\n            return virtioFlags;\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_TRANSITIONAL)\n            return pciFlags;\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_E1000E)\n            return pcieFlags;\n\n        return pciFlags;\n    }\n\n    case VIR_DOMAIN_DEVICE_SOUND:\n        switch ((virDomainSoundModel) dev->data.sound->model) {\n        case VIR_DOMAIN_SOUND_MODEL_ES1370:\n        case VIR_DOMAIN_SOUND_MODEL_AC97:\n        case VIR_DOMAIN_SOUND_MODEL_ICH6:\n        case VIR_DOMAIN_SOUND_MODEL_ICH9:\n            return pciFlags;\n\n        case VIR_DOMAIN_SOUND_MODEL_SB16:\n        case VIR_DOMAIN_SOUND_MODEL_PCSPK:\n        case VIR_DOMAIN_SOUND_MODEL_USB:\n        case VIR_DOMAIN_SOUND_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_DISK:\n        switch ((virDomainDiskBus) dev->data.disk->bus) {\n        case VIR_DOMAIN_DISK_BUS_VIRTIO:\n            /* only virtio disks use PCI */\n            switch ((virDomainDiskModel) dev->data.disk->model) {\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO:\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_DISK_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_DISK_MODEL_LAST:\n                break;\n            }\n            return 0;\n\n        case VIR_DOMAIN_DISK_BUS_IDE:\n        case VIR_DOMAIN_DISK_BUS_FDC:\n        case VIR_DOMAIN_DISK_BUS_SCSI:\n        case VIR_DOMAIN_DISK_BUS_XEN:\n        case VIR_DOMAIN_DISK_BUS_USB:\n        case VIR_DOMAIN_DISK_BUS_UML:\n        case VIR_DOMAIN_DISK_BUS_SATA:\n        case VIR_DOMAIN_DISK_BUS_SD:\n        case VIR_DOMAIN_DISK_BUS_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_HOSTDEV: {\n        virDomainHostdevDefPtr hostdev = dev->data.hostdev;\n        bool isExpress = false;\n        virPCIDevicePtr pciDev;\n        virPCIDeviceAddressPtr hostAddr = &hostdev->source.subsys.u.pci.addr;\n\n        if (!virHostdevIsMdevDevice(hostdev) &&\n            (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n             (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n              hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST))) {\n            return 0;\n        }\n\n        if (pciFlags == pcieFlags) {\n            /* This arch/qemu only supports legacy PCI, so there\n             * is no point in checking if the device is an Express\n             * device.\n             */\n            return pciFlags;\n        }\n\n        if (virDeviceInfoPCIAddressIsPresent(hostdev->info)) {\n            /* A guest-side address has already been assigned, so\n             * we can avoid reading the PCI config, and just use\n             * pcieFlags, since the pciConnectFlags checking is\n             * more relaxed when an address is already assigned\n             * than it is when we're looking for a new address (so\n             * validation will pass regardless of whether we set\n             * the flags to PCI or PCIe).\n             */\n            return pcieFlags;\n        }\n\n        /* mdevs don't have corresponding files in /sys that we can poke to\n         * try and figure out whether they are legacy PCI or PCI Express, so\n         * the logic below would never work; instead, we just go ahead and\n         * assume they're PCI Express. This is a very reasonable assumption,\n         * as all current mdev-capable devices are indeed PCI Express */\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV)\n            return pcieFlags;\n\n        /* according to pbonzini, from the guest PoV vhost-scsi devices\n         * are the same as virtio-scsi, so they should follow virtio logic\n         */\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST) {\n            switch ((virDomainHostdevSubsysSCSIVHostModelType) hostdev->source.subsys.u.scsi_host.model) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_LAST:\n                break;\n            }\n            return 0;\n        }\n\n        if (!(pciDev = virPCIDeviceNew(hostAddr->domain,\n                                       hostAddr->bus,\n                                       hostAddr->slot,\n                                       hostAddr->function))) {\n            /* libvirt should be able to perform all the\n             * operations in virPCIDeviceNew() even if it's\n             * running unprivileged, so if this fails, the device\n             * apparently doesn't currently exist on the host.\n             * Since the overwhelming majority of assignable host\n             * devices are PCIe, assume this one is too.\n             */\n            return pcieFlags;\n        }\n\n        if (!driver->privileged) {\n            /* unprivileged libvirtd is unable to read *all* of a\n             * device's PCI config (it can only read the first 64\n             * bytes, which isn't enough for the check that's done\n             * in virPCIDeviceIsPCIExpress()), so instead of\n             * trying and failing, we make an educated guess based\n             * on the length of the device's config file - if it\n             * is 256 bytes, then it is definitely a legacy PCI\n             * device. If it's larger than that, then it is\n             * *probably PCIe (although it could be PCI-x, but\n             * those are extremely rare). If the config file can't\n             * be found (in which case the \"length\" will be -1),\n             * then we blindly assume the most likely outcome -\n             * PCIe.\n             */\n            off_t configLen\n               = virFileLength(virPCIDeviceGetConfigPath(pciDev), -1);\n\n            virPCIDeviceFree(pciDev);\n\n            if (configLen == 256)\n                return pciFlags;\n\n            return pcieFlags;\n        }\n\n        /* If we are running with privileges, we can examine the\n         * PCI config contents with virPCIDeviceIsPCIExpress() for\n         * a definitive answer.\n         */\n        isExpress = virPCIDeviceIsPCIExpress(pciDev);\n        virPCIDeviceFree(pciDev);\n\n        if (isExpress)\n            return pcieFlags;\n\n        return pciFlags;\n    }\n\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        switch ((virDomainMemballoonModel) dev->data.memballoon->model) {\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_MEMBALLOON_MODEL_XEN:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_NONE:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_RNG:\n        switch ((virDomainRNGModel) dev->data.rng->model) {\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO:\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_RNG_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        /* only one model connects using PCI */\n        switch ((virDomainWatchdogModel) dev->data.watchdog->model) {\n        case VIR_DOMAIN_WATCHDOG_MODEL_I6300ESB:\n            return pciFlags;\n\n        case VIR_DOMAIN_WATCHDOG_MODEL_IB700:\n        case VIR_DOMAIN_WATCHDOG_MODEL_DIAG288:\n        case VIR_DOMAIN_WATCHDOG_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        switch ((virDomainVideoType)dev->data.video->type) {\n        case VIR_DOMAIN_VIDEO_TYPE_VIRTIO:\n            return virtioFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_VGA:\n        case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n        case VIR_DOMAIN_VIDEO_TYPE_VMVGA:\n        case VIR_DOMAIN_VIDEO_TYPE_XEN:\n        case VIR_DOMAIN_VIDEO_TYPE_VBOX:\n        case VIR_DOMAIN_VIDEO_TYPE_QXL:\n        case VIR_DOMAIN_VIDEO_TYPE_PARALLELS:\n            return pciFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_BOCHS:\n            return pcieFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_DEFAULT:\n        case VIR_DOMAIN_VIDEO_TYPE_GOP:\n        case VIR_DOMAIN_VIDEO_TYPE_NONE:\n        case VIR_DOMAIN_VIDEO_TYPE_RAMFB:\n        case VIR_DOMAIN_VIDEO_TYPE_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        return pciFlags;\n\n    case VIR_DOMAIN_DEVICE_INPUT:\n        switch ((virDomainInputBus) dev->data.input->bus) {\n        case VIR_DOMAIN_INPUT_BUS_VIRTIO:\n            switch ((virDomainInputModel) dev->data.input->model) {\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO:\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_INPUT_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_INPUT_MODEL_LAST:\n                break;\n            }\n            return 0;\n\n        case VIR_DOMAIN_INPUT_BUS_PS2:\n        case VIR_DOMAIN_INPUT_BUS_USB:\n        case VIR_DOMAIN_INPUT_BUS_XEN:\n        case VIR_DOMAIN_INPUT_BUS_PARALLELS:\n        case VIR_DOMAIN_INPUT_BUS_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_CHR:\n        switch ((virDomainChrSerialTargetType)dev->data.chr->targetType) {\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_PCI:\n            return pciFlags;\n\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_ISA:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_USB:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SPAPR_VIO:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SYSTEM:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SCLP:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_NONE:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        switch ((virDomainVsockModel) dev->data.vsock->model) {\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO:\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_VSOCK_MODEL_DEFAULT:\n        case VIR_DOMAIN_VSOCK_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n        /* These devices don't ever connect with PCI */\n    case VIR_DOMAIN_DEVICE_NVRAM:\n    case VIR_DOMAIN_DEVICE_TPM:\n    case VIR_DOMAIN_DEVICE_PANIC:\n    case VIR_DOMAIN_DEVICE_MEMORY:\n    case VIR_DOMAIN_DEVICE_HUB:\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        /* These devices don't even have a DeviceInfo */\n    case VIR_DOMAIN_DEVICE_LEASE:\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n    case VIR_DOMAIN_DEVICE_IOMMU:\n    case VIR_DOMAIN_DEVICE_LAST:\n    case VIR_DOMAIN_DEVICE_NONE:\n        return 0;\n    }\n\n    /* We can never get here, because all cases are covered in the\n     * switch, and they all return, but the compiler will still\n     * complain \"control reaches end of non-void function\" unless\n     * we add the following return.\n     */\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic virDomainPCIConnectFlags\nqemuDomainDeviceCalculatePCIConnectFlags(virDomainDeviceDefPtr dev,\n                                         virQEMUDriverPtr driver,\n                                         virDomainPCIConnectFlags pcieFlags,\n                                         virDomainPCIConnectFlags virtioFlags)\n{\n    virDomainPCIConnectFlags pciFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                                         VIR_PCI_CONNECT_HOTPLUGGABLE);\n\n    switch ((virDomainDeviceType)dev->type) {\n    case VIR_DOMAIN_DEVICE_CONTROLLER: {\n        virDomainControllerDefPtr cont = dev->data.controller;\n\n        switch ((virDomainControllerType)cont->type) {\n        case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n            return virDomainPCIControllerModelToConnectType(cont->model);\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n            return pciFlags;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n            switch ((virDomainControllerModelUSB) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT:\n                /* qemuDomainControllerDefPostParse should have\n                 * changed 'model' to an explicit USB model in\n                 * most cases. Since we're still on the default\n                 * though, we must be going to use \"-usb\", which\n                 * is assumed to be a PCI default\n                 */\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QEMU_XHCI:\n                return pcieFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_EHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_EHCI1:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI2:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI3:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_VT82C686B_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX4_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PCI_OHCI:\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1: /* xen only */\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2: /* xen only */\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_IDE:\n            return pciFlags;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_SCSI:\n            switch ((virDomainControllerModelSCSI) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_DEFAULT:\n                return 0;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_NON_TRANSITIONAL:\n                return virtioFlags;\n\n            /* Transitional devices only work in conventional PCI slots */\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_TRANSITIONAL:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_AUTO:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1078:\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL:\n            switch ((virDomainControllerModelVirtioSerial) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO:\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_DEFAULT:\n                return virtioFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_FDC:\n        case VIR_DOMAIN_CONTROLLER_TYPE_CCID:\n        case VIR_DOMAIN_CONTROLLER_TYPE_XENBUS:\n        case VIR_DOMAIN_CONTROLLER_TYPE_LAST:\n            return 0;\n        }\n    }\n        break;\n\n    case VIR_DOMAIN_DEVICE_FS:\n        switch ((virDomainFSDriverType) dev->data.fs->fsdriver) {\n        case VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_PATH:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_HANDLE:\n            /* these drivers are handled by virtio-9p-pci */\n            switch ((virDomainFSModel) dev->data.fs->model) {\n            case VIR_DOMAIN_FS_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_FS_MODEL_VIRTIO:\n            case VIR_DOMAIN_FS_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_FS_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_FS_MODEL_LAST:\n                break;\n            }\n            break;\n\n        case VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS:\n            /* vhost-user-fs-pci */\n            return virtioFlags;\n\n        case VIR_DOMAIN_FS_DRIVER_TYPE_LOOP:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_NBD:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_PLOOP:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_LAST:\n            return 0;\n        }\n\n        return 0;\n\n    case VIR_DOMAIN_DEVICE_NET: {\n        virDomainNetDefPtr net = dev->data.net;\n\n        /* NB: a type='hostdev' will use PCI, but its\n         * address is assigned when we're assigning the\n         * addresses for other hostdev devices.\n         */\n        if (net->type == VIR_DOMAIN_NET_TYPE_HOSTDEV ||\n            net->model == VIR_DOMAIN_NET_MODEL_USB_NET) {\n            return 0;\n        }\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO ||\n            net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_NON_TRANSITIONAL)\n            return virtioFlags;\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_TRANSITIONAL)\n            return pciFlags;\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_E1000E)\n            return pcieFlags;\n\n        return pciFlags;\n    }\n\n    case VIR_DOMAIN_DEVICE_SOUND:\n        switch ((virDomainSoundModel) dev->data.sound->model) {\n        case VIR_DOMAIN_SOUND_MODEL_ES1370:\n        case VIR_DOMAIN_SOUND_MODEL_AC97:\n        case VIR_DOMAIN_SOUND_MODEL_ICH6:\n        case VIR_DOMAIN_SOUND_MODEL_ICH9:\n            return pciFlags;\n\n        case VIR_DOMAIN_SOUND_MODEL_SB16:\n        case VIR_DOMAIN_SOUND_MODEL_PCSPK:\n        case VIR_DOMAIN_SOUND_MODEL_USB:\n        case VIR_DOMAIN_SOUND_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_DISK:\n        switch ((virDomainDiskBus) dev->data.disk->bus) {\n        case VIR_DOMAIN_DISK_BUS_VIRTIO:\n            /* only virtio disks use PCI */\n            switch ((virDomainDiskModel) dev->data.disk->model) {\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO:\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_DISK_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_DISK_MODEL_LAST:\n                break;\n            }\n            return 0;\n\n        case VIR_DOMAIN_DISK_BUS_IDE:\n        case VIR_DOMAIN_DISK_BUS_FDC:\n        case VIR_DOMAIN_DISK_BUS_SCSI:\n        case VIR_DOMAIN_DISK_BUS_XEN:\n        case VIR_DOMAIN_DISK_BUS_USB:\n        case VIR_DOMAIN_DISK_BUS_UML:\n        case VIR_DOMAIN_DISK_BUS_SATA:\n        case VIR_DOMAIN_DISK_BUS_SD:\n        case VIR_DOMAIN_DISK_BUS_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_HOSTDEV: {\n        virDomainHostdevDefPtr hostdev = dev->data.hostdev;\n        bool isExpress = false;\n        virPCIDevicePtr pciDev;\n        virPCIDeviceAddressPtr hostAddr = &hostdev->source.subsys.u.pci.addr;\n\n        if (!virHostdevIsMdevDevice(hostdev) &&\n            (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n             (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n              hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST))) {\n            return 0;\n        }\n\n        if (pciFlags == pcieFlags) {\n            /* This arch/qemu only supports legacy PCI, so there\n             * is no point in checking if the device is an Express\n             * device.\n             */\n            return pciFlags;\n        }\n\n        if (virDeviceInfoPCIAddressIsPresent(hostdev->info)) {\n            /* A guest-side address has already been assigned, so\n             * we can avoid reading the PCI config, and just use\n             * pcieFlags, since the pciConnectFlags checking is\n             * more relaxed when an address is already assigned\n             * than it is when we're looking for a new address (so\n             * validation will pass regardless of whether we set\n             * the flags to PCI or PCIe).\n             */\n            return pcieFlags;\n        }\n\n        /* mdevs don't have corresponding files in /sys that we can poke to\n         * try and figure out whether they are legacy PCI or PCI Express, so\n         * the logic below would never work; instead, we just go ahead and\n         * assume they're PCI Express. This is a very reasonable assumption,\n         * as all current mdev-capable devices are indeed PCI Express */\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV)\n            return pcieFlags;\n\n        /* according to pbonzini, from the guest PoV vhost-scsi devices\n         * are the same as virtio-scsi, so they should follow virtio logic\n         */\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST) {\n            switch ((virDomainHostdevSubsysSCSIVHostModelType) hostdev->source.subsys.u.scsi_host.model) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_LAST:\n                break;\n            }\n            return 0;\n        }\n\n        if (!(pciDev = virPCIDeviceNew(hostAddr->domain,\n                                       hostAddr->bus,\n                                       hostAddr->slot,\n                                       hostAddr->function))) {\n            /* libvirt should be able to perform all the\n             * operations in virPCIDeviceNew() even if it's\n             * running unprivileged, so if this fails, the device\n             * apparently doesn't currently exist on the host.\n             * Since the overwhelming majority of assignable host\n             * devices are PCIe, assume this one is too.\n             */\n            return pcieFlags;\n        }\n\n        if (!driver->privileged) {\n            /* unprivileged libvirtd is unable to read *all* of a\n             * device's PCI config (it can only read the first 64\n             * bytes, which isn't enough for the check that's done\n             * in virPCIDeviceIsPCIExpress()), so instead of\n             * trying and failing, we make an educated guess based\n             * on the length of the device's config file - if it\n             * is 256 bytes, then it is definitely a legacy PCI\n             * device. If it's larger than that, then it is\n             * *probably PCIe (although it could be PCI-x, but\n             * those are extremely rare). If the config file can't\n             * be found (in which case the \"length\" will be -1),\n             * then we blindly assume the most likely outcome -\n             * PCIe.\n             */\n            off_t configLen\n               = virFileLength(virPCIDeviceGetConfigPath(pciDev), -1);\n\n            virPCIDeviceFree(pciDev);\n\n            if (configLen == 256)\n                return pciFlags;\n\n            return pcieFlags;\n        }\n\n        /* If we are running with privileges, we can examine the\n         * PCI config contents with virPCIDeviceIsPCIExpress() for\n         * a definitive answer.\n         */\n        isExpress = virPCIDeviceIsPCIExpress(pciDev);\n        virPCIDeviceFree(pciDev);\n\n        if (isExpress)\n            return pcieFlags;\n\n        return pciFlags;\n    }\n\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        switch ((virDomainMemballoonModel) dev->data.memballoon->model) {\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_MEMBALLOON_MODEL_XEN:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_NONE:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_RNG:\n        switch ((virDomainRNGModel) dev->data.rng->model) {\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO:\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_RNG_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        /* only one model connects using PCI */\n        switch ((virDomainWatchdogModel) dev->data.watchdog->model) {\n        case VIR_DOMAIN_WATCHDOG_MODEL_I6300ESB:\n            return pciFlags;\n\n        case VIR_DOMAIN_WATCHDOG_MODEL_IB700:\n        case VIR_DOMAIN_WATCHDOG_MODEL_DIAG288:\n        case VIR_DOMAIN_WATCHDOG_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        switch ((virDomainVideoType)dev->data.video->type) {\n        case VIR_DOMAIN_VIDEO_TYPE_VIRTIO:\n            return virtioFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_VGA:\n        case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n        case VIR_DOMAIN_VIDEO_TYPE_VMVGA:\n        case VIR_DOMAIN_VIDEO_TYPE_XEN:\n        case VIR_DOMAIN_VIDEO_TYPE_VBOX:\n        case VIR_DOMAIN_VIDEO_TYPE_QXL:\n        case VIR_DOMAIN_VIDEO_TYPE_PARALLELS:\n            return pciFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_BOCHS:\n            return pcieFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_DEFAULT:\n        case VIR_DOMAIN_VIDEO_TYPE_GOP:\n        case VIR_DOMAIN_VIDEO_TYPE_NONE:\n        case VIR_DOMAIN_VIDEO_TYPE_RAMFB:\n        case VIR_DOMAIN_VIDEO_TYPE_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        return pciFlags;\n\n    case VIR_DOMAIN_DEVICE_INPUT:\n        switch ((virDomainInputBus) dev->data.input->bus) {\n        case VIR_DOMAIN_INPUT_BUS_VIRTIO:\n            switch ((virDomainInputModel) dev->data.input->model) {\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO:\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_INPUT_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_INPUT_MODEL_LAST:\n                break;\n            }\n            return 0;\n\n        case VIR_DOMAIN_INPUT_BUS_PS2:\n        case VIR_DOMAIN_INPUT_BUS_USB:\n        case VIR_DOMAIN_INPUT_BUS_XEN:\n        case VIR_DOMAIN_INPUT_BUS_PARALLELS:\n        case VIR_DOMAIN_INPUT_BUS_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_CHR:\n        switch ((virDomainChrSerialTargetType)dev->data.chr->targetType) {\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_PCI:\n            return pciFlags;\n\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_ISA:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_USB:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SPAPR_VIO:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SYSTEM:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SCLP:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_NONE:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        switch ((virDomainVsockModel) dev->data.vsock->model) {\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO:\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_VSOCK_MODEL_DEFAULT:\n        case VIR_DOMAIN_VSOCK_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n        /* These devices don't ever connect with PCI */\n    case VIR_DOMAIN_DEVICE_NVRAM:\n    case VIR_DOMAIN_DEVICE_TPM:\n    case VIR_DOMAIN_DEVICE_PANIC:\n    case VIR_DOMAIN_DEVICE_MEMORY:\n    case VIR_DOMAIN_DEVICE_HUB:\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        /* These devices don't even have a DeviceInfo */\n    case VIR_DOMAIN_DEVICE_LEASE:\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n    case VIR_DOMAIN_DEVICE_IOMMU:\n    case VIR_DOMAIN_DEVICE_LAST:\n    case VIR_DOMAIN_DEVICE_NONE:\n        return 0;\n    }\n\n    /* We can never get here, because all cases are covered in the\n     * switch, and they all return, but the compiler will still\n     * complain \"control reaches end of non-void function\" unless\n     * we add the following return.\n     */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainFillDevicePCIConnectFlagsIterInit",
          "args": [
            "def",
            "qemuCaps",
            "driver",
            "&data"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainFillDevicePCIConnectFlagsIterInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "1065-1087",
          "snippet": "static void\nqemuDomainFillDevicePCIConnectFlagsIterInit(virDomainDefPtr def,\n                                            virQEMUCapsPtr qemuCaps,\n                                            virQEMUDriverPtr driver,\n                                            qemuDomainFillDevicePCIConnectFlagsIterData *data)\n{\n    data->driver = driver;\n\n    if (qemuDomainHasPCIeRoot(def)) {\n        data->pcieFlags = (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                           VIR_PCI_CONNECT_HOTPLUGGABLE);\n    } else {\n        data->pcieFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                           VIR_PCI_CONNECT_HOTPLUGGABLE);\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_DISABLE_LEGACY)) {\n        data->virtioFlags = data->pcieFlags;\n    } else {\n        data->virtioFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                             VIR_PCI_CONNECT_HOTPLUGGABLE);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic void\nqemuDomainFillDevicePCIConnectFlagsIterInit(virDomainDefPtr def,\n                                            virQEMUCapsPtr qemuCaps,\n                                            virQEMUDriverPtr driver,\n                                            qemuDomainFillDevicePCIConnectFlagsIterData *data)\n{\n    data->driver = driver;\n\n    if (qemuDomainHasPCIeRoot(def)) {\n        data->pcieFlags = (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                           VIR_PCI_CONNECT_HOTPLUGGABLE);\n    } else {\n        data->pcieFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                           VIR_PCI_CONNECT_HOTPLUGGABLE);\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_DISABLE_LEGACY)) {\n        data->virtioFlags = data->pcieFlags;\n    } else {\n        data->virtioFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                             VIR_PCI_CONNECT_HOTPLUGGABLE);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDeviceGetInfo",
          "args": [
            "dev"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceGetInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3933-3989",
          "snippet": "virDomainDeviceInfoPtr\nvirDomainDeviceGetInfo(virDomainDeviceDefPtr device)\n{\n    switch ((virDomainDeviceType) device->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        return &device->data.disk->info;\n    case VIR_DOMAIN_DEVICE_FS:\n        return &device->data.fs->info;\n    case VIR_DOMAIN_DEVICE_NET:\n        return &device->data.net->info;\n    case VIR_DOMAIN_DEVICE_INPUT:\n        return &device->data.input->info;\n    case VIR_DOMAIN_DEVICE_SOUND:\n        return &device->data.sound->info;\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        return &device->data.video->info;\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n        return device->data.hostdev->info;\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        return &device->data.watchdog->info;\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n        return &device->data.controller->info;\n    case VIR_DOMAIN_DEVICE_HUB:\n        return &device->data.hub->info;\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n        return &device->data.redirdev->info;\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        return &device->data.smartcard->info;\n    case VIR_DOMAIN_DEVICE_CHR:\n        return &device->data.chr->info;\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        return &device->data.memballoon->info;\n    case VIR_DOMAIN_DEVICE_NVRAM:\n        return &device->data.nvram->info;\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        return &device->data.shmem->info;\n    case VIR_DOMAIN_DEVICE_RNG:\n        return &device->data.rng->info;\n    case VIR_DOMAIN_DEVICE_TPM:\n        return &device->data.tpm->info;\n    case VIR_DOMAIN_DEVICE_PANIC:\n        return &device->data.panic->info;\n    case VIR_DOMAIN_DEVICE_MEMORY:\n        return &device->data.memory->info;\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        return &device->data.vsock->info;\n\n    /* The following devices do not contain virDomainDeviceInfo */\n    case VIR_DOMAIN_DEVICE_LEASE:\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n    case VIR_DOMAIN_DEVICE_IOMMU:\n    case VIR_DOMAIN_DEVICE_LAST:\n    case VIR_DOMAIN_DEVICE_NONE:\n        break;\n    }\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDeviceInfoPtr\nvirDomainDeviceGetInfo(virDomainDeviceDefPtr device)\n{\n    switch ((virDomainDeviceType) device->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        return &device->data.disk->info;\n    case VIR_DOMAIN_DEVICE_FS:\n        return &device->data.fs->info;\n    case VIR_DOMAIN_DEVICE_NET:\n        return &device->data.net->info;\n    case VIR_DOMAIN_DEVICE_INPUT:\n        return &device->data.input->info;\n    case VIR_DOMAIN_DEVICE_SOUND:\n        return &device->data.sound->info;\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        return &device->data.video->info;\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n        return device->data.hostdev->info;\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        return &device->data.watchdog->info;\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n        return &device->data.controller->info;\n    case VIR_DOMAIN_DEVICE_HUB:\n        return &device->data.hub->info;\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n        return &device->data.redirdev->info;\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        return &device->data.smartcard->info;\n    case VIR_DOMAIN_DEVICE_CHR:\n        return &device->data.chr->info;\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        return &device->data.memballoon->info;\n    case VIR_DOMAIN_DEVICE_NVRAM:\n        return &device->data.nvram->info;\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        return &device->data.shmem->info;\n    case VIR_DOMAIN_DEVICE_RNG:\n        return &device->data.rng->info;\n    case VIR_DOMAIN_DEVICE_TPM:\n        return &device->data.tpm->info;\n    case VIR_DOMAIN_DEVICE_PANIC:\n        return &device->data.panic->info;\n    case VIR_DOMAIN_DEVICE_MEMORY:\n        return &device->data.memory->info;\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        return &device->data.vsock->info;\n\n    /* The following devices do not contain virDomainDeviceInfo */\n    case VIR_DOMAIN_DEVICE_LEASE:\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n    case VIR_DOMAIN_DEVICE_IOMMU:\n    case VIR_DOMAIN_DEVICE_LAST:\n    case VIR_DOMAIN_DEVICE_NONE:\n        break;\n    }\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic void\nqemuDomainFillDevicePCIConnectFlags(virDomainDefPtr def,\n                                    virDomainDeviceDefPtr dev,\n                                    virQEMUCapsPtr qemuCaps,\n                                    virQEMUDriverPtr driver)\n{\n    virDomainDeviceInfoPtr info = virDomainDeviceGetInfo(dev);\n\n    if (info) {\n        /* qemuDomainDeviceCalculatePCIConnectFlags() is called with\n         * the data setup in the ...IterData by ...IterInit() rather\n         * than setting the values directly here.  It may seem like\n         * pointless posturing, but it's done this way to eliminate\n         * duplicated setup code while allowing more efficient\n         * operation when it's being done repeatedly with the device\n         * iterator (since qemuDomainFillAllPCIConnectFlags() only\n         * calls ...IterInit() once for all devices).\n         */\n        qemuDomainFillDevicePCIConnectFlagsIterData data;\n\n        qemuDomainFillDevicePCIConnectFlagsIterInit(def, qemuCaps, driver, &data);\n\n        info->pciConnectFlags\n            = qemuDomainDeviceCalculatePCIConnectFlags(dev, data.driver,\n                                                       data.pcieFlags,\n                                                       data.virtioFlags);\n    }\n}"
  },
  {
    "function_name": "qemuDomainSetupIsolationGroups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1394-1419",
    "snippet": "static int\nqemuDomainSetupIsolationGroups(virDomainDefPtr def)\n{\n    int idx;\n\n    /* Only pSeries guests care about isolation groups at the moment */\n    if (!qemuDomainIsPSeries(def))\n        return 0;\n\n    idx = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_PCI, 0);\n    if (idx < 0)\n        return -1;\n\n    /* We want to prevent hostdevs from being plugged into the default PHB:\n     * we can make sure that doesn't happen by locking its isolation group */\n    def->controllers[idx]->info.isolationGroupLocked = true;\n\n    /* Fill in isolation groups for all other devices */\n    if (virDomainDeviceInfoIterate(def,\n                                   qemuDomainFillDeviceIsolationGroupIter,\n                                   NULL) < 0) {\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDeviceInfoIterate",
          "args": [
            "def",
            "qemuDomainFillDeviceIsolationGroupIter",
            "NULL"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceInfoIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "4352-4358",
          "snippet": "int\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainControllerFind",
          "args": [
            "def",
            "VIR_DOMAIN_CONTROLLER_TYPE_PCI",
            "0"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainControllerFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17803-17818",
          "snippet": "int\nvirDomainControllerFind(const virDomainDef *def,\n                        int type,\n                        int idx)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if ((def->controllers[i]->type == type) &&\n            (def->controllers[i]->idx == idx)) {\n            return i;\n        }\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainControllerFind(const virDomainDef *def,\n                        int type,\n                        int idx)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if ((def->controllers[i]->type == type) &&\n            (def->controllers[i]->idx == idx)) {\n            return i;\n        }\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainIsPSeries",
          "args": [
            "def"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainIsPSeries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12912-12916",
          "snippet": "bool\nqemuDomainIsPSeries(const virDomainDef *def)\n{\n    return qemuDomainMachineIsPSeries(def->os.machine, def->os.arch);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainIsPSeries(const virDomainDef *def)\n{\n    return qemuDomainMachineIsPSeries(def->os.machine, def->os.arch);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainSetupIsolationGroups(virDomainDefPtr def)\n{\n    int idx;\n\n    /* Only pSeries guests care about isolation groups at the moment */\n    if (!qemuDomainIsPSeries(def))\n        return 0;\n\n    idx = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_PCI, 0);\n    if (idx < 0)\n        return -1;\n\n    /* We want to prevent hostdevs from being plugged into the default PHB:\n     * we can make sure that doesn't happen by locking its isolation group */\n    def->controllers[idx]->info.isolationGroupLocked = true;\n\n    /* Fill in isolation groups for all other devices */\n    if (virDomainDeviceInfoIterate(def,\n                                   qemuDomainFillDeviceIsolationGroupIter,\n                                   NULL) < 0) {\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainFillDeviceIsolationGroupIter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1370-1379",
    "snippet": "static int\nqemuDomainFillDeviceIsolationGroupIter(virDomainDefPtr def,\n                                       virDomainDeviceDefPtr dev,\n                                       virDomainDeviceInfoPtr info G_GNUC_UNUSED,\n                                       void *opaque G_GNUC_UNUSED)\n{\n    qemuDomainFillDeviceIsolationGroup(def, dev);\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainFillDeviceIsolationGroup",
          "args": [
            "def",
            "dev"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainFillDeviceIsolationGroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "1266-1355",
          "snippet": "void\nqemuDomainFillDeviceIsolationGroup(virDomainDefPtr def,\n                                   virDomainDeviceDefPtr dev)\n{\n    /* Only host devices need their isolation group to be different from\n     * the default. Interfaces of type hostdev are just host devices in\n     * disguise, but we don't need to handle them separately because for\n     * each such interface a corresponding hostdev is also added to the\n     * guest configuration */\n    if (dev->type == VIR_DOMAIN_DEVICE_HOSTDEV) {\n        virDomainHostdevDefPtr hostdev = dev->data.hostdev;\n        virDomainDeviceInfoPtr info = hostdev->info;\n        virPCIDeviceAddressPtr hostAddr;\n        int tmp;\n\n        /* Only PCI host devices are subject to isolation */\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n            hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI) {\n            return;\n        }\n\n        hostAddr = &hostdev->source.subsys.u.pci.addr;\n\n        /* If a non-default isolation has already been assigned to the\n         * device, we can avoid looking up the information again */\n        if (info->isolationGroup > 0)\n            return;\n\n        /* The isolation group depends on the IOMMU group assigned by the host */\n        tmp = virPCIDeviceAddressGetIOMMUGroupNum(hostAddr);\n\n        if (tmp < 0) {\n            VIR_WARN(\"Can't look up isolation group for host device \"\n                     \"%04x:%02x:%02x.%x, device won't be isolated\",\n                     hostAddr->domain, hostAddr->bus,\n                     hostAddr->slot, hostAddr->function);\n            return;\n        }\n\n        /* The isolation group for a host device is its IOMMU group,\n         * increased by one: this is because zero is a valid IOMMU group but\n         * that's also the default isolation group, which we want to save\n         * for emulated devices. Shifting isolation groups for host devices\n         * by one ensures there is no overlap */\n        info->isolationGroup = tmp + 1;\n\n        VIR_DEBUG(\"Isolation group for host device %04x:%02x:%02x.%x is %u\",\n                  hostAddr->domain, hostAddr->bus,\n                  hostAddr->slot, hostAddr->function,\n                  info->isolationGroup);\n\n    } else if (dev->type == VIR_DOMAIN_DEVICE_NET) {\n        virDomainNetDefPtr iface = dev->data.net;\n        virDomainDeviceInfoPtr info = &iface->info;\n        unsigned int tmp;\n\n        /* Network interfaces can ultimately result in the guest being\n         * assigned a host device if the libvirt network they're connected\n         * to is of type hostdev. All other kinds of network interfaces don't\n         * require us to isolate the guest device, so we can skip them */\n        if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK ||\n            virDomainNetResolveActualType(iface) != VIR_DOMAIN_NET_TYPE_HOSTDEV) {\n            return;\n        }\n\n        /* If a non-default isolation has already been assigned to the\n         * device, we can avoid looking up the information again */\n        if (info->isolationGroup > 0)\n            return;\n\n        /* Obtain a synthetic isolation group for the device, since at this\n         * point in time we don't have access to the IOMMU group of the host\n         * device that will eventually be used by the guest */\n        tmp = qemuDomainFindUnusedIsolationGroup(def);\n\n        if (tmp == 0) {\n            VIR_WARN(\"Can't obtain usable isolation group for interface \"\n                     \"configured to use hostdev-backed network '%s', \"\n                     \"device won't be isolated\",\n                     iface->data.network.name);\n            return;\n        }\n\n        info->isolationGroup = tmp;\n\n        VIR_DEBUG(\"Isolation group for interface configured to use \"\n                  \"hostdev-backed network '%s' is %u\",\n                  iface->data.network.name, info->isolationGroup);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nvoid\nqemuDomainFillDeviceIsolationGroup(virDomainDefPtr def,\n                                   virDomainDeviceDefPtr dev)\n{\n    /* Only host devices need their isolation group to be different from\n     * the default. Interfaces of type hostdev are just host devices in\n     * disguise, but we don't need to handle them separately because for\n     * each such interface a corresponding hostdev is also added to the\n     * guest configuration */\n    if (dev->type == VIR_DOMAIN_DEVICE_HOSTDEV) {\n        virDomainHostdevDefPtr hostdev = dev->data.hostdev;\n        virDomainDeviceInfoPtr info = hostdev->info;\n        virPCIDeviceAddressPtr hostAddr;\n        int tmp;\n\n        /* Only PCI host devices are subject to isolation */\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n            hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI) {\n            return;\n        }\n\n        hostAddr = &hostdev->source.subsys.u.pci.addr;\n\n        /* If a non-default isolation has already been assigned to the\n         * device, we can avoid looking up the information again */\n        if (info->isolationGroup > 0)\n            return;\n\n        /* The isolation group depends on the IOMMU group assigned by the host */\n        tmp = virPCIDeviceAddressGetIOMMUGroupNum(hostAddr);\n\n        if (tmp < 0) {\n            VIR_WARN(\"Can't look up isolation group for host device \"\n                     \"%04x:%02x:%02x.%x, device won't be isolated\",\n                     hostAddr->domain, hostAddr->bus,\n                     hostAddr->slot, hostAddr->function);\n            return;\n        }\n\n        /* The isolation group for a host device is its IOMMU group,\n         * increased by one: this is because zero is a valid IOMMU group but\n         * that's also the default isolation group, which we want to save\n         * for emulated devices. Shifting isolation groups for host devices\n         * by one ensures there is no overlap */\n        info->isolationGroup = tmp + 1;\n\n        VIR_DEBUG(\"Isolation group for host device %04x:%02x:%02x.%x is %u\",\n                  hostAddr->domain, hostAddr->bus,\n                  hostAddr->slot, hostAddr->function,\n                  info->isolationGroup);\n\n    } else if (dev->type == VIR_DOMAIN_DEVICE_NET) {\n        virDomainNetDefPtr iface = dev->data.net;\n        virDomainDeviceInfoPtr info = &iface->info;\n        unsigned int tmp;\n\n        /* Network interfaces can ultimately result in the guest being\n         * assigned a host device if the libvirt network they're connected\n         * to is of type hostdev. All other kinds of network interfaces don't\n         * require us to isolate the guest device, so we can skip them */\n        if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK ||\n            virDomainNetResolveActualType(iface) != VIR_DOMAIN_NET_TYPE_HOSTDEV) {\n            return;\n        }\n\n        /* If a non-default isolation has already been assigned to the\n         * device, we can avoid looking up the information again */\n        if (info->isolationGroup > 0)\n            return;\n\n        /* Obtain a synthetic isolation group for the device, since at this\n         * point in time we don't have access to the IOMMU group of the host\n         * device that will eventually be used by the guest */\n        tmp = qemuDomainFindUnusedIsolationGroup(def);\n\n        if (tmp == 0) {\n            VIR_WARN(\"Can't obtain usable isolation group for interface \"\n                     \"configured to use hostdev-backed network '%s', \"\n                     \"device won't be isolated\",\n                     iface->data.network.name);\n            return;\n        }\n\n        info->isolationGroup = tmp;\n\n        VIR_DEBUG(\"Isolation group for interface configured to use \"\n                  \"hostdev-backed network '%s' is %u\",\n                  iface->data.network.name, info->isolationGroup);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainFillDeviceIsolationGroupIter(virDomainDefPtr def,\n                                       virDomainDeviceDefPtr dev,\n                                       virDomainDeviceInfoPtr info G_GNUC_UNUSED,\n                                       void *opaque G_GNUC_UNUSED)\n{\n    qemuDomainFillDeviceIsolationGroup(def, dev);\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainFillDeviceIsolationGroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1266-1355",
    "snippet": "void\nqemuDomainFillDeviceIsolationGroup(virDomainDefPtr def,\n                                   virDomainDeviceDefPtr dev)\n{\n    /* Only host devices need their isolation group to be different from\n     * the default. Interfaces of type hostdev are just host devices in\n     * disguise, but we don't need to handle them separately because for\n     * each such interface a corresponding hostdev is also added to the\n     * guest configuration */\n    if (dev->type == VIR_DOMAIN_DEVICE_HOSTDEV) {\n        virDomainHostdevDefPtr hostdev = dev->data.hostdev;\n        virDomainDeviceInfoPtr info = hostdev->info;\n        virPCIDeviceAddressPtr hostAddr;\n        int tmp;\n\n        /* Only PCI host devices are subject to isolation */\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n            hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI) {\n            return;\n        }\n\n        hostAddr = &hostdev->source.subsys.u.pci.addr;\n\n        /* If a non-default isolation has already been assigned to the\n         * device, we can avoid looking up the information again */\n        if (info->isolationGroup > 0)\n            return;\n\n        /* The isolation group depends on the IOMMU group assigned by the host */\n        tmp = virPCIDeviceAddressGetIOMMUGroupNum(hostAddr);\n\n        if (tmp < 0) {\n            VIR_WARN(\"Can't look up isolation group for host device \"\n                     \"%04x:%02x:%02x.%x, device won't be isolated\",\n                     hostAddr->domain, hostAddr->bus,\n                     hostAddr->slot, hostAddr->function);\n            return;\n        }\n\n        /* The isolation group for a host device is its IOMMU group,\n         * increased by one: this is because zero is a valid IOMMU group but\n         * that's also the default isolation group, which we want to save\n         * for emulated devices. Shifting isolation groups for host devices\n         * by one ensures there is no overlap */\n        info->isolationGroup = tmp + 1;\n\n        VIR_DEBUG(\"Isolation group for host device %04x:%02x:%02x.%x is %u\",\n                  hostAddr->domain, hostAddr->bus,\n                  hostAddr->slot, hostAddr->function,\n                  info->isolationGroup);\n\n    } else if (dev->type == VIR_DOMAIN_DEVICE_NET) {\n        virDomainNetDefPtr iface = dev->data.net;\n        virDomainDeviceInfoPtr info = &iface->info;\n        unsigned int tmp;\n\n        /* Network interfaces can ultimately result in the guest being\n         * assigned a host device if the libvirt network they're connected\n         * to is of type hostdev. All other kinds of network interfaces don't\n         * require us to isolate the guest device, so we can skip them */\n        if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK ||\n            virDomainNetResolveActualType(iface) != VIR_DOMAIN_NET_TYPE_HOSTDEV) {\n            return;\n        }\n\n        /* If a non-default isolation has already been assigned to the\n         * device, we can avoid looking up the information again */\n        if (info->isolationGroup > 0)\n            return;\n\n        /* Obtain a synthetic isolation group for the device, since at this\n         * point in time we don't have access to the IOMMU group of the host\n         * device that will eventually be used by the guest */\n        tmp = qemuDomainFindUnusedIsolationGroup(def);\n\n        if (tmp == 0) {\n            VIR_WARN(\"Can't obtain usable isolation group for interface \"\n                     \"configured to use hostdev-backed network '%s', \"\n                     \"device won't be isolated\",\n                     iface->data.network.name);\n            return;\n        }\n\n        info->isolationGroup = tmp;\n\n        VIR_DEBUG(\"Isolation group for interface configured to use \"\n                  \"hostdev-backed network '%s' is %u\",\n                  iface->data.network.name, info->isolationGroup);\n    }\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Isolation group for interface configured to use \"\n                  \"hostdev-backed network '%s' is %u\"",
            "iface->data.network.name",
            "info->isolationGroup"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Can't obtain usable isolation group for interface \"\n                     \"configured to use hostdev-backed network '%s', \"\n                     \"device won't be isolated\"",
            "iface->data.network.name"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainFindUnusedIsolationGroup",
          "args": [
            "def"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainFindUnusedIsolationGroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "1239-1256",
          "snippet": "static unsigned int\nqemuDomainFindUnusedIsolationGroup(virDomainDefPtr def)\n{\n    unsigned int isolationGroup = UINT_MAX;\n\n    /* We start from the highest possible isolation group and work our\n     * way backwards so that we're working in a completely different range\n     * from IOMMU groups, thus avoiding clashes. We're realistically going\n     * to call this function just a few times per guest anyway */\n    while (isolationGroup > 0 &&\n           virDomainDeviceInfoIterate(def,\n                                      qemuDomainFindUnusedIsolationGroupIter,\n                                      &isolationGroup) < 0) {\n        isolationGroup--;\n    }\n\n    return isolationGroup;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic unsigned int\nqemuDomainFindUnusedIsolationGroup(virDomainDefPtr def)\n{\n    unsigned int isolationGroup = UINT_MAX;\n\n    /* We start from the highest possible isolation group and work our\n     * way backwards so that we're working in a completely different range\n     * from IOMMU groups, thus avoiding clashes. We're realistically going\n     * to call this function just a few times per guest anyway */\n    while (isolationGroup > 0 &&\n           virDomainDeviceInfoIterate(def,\n                                      qemuDomainFindUnusedIsolationGroupIter,\n                                      &isolationGroup) < 0) {\n        isolationGroup--;\n    }\n\n    return isolationGroup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetResolveActualType",
          "args": [
            "iface"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetResolveActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "31654-31729",
          "snippet": "int\nvirDomainNetResolveActualType(virDomainNetDefPtr iface)\n{\n    virNetworkDefPtr def = NULL;\n    int ret = -1;\n    g_autofree char *xml = NULL;\n    g_autoptr(virConnect) conn = NULL;\n    g_autoptr(virNetwork) net = NULL;\n\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n\n    if (iface->data.network.actual)\n        return iface->data.network.actual->type;\n\n    if (!(conn = virGetConnectNetwork()))\n        return -1;\n\n    if (!(net = virNetworkLookupByName(conn, iface->data.network.name)))\n        goto cleanup;\n\n    if (!(xml = virNetworkGetXMLDesc(net, 0)))\n        goto cleanup;\n\n    if (!(def = virNetworkDefParseString(xml, NULL)))\n        goto cleanup;\n\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* for these forward types, the actual net type really *is*\n         * NETWORK; we just keep the info from the portgroup in\n         * iface->data.network.actual\n         */\n        ret = VIR_DOMAIN_NET_TYPE_NETWORK;\n        break;\n\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        ret = VIR_DOMAIN_NET_TYPE_HOSTDEV;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            /* <forward type='bridge'/> <bridge name='xxx'/>\n             * is VIR_DOMAIN_NET_TYPE_BRIDGE\n             */\n            ret = VIR_DOMAIN_NET_TYPE_BRIDGE;\n            break;\n        }\n\n        /* intentionally fall through to the direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        /* <forward type='bridge|private|vepa|passthrough'> are all\n         * VIR_DOMAIN_NET_TYPE_DIRECT.\n         */\n        ret = VIR_DOMAIN_NET_TYPE_DIRECT;\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto cleanup;\n    }\n\n cleanup:\n    virNetworkDefFree(def);\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainNetResolveActualType(virDomainNetDefPtr iface)\n{\n    virNetworkDefPtr def = NULL;\n    int ret = -1;\n    g_autofree char *xml = NULL;\n    g_autoptr(virConnect) conn = NULL;\n    g_autoptr(virNetwork) net = NULL;\n\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n\n    if (iface->data.network.actual)\n        return iface->data.network.actual->type;\n\n    if (!(conn = virGetConnectNetwork()))\n        return -1;\n\n    if (!(net = virNetworkLookupByName(conn, iface->data.network.name)))\n        goto cleanup;\n\n    if (!(xml = virNetworkGetXMLDesc(net, 0)))\n        goto cleanup;\n\n    if (!(def = virNetworkDefParseString(xml, NULL)))\n        goto cleanup;\n\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* for these forward types, the actual net type really *is*\n         * NETWORK; we just keep the info from the portgroup in\n         * iface->data.network.actual\n         */\n        ret = VIR_DOMAIN_NET_TYPE_NETWORK;\n        break;\n\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        ret = VIR_DOMAIN_NET_TYPE_HOSTDEV;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            /* <forward type='bridge'/> <bridge name='xxx'/>\n             * is VIR_DOMAIN_NET_TYPE_BRIDGE\n             */\n            ret = VIR_DOMAIN_NET_TYPE_BRIDGE;\n            break;\n        }\n\n        /* intentionally fall through to the direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        /* <forward type='bridge|private|vepa|passthrough'> are all\n         * VIR_DOMAIN_NET_TYPE_DIRECT.\n         */\n        ret = VIR_DOMAIN_NET_TYPE_DIRECT;\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto cleanup;\n    }\n\n cleanup:\n    virNetworkDefFree(def);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Isolation group for host device %04x:%02x:%02x.%x is %u\"",
            "hostAddr->domain",
            "hostAddr->bus",
            "hostAddr->slot",
            "hostAddr->function",
            "info->isolationGroup"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Can't look up isolation group for host device \"\n                     \"%04x:%02x:%02x.%x, device won't be isolated\"",
            "hostAddr->domain",
            "hostAddr->bus",
            "hostAddr->slot",
            "hostAddr->function"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressGetIOMMUGroupNum",
          "args": [
            "hostAddr"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressGetIOMMUGroupNum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1917-1950",
          "snippet": "int\nvirPCIDeviceAddressGetIOMMUGroupNum(virPCIDeviceAddressPtr addr)\n{\n    g_autofree char *devName = NULL;\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupNumStr = NULL;\n    unsigned int groupNum;\n\n    devName = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, addr->domain, addr->bus,\n                              addr->slot, addr->function);\n\n    if (!(devPath = virPCIFile(devName, \"iommu_group\")))\n        return -1;\n    if (virFileIsLink(devPath) != 1)\n        return -2;\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       devName, devPath);\n        return -1;\n    }\n\n    groupNumStr = g_path_get_basename(groupPath);\n    if (virStrToLong_ui(groupNumStr, NULL, 10, &groupNum) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"device %s iommu_group symlink %s has \"\n                         \"invalid group number %s\"),\n                       devName, groupPath, groupNumStr);\n        return -1;\n    }\n\n    return groupNum;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceAddressGetIOMMUGroupNum(virPCIDeviceAddressPtr addr)\n{\n    g_autofree char *devName = NULL;\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupNumStr = NULL;\n    unsigned int groupNum;\n\n    devName = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, addr->domain, addr->bus,\n                              addr->slot, addr->function);\n\n    if (!(devPath = virPCIFile(devName, \"iommu_group\")))\n        return -1;\n    if (virFileIsLink(devPath) != 1)\n        return -2;\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       devName, devPath);\n        return -1;\n    }\n\n    groupNumStr = g_path_get_basename(groupPath);\n    if (virStrToLong_ui(groupNumStr, NULL, 10, &groupNum) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"device %s iommu_group symlink %s has \"\n                         \"invalid group number %s\"),\n                       devName, groupPath, groupNumStr);\n        return -1;\n    }\n\n    return groupNum;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nvoid\nqemuDomainFillDeviceIsolationGroup(virDomainDefPtr def,\n                                   virDomainDeviceDefPtr dev)\n{\n    /* Only host devices need their isolation group to be different from\n     * the default. Interfaces of type hostdev are just host devices in\n     * disguise, but we don't need to handle them separately because for\n     * each such interface a corresponding hostdev is also added to the\n     * guest configuration */\n    if (dev->type == VIR_DOMAIN_DEVICE_HOSTDEV) {\n        virDomainHostdevDefPtr hostdev = dev->data.hostdev;\n        virDomainDeviceInfoPtr info = hostdev->info;\n        virPCIDeviceAddressPtr hostAddr;\n        int tmp;\n\n        /* Only PCI host devices are subject to isolation */\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n            hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI) {\n            return;\n        }\n\n        hostAddr = &hostdev->source.subsys.u.pci.addr;\n\n        /* If a non-default isolation has already been assigned to the\n         * device, we can avoid looking up the information again */\n        if (info->isolationGroup > 0)\n            return;\n\n        /* The isolation group depends on the IOMMU group assigned by the host */\n        tmp = virPCIDeviceAddressGetIOMMUGroupNum(hostAddr);\n\n        if (tmp < 0) {\n            VIR_WARN(\"Can't look up isolation group for host device \"\n                     \"%04x:%02x:%02x.%x, device won't be isolated\",\n                     hostAddr->domain, hostAddr->bus,\n                     hostAddr->slot, hostAddr->function);\n            return;\n        }\n\n        /* The isolation group for a host device is its IOMMU group,\n         * increased by one: this is because zero is a valid IOMMU group but\n         * that's also the default isolation group, which we want to save\n         * for emulated devices. Shifting isolation groups for host devices\n         * by one ensures there is no overlap */\n        info->isolationGroup = tmp + 1;\n\n        VIR_DEBUG(\"Isolation group for host device %04x:%02x:%02x.%x is %u\",\n                  hostAddr->domain, hostAddr->bus,\n                  hostAddr->slot, hostAddr->function,\n                  info->isolationGroup);\n\n    } else if (dev->type == VIR_DOMAIN_DEVICE_NET) {\n        virDomainNetDefPtr iface = dev->data.net;\n        virDomainDeviceInfoPtr info = &iface->info;\n        unsigned int tmp;\n\n        /* Network interfaces can ultimately result in the guest being\n         * assigned a host device if the libvirt network they're connected\n         * to is of type hostdev. All other kinds of network interfaces don't\n         * require us to isolate the guest device, so we can skip them */\n        if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK ||\n            virDomainNetResolveActualType(iface) != VIR_DOMAIN_NET_TYPE_HOSTDEV) {\n            return;\n        }\n\n        /* If a non-default isolation has already been assigned to the\n         * device, we can avoid looking up the information again */\n        if (info->isolationGroup > 0)\n            return;\n\n        /* Obtain a synthetic isolation group for the device, since at this\n         * point in time we don't have access to the IOMMU group of the host\n         * device that will eventually be used by the guest */\n        tmp = qemuDomainFindUnusedIsolationGroup(def);\n\n        if (tmp == 0) {\n            VIR_WARN(\"Can't obtain usable isolation group for interface \"\n                     \"configured to use hostdev-backed network '%s', \"\n                     \"device won't be isolated\",\n                     iface->data.network.name);\n            return;\n        }\n\n        info->isolationGroup = tmp;\n\n        VIR_DEBUG(\"Isolation group for interface configured to use \"\n                  \"hostdev-backed network '%s' is %u\",\n                  iface->data.network.name, info->isolationGroup);\n    }\n}"
  },
  {
    "function_name": "qemuDomainFindUnusedIsolationGroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1239-1256",
    "snippet": "static unsigned int\nqemuDomainFindUnusedIsolationGroup(virDomainDefPtr def)\n{\n    unsigned int isolationGroup = UINT_MAX;\n\n    /* We start from the highest possible isolation group and work our\n     * way backwards so that we're working in a completely different range\n     * from IOMMU groups, thus avoiding clashes. We're realistically going\n     * to call this function just a few times per guest anyway */\n    while (isolationGroup > 0 &&\n           virDomainDeviceInfoIterate(def,\n                                      qemuDomainFindUnusedIsolationGroupIter,\n                                      &isolationGroup) < 0) {\n        isolationGroup--;\n    }\n\n    return isolationGroup;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDeviceInfoIterate",
          "args": [
            "def",
            "qemuDomainFindUnusedIsolationGroupIter",
            "&isolationGroup"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceInfoIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "4352-4358",
          "snippet": "int\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic unsigned int\nqemuDomainFindUnusedIsolationGroup(virDomainDefPtr def)\n{\n    unsigned int isolationGroup = UINT_MAX;\n\n    /* We start from the highest possible isolation group and work our\n     * way backwards so that we're working in a completely different range\n     * from IOMMU groups, thus avoiding clashes. We're realistically going\n     * to call this function just a few times per guest anyway */\n    while (isolationGroup > 0 &&\n           virDomainDeviceInfoIterate(def,\n                                      qemuDomainFindUnusedIsolationGroupIter,\n                                      &isolationGroup) < 0) {\n        isolationGroup--;\n    }\n\n    return isolationGroup;\n}"
  },
  {
    "function_name": "qemuDomainFindUnusedIsolationGroupIter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1208-1220",
    "snippet": "static int\nqemuDomainFindUnusedIsolationGroupIter(virDomainDefPtr def G_GNUC_UNUSED,\n                                       virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                                       virDomainDeviceInfoPtr info,\n                                       void *opaque)\n{\n    unsigned int *isolationGroup = opaque;\n\n    if (info->isolationGroup == *isolationGroup)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainFindUnusedIsolationGroupIter(virDomainDefPtr def G_GNUC_UNUSED,\n                                       virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                                       virDomainDeviceInfoPtr info,\n                                       void *opaque)\n{\n    unsigned int *isolationGroup = opaque;\n\n    if (info->isolationGroup == *isolationGroup)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainFillAllPCIExtensionFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1186-1193",
    "snippet": "static int\nqemuDomainFillAllPCIExtensionFlags(virDomainDefPtr def,\n                                   virQEMUCapsPtr qemuCaps)\n{\n    return virDomainDeviceInfoIterate(def,\n                                      qemuDomainFillDevicePCIExtensionFlagsIter,\n                                      qemuCaps);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDeviceInfoIterate",
          "args": [
            "def",
            "qemuDomainFillDevicePCIExtensionFlagsIter",
            "qemuCaps"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceInfoIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "4352-4358",
          "snippet": "int\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainFillAllPCIExtensionFlags(virDomainDefPtr def,\n                                   virQEMUCapsPtr qemuCaps)\n{\n    return virDomainDeviceInfoIterate(def,\n                                      qemuDomainFillDevicePCIExtensionFlagsIter,\n                                      qemuCaps);\n}"
  },
  {
    "function_name": "qemuDomainFillDevicePCIExtensionFlagsIter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1159-1171",
    "snippet": "static int\nqemuDomainFillDevicePCIExtensionFlagsIter(virDomainDefPtr def G_GNUC_UNUSED,\n                                          virDomainDeviceDefPtr dev,\n                                          virDomainDeviceInfoPtr info,\n                                          void *opaque)\n{\n    virQEMUCapsPtr qemuCaps = opaque;\n\n    info->pciAddrExtFlags =\n        qemuDomainDeviceCalculatePCIAddressExtensionFlags(qemuCaps, dev);\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainDeviceCalculatePCIAddressExtensionFlags",
          "args": [
            "qemuCaps",
            "dev"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainDeviceCalculatePCIAddressExtensionFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "544-556",
          "snippet": "static virPCIDeviceAddressExtensionFlags\nqemuDomainDeviceCalculatePCIAddressExtensionFlags(virQEMUCapsPtr qemuCaps,\n                                                  virDomainDeviceDefPtr dev)\n{\n    virPCIDeviceAddressExtensionFlags extFlags = 0;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_ZPCI) &&\n        qemuDomainDeviceSupportZPCI(dev)) {\n        extFlags |= VIR_PCI_ADDRESS_EXTENSION_ZPCI;\n    }\n\n    return extFlags;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic virPCIDeviceAddressExtensionFlags\nqemuDomainDeviceCalculatePCIAddressExtensionFlags(virQEMUCapsPtr qemuCaps,\n                                                  virDomainDeviceDefPtr dev)\n{\n    virPCIDeviceAddressExtensionFlags extFlags = 0;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_ZPCI) &&\n        qemuDomainDeviceSupportZPCI(dev)) {\n        extFlags |= VIR_PCI_ADDRESS_EXTENSION_ZPCI;\n    }\n\n    return extFlags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainFillDevicePCIExtensionFlagsIter(virDomainDefPtr def G_GNUC_UNUSED,\n                                          virDomainDeviceDefPtr dev,\n                                          virDomainDeviceInfoPtr info,\n                                          void *opaque)\n{\n    virQEMUCapsPtr qemuCaps = opaque;\n\n    info->pciAddrExtFlags =\n        qemuDomainDeviceCalculatePCIAddressExtensionFlags(qemuCaps, dev);\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainFillAllPCIConnectFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1131-1143",
    "snippet": "static int\nqemuDomainFillAllPCIConnectFlags(virDomainDefPtr def,\n                                 virQEMUCapsPtr qemuCaps,\n                                 virQEMUDriverPtr driver)\n{\n    qemuDomainFillDevicePCIConnectFlagsIterData data;\n\n    qemuDomainFillDevicePCIConnectFlagsIterInit(def, qemuCaps, driver, &data);\n\n    return virDomainDeviceInfoIterate(def,\n                                      qemuDomainFillDevicePCIConnectFlagsIter,\n                                      &data);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDeviceInfoIterate",
          "args": [
            "def",
            "qemuDomainFillDevicePCIConnectFlagsIter",
            "&data"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceInfoIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "4352-4358",
          "snippet": "int\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainFillDevicePCIConnectFlagsIterInit",
          "args": [
            "def",
            "qemuCaps",
            "driver",
            "&data"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainFillDevicePCIConnectFlagsIterInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "1065-1087",
          "snippet": "static void\nqemuDomainFillDevicePCIConnectFlagsIterInit(virDomainDefPtr def,\n                                            virQEMUCapsPtr qemuCaps,\n                                            virQEMUDriverPtr driver,\n                                            qemuDomainFillDevicePCIConnectFlagsIterData *data)\n{\n    data->driver = driver;\n\n    if (qemuDomainHasPCIeRoot(def)) {\n        data->pcieFlags = (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                           VIR_PCI_CONNECT_HOTPLUGGABLE);\n    } else {\n        data->pcieFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                           VIR_PCI_CONNECT_HOTPLUGGABLE);\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_DISABLE_LEGACY)) {\n        data->virtioFlags = data->pcieFlags;\n    } else {\n        data->virtioFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                             VIR_PCI_CONNECT_HOTPLUGGABLE);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic void\nqemuDomainFillDevicePCIConnectFlagsIterInit(virDomainDefPtr def,\n                                            virQEMUCapsPtr qemuCaps,\n                                            virQEMUDriverPtr driver,\n                                            qemuDomainFillDevicePCIConnectFlagsIterData *data)\n{\n    data->driver = driver;\n\n    if (qemuDomainHasPCIeRoot(def)) {\n        data->pcieFlags = (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                           VIR_PCI_CONNECT_HOTPLUGGABLE);\n    } else {\n        data->pcieFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                           VIR_PCI_CONNECT_HOTPLUGGABLE);\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_DISABLE_LEGACY)) {\n        data->virtioFlags = data->pcieFlags;\n    } else {\n        data->virtioFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                             VIR_PCI_CONNECT_HOTPLUGGABLE);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainFillAllPCIConnectFlags(virDomainDefPtr def,\n                                 virQEMUCapsPtr qemuCaps,\n                                 virQEMUDriverPtr driver)\n{\n    qemuDomainFillDevicePCIConnectFlagsIterData data;\n\n    qemuDomainFillDevicePCIConnectFlagsIterInit(def, qemuCaps, driver, &data);\n\n    return virDomainDeviceInfoIterate(def,\n                                      qemuDomainFillDevicePCIConnectFlagsIter,\n                                      &data);\n}"
  },
  {
    "function_name": "qemuDomainFillDevicePCIConnectFlagsIter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1103-1116",
    "snippet": "static int\nqemuDomainFillDevicePCIConnectFlagsIter(virDomainDefPtr def G_GNUC_UNUSED,\n                                        virDomainDeviceDefPtr dev,\n                                        virDomainDeviceInfoPtr info,\n                                        void *opaque)\n{\n    qemuDomainFillDevicePCIConnectFlagsIterData *data = opaque;\n\n    info->pciConnectFlags\n        = qemuDomainDeviceCalculatePCIConnectFlags(dev, data->driver,\n                                                   data->pcieFlags,\n                                                   data->virtioFlags);\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainDeviceCalculatePCIConnectFlags",
          "args": [
            "dev",
            "data->driver",
            "data->pcieFlags",
            "data->virtioFlags"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainDeviceCalculatePCIConnectFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "576-1049",
          "snippet": "static virDomainPCIConnectFlags\nqemuDomainDeviceCalculatePCIConnectFlags(virDomainDeviceDefPtr dev,\n                                         virQEMUDriverPtr driver,\n                                         virDomainPCIConnectFlags pcieFlags,\n                                         virDomainPCIConnectFlags virtioFlags)\n{\n    virDomainPCIConnectFlags pciFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                                         VIR_PCI_CONNECT_HOTPLUGGABLE);\n\n    switch ((virDomainDeviceType)dev->type) {\n    case VIR_DOMAIN_DEVICE_CONTROLLER: {\n        virDomainControllerDefPtr cont = dev->data.controller;\n\n        switch ((virDomainControllerType)cont->type) {\n        case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n            return virDomainPCIControllerModelToConnectType(cont->model);\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n            return pciFlags;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n            switch ((virDomainControllerModelUSB) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT:\n                /* qemuDomainControllerDefPostParse should have\n                 * changed 'model' to an explicit USB model in\n                 * most cases. Since we're still on the default\n                 * though, we must be going to use \"-usb\", which\n                 * is assumed to be a PCI default\n                 */\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QEMU_XHCI:\n                return pcieFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_EHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_EHCI1:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI2:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI3:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_VT82C686B_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX4_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PCI_OHCI:\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1: /* xen only */\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2: /* xen only */\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_IDE:\n            return pciFlags;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_SCSI:\n            switch ((virDomainControllerModelSCSI) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_DEFAULT:\n                return 0;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_NON_TRANSITIONAL:\n                return virtioFlags;\n\n            /* Transitional devices only work in conventional PCI slots */\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_TRANSITIONAL:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_AUTO:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1078:\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL:\n            switch ((virDomainControllerModelVirtioSerial) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO:\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_DEFAULT:\n                return virtioFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_FDC:\n        case VIR_DOMAIN_CONTROLLER_TYPE_CCID:\n        case VIR_DOMAIN_CONTROLLER_TYPE_XENBUS:\n        case VIR_DOMAIN_CONTROLLER_TYPE_LAST:\n            return 0;\n        }\n    }\n        break;\n\n    case VIR_DOMAIN_DEVICE_FS:\n        switch ((virDomainFSDriverType) dev->data.fs->fsdriver) {\n        case VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_PATH:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_HANDLE:\n            /* these drivers are handled by virtio-9p-pci */\n            switch ((virDomainFSModel) dev->data.fs->model) {\n            case VIR_DOMAIN_FS_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_FS_MODEL_VIRTIO:\n            case VIR_DOMAIN_FS_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_FS_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_FS_MODEL_LAST:\n                break;\n            }\n            break;\n\n        case VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS:\n            /* vhost-user-fs-pci */\n            return virtioFlags;\n\n        case VIR_DOMAIN_FS_DRIVER_TYPE_LOOP:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_NBD:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_PLOOP:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_LAST:\n            return 0;\n        }\n\n        return 0;\n\n    case VIR_DOMAIN_DEVICE_NET: {\n        virDomainNetDefPtr net = dev->data.net;\n\n        /* NB: a type='hostdev' will use PCI, but its\n         * address is assigned when we're assigning the\n         * addresses for other hostdev devices.\n         */\n        if (net->type == VIR_DOMAIN_NET_TYPE_HOSTDEV ||\n            net->model == VIR_DOMAIN_NET_MODEL_USB_NET) {\n            return 0;\n        }\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO ||\n            net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_NON_TRANSITIONAL)\n            return virtioFlags;\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_TRANSITIONAL)\n            return pciFlags;\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_E1000E)\n            return pcieFlags;\n\n        return pciFlags;\n    }\n\n    case VIR_DOMAIN_DEVICE_SOUND:\n        switch ((virDomainSoundModel) dev->data.sound->model) {\n        case VIR_DOMAIN_SOUND_MODEL_ES1370:\n        case VIR_DOMAIN_SOUND_MODEL_AC97:\n        case VIR_DOMAIN_SOUND_MODEL_ICH6:\n        case VIR_DOMAIN_SOUND_MODEL_ICH9:\n            return pciFlags;\n\n        case VIR_DOMAIN_SOUND_MODEL_SB16:\n        case VIR_DOMAIN_SOUND_MODEL_PCSPK:\n        case VIR_DOMAIN_SOUND_MODEL_USB:\n        case VIR_DOMAIN_SOUND_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_DISK:\n        switch ((virDomainDiskBus) dev->data.disk->bus) {\n        case VIR_DOMAIN_DISK_BUS_VIRTIO:\n            /* only virtio disks use PCI */\n            switch ((virDomainDiskModel) dev->data.disk->model) {\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO:\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_DISK_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_DISK_MODEL_LAST:\n                break;\n            }\n            return 0;\n\n        case VIR_DOMAIN_DISK_BUS_IDE:\n        case VIR_DOMAIN_DISK_BUS_FDC:\n        case VIR_DOMAIN_DISK_BUS_SCSI:\n        case VIR_DOMAIN_DISK_BUS_XEN:\n        case VIR_DOMAIN_DISK_BUS_USB:\n        case VIR_DOMAIN_DISK_BUS_UML:\n        case VIR_DOMAIN_DISK_BUS_SATA:\n        case VIR_DOMAIN_DISK_BUS_SD:\n        case VIR_DOMAIN_DISK_BUS_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_HOSTDEV: {\n        virDomainHostdevDefPtr hostdev = dev->data.hostdev;\n        bool isExpress = false;\n        virPCIDevicePtr pciDev;\n        virPCIDeviceAddressPtr hostAddr = &hostdev->source.subsys.u.pci.addr;\n\n        if (!virHostdevIsMdevDevice(hostdev) &&\n            (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n             (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n              hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST))) {\n            return 0;\n        }\n\n        if (pciFlags == pcieFlags) {\n            /* This arch/qemu only supports legacy PCI, so there\n             * is no point in checking if the device is an Express\n             * device.\n             */\n            return pciFlags;\n        }\n\n        if (virDeviceInfoPCIAddressIsPresent(hostdev->info)) {\n            /* A guest-side address has already been assigned, so\n             * we can avoid reading the PCI config, and just use\n             * pcieFlags, since the pciConnectFlags checking is\n             * more relaxed when an address is already assigned\n             * than it is when we're looking for a new address (so\n             * validation will pass regardless of whether we set\n             * the flags to PCI or PCIe).\n             */\n            return pcieFlags;\n        }\n\n        /* mdevs don't have corresponding files in /sys that we can poke to\n         * try and figure out whether they are legacy PCI or PCI Express, so\n         * the logic below would never work; instead, we just go ahead and\n         * assume they're PCI Express. This is a very reasonable assumption,\n         * as all current mdev-capable devices are indeed PCI Express */\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV)\n            return pcieFlags;\n\n        /* according to pbonzini, from the guest PoV vhost-scsi devices\n         * are the same as virtio-scsi, so they should follow virtio logic\n         */\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST) {\n            switch ((virDomainHostdevSubsysSCSIVHostModelType) hostdev->source.subsys.u.scsi_host.model) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_LAST:\n                break;\n            }\n            return 0;\n        }\n\n        if (!(pciDev = virPCIDeviceNew(hostAddr->domain,\n                                       hostAddr->bus,\n                                       hostAddr->slot,\n                                       hostAddr->function))) {\n            /* libvirt should be able to perform all the\n             * operations in virPCIDeviceNew() even if it's\n             * running unprivileged, so if this fails, the device\n             * apparently doesn't currently exist on the host.\n             * Since the overwhelming majority of assignable host\n             * devices are PCIe, assume this one is too.\n             */\n            return pcieFlags;\n        }\n\n        if (!driver->privileged) {\n            /* unprivileged libvirtd is unable to read *all* of a\n             * device's PCI config (it can only read the first 64\n             * bytes, which isn't enough for the check that's done\n             * in virPCIDeviceIsPCIExpress()), so instead of\n             * trying and failing, we make an educated guess based\n             * on the length of the device's config file - if it\n             * is 256 bytes, then it is definitely a legacy PCI\n             * device. If it's larger than that, then it is\n             * *probably PCIe (although it could be PCI-x, but\n             * those are extremely rare). If the config file can't\n             * be found (in which case the \"length\" will be -1),\n             * then we blindly assume the most likely outcome -\n             * PCIe.\n             */\n            off_t configLen\n               = virFileLength(virPCIDeviceGetConfigPath(pciDev), -1);\n\n            virPCIDeviceFree(pciDev);\n\n            if (configLen == 256)\n                return pciFlags;\n\n            return pcieFlags;\n        }\n\n        /* If we are running with privileges, we can examine the\n         * PCI config contents with virPCIDeviceIsPCIExpress() for\n         * a definitive answer.\n         */\n        isExpress = virPCIDeviceIsPCIExpress(pciDev);\n        virPCIDeviceFree(pciDev);\n\n        if (isExpress)\n            return pcieFlags;\n\n        return pciFlags;\n    }\n\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        switch ((virDomainMemballoonModel) dev->data.memballoon->model) {\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_MEMBALLOON_MODEL_XEN:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_NONE:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_RNG:\n        switch ((virDomainRNGModel) dev->data.rng->model) {\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO:\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_RNG_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        /* only one model connects using PCI */\n        switch ((virDomainWatchdogModel) dev->data.watchdog->model) {\n        case VIR_DOMAIN_WATCHDOG_MODEL_I6300ESB:\n            return pciFlags;\n\n        case VIR_DOMAIN_WATCHDOG_MODEL_IB700:\n        case VIR_DOMAIN_WATCHDOG_MODEL_DIAG288:\n        case VIR_DOMAIN_WATCHDOG_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        switch ((virDomainVideoType)dev->data.video->type) {\n        case VIR_DOMAIN_VIDEO_TYPE_VIRTIO:\n            return virtioFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_VGA:\n        case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n        case VIR_DOMAIN_VIDEO_TYPE_VMVGA:\n        case VIR_DOMAIN_VIDEO_TYPE_XEN:\n        case VIR_DOMAIN_VIDEO_TYPE_VBOX:\n        case VIR_DOMAIN_VIDEO_TYPE_QXL:\n        case VIR_DOMAIN_VIDEO_TYPE_PARALLELS:\n            return pciFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_BOCHS:\n            return pcieFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_DEFAULT:\n        case VIR_DOMAIN_VIDEO_TYPE_GOP:\n        case VIR_DOMAIN_VIDEO_TYPE_NONE:\n        case VIR_DOMAIN_VIDEO_TYPE_RAMFB:\n        case VIR_DOMAIN_VIDEO_TYPE_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        return pciFlags;\n\n    case VIR_DOMAIN_DEVICE_INPUT:\n        switch ((virDomainInputBus) dev->data.input->bus) {\n        case VIR_DOMAIN_INPUT_BUS_VIRTIO:\n            switch ((virDomainInputModel) dev->data.input->model) {\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO:\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_INPUT_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_INPUT_MODEL_LAST:\n                break;\n            }\n            return 0;\n\n        case VIR_DOMAIN_INPUT_BUS_PS2:\n        case VIR_DOMAIN_INPUT_BUS_USB:\n        case VIR_DOMAIN_INPUT_BUS_XEN:\n        case VIR_DOMAIN_INPUT_BUS_PARALLELS:\n        case VIR_DOMAIN_INPUT_BUS_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_CHR:\n        switch ((virDomainChrSerialTargetType)dev->data.chr->targetType) {\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_PCI:\n            return pciFlags;\n\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_ISA:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_USB:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SPAPR_VIO:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SYSTEM:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SCLP:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_NONE:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        switch ((virDomainVsockModel) dev->data.vsock->model) {\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO:\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_VSOCK_MODEL_DEFAULT:\n        case VIR_DOMAIN_VSOCK_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n        /* These devices don't ever connect with PCI */\n    case VIR_DOMAIN_DEVICE_NVRAM:\n    case VIR_DOMAIN_DEVICE_TPM:\n    case VIR_DOMAIN_DEVICE_PANIC:\n    case VIR_DOMAIN_DEVICE_MEMORY:\n    case VIR_DOMAIN_DEVICE_HUB:\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        /* These devices don't even have a DeviceInfo */\n    case VIR_DOMAIN_DEVICE_LEASE:\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n    case VIR_DOMAIN_DEVICE_IOMMU:\n    case VIR_DOMAIN_DEVICE_LAST:\n    case VIR_DOMAIN_DEVICE_NONE:\n        return 0;\n    }\n\n    /* We can never get here, because all cases are covered in the\n     * switch, and they all return, but the compiler will still\n     * complain \"control reaches end of non-void function\" unless\n     * we add the following return.\n     */\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic virDomainPCIConnectFlags\nqemuDomainDeviceCalculatePCIConnectFlags(virDomainDeviceDefPtr dev,\n                                         virQEMUDriverPtr driver,\n                                         virDomainPCIConnectFlags pcieFlags,\n                                         virDomainPCIConnectFlags virtioFlags)\n{\n    virDomainPCIConnectFlags pciFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                                         VIR_PCI_CONNECT_HOTPLUGGABLE);\n\n    switch ((virDomainDeviceType)dev->type) {\n    case VIR_DOMAIN_DEVICE_CONTROLLER: {\n        virDomainControllerDefPtr cont = dev->data.controller;\n\n        switch ((virDomainControllerType)cont->type) {\n        case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n            return virDomainPCIControllerModelToConnectType(cont->model);\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n            return pciFlags;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n            switch ((virDomainControllerModelUSB) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT:\n                /* qemuDomainControllerDefPostParse should have\n                 * changed 'model' to an explicit USB model in\n                 * most cases. Since we're still on the default\n                 * though, we must be going to use \"-usb\", which\n                 * is assumed to be a PCI default\n                 */\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QEMU_XHCI:\n                return pcieFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_EHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_EHCI1:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI2:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI3:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_VT82C686B_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX4_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PCI_OHCI:\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1: /* xen only */\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2: /* xen only */\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_IDE:\n            return pciFlags;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_SCSI:\n            switch ((virDomainControllerModelSCSI) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_DEFAULT:\n                return 0;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_NON_TRANSITIONAL:\n                return virtioFlags;\n\n            /* Transitional devices only work in conventional PCI slots */\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_TRANSITIONAL:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_AUTO:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1078:\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL:\n            switch ((virDomainControllerModelVirtioSerial) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO:\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_DEFAULT:\n                return virtioFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_FDC:\n        case VIR_DOMAIN_CONTROLLER_TYPE_CCID:\n        case VIR_DOMAIN_CONTROLLER_TYPE_XENBUS:\n        case VIR_DOMAIN_CONTROLLER_TYPE_LAST:\n            return 0;\n        }\n    }\n        break;\n\n    case VIR_DOMAIN_DEVICE_FS:\n        switch ((virDomainFSDriverType) dev->data.fs->fsdriver) {\n        case VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_PATH:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_HANDLE:\n            /* these drivers are handled by virtio-9p-pci */\n            switch ((virDomainFSModel) dev->data.fs->model) {\n            case VIR_DOMAIN_FS_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_FS_MODEL_VIRTIO:\n            case VIR_DOMAIN_FS_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_FS_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_FS_MODEL_LAST:\n                break;\n            }\n            break;\n\n        case VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS:\n            /* vhost-user-fs-pci */\n            return virtioFlags;\n\n        case VIR_DOMAIN_FS_DRIVER_TYPE_LOOP:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_NBD:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_PLOOP:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_LAST:\n            return 0;\n        }\n\n        return 0;\n\n    case VIR_DOMAIN_DEVICE_NET: {\n        virDomainNetDefPtr net = dev->data.net;\n\n        /* NB: a type='hostdev' will use PCI, but its\n         * address is assigned when we're assigning the\n         * addresses for other hostdev devices.\n         */\n        if (net->type == VIR_DOMAIN_NET_TYPE_HOSTDEV ||\n            net->model == VIR_DOMAIN_NET_MODEL_USB_NET) {\n            return 0;\n        }\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO ||\n            net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_NON_TRANSITIONAL)\n            return virtioFlags;\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_TRANSITIONAL)\n            return pciFlags;\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_E1000E)\n            return pcieFlags;\n\n        return pciFlags;\n    }\n\n    case VIR_DOMAIN_DEVICE_SOUND:\n        switch ((virDomainSoundModel) dev->data.sound->model) {\n        case VIR_DOMAIN_SOUND_MODEL_ES1370:\n        case VIR_DOMAIN_SOUND_MODEL_AC97:\n        case VIR_DOMAIN_SOUND_MODEL_ICH6:\n        case VIR_DOMAIN_SOUND_MODEL_ICH9:\n            return pciFlags;\n\n        case VIR_DOMAIN_SOUND_MODEL_SB16:\n        case VIR_DOMAIN_SOUND_MODEL_PCSPK:\n        case VIR_DOMAIN_SOUND_MODEL_USB:\n        case VIR_DOMAIN_SOUND_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_DISK:\n        switch ((virDomainDiskBus) dev->data.disk->bus) {\n        case VIR_DOMAIN_DISK_BUS_VIRTIO:\n            /* only virtio disks use PCI */\n            switch ((virDomainDiskModel) dev->data.disk->model) {\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO:\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_DISK_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_DISK_MODEL_LAST:\n                break;\n            }\n            return 0;\n\n        case VIR_DOMAIN_DISK_BUS_IDE:\n        case VIR_DOMAIN_DISK_BUS_FDC:\n        case VIR_DOMAIN_DISK_BUS_SCSI:\n        case VIR_DOMAIN_DISK_BUS_XEN:\n        case VIR_DOMAIN_DISK_BUS_USB:\n        case VIR_DOMAIN_DISK_BUS_UML:\n        case VIR_DOMAIN_DISK_BUS_SATA:\n        case VIR_DOMAIN_DISK_BUS_SD:\n        case VIR_DOMAIN_DISK_BUS_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_HOSTDEV: {\n        virDomainHostdevDefPtr hostdev = dev->data.hostdev;\n        bool isExpress = false;\n        virPCIDevicePtr pciDev;\n        virPCIDeviceAddressPtr hostAddr = &hostdev->source.subsys.u.pci.addr;\n\n        if (!virHostdevIsMdevDevice(hostdev) &&\n            (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n             (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n              hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST))) {\n            return 0;\n        }\n\n        if (pciFlags == pcieFlags) {\n            /* This arch/qemu only supports legacy PCI, so there\n             * is no point in checking if the device is an Express\n             * device.\n             */\n            return pciFlags;\n        }\n\n        if (virDeviceInfoPCIAddressIsPresent(hostdev->info)) {\n            /* A guest-side address has already been assigned, so\n             * we can avoid reading the PCI config, and just use\n             * pcieFlags, since the pciConnectFlags checking is\n             * more relaxed when an address is already assigned\n             * than it is when we're looking for a new address (so\n             * validation will pass regardless of whether we set\n             * the flags to PCI or PCIe).\n             */\n            return pcieFlags;\n        }\n\n        /* mdevs don't have corresponding files in /sys that we can poke to\n         * try and figure out whether they are legacy PCI or PCI Express, so\n         * the logic below would never work; instead, we just go ahead and\n         * assume they're PCI Express. This is a very reasonable assumption,\n         * as all current mdev-capable devices are indeed PCI Express */\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV)\n            return pcieFlags;\n\n        /* according to pbonzini, from the guest PoV vhost-scsi devices\n         * are the same as virtio-scsi, so they should follow virtio logic\n         */\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST) {\n            switch ((virDomainHostdevSubsysSCSIVHostModelType) hostdev->source.subsys.u.scsi_host.model) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_LAST:\n                break;\n            }\n            return 0;\n        }\n\n        if (!(pciDev = virPCIDeviceNew(hostAddr->domain,\n                                       hostAddr->bus,\n                                       hostAddr->slot,\n                                       hostAddr->function))) {\n            /* libvirt should be able to perform all the\n             * operations in virPCIDeviceNew() even if it's\n             * running unprivileged, so if this fails, the device\n             * apparently doesn't currently exist on the host.\n             * Since the overwhelming majority of assignable host\n             * devices are PCIe, assume this one is too.\n             */\n            return pcieFlags;\n        }\n\n        if (!driver->privileged) {\n            /* unprivileged libvirtd is unable to read *all* of a\n             * device's PCI config (it can only read the first 64\n             * bytes, which isn't enough for the check that's done\n             * in virPCIDeviceIsPCIExpress()), so instead of\n             * trying and failing, we make an educated guess based\n             * on the length of the device's config file - if it\n             * is 256 bytes, then it is definitely a legacy PCI\n             * device. If it's larger than that, then it is\n             * *probably PCIe (although it could be PCI-x, but\n             * those are extremely rare). If the config file can't\n             * be found (in which case the \"length\" will be -1),\n             * then we blindly assume the most likely outcome -\n             * PCIe.\n             */\n            off_t configLen\n               = virFileLength(virPCIDeviceGetConfigPath(pciDev), -1);\n\n            virPCIDeviceFree(pciDev);\n\n            if (configLen == 256)\n                return pciFlags;\n\n            return pcieFlags;\n        }\n\n        /* If we are running with privileges, we can examine the\n         * PCI config contents with virPCIDeviceIsPCIExpress() for\n         * a definitive answer.\n         */\n        isExpress = virPCIDeviceIsPCIExpress(pciDev);\n        virPCIDeviceFree(pciDev);\n\n        if (isExpress)\n            return pcieFlags;\n\n        return pciFlags;\n    }\n\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        switch ((virDomainMemballoonModel) dev->data.memballoon->model) {\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_MEMBALLOON_MODEL_XEN:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_NONE:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_RNG:\n        switch ((virDomainRNGModel) dev->data.rng->model) {\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO:\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_RNG_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        /* only one model connects using PCI */\n        switch ((virDomainWatchdogModel) dev->data.watchdog->model) {\n        case VIR_DOMAIN_WATCHDOG_MODEL_I6300ESB:\n            return pciFlags;\n\n        case VIR_DOMAIN_WATCHDOG_MODEL_IB700:\n        case VIR_DOMAIN_WATCHDOG_MODEL_DIAG288:\n        case VIR_DOMAIN_WATCHDOG_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        switch ((virDomainVideoType)dev->data.video->type) {\n        case VIR_DOMAIN_VIDEO_TYPE_VIRTIO:\n            return virtioFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_VGA:\n        case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n        case VIR_DOMAIN_VIDEO_TYPE_VMVGA:\n        case VIR_DOMAIN_VIDEO_TYPE_XEN:\n        case VIR_DOMAIN_VIDEO_TYPE_VBOX:\n        case VIR_DOMAIN_VIDEO_TYPE_QXL:\n        case VIR_DOMAIN_VIDEO_TYPE_PARALLELS:\n            return pciFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_BOCHS:\n            return pcieFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_DEFAULT:\n        case VIR_DOMAIN_VIDEO_TYPE_GOP:\n        case VIR_DOMAIN_VIDEO_TYPE_NONE:\n        case VIR_DOMAIN_VIDEO_TYPE_RAMFB:\n        case VIR_DOMAIN_VIDEO_TYPE_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        return pciFlags;\n\n    case VIR_DOMAIN_DEVICE_INPUT:\n        switch ((virDomainInputBus) dev->data.input->bus) {\n        case VIR_DOMAIN_INPUT_BUS_VIRTIO:\n            switch ((virDomainInputModel) dev->data.input->model) {\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO:\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_INPUT_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_INPUT_MODEL_LAST:\n                break;\n            }\n            return 0;\n\n        case VIR_DOMAIN_INPUT_BUS_PS2:\n        case VIR_DOMAIN_INPUT_BUS_USB:\n        case VIR_DOMAIN_INPUT_BUS_XEN:\n        case VIR_DOMAIN_INPUT_BUS_PARALLELS:\n        case VIR_DOMAIN_INPUT_BUS_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_CHR:\n        switch ((virDomainChrSerialTargetType)dev->data.chr->targetType) {\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_PCI:\n            return pciFlags;\n\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_ISA:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_USB:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SPAPR_VIO:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SYSTEM:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SCLP:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_NONE:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        switch ((virDomainVsockModel) dev->data.vsock->model) {\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO:\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_VSOCK_MODEL_DEFAULT:\n        case VIR_DOMAIN_VSOCK_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n        /* These devices don't ever connect with PCI */\n    case VIR_DOMAIN_DEVICE_NVRAM:\n    case VIR_DOMAIN_DEVICE_TPM:\n    case VIR_DOMAIN_DEVICE_PANIC:\n    case VIR_DOMAIN_DEVICE_MEMORY:\n    case VIR_DOMAIN_DEVICE_HUB:\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        /* These devices don't even have a DeviceInfo */\n    case VIR_DOMAIN_DEVICE_LEASE:\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n    case VIR_DOMAIN_DEVICE_IOMMU:\n    case VIR_DOMAIN_DEVICE_LAST:\n    case VIR_DOMAIN_DEVICE_NONE:\n        return 0;\n    }\n\n    /* We can never get here, because all cases are covered in the\n     * switch, and they all return, but the compiler will still\n     * complain \"control reaches end of non-void function\" unless\n     * we add the following return.\n     */\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainFillDevicePCIConnectFlagsIter(virDomainDefPtr def G_GNUC_UNUSED,\n                                        virDomainDeviceDefPtr dev,\n                                        virDomainDeviceInfoPtr info,\n                                        void *opaque)\n{\n    qemuDomainFillDevicePCIConnectFlagsIterData *data = opaque;\n\n    info->pciConnectFlags\n        = qemuDomainDeviceCalculatePCIConnectFlags(dev, data->driver,\n                                                   data->pcieFlags,\n                                                   data->virtioFlags);\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainFillDevicePCIConnectFlagsIterInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "1065-1087",
    "snippet": "static void\nqemuDomainFillDevicePCIConnectFlagsIterInit(virDomainDefPtr def,\n                                            virQEMUCapsPtr qemuCaps,\n                                            virQEMUDriverPtr driver,\n                                            qemuDomainFillDevicePCIConnectFlagsIterData *data)\n{\n    data->driver = driver;\n\n    if (qemuDomainHasPCIeRoot(def)) {\n        data->pcieFlags = (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                           VIR_PCI_CONNECT_HOTPLUGGABLE);\n    } else {\n        data->pcieFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                           VIR_PCI_CONNECT_HOTPLUGGABLE);\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_DISABLE_LEGACY)) {\n        data->virtioFlags = data->pcieFlags;\n    } else {\n        data->virtioFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                             VIR_PCI_CONNECT_HOTPLUGGABLE);\n    }\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_VIRTIO_PCI_DISABLE_LEGACY"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainHasPCIeRoot",
          "args": [
            "def"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainHasPCIeRoot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12934-12946",
          "snippet": "bool\nqemuDomainHasPCIeRoot(const virDomainDef *def)\n{\n    int root = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_PCI, 0);\n\n    if (root < 0)\n        return false;\n\n    if (def->controllers[root]->model != VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT)\n        return false;\n\n    return true;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainHasPCIeRoot(const virDomainDef *def)\n{\n    int root = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_PCI, 0);\n\n    if (root < 0)\n        return false;\n\n    if (def->controllers[root]->model != VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT)\n        return false;\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic void\nqemuDomainFillDevicePCIConnectFlagsIterInit(virDomainDefPtr def,\n                                            virQEMUCapsPtr qemuCaps,\n                                            virQEMUDriverPtr driver,\n                                            qemuDomainFillDevicePCIConnectFlagsIterData *data)\n{\n    data->driver = driver;\n\n    if (qemuDomainHasPCIeRoot(def)) {\n        data->pcieFlags = (VIR_PCI_CONNECT_TYPE_PCIE_DEVICE |\n                           VIR_PCI_CONNECT_HOTPLUGGABLE);\n    } else {\n        data->pcieFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                           VIR_PCI_CONNECT_HOTPLUGGABLE);\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_DISABLE_LEGACY)) {\n        data->virtioFlags = data->pcieFlags;\n    } else {\n        data->virtioFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                             VIR_PCI_CONNECT_HOTPLUGGABLE);\n    }\n}"
  },
  {
    "function_name": "qemuDomainDeviceCalculatePCIConnectFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "576-1049",
    "snippet": "static virDomainPCIConnectFlags\nqemuDomainDeviceCalculatePCIConnectFlags(virDomainDeviceDefPtr dev,\n                                         virQEMUDriverPtr driver,\n                                         virDomainPCIConnectFlags pcieFlags,\n                                         virDomainPCIConnectFlags virtioFlags)\n{\n    virDomainPCIConnectFlags pciFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                                         VIR_PCI_CONNECT_HOTPLUGGABLE);\n\n    switch ((virDomainDeviceType)dev->type) {\n    case VIR_DOMAIN_DEVICE_CONTROLLER: {\n        virDomainControllerDefPtr cont = dev->data.controller;\n\n        switch ((virDomainControllerType)cont->type) {\n        case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n            return virDomainPCIControllerModelToConnectType(cont->model);\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n            return pciFlags;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n            switch ((virDomainControllerModelUSB) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT:\n                /* qemuDomainControllerDefPostParse should have\n                 * changed 'model' to an explicit USB model in\n                 * most cases. Since we're still on the default\n                 * though, we must be going to use \"-usb\", which\n                 * is assumed to be a PCI default\n                 */\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QEMU_XHCI:\n                return pcieFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_EHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_EHCI1:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI2:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI3:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_VT82C686B_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX4_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PCI_OHCI:\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1: /* xen only */\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2: /* xen only */\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_IDE:\n            return pciFlags;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_SCSI:\n            switch ((virDomainControllerModelSCSI) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_DEFAULT:\n                return 0;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_NON_TRANSITIONAL:\n                return virtioFlags;\n\n            /* Transitional devices only work in conventional PCI slots */\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_TRANSITIONAL:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_AUTO:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1078:\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL:\n            switch ((virDomainControllerModelVirtioSerial) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO:\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_DEFAULT:\n                return virtioFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_FDC:\n        case VIR_DOMAIN_CONTROLLER_TYPE_CCID:\n        case VIR_DOMAIN_CONTROLLER_TYPE_XENBUS:\n        case VIR_DOMAIN_CONTROLLER_TYPE_LAST:\n            return 0;\n        }\n    }\n        break;\n\n    case VIR_DOMAIN_DEVICE_FS:\n        switch ((virDomainFSDriverType) dev->data.fs->fsdriver) {\n        case VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_PATH:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_HANDLE:\n            /* these drivers are handled by virtio-9p-pci */\n            switch ((virDomainFSModel) dev->data.fs->model) {\n            case VIR_DOMAIN_FS_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_FS_MODEL_VIRTIO:\n            case VIR_DOMAIN_FS_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_FS_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_FS_MODEL_LAST:\n                break;\n            }\n            break;\n\n        case VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS:\n            /* vhost-user-fs-pci */\n            return virtioFlags;\n\n        case VIR_DOMAIN_FS_DRIVER_TYPE_LOOP:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_NBD:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_PLOOP:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_LAST:\n            return 0;\n        }\n\n        return 0;\n\n    case VIR_DOMAIN_DEVICE_NET: {\n        virDomainNetDefPtr net = dev->data.net;\n\n        /* NB: a type='hostdev' will use PCI, but its\n         * address is assigned when we're assigning the\n         * addresses for other hostdev devices.\n         */\n        if (net->type == VIR_DOMAIN_NET_TYPE_HOSTDEV ||\n            net->model == VIR_DOMAIN_NET_MODEL_USB_NET) {\n            return 0;\n        }\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO ||\n            net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_NON_TRANSITIONAL)\n            return virtioFlags;\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_TRANSITIONAL)\n            return pciFlags;\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_E1000E)\n            return pcieFlags;\n\n        return pciFlags;\n    }\n\n    case VIR_DOMAIN_DEVICE_SOUND:\n        switch ((virDomainSoundModel) dev->data.sound->model) {\n        case VIR_DOMAIN_SOUND_MODEL_ES1370:\n        case VIR_DOMAIN_SOUND_MODEL_AC97:\n        case VIR_DOMAIN_SOUND_MODEL_ICH6:\n        case VIR_DOMAIN_SOUND_MODEL_ICH9:\n            return pciFlags;\n\n        case VIR_DOMAIN_SOUND_MODEL_SB16:\n        case VIR_DOMAIN_SOUND_MODEL_PCSPK:\n        case VIR_DOMAIN_SOUND_MODEL_USB:\n        case VIR_DOMAIN_SOUND_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_DISK:\n        switch ((virDomainDiskBus) dev->data.disk->bus) {\n        case VIR_DOMAIN_DISK_BUS_VIRTIO:\n            /* only virtio disks use PCI */\n            switch ((virDomainDiskModel) dev->data.disk->model) {\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO:\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_DISK_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_DISK_MODEL_LAST:\n                break;\n            }\n            return 0;\n\n        case VIR_DOMAIN_DISK_BUS_IDE:\n        case VIR_DOMAIN_DISK_BUS_FDC:\n        case VIR_DOMAIN_DISK_BUS_SCSI:\n        case VIR_DOMAIN_DISK_BUS_XEN:\n        case VIR_DOMAIN_DISK_BUS_USB:\n        case VIR_DOMAIN_DISK_BUS_UML:\n        case VIR_DOMAIN_DISK_BUS_SATA:\n        case VIR_DOMAIN_DISK_BUS_SD:\n        case VIR_DOMAIN_DISK_BUS_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_HOSTDEV: {\n        virDomainHostdevDefPtr hostdev = dev->data.hostdev;\n        bool isExpress = false;\n        virPCIDevicePtr pciDev;\n        virPCIDeviceAddressPtr hostAddr = &hostdev->source.subsys.u.pci.addr;\n\n        if (!virHostdevIsMdevDevice(hostdev) &&\n            (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n             (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n              hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST))) {\n            return 0;\n        }\n\n        if (pciFlags == pcieFlags) {\n            /* This arch/qemu only supports legacy PCI, so there\n             * is no point in checking if the device is an Express\n             * device.\n             */\n            return pciFlags;\n        }\n\n        if (virDeviceInfoPCIAddressIsPresent(hostdev->info)) {\n            /* A guest-side address has already been assigned, so\n             * we can avoid reading the PCI config, and just use\n             * pcieFlags, since the pciConnectFlags checking is\n             * more relaxed when an address is already assigned\n             * than it is when we're looking for a new address (so\n             * validation will pass regardless of whether we set\n             * the flags to PCI or PCIe).\n             */\n            return pcieFlags;\n        }\n\n        /* mdevs don't have corresponding files in /sys that we can poke to\n         * try and figure out whether they are legacy PCI or PCI Express, so\n         * the logic below would never work; instead, we just go ahead and\n         * assume they're PCI Express. This is a very reasonable assumption,\n         * as all current mdev-capable devices are indeed PCI Express */\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV)\n            return pcieFlags;\n\n        /* according to pbonzini, from the guest PoV vhost-scsi devices\n         * are the same as virtio-scsi, so they should follow virtio logic\n         */\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST) {\n            switch ((virDomainHostdevSubsysSCSIVHostModelType) hostdev->source.subsys.u.scsi_host.model) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_LAST:\n                break;\n            }\n            return 0;\n        }\n\n        if (!(pciDev = virPCIDeviceNew(hostAddr->domain,\n                                       hostAddr->bus,\n                                       hostAddr->slot,\n                                       hostAddr->function))) {\n            /* libvirt should be able to perform all the\n             * operations in virPCIDeviceNew() even if it's\n             * running unprivileged, so if this fails, the device\n             * apparently doesn't currently exist on the host.\n             * Since the overwhelming majority of assignable host\n             * devices are PCIe, assume this one is too.\n             */\n            return pcieFlags;\n        }\n\n        if (!driver->privileged) {\n            /* unprivileged libvirtd is unable to read *all* of a\n             * device's PCI config (it can only read the first 64\n             * bytes, which isn't enough for the check that's done\n             * in virPCIDeviceIsPCIExpress()), so instead of\n             * trying and failing, we make an educated guess based\n             * on the length of the device's config file - if it\n             * is 256 bytes, then it is definitely a legacy PCI\n             * device. If it's larger than that, then it is\n             * *probably PCIe (although it could be PCI-x, but\n             * those are extremely rare). If the config file can't\n             * be found (in which case the \"length\" will be -1),\n             * then we blindly assume the most likely outcome -\n             * PCIe.\n             */\n            off_t configLen\n               = virFileLength(virPCIDeviceGetConfigPath(pciDev), -1);\n\n            virPCIDeviceFree(pciDev);\n\n            if (configLen == 256)\n                return pciFlags;\n\n            return pcieFlags;\n        }\n\n        /* If we are running with privileges, we can examine the\n         * PCI config contents with virPCIDeviceIsPCIExpress() for\n         * a definitive answer.\n         */\n        isExpress = virPCIDeviceIsPCIExpress(pciDev);\n        virPCIDeviceFree(pciDev);\n\n        if (isExpress)\n            return pcieFlags;\n\n        return pciFlags;\n    }\n\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        switch ((virDomainMemballoonModel) dev->data.memballoon->model) {\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_MEMBALLOON_MODEL_XEN:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_NONE:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_RNG:\n        switch ((virDomainRNGModel) dev->data.rng->model) {\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO:\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_RNG_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        /* only one model connects using PCI */\n        switch ((virDomainWatchdogModel) dev->data.watchdog->model) {\n        case VIR_DOMAIN_WATCHDOG_MODEL_I6300ESB:\n            return pciFlags;\n\n        case VIR_DOMAIN_WATCHDOG_MODEL_IB700:\n        case VIR_DOMAIN_WATCHDOG_MODEL_DIAG288:\n        case VIR_DOMAIN_WATCHDOG_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        switch ((virDomainVideoType)dev->data.video->type) {\n        case VIR_DOMAIN_VIDEO_TYPE_VIRTIO:\n            return virtioFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_VGA:\n        case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n        case VIR_DOMAIN_VIDEO_TYPE_VMVGA:\n        case VIR_DOMAIN_VIDEO_TYPE_XEN:\n        case VIR_DOMAIN_VIDEO_TYPE_VBOX:\n        case VIR_DOMAIN_VIDEO_TYPE_QXL:\n        case VIR_DOMAIN_VIDEO_TYPE_PARALLELS:\n            return pciFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_BOCHS:\n            return pcieFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_DEFAULT:\n        case VIR_DOMAIN_VIDEO_TYPE_GOP:\n        case VIR_DOMAIN_VIDEO_TYPE_NONE:\n        case VIR_DOMAIN_VIDEO_TYPE_RAMFB:\n        case VIR_DOMAIN_VIDEO_TYPE_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        return pciFlags;\n\n    case VIR_DOMAIN_DEVICE_INPUT:\n        switch ((virDomainInputBus) dev->data.input->bus) {\n        case VIR_DOMAIN_INPUT_BUS_VIRTIO:\n            switch ((virDomainInputModel) dev->data.input->model) {\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO:\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_INPUT_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_INPUT_MODEL_LAST:\n                break;\n            }\n            return 0;\n\n        case VIR_DOMAIN_INPUT_BUS_PS2:\n        case VIR_DOMAIN_INPUT_BUS_USB:\n        case VIR_DOMAIN_INPUT_BUS_XEN:\n        case VIR_DOMAIN_INPUT_BUS_PARALLELS:\n        case VIR_DOMAIN_INPUT_BUS_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_CHR:\n        switch ((virDomainChrSerialTargetType)dev->data.chr->targetType) {\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_PCI:\n            return pciFlags;\n\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_ISA:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_USB:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SPAPR_VIO:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SYSTEM:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SCLP:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_NONE:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        switch ((virDomainVsockModel) dev->data.vsock->model) {\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO:\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_VSOCK_MODEL_DEFAULT:\n        case VIR_DOMAIN_VSOCK_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n        /* These devices don't ever connect with PCI */\n    case VIR_DOMAIN_DEVICE_NVRAM:\n    case VIR_DOMAIN_DEVICE_TPM:\n    case VIR_DOMAIN_DEVICE_PANIC:\n    case VIR_DOMAIN_DEVICE_MEMORY:\n    case VIR_DOMAIN_DEVICE_HUB:\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        /* These devices don't even have a DeviceInfo */\n    case VIR_DOMAIN_DEVICE_LEASE:\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n    case VIR_DOMAIN_DEVICE_IOMMU:\n    case VIR_DOMAIN_DEVICE_LAST:\n    case VIR_DOMAIN_DEVICE_NONE:\n        return 0;\n    }\n\n    /* We can never get here, because all cases are covered in the\n     * switch, and they all return, but the compiler will still\n     * complain \"control reaches end of non-void function\" unless\n     * we add the following return.\n     */\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceFree",
          "args": [
            "pciDev"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1439-1450",
          "snippet": "void\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceIsPCIExpress",
          "args": [
            "pciDev"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceIsPCIExpress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2727-2744",
          "snippet": "int\nvirPCIDeviceIsPCIExpress(virPCIDevicePtr dev)\n{\n    int fd;\n    int ret = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return ret;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    ret = dev->pcie_cap_pos != 0;\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceIsPCIExpress(virPCIDevicePtr dev)\n{\n    int fd;\n    int ret = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return ret;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    ret = dev->pcie_cap_pos != 0;\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileLength",
          "args": [
            "virPCIDeviceGetConfigPath(pciDev)",
            "-1"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "virFileLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1829-1847",
          "snippet": "off_t\nvirFileLength(const char *path, int fd)\n{\n    struct stat s;\n\n    if (fd >= 0) {\n        if (fstat(fd, &s) < 0)\n            return -1;\n    } else {\n        if (stat(path, &s) < 0)\n            return -1;\n    }\n\n    if (!S_ISREG(s.st_mode))\n       return -1;\n\n    return s.st_size;\n\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\noff_t\nvirFileLength(const char *path, int fd)\n{\n    struct stat s;\n\n    if (fd >= 0) {\n        if (fstat(fd, &s) < 0)\n            return -1;\n    } else {\n        if (stat(path, &s) < 0)\n            return -1;\n    }\n\n    if (!S_ISREG(s.st_mode))\n       return -1;\n\n    return s.st_size;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetConfigPath",
          "args": [
            "pciDev"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetConfigPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1479-1483",
          "snippet": "const char *\nvirPCIDeviceGetConfigPath(virPCIDevicePtr dev)\n{\n    return dev->path;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nconst char *\nvirPCIDeviceGetConfigPath(virPCIDevicePtr dev)\n{\n    return dev->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceNew",
          "args": [
            "hostAddr->domain",
            "hostAddr->bus",
            "hostAddr->slot",
            "hostAddr->function"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1364-1416",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nvirPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDeviceInfoPCIAddressIsPresent",
          "args": [
            "hostdev->info"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "virDeviceInfoPCIAddressIsPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "191-196",
          "snippet": "bool\nvirDeviceInfoPCIAddressIsPresent(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n           !virPCIDeviceAddressIsEmpty(&info->addr.pci);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool\nvirDeviceInfoPCIAddressIsPresent(const virDomainDeviceInfo *info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI &&\n           !virPCIDeviceAddressIsEmpty(&info->addr.pci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsMdevDevice",
          "args": [
            "hostdev"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsMdevDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32296-32301",
          "snippet": "bool\nvirHostdevIsMdevDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirHostdevIsMdevDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainPCIControllerModelToConnectType",
          "args": [
            "cont->model"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainPCIControllerModelToConnectType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "266-309",
          "snippet": "virDomainPCIConnectFlags\nvirDomainPCIControllerModelToConnectType(virDomainControllerModelPCI model)\n{\n    /* given a VIR_DOMAIN_CONTROLLER_MODEL_PCI*, return\n     * the equivalent VIR_PCI_CONNECT_TYPE_*.\n     */\n    switch (model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n        /* pci-root and pcie-root are implicit in the machine,\n         * and have no upstream connection, \"last\" will never actually\n         * happen, it's just there so that all possible cases are\n         * covered in the switch (keeps the compiler happy).\n         */\n        return 0;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n        return VIR_PCI_CONNECT_TYPE_PCI_BRIDGE;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n        return VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n        return VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n        return VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n        return VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n        return VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT | VIR_PCI_CONNECT_AGGREGATE_SLOT;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n        return VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n        return VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvirDomainPCIConnectFlags\nvirDomainPCIControllerModelToConnectType(virDomainControllerModelPCI model)\n{\n    /* given a VIR_DOMAIN_CONTROLLER_MODEL_PCI*, return\n     * the equivalent VIR_PCI_CONNECT_TYPE_*.\n     */\n    switch (model) {\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_DEFAULT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_LAST:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_ROOT:\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT:\n        /* pci-root and pcie-root are implicit in the machine,\n         * and have no upstream connection, \"last\" will never actually\n         * happen, it's just there so that all possible cases are\n         * covered in the switch (keeps the compiler happy).\n         */\n        return 0;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_BRIDGE:\n        return VIR_PCI_CONNECT_TYPE_PCI_BRIDGE;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCI_EXPANDER_BUS:\n        return VIR_PCI_CONNECT_TYPE_PCI_EXPANDER_BUS;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_EXPANDER_BUS:\n        return VIR_PCI_CONNECT_TYPE_PCIE_EXPANDER_BUS;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_DMI_TO_PCI_BRIDGE:\n        return VIR_PCI_CONNECT_TYPE_DMI_TO_PCI_BRIDGE;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_TO_PCI_BRIDGE:\n        return VIR_PCI_CONNECT_TYPE_PCIE_TO_PCI_BRIDGE;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT_PORT:\n        return VIR_PCI_CONNECT_TYPE_PCIE_ROOT_PORT | VIR_PCI_CONNECT_AGGREGATE_SLOT;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_UPSTREAM_PORT:\n        return VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_UPSTREAM_PORT;\n\n    case VIR_DOMAIN_CONTROLLER_MODEL_PCIE_SWITCH_DOWNSTREAM_PORT:\n        return VIR_PCI_CONNECT_TYPE_PCIE_SWITCH_DOWNSTREAM_PORT;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic virDomainPCIConnectFlags\nqemuDomainDeviceCalculatePCIConnectFlags(virDomainDeviceDefPtr dev,\n                                         virQEMUDriverPtr driver,\n                                         virDomainPCIConnectFlags pcieFlags,\n                                         virDomainPCIConnectFlags virtioFlags)\n{\n    virDomainPCIConnectFlags pciFlags = (VIR_PCI_CONNECT_TYPE_PCI_DEVICE |\n                                         VIR_PCI_CONNECT_HOTPLUGGABLE);\n\n    switch ((virDomainDeviceType)dev->type) {\n    case VIR_DOMAIN_DEVICE_CONTROLLER: {\n        virDomainControllerDefPtr cont = dev->data.controller;\n\n        switch ((virDomainControllerType)cont->type) {\n        case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n            return virDomainPCIControllerModelToConnectType(cont->model);\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n            return pciFlags;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n            switch ((virDomainControllerModelUSB) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_DEFAULT:\n                /* qemuDomainControllerDefPostParse should have\n                 * changed 'model' to an explicit USB model in\n                 * most cases. Since we're still on the default\n                 * though, we must be going to use \"-usb\", which\n                 * is assumed to be a PCI default\n                 */\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QEMU_XHCI:\n                return pcieFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_EHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_EHCI1:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI1:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI2:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_ICH9_UHCI3:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_VT82C686B_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX3_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PIIX4_UHCI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_PCI_OHCI:\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1: /* xen only */\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2: /* xen only */\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE:\n            case VIR_DOMAIN_CONTROLLER_MODEL_USB_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_IDE:\n            return pciFlags;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_SCSI:\n            switch ((virDomainControllerModelSCSI) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_DEFAULT:\n                return 0;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_NON_TRANSITIONAL:\n                return virtioFlags;\n\n            /* Transitional devices only work in conventional PCI slots */\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_TRANSITIONAL:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_AUTO:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI:\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1078:\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL:\n            switch ((virDomainControllerModelVirtioSerial) cont->model) {\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO:\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_DEFAULT:\n                return virtioFlags;\n\n            case VIR_DOMAIN_CONTROLLER_MODEL_VIRTIO_SERIAL_LAST:\n                return 0;\n            }\n            break;\n\n        case VIR_DOMAIN_CONTROLLER_TYPE_FDC:\n        case VIR_DOMAIN_CONTROLLER_TYPE_CCID:\n        case VIR_DOMAIN_CONTROLLER_TYPE_XENBUS:\n        case VIR_DOMAIN_CONTROLLER_TYPE_LAST:\n            return 0;\n        }\n    }\n        break;\n\n    case VIR_DOMAIN_DEVICE_FS:\n        switch ((virDomainFSDriverType) dev->data.fs->fsdriver) {\n        case VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_PATH:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_HANDLE:\n            /* these drivers are handled by virtio-9p-pci */\n            switch ((virDomainFSModel) dev->data.fs->model) {\n            case VIR_DOMAIN_FS_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_FS_MODEL_VIRTIO:\n            case VIR_DOMAIN_FS_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_FS_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_FS_MODEL_LAST:\n                break;\n            }\n            break;\n\n        case VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS:\n            /* vhost-user-fs-pci */\n            return virtioFlags;\n\n        case VIR_DOMAIN_FS_DRIVER_TYPE_LOOP:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_NBD:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_PLOOP:\n        case VIR_DOMAIN_FS_DRIVER_TYPE_LAST:\n            return 0;\n        }\n\n        return 0;\n\n    case VIR_DOMAIN_DEVICE_NET: {\n        virDomainNetDefPtr net = dev->data.net;\n\n        /* NB: a type='hostdev' will use PCI, but its\n         * address is assigned when we're assigning the\n         * addresses for other hostdev devices.\n         */\n        if (net->type == VIR_DOMAIN_NET_TYPE_HOSTDEV ||\n            net->model == VIR_DOMAIN_NET_MODEL_USB_NET) {\n            return 0;\n        }\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO ||\n            net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_NON_TRANSITIONAL)\n            return virtioFlags;\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_TRANSITIONAL)\n            return pciFlags;\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_E1000E)\n            return pcieFlags;\n\n        return pciFlags;\n    }\n\n    case VIR_DOMAIN_DEVICE_SOUND:\n        switch ((virDomainSoundModel) dev->data.sound->model) {\n        case VIR_DOMAIN_SOUND_MODEL_ES1370:\n        case VIR_DOMAIN_SOUND_MODEL_AC97:\n        case VIR_DOMAIN_SOUND_MODEL_ICH6:\n        case VIR_DOMAIN_SOUND_MODEL_ICH9:\n            return pciFlags;\n\n        case VIR_DOMAIN_SOUND_MODEL_SB16:\n        case VIR_DOMAIN_SOUND_MODEL_PCSPK:\n        case VIR_DOMAIN_SOUND_MODEL_USB:\n        case VIR_DOMAIN_SOUND_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_DISK:\n        switch ((virDomainDiskBus) dev->data.disk->bus) {\n        case VIR_DOMAIN_DISK_BUS_VIRTIO:\n            /* only virtio disks use PCI */\n            switch ((virDomainDiskModel) dev->data.disk->model) {\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO:\n            case VIR_DOMAIN_DISK_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_DISK_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_DISK_MODEL_LAST:\n                break;\n            }\n            return 0;\n\n        case VIR_DOMAIN_DISK_BUS_IDE:\n        case VIR_DOMAIN_DISK_BUS_FDC:\n        case VIR_DOMAIN_DISK_BUS_SCSI:\n        case VIR_DOMAIN_DISK_BUS_XEN:\n        case VIR_DOMAIN_DISK_BUS_USB:\n        case VIR_DOMAIN_DISK_BUS_UML:\n        case VIR_DOMAIN_DISK_BUS_SATA:\n        case VIR_DOMAIN_DISK_BUS_SD:\n        case VIR_DOMAIN_DISK_BUS_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_HOSTDEV: {\n        virDomainHostdevDefPtr hostdev = dev->data.hostdev;\n        bool isExpress = false;\n        virPCIDevicePtr pciDev;\n        virPCIDeviceAddressPtr hostAddr = &hostdev->source.subsys.u.pci.addr;\n\n        if (!virHostdevIsMdevDevice(hostdev) &&\n            (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n             (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n              hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST))) {\n            return 0;\n        }\n\n        if (pciFlags == pcieFlags) {\n            /* This arch/qemu only supports legacy PCI, so there\n             * is no point in checking if the device is an Express\n             * device.\n             */\n            return pciFlags;\n        }\n\n        if (virDeviceInfoPCIAddressIsPresent(hostdev->info)) {\n            /* A guest-side address has already been assigned, so\n             * we can avoid reading the PCI config, and just use\n             * pcieFlags, since the pciConnectFlags checking is\n             * more relaxed when an address is already assigned\n             * than it is when we're looking for a new address (so\n             * validation will pass regardless of whether we set\n             * the flags to PCI or PCIe).\n             */\n            return pcieFlags;\n        }\n\n        /* mdevs don't have corresponding files in /sys that we can poke to\n         * try and figure out whether they are legacy PCI or PCI Express, so\n         * the logic below would never work; instead, we just go ahead and\n         * assume they're PCI Express. This is a very reasonable assumption,\n         * as all current mdev-capable devices are indeed PCI Express */\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV)\n            return pcieFlags;\n\n        /* according to pbonzini, from the guest PoV vhost-scsi devices\n         * are the same as virtio-scsi, so they should follow virtio logic\n         */\n        if (hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST) {\n            switch ((virDomainHostdevSubsysSCSIVHostModelType) hostdev->source.subsys.u.scsi_host.model) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_VHOST_MODEL_TYPE_LAST:\n                break;\n            }\n            return 0;\n        }\n\n        if (!(pciDev = virPCIDeviceNew(hostAddr->domain,\n                                       hostAddr->bus,\n                                       hostAddr->slot,\n                                       hostAddr->function))) {\n            /* libvirt should be able to perform all the\n             * operations in virPCIDeviceNew() even if it's\n             * running unprivileged, so if this fails, the device\n             * apparently doesn't currently exist on the host.\n             * Since the overwhelming majority of assignable host\n             * devices are PCIe, assume this one is too.\n             */\n            return pcieFlags;\n        }\n\n        if (!driver->privileged) {\n            /* unprivileged libvirtd is unable to read *all* of a\n             * device's PCI config (it can only read the first 64\n             * bytes, which isn't enough for the check that's done\n             * in virPCIDeviceIsPCIExpress()), so instead of\n             * trying and failing, we make an educated guess based\n             * on the length of the device's config file - if it\n             * is 256 bytes, then it is definitely a legacy PCI\n             * device. If it's larger than that, then it is\n             * *probably PCIe (although it could be PCI-x, but\n             * those are extremely rare). If the config file can't\n             * be found (in which case the \"length\" will be -1),\n             * then we blindly assume the most likely outcome -\n             * PCIe.\n             */\n            off_t configLen\n               = virFileLength(virPCIDeviceGetConfigPath(pciDev), -1);\n\n            virPCIDeviceFree(pciDev);\n\n            if (configLen == 256)\n                return pciFlags;\n\n            return pcieFlags;\n        }\n\n        /* If we are running with privileges, we can examine the\n         * PCI config contents with virPCIDeviceIsPCIExpress() for\n         * a definitive answer.\n         */\n        isExpress = virPCIDeviceIsPCIExpress(pciDev);\n        virPCIDeviceFree(pciDev);\n\n        if (isExpress)\n            return pcieFlags;\n\n        return pciFlags;\n    }\n\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        switch ((virDomainMemballoonModel) dev->data.memballoon->model) {\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_MEMBALLOON_MODEL_XEN:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_NONE:\n        case VIR_DOMAIN_MEMBALLOON_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_RNG:\n        switch ((virDomainRNGModel) dev->data.rng->model) {\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO:\n        case VIR_DOMAIN_RNG_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_RNG_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        /* only one model connects using PCI */\n        switch ((virDomainWatchdogModel) dev->data.watchdog->model) {\n        case VIR_DOMAIN_WATCHDOG_MODEL_I6300ESB:\n            return pciFlags;\n\n        case VIR_DOMAIN_WATCHDOG_MODEL_IB700:\n        case VIR_DOMAIN_WATCHDOG_MODEL_DIAG288:\n        case VIR_DOMAIN_WATCHDOG_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        switch ((virDomainVideoType)dev->data.video->type) {\n        case VIR_DOMAIN_VIDEO_TYPE_VIRTIO:\n            return virtioFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_VGA:\n        case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n        case VIR_DOMAIN_VIDEO_TYPE_VMVGA:\n        case VIR_DOMAIN_VIDEO_TYPE_XEN:\n        case VIR_DOMAIN_VIDEO_TYPE_VBOX:\n        case VIR_DOMAIN_VIDEO_TYPE_QXL:\n        case VIR_DOMAIN_VIDEO_TYPE_PARALLELS:\n            return pciFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_BOCHS:\n            return pcieFlags;\n\n        case VIR_DOMAIN_VIDEO_TYPE_DEFAULT:\n        case VIR_DOMAIN_VIDEO_TYPE_GOP:\n        case VIR_DOMAIN_VIDEO_TYPE_NONE:\n        case VIR_DOMAIN_VIDEO_TYPE_RAMFB:\n        case VIR_DOMAIN_VIDEO_TYPE_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        return pciFlags;\n\n    case VIR_DOMAIN_DEVICE_INPUT:\n        switch ((virDomainInputBus) dev->data.input->bus) {\n        case VIR_DOMAIN_INPUT_BUS_VIRTIO:\n            switch ((virDomainInputModel) dev->data.input->model) {\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO_TRANSITIONAL:\n                /* Transitional devices only work in conventional PCI slots */\n                return pciFlags;\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO:\n            case VIR_DOMAIN_INPUT_MODEL_VIRTIO_NON_TRANSITIONAL:\n            case VIR_DOMAIN_INPUT_MODEL_DEFAULT:\n                return virtioFlags;\n            case VIR_DOMAIN_INPUT_MODEL_LAST:\n                break;\n            }\n            return 0;\n\n        case VIR_DOMAIN_INPUT_BUS_PS2:\n        case VIR_DOMAIN_INPUT_BUS_USB:\n        case VIR_DOMAIN_INPUT_BUS_XEN:\n        case VIR_DOMAIN_INPUT_BUS_PARALLELS:\n        case VIR_DOMAIN_INPUT_BUS_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_CHR:\n        switch ((virDomainChrSerialTargetType)dev->data.chr->targetType) {\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_PCI:\n            return pciFlags;\n\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_ISA:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_USB:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SPAPR_VIO:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SYSTEM:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SCLP:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_NONE:\n        case VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_LAST:\n            return 0;\n        }\n        break;\n\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        switch ((virDomainVsockModel) dev->data.vsock->model) {\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO_TRANSITIONAL:\n            /* Transitional devices only work in conventional PCI slots */\n            return pciFlags;\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO:\n        case VIR_DOMAIN_VSOCK_MODEL_VIRTIO_NON_TRANSITIONAL:\n            return virtioFlags;\n\n        case VIR_DOMAIN_VSOCK_MODEL_DEFAULT:\n        case VIR_DOMAIN_VSOCK_MODEL_LAST:\n            return 0;\n        }\n        break;\n\n        /* These devices don't ever connect with PCI */\n    case VIR_DOMAIN_DEVICE_NVRAM:\n    case VIR_DOMAIN_DEVICE_TPM:\n    case VIR_DOMAIN_DEVICE_PANIC:\n    case VIR_DOMAIN_DEVICE_MEMORY:\n    case VIR_DOMAIN_DEVICE_HUB:\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        /* These devices don't even have a DeviceInfo */\n    case VIR_DOMAIN_DEVICE_LEASE:\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n    case VIR_DOMAIN_DEVICE_IOMMU:\n    case VIR_DOMAIN_DEVICE_LAST:\n    case VIR_DOMAIN_DEVICE_NONE:\n        return 0;\n    }\n\n    /* We can never get here, because all cases are covered in the\n     * switch, and they all return, but the compiler will still\n     * complain \"control reaches end of non-void function\" unless\n     * we add the following return.\n     */\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainDeviceCalculatePCIAddressExtensionFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "544-556",
    "snippet": "static virPCIDeviceAddressExtensionFlags\nqemuDomainDeviceCalculatePCIAddressExtensionFlags(virQEMUCapsPtr qemuCaps,\n                                                  virDomainDeviceDefPtr dev)\n{\n    virPCIDeviceAddressExtensionFlags extFlags = 0;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_ZPCI) &&\n        qemuDomainDeviceSupportZPCI(dev)) {\n        extFlags |= VIR_PCI_ADDRESS_EXTENSION_ZPCI;\n    }\n\n    return extFlags;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainDeviceSupportZPCI",
          "args": [
            "dev"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainDeviceSupportZPCI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "501-541",
          "snippet": "static bool\nqemuDomainDeviceSupportZPCI(virDomainDeviceDefPtr device)\n{\n    switch ((virDomainDeviceType)device->type) {\n    case VIR_DOMAIN_DEVICE_CHR:\n        return false;\n\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n    case VIR_DOMAIN_DEVICE_DISK:\n    case VIR_DOMAIN_DEVICE_LEASE:\n    case VIR_DOMAIN_DEVICE_FS:\n    case VIR_DOMAIN_DEVICE_NET:\n    case VIR_DOMAIN_DEVICE_INPUT:\n    case VIR_DOMAIN_DEVICE_SOUND:\n    case VIR_DOMAIN_DEVICE_VIDEO:\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n    case VIR_DOMAIN_DEVICE_HUB:\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n    case VIR_DOMAIN_DEVICE_NVRAM:\n    case VIR_DOMAIN_DEVICE_RNG:\n    case VIR_DOMAIN_DEVICE_SHMEM:\n    case VIR_DOMAIN_DEVICE_TPM:\n    case VIR_DOMAIN_DEVICE_PANIC:\n    case VIR_DOMAIN_DEVICE_MEMORY:\n    case VIR_DOMAIN_DEVICE_IOMMU:\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        break;\n\n    case VIR_DOMAIN_DEVICE_NONE:\n    case VIR_DOMAIN_DEVICE_LAST:\n    default:\n        virReportEnumRangeError(virDomainDeviceType, device->type);\n        return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic bool\nqemuDomainDeviceSupportZPCI(virDomainDeviceDefPtr device)\n{\n    switch ((virDomainDeviceType)device->type) {\n    case VIR_DOMAIN_DEVICE_CHR:\n        return false;\n\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n    case VIR_DOMAIN_DEVICE_DISK:\n    case VIR_DOMAIN_DEVICE_LEASE:\n    case VIR_DOMAIN_DEVICE_FS:\n    case VIR_DOMAIN_DEVICE_NET:\n    case VIR_DOMAIN_DEVICE_INPUT:\n    case VIR_DOMAIN_DEVICE_SOUND:\n    case VIR_DOMAIN_DEVICE_VIDEO:\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n    case VIR_DOMAIN_DEVICE_HUB:\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n    case VIR_DOMAIN_DEVICE_NVRAM:\n    case VIR_DOMAIN_DEVICE_RNG:\n    case VIR_DOMAIN_DEVICE_SHMEM:\n    case VIR_DOMAIN_DEVICE_TPM:\n    case VIR_DOMAIN_DEVICE_PANIC:\n    case VIR_DOMAIN_DEVICE_MEMORY:\n    case VIR_DOMAIN_DEVICE_IOMMU:\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        break;\n\n    case VIR_DOMAIN_DEVICE_NONE:\n    case VIR_DOMAIN_DEVICE_LAST:\n    default:\n        virReportEnumRangeError(virDomainDeviceType, device->type);\n        return false;\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_DEVICE_ZPCI"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic virPCIDeviceAddressExtensionFlags\nqemuDomainDeviceCalculatePCIAddressExtensionFlags(virQEMUCapsPtr qemuCaps,\n                                                  virDomainDeviceDefPtr dev)\n{\n    virPCIDeviceAddressExtensionFlags extFlags = 0;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_ZPCI) &&\n        qemuDomainDeviceSupportZPCI(dev)) {\n        extFlags |= VIR_PCI_ADDRESS_EXTENSION_ZPCI;\n    }\n\n    return extFlags;\n}"
  },
  {
    "function_name": "qemuDomainDeviceSupportZPCI",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "501-541",
    "snippet": "static bool\nqemuDomainDeviceSupportZPCI(virDomainDeviceDefPtr device)\n{\n    switch ((virDomainDeviceType)device->type) {\n    case VIR_DOMAIN_DEVICE_CHR:\n        return false;\n\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n    case VIR_DOMAIN_DEVICE_DISK:\n    case VIR_DOMAIN_DEVICE_LEASE:\n    case VIR_DOMAIN_DEVICE_FS:\n    case VIR_DOMAIN_DEVICE_NET:\n    case VIR_DOMAIN_DEVICE_INPUT:\n    case VIR_DOMAIN_DEVICE_SOUND:\n    case VIR_DOMAIN_DEVICE_VIDEO:\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n    case VIR_DOMAIN_DEVICE_HUB:\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n    case VIR_DOMAIN_DEVICE_NVRAM:\n    case VIR_DOMAIN_DEVICE_RNG:\n    case VIR_DOMAIN_DEVICE_SHMEM:\n    case VIR_DOMAIN_DEVICE_TPM:\n    case VIR_DOMAIN_DEVICE_PANIC:\n    case VIR_DOMAIN_DEVICE_MEMORY:\n    case VIR_DOMAIN_DEVICE_IOMMU:\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        break;\n\n    case VIR_DOMAIN_DEVICE_NONE:\n    case VIR_DOMAIN_DEVICE_LAST:\n    default:\n        virReportEnumRangeError(virDomainDeviceType, device->type);\n        return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virDomainDeviceType",
            "device->type"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic bool\nqemuDomainDeviceSupportZPCI(virDomainDeviceDefPtr device)\n{\n    switch ((virDomainDeviceType)device->type) {\n    case VIR_DOMAIN_DEVICE_CHR:\n        return false;\n\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n    case VIR_DOMAIN_DEVICE_DISK:\n    case VIR_DOMAIN_DEVICE_LEASE:\n    case VIR_DOMAIN_DEVICE_FS:\n    case VIR_DOMAIN_DEVICE_NET:\n    case VIR_DOMAIN_DEVICE_INPUT:\n    case VIR_DOMAIN_DEVICE_SOUND:\n    case VIR_DOMAIN_DEVICE_VIDEO:\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n    case VIR_DOMAIN_DEVICE_HUB:\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n    case VIR_DOMAIN_DEVICE_NVRAM:\n    case VIR_DOMAIN_DEVICE_RNG:\n    case VIR_DOMAIN_DEVICE_SHMEM:\n    case VIR_DOMAIN_DEVICE_TPM:\n    case VIR_DOMAIN_DEVICE_PANIC:\n    case VIR_DOMAIN_DEVICE_MEMORY:\n    case VIR_DOMAIN_DEVICE_IOMMU:\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        break;\n\n    case VIR_DOMAIN_DEVICE_NONE:\n    case VIR_DOMAIN_DEVICE_LAST:\n    default:\n        virReportEnumRangeError(virDomainDeviceType, device->type);\n        return false;\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "qemuDomainAssignVirtioMMIOAddresses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "467-498",
    "snippet": "static void\nqemuDomainAssignVirtioMMIOAddresses(virDomainDefPtr def,\n                                    virQEMUCapsPtr qemuCaps)\n{\n    if (def->os.arch != VIR_ARCH_ARMV6L &&\n        def->os.arch != VIR_ARCH_ARMV7L &&\n        def->os.arch != VIR_ARCH_AARCH64 &&\n        !ARCH_IS_RISCV(def->os.arch)) {\n        return;\n    }\n\n    if (!(STRPREFIX(def->os.machine, \"vexpress-\") ||\n          qemuDomainIsARMVirt(def) ||\n          qemuDomainIsRISCVVirt(def))) {\n        return;\n    }\n\n    /* We use virtio-mmio by default on virt guests only if they already\n     * have at least one virtio-mmio device: in all other cases, assuming\n     * the QEMU binary supports all necessary capabilities (PCIe Root plus\n     * some kind of PCIe Root Port), we prefer virtio-pci */\n    if (qemuDomainHasPCIeRoot(def) &&\n        (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_PCIE_ROOT_PORT) ||\n         virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_IOH3420)) &&\n        !qemuDomainHasVirtioMMIODevices(def)) {\n        qemuDomainPrimeVirtioDeviceAddresses(def,\n                                             VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI);\n    } else if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIRTIO_MMIO)) {\n        qemuDomainPrimeVirtioDeviceAddresses(def,\n                                             VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_MMIO);\n    }\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainPrimeVirtioDeviceAddresses",
          "args": [
            "def",
            "VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_MMIO"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainPrimeVirtioDeviceAddresses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "306-387",
          "snippet": "static void\nqemuDomainPrimeVirtioDeviceAddresses(virDomainDefPtr def,\n                                     virDomainDeviceAddressType type)\n{\n    /*\n       declare address-less virtio devices to be of address type 'type'\n       disks, networks, videos, consoles, controllers, memballoon and rng\n       in this order\n       if type is ccw filesystem and vsock devices are declared to be of\n       address type ccw\n    */\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (def->disks[i]->bus == VIR_DOMAIN_DISK_BUS_VIRTIO &&\n            def->disks[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->disks[i]->info.type = type;\n    }\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n\n        if (virDomainNetIsVirtioModel(net) &&\n            net->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            net->info.type = type;\n        }\n    }\n\n    for (i = 0; i < def->nvideos; i++) {\n        virDomainVideoDefPtr video = def->videos[i];\n\n        if (video->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE &&\n            video->type == VIR_DOMAIN_VIDEO_TYPE_VIRTIO)\n            video->info.type = type;\n    }\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (def->inputs[i]->bus == VIR_DOMAIN_INPUT_BUS_VIRTIO &&\n            def->inputs[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->inputs[i]->info.type = type;\n    }\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if ((cont->type == VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL ||\n             cont->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI) &&\n            cont->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            cont->info.type = type;\n        }\n    }\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type ==\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST &&\n            def->hostdevs[i]->info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->hostdevs[i]->info->type = type;\n    }\n\n    /* All memballoon devices accepted by the qemu driver are virtio */\n    if (virDomainDefHasMemballoon(def) &&\n        def->memballoon->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n        def->memballoon->info.type = type;\n\n    for (i = 0; i < def->nrngs; i++) {\n        /* All <rng> devices accepted by the qemu driver are virtio */\n        if (def->rngs[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->rngs[i]->info.type = type;\n    }\n\n    if (type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW) {\n        for (i = 0; i < def->nfss; i++) {\n            if (def->fss[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n                def->fss[i]->info.type = type;\n        }\n        if (def->vsock &&\n            def->vsock->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            def->vsock->info.type = type;\n        }\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic void\nqemuDomainPrimeVirtioDeviceAddresses(virDomainDefPtr def,\n                                     virDomainDeviceAddressType type)\n{\n    /*\n       declare address-less virtio devices to be of address type 'type'\n       disks, networks, videos, consoles, controllers, memballoon and rng\n       in this order\n       if type is ccw filesystem and vsock devices are declared to be of\n       address type ccw\n    */\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (def->disks[i]->bus == VIR_DOMAIN_DISK_BUS_VIRTIO &&\n            def->disks[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->disks[i]->info.type = type;\n    }\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n\n        if (virDomainNetIsVirtioModel(net) &&\n            net->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            net->info.type = type;\n        }\n    }\n\n    for (i = 0; i < def->nvideos; i++) {\n        virDomainVideoDefPtr video = def->videos[i];\n\n        if (video->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE &&\n            video->type == VIR_DOMAIN_VIDEO_TYPE_VIRTIO)\n            video->info.type = type;\n    }\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (def->inputs[i]->bus == VIR_DOMAIN_INPUT_BUS_VIRTIO &&\n            def->inputs[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->inputs[i]->info.type = type;\n    }\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if ((cont->type == VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL ||\n             cont->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI) &&\n            cont->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            cont->info.type = type;\n        }\n    }\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type ==\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST &&\n            def->hostdevs[i]->info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->hostdevs[i]->info->type = type;\n    }\n\n    /* All memballoon devices accepted by the qemu driver are virtio */\n    if (virDomainDefHasMemballoon(def) &&\n        def->memballoon->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n        def->memballoon->info.type = type;\n\n    for (i = 0; i < def->nrngs; i++) {\n        /* All <rng> devices accepted by the qemu driver are virtio */\n        if (def->rngs[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->rngs[i]->info.type = type;\n    }\n\n    if (type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW) {\n        for (i = 0; i < def->nfss; i++) {\n            if (def->fss[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n                def->fss[i]->info.type = type;\n        }\n        if (def->vsock &&\n            def->vsock->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            def->vsock->info.type = type;\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_DEVICE_VIRTIO_MMIO"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainHasVirtioMMIODevices",
          "args": [
            "def"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainHasVirtioMMIODevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "454-464",
          "snippet": "static bool\nqemuDomainHasVirtioMMIODevices(virDomainDefPtr def)\n{\n    bool result = false;\n\n    virDomainDeviceInfoIterate(def,\n                               qemuDomainHasVirtioMMIODevicesCallback,\n                               &result);\n\n    return result;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic bool\nqemuDomainHasVirtioMMIODevices(virDomainDefPtr def)\n{\n    bool result = false;\n\n    virDomainDeviceInfoIterate(def,\n                               qemuDomainHasVirtioMMIODevicesCallback,\n                               &result);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainHasPCIeRoot",
          "args": [
            "def"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainHasPCIeRoot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12934-12946",
          "snippet": "bool\nqemuDomainHasPCIeRoot(const virDomainDef *def)\n{\n    int root = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_PCI, 0);\n\n    if (root < 0)\n        return false;\n\n    if (def->controllers[root]->model != VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT)\n        return false;\n\n    return true;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainHasPCIeRoot(const virDomainDef *def)\n{\n    int root = virDomainControllerFind(def, VIR_DOMAIN_CONTROLLER_TYPE_PCI, 0);\n\n    if (root < 0)\n        return false;\n\n    if (def->controllers[root]->model != VIR_DOMAIN_CONTROLLER_MODEL_PCIE_ROOT)\n        return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainIsRISCVVirt",
          "args": [
            "def"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainIsRISCVVirt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12905-12909",
          "snippet": "bool\nqemuDomainIsRISCVVirt(const virDomainDef *def)\n{\n    return qemuDomainMachineIsRISCVVirt(def->os.machine, def->os.arch);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainIsRISCVVirt(const virDomainDef *def)\n{\n    return qemuDomainMachineIsRISCVVirt(def->os.machine, def->os.arch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainIsARMVirt",
          "args": [
            "def"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainIsARMVirt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12898-12902",
          "snippet": "bool\nqemuDomainIsARMVirt(const virDomainDef *def)\n{\n    return qemuDomainMachineIsARMVirt(def->os.machine, def->os.arch);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainIsARMVirt(const virDomainDef *def)\n{\n    return qemuDomainMachineIsARMVirt(def->os.machine, def->os.arch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "def->os.machine",
            "\"vexpress-\""
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_RISCV",
          "args": [
            "def->os.arch"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic void\nqemuDomainAssignVirtioMMIOAddresses(virDomainDefPtr def,\n                                    virQEMUCapsPtr qemuCaps)\n{\n    if (def->os.arch != VIR_ARCH_ARMV6L &&\n        def->os.arch != VIR_ARCH_ARMV7L &&\n        def->os.arch != VIR_ARCH_AARCH64 &&\n        !ARCH_IS_RISCV(def->os.arch)) {\n        return;\n    }\n\n    if (!(STRPREFIX(def->os.machine, \"vexpress-\") ||\n          qemuDomainIsARMVirt(def) ||\n          qemuDomainIsRISCVVirt(def))) {\n        return;\n    }\n\n    /* We use virtio-mmio by default on virt guests only if they already\n     * have at least one virtio-mmio device: in all other cases, assuming\n     * the QEMU binary supports all necessary capabilities (PCIe Root plus\n     * some kind of PCIe Root Port), we prefer virtio-pci */\n    if (qemuDomainHasPCIeRoot(def) &&\n        (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_PCIE_ROOT_PORT) ||\n         virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_IOH3420)) &&\n        !qemuDomainHasVirtioMMIODevices(def)) {\n        qemuDomainPrimeVirtioDeviceAddresses(def,\n                                             VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI);\n    } else if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIRTIO_MMIO)) {\n        qemuDomainPrimeVirtioDeviceAddresses(def,\n                                             VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_MMIO);\n    }\n}"
  },
  {
    "function_name": "qemuDomainHasVirtioMMIODevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "454-464",
    "snippet": "static bool\nqemuDomainHasVirtioMMIODevices(virDomainDefPtr def)\n{\n    bool result = false;\n\n    virDomainDeviceInfoIterate(def,\n                               qemuDomainHasVirtioMMIODevicesCallback,\n                               &result);\n\n    return result;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDeviceInfoIterate",
          "args": [
            "def",
            "qemuDomainHasVirtioMMIODevicesCallback",
            "&result"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceInfoIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "4352-4358",
          "snippet": "int\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic bool\nqemuDomainHasVirtioMMIODevices(virDomainDefPtr def)\n{\n    bool result = false;\n\n    virDomainDeviceInfoIterate(def,\n                               qemuDomainHasVirtioMMIODevicesCallback,\n                               &result);\n\n    return result;\n}"
  },
  {
    "function_name": "qemuDomainHasVirtioMMIODevicesCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "429-443",
    "snippet": "static int\nqemuDomainHasVirtioMMIODevicesCallback(virDomainDefPtr def G_GNUC_UNUSED,\n                                       virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                                       virDomainDeviceInfoPtr info,\n                                       void *opaque)\n{\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_MMIO) {\n        /* We can stop iterating as soon as we find the first\n         * virtio-mmio device */\n        *((bool *)opaque) = true;\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainHasVirtioMMIODevicesCallback(virDomainDefPtr def G_GNUC_UNUSED,\n                                       virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                                       virDomainDeviceInfoPtr info,\n                                       void *opaque)\n{\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_MMIO) {\n        /* We can stop iterating as soon as we find the first\n         * virtio-mmio device */\n        *((bool *)opaque) = true;\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainAssignS390Addresses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "396-426",
    "snippet": "static int\nqemuDomainAssignS390Addresses(virDomainDefPtr def,\n                              virQEMUCapsPtr qemuCaps)\n{\n    int ret = -1;\n    virDomainCCWAddressSetPtr addrs = NULL;\n\n    if (qemuDomainIsS390CCW(def) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_CCW)) {\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VFIO_CCW))\n            qemuDomainPrimeVfioDeviceAddresses(\n                def, VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW);\n        qemuDomainPrimeVirtioDeviceAddresses(\n            def, VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW);\n\n        if (!(addrs = virDomainCCWAddressSetCreateFromDomain(def)))\n            goto cleanup;\n\n    } else if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_S390)) {\n        /* deal with legacy virtio-s390 */\n        qemuDomainPrimeVirtioDeviceAddresses(\n            def, VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_S390);\n    }\n\n    ret = 0;\n\n cleanup:\n    virDomainCCWAddressSetFree(addrs);\n\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainCCWAddressSetFree",
          "args": [
            "addrs"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCCWAddressSetFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1463-1470",
          "snippet": "void virDomainCCWAddressSetFree(virDomainCCWAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virHashFree(addrs->defined);\n    VIR_FREE(addrs);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid virDomainCCWAddressSetFree(virDomainCCWAddressSetPtr addrs)\n{\n    if (!addrs)\n        return;\n\n    virHashFree(addrs->defined);\n    VIR_FREE(addrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainPrimeVirtioDeviceAddresses",
          "args": [
            "def",
            "VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_S390"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainPrimeVirtioDeviceAddresses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "306-387",
          "snippet": "static void\nqemuDomainPrimeVirtioDeviceAddresses(virDomainDefPtr def,\n                                     virDomainDeviceAddressType type)\n{\n    /*\n       declare address-less virtio devices to be of address type 'type'\n       disks, networks, videos, consoles, controllers, memballoon and rng\n       in this order\n       if type is ccw filesystem and vsock devices are declared to be of\n       address type ccw\n    */\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (def->disks[i]->bus == VIR_DOMAIN_DISK_BUS_VIRTIO &&\n            def->disks[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->disks[i]->info.type = type;\n    }\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n\n        if (virDomainNetIsVirtioModel(net) &&\n            net->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            net->info.type = type;\n        }\n    }\n\n    for (i = 0; i < def->nvideos; i++) {\n        virDomainVideoDefPtr video = def->videos[i];\n\n        if (video->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE &&\n            video->type == VIR_DOMAIN_VIDEO_TYPE_VIRTIO)\n            video->info.type = type;\n    }\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (def->inputs[i]->bus == VIR_DOMAIN_INPUT_BUS_VIRTIO &&\n            def->inputs[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->inputs[i]->info.type = type;\n    }\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if ((cont->type == VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL ||\n             cont->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI) &&\n            cont->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            cont->info.type = type;\n        }\n    }\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type ==\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST &&\n            def->hostdevs[i]->info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->hostdevs[i]->info->type = type;\n    }\n\n    /* All memballoon devices accepted by the qemu driver are virtio */\n    if (virDomainDefHasMemballoon(def) &&\n        def->memballoon->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n        def->memballoon->info.type = type;\n\n    for (i = 0; i < def->nrngs; i++) {\n        /* All <rng> devices accepted by the qemu driver are virtio */\n        if (def->rngs[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->rngs[i]->info.type = type;\n    }\n\n    if (type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW) {\n        for (i = 0; i < def->nfss; i++) {\n            if (def->fss[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n                def->fss[i]->info.type = type;\n        }\n        if (def->vsock &&\n            def->vsock->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            def->vsock->info.type = type;\n        }\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic void\nqemuDomainPrimeVirtioDeviceAddresses(virDomainDefPtr def,\n                                     virDomainDeviceAddressType type)\n{\n    /*\n       declare address-less virtio devices to be of address type 'type'\n       disks, networks, videos, consoles, controllers, memballoon and rng\n       in this order\n       if type is ccw filesystem and vsock devices are declared to be of\n       address type ccw\n    */\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (def->disks[i]->bus == VIR_DOMAIN_DISK_BUS_VIRTIO &&\n            def->disks[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->disks[i]->info.type = type;\n    }\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n\n        if (virDomainNetIsVirtioModel(net) &&\n            net->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            net->info.type = type;\n        }\n    }\n\n    for (i = 0; i < def->nvideos; i++) {\n        virDomainVideoDefPtr video = def->videos[i];\n\n        if (video->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE &&\n            video->type == VIR_DOMAIN_VIDEO_TYPE_VIRTIO)\n            video->info.type = type;\n    }\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (def->inputs[i]->bus == VIR_DOMAIN_INPUT_BUS_VIRTIO &&\n            def->inputs[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->inputs[i]->info.type = type;\n    }\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if ((cont->type == VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL ||\n             cont->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI) &&\n            cont->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            cont->info.type = type;\n        }\n    }\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type ==\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST &&\n            def->hostdevs[i]->info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->hostdevs[i]->info->type = type;\n    }\n\n    /* All memballoon devices accepted by the qemu driver are virtio */\n    if (virDomainDefHasMemballoon(def) &&\n        def->memballoon->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n        def->memballoon->info.type = type;\n\n    for (i = 0; i < def->nrngs; i++) {\n        /* All <rng> devices accepted by the qemu driver are virtio */\n        if (def->rngs[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->rngs[i]->info.type = type;\n    }\n\n    if (type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW) {\n        for (i = 0; i < def->nfss; i++) {\n            if (def->fss[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n                def->fss[i]->info.type = type;\n        }\n        if (def->vsock &&\n            def->vsock->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            def->vsock->info.type = type;\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_VIRTIO_S390"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainCCWAddressSetCreateFromDomain",
          "args": [
            "def"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCCWAddressSetCreateFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1496-1517",
          "snippet": "virDomainCCWAddressSetPtr\nvirDomainCCWAddressSetCreateFromDomain(virDomainDefPtr def)\n{\n    virDomainCCWAddressSetPtr addrs = NULL;\n\n    if (!(addrs = virDomainCCWAddressSetCreate()))\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def, virDomainCCWAddressValidate,\n                                   addrs) < 0)\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def, virDomainCCWAddressAllocate,\n                                   addrs) < 0)\n        goto error;\n\n    return addrs;\n\n error:\n    virDomainCCWAddressSetFree(addrs);\n    return NULL;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvirDomainCCWAddressSetPtr\nvirDomainCCWAddressSetCreateFromDomain(virDomainDefPtr def)\n{\n    virDomainCCWAddressSetPtr addrs = NULL;\n\n    if (!(addrs = virDomainCCWAddressSetCreate()))\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def, virDomainCCWAddressValidate,\n                                   addrs) < 0)\n        goto error;\n\n    if (virDomainDeviceInfoIterate(def, virDomainCCWAddressAllocate,\n                                   addrs) < 0)\n        goto error;\n\n    return addrs;\n\n error:\n    virDomainCCWAddressSetFree(addrs);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainPrimeVfioDeviceAddresses",
          "args": [
            "def",
            "VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainPrimeVfioDeviceAddresses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "285-303",
          "snippet": "static void\nqemuDomainPrimeVfioDeviceAddresses(virDomainDefPtr def,\n                                   virDomainDeviceAddressType type)\n{\n    size_t i;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevSubsysPtr subsys = &def->hostdevs[i]->source.subsys;\n\n        if (virHostdevIsMdevDevice(def->hostdevs[i]) &&\n            subsys->u.mdev.model == VIR_MDEV_MODEL_TYPE_VFIO_CCW &&\n            def->hostdevs[i]->info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->hostdevs[i]->info->type = type;\n\n        if (virHostdevIsMdevDevice(def->hostdevs[i]) &&\n            subsys->u.mdev.model == VIR_MDEV_MODEL_TYPE_VFIO_AP)\n            def->hostdevs[i]->info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic void\nqemuDomainPrimeVfioDeviceAddresses(virDomainDefPtr def,\n                                   virDomainDeviceAddressType type)\n{\n    size_t i;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevSubsysPtr subsys = &def->hostdevs[i]->source.subsys;\n\n        if (virHostdevIsMdevDevice(def->hostdevs[i]) &&\n            subsys->u.mdev.model == VIR_MDEV_MODEL_TYPE_VFIO_CCW &&\n            def->hostdevs[i]->info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->hostdevs[i]->info->type = type;\n\n        if (virHostdevIsMdevDevice(def->hostdevs[i]) &&\n            subsys->u.mdev.model == VIR_MDEV_MODEL_TYPE_VFIO_AP)\n            def->hostdevs[i]->info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainIsS390CCW",
          "args": [
            "def"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainIsS390CCW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12891-12895",
          "snippet": "bool\nqemuDomainIsS390CCW(const virDomainDef *def)\n{\n    return qemuDomainMachineIsS390CCW(def->os.machine, def->os.arch);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainIsS390CCW(const virDomainDef *def)\n{\n    return qemuDomainMachineIsS390CCW(def->os.machine, def->os.arch);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignS390Addresses(virDomainDefPtr def,\n                              virQEMUCapsPtr qemuCaps)\n{\n    int ret = -1;\n    virDomainCCWAddressSetPtr addrs = NULL;\n\n    if (qemuDomainIsS390CCW(def) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_CCW)) {\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VFIO_CCW))\n            qemuDomainPrimeVfioDeviceAddresses(\n                def, VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW);\n        qemuDomainPrimeVirtioDeviceAddresses(\n            def, VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW);\n\n        if (!(addrs = virDomainCCWAddressSetCreateFromDomain(def)))\n            goto cleanup;\n\n    } else if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_S390)) {\n        /* deal with legacy virtio-s390 */\n        qemuDomainPrimeVirtioDeviceAddresses(\n            def, VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_S390);\n    }\n\n    ret = 0;\n\n cleanup:\n    virDomainCCWAddressSetFree(addrs);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuDomainPrimeVirtioDeviceAddresses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "306-387",
    "snippet": "static void\nqemuDomainPrimeVirtioDeviceAddresses(virDomainDefPtr def,\n                                     virDomainDeviceAddressType type)\n{\n    /*\n       declare address-less virtio devices to be of address type 'type'\n       disks, networks, videos, consoles, controllers, memballoon and rng\n       in this order\n       if type is ccw filesystem and vsock devices are declared to be of\n       address type ccw\n    */\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (def->disks[i]->bus == VIR_DOMAIN_DISK_BUS_VIRTIO &&\n            def->disks[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->disks[i]->info.type = type;\n    }\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n\n        if (virDomainNetIsVirtioModel(net) &&\n            net->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            net->info.type = type;\n        }\n    }\n\n    for (i = 0; i < def->nvideos; i++) {\n        virDomainVideoDefPtr video = def->videos[i];\n\n        if (video->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE &&\n            video->type == VIR_DOMAIN_VIDEO_TYPE_VIRTIO)\n            video->info.type = type;\n    }\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (def->inputs[i]->bus == VIR_DOMAIN_INPUT_BUS_VIRTIO &&\n            def->inputs[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->inputs[i]->info.type = type;\n    }\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if ((cont->type == VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL ||\n             cont->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI) &&\n            cont->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            cont->info.type = type;\n        }\n    }\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type ==\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST &&\n            def->hostdevs[i]->info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->hostdevs[i]->info->type = type;\n    }\n\n    /* All memballoon devices accepted by the qemu driver are virtio */\n    if (virDomainDefHasMemballoon(def) &&\n        def->memballoon->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n        def->memballoon->info.type = type;\n\n    for (i = 0; i < def->nrngs; i++) {\n        /* All <rng> devices accepted by the qemu driver are virtio */\n        if (def->rngs[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->rngs[i]->info.type = type;\n    }\n\n    if (type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW) {\n        for (i = 0; i < def->nfss; i++) {\n            if (def->fss[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n                def->fss[i]->info.type = type;\n        }\n        if (def->vsock &&\n            def->vsock->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            def->vsock->info.type = type;\n        }\n    }\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefHasMemballoon",
          "args": [
            "def"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefHasMemballoon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30883-30888",
          "snippet": "bool\nvirDomainDefHasMemballoon(const virDomainDef *def)\n{\n    return def->memballoon &&\n           def->memballoon->model != VIR_DOMAIN_MEMBALLOON_MODEL_NONE;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainDefHasMemballoon(const virDomainDef *def)\n{\n    return def->memballoon &&\n           def->memballoon->model != VIR_DOMAIN_MEMBALLOON_MODEL_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetIsVirtioModel",
          "args": [
            "net"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetIsVirtioModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30344-30350",
          "snippet": "bool\nvirDomainNetIsVirtioModel(const virDomainNetDef *net)\n{\n    return (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO ||\n            net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_TRANSITIONAL ||\n            net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_NON_TRANSITIONAL);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainNetIsVirtioModel(const virDomainNetDef *net)\n{\n    return (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO ||\n            net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_TRANSITIONAL ||\n            net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_NON_TRANSITIONAL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic void\nqemuDomainPrimeVirtioDeviceAddresses(virDomainDefPtr def,\n                                     virDomainDeviceAddressType type)\n{\n    /*\n       declare address-less virtio devices to be of address type 'type'\n       disks, networks, videos, consoles, controllers, memballoon and rng\n       in this order\n       if type is ccw filesystem and vsock devices are declared to be of\n       address type ccw\n    */\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (def->disks[i]->bus == VIR_DOMAIN_DISK_BUS_VIRTIO &&\n            def->disks[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->disks[i]->info.type = type;\n    }\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n\n        if (virDomainNetIsVirtioModel(net) &&\n            net->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            net->info.type = type;\n        }\n    }\n\n    for (i = 0; i < def->nvideos; i++) {\n        virDomainVideoDefPtr video = def->videos[i];\n\n        if (video->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE &&\n            video->type == VIR_DOMAIN_VIDEO_TYPE_VIRTIO)\n            video->info.type = type;\n    }\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (def->inputs[i]->bus == VIR_DOMAIN_INPUT_BUS_VIRTIO &&\n            def->inputs[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->inputs[i]->info.type = type;\n    }\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if ((cont->type == VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL ||\n             cont->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI) &&\n            cont->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            cont->info.type = type;\n        }\n    }\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type ==\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST &&\n            def->hostdevs[i]->info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->hostdevs[i]->info->type = type;\n    }\n\n    /* All memballoon devices accepted by the qemu driver are virtio */\n    if (virDomainDefHasMemballoon(def) &&\n        def->memballoon->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n        def->memballoon->info.type = type;\n\n    for (i = 0; i < def->nrngs; i++) {\n        /* All <rng> devices accepted by the qemu driver are virtio */\n        if (def->rngs[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->rngs[i]->info.type = type;\n    }\n\n    if (type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW) {\n        for (i = 0; i < def->nfss; i++) {\n            if (def->fss[i]->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n                def->fss[i]->info.type = type;\n        }\n        if (def->vsock &&\n            def->vsock->info.type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE) {\n            def->vsock->info.type = type;\n        }\n    }\n}"
  },
  {
    "function_name": "qemuDomainPrimeVfioDeviceAddresses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "285-303",
    "snippet": "static void\nqemuDomainPrimeVfioDeviceAddresses(virDomainDefPtr def,\n                                   virDomainDeviceAddressType type)\n{\n    size_t i;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevSubsysPtr subsys = &def->hostdevs[i]->source.subsys;\n\n        if (virHostdevIsMdevDevice(def->hostdevs[i]) &&\n            subsys->u.mdev.model == VIR_MDEV_MODEL_TYPE_VFIO_CCW &&\n            def->hostdevs[i]->info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->hostdevs[i]->info->type = type;\n\n        if (virHostdevIsMdevDevice(def->hostdevs[i]) &&\n            subsys->u.mdev.model == VIR_MDEV_MODEL_TYPE_VFIO_AP)\n            def->hostdevs[i]->info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE;\n    }\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevIsMdevDevice",
          "args": [
            "def->hostdevs[i]"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsMdevDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32296-32301",
          "snippet": "bool\nvirHostdevIsMdevDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirHostdevIsMdevDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic void\nqemuDomainPrimeVfioDeviceAddresses(virDomainDefPtr def,\n                                   virDomainDeviceAddressType type)\n{\n    size_t i;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevSubsysPtr subsys = &def->hostdevs[i]->source.subsys;\n\n        if (virHostdevIsMdevDevice(def->hostdevs[i]) &&\n            subsys->u.mdev.model == VIR_MDEV_MODEL_TYPE_VFIO_CCW &&\n            def->hostdevs[i]->info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE)\n            def->hostdevs[i]->info->type = type;\n\n        if (virHostdevIsMdevDevice(def->hostdevs[i]) &&\n            subsys->u.mdev.model == VIR_MDEV_MODEL_TYPE_VFIO_AP)\n            def->hostdevs[i]->info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_NONE;\n    }\n}"
  },
  {
    "function_name": "qemuDomainAssignSpaprVIOAddresses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "223-282",
    "snippet": "static int\nqemuDomainAssignSpaprVIOAddresses(virDomainDefPtr def)\n{\n    size_t i;\n\n    /* Default values match QEMU. See spapr_(llan|vscsi|vty).c */\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_SPAPR_VLAN)\n            net->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n\n        if (qemuDomainAssignSpaprVIOAddress(def, &net->info, VIO_ADDR_NET) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI &&\n            cont->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI) {\n            cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n        }\n        if (qemuDomainAssignSpaprVIOAddress(def, &cont->info,\n                                            VIO_ADDR_SCSI) < 0) {\n            return -1;\n        }\n    }\n\n    for (i = 0; i < def->nserials; i++) {\n        if (def->serials[i]->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL &&\n            def->serials[i]->targetType == VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SPAPR_VIO) {\n            def->serials[i]->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n        }\n        if (qemuDomainAssignSpaprVIOAddress(def, &def->serials[i]->info,\n                                            VIO_ADDR_SERIAL) < 0)\n            return -1;\n    }\n\n    if (def->nvram) {\n        if (qemuDomainIsPSeries(def))\n            def->nvram->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n        if (qemuDomainAssignSpaprVIOAddress(def, &def->nvram->info,\n                                            VIO_ADDR_NVRAM) < 0)\n            return -1;\n    }\n\n    if (def->tpm) {\n        if (qemuDomainIsPSeries(def))\n            def->tpm->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n        if (qemuDomainAssignSpaprVIOAddress(def, &def->tpm->info,\n                                            VIO_ADDR_TPM) < 0)\n            return -1;\n    }\n\n    /* No other devices are currently supported on spapr-vio */\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VIO_ADDR_TPM 0x4000ul",
      "#define VIO_ADDR_NVRAM 0x3000ul",
      "#define VIO_ADDR_SERIAL 0x30000000ul",
      "#define VIO_ADDR_SCSI 0x2000ul",
      "#define VIO_ADDR_NET 0x1000ul"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainAssignSpaprVIOAddress",
          "args": [
            "def",
            "&def->tpm->info",
            "VIO_ADDR_TPM"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainAssignSpaprVIOAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "186-220",
          "snippet": "static int\nqemuDomainAssignSpaprVIOAddress(virDomainDefPtr def,\n                                virDomainDeviceInfoPtr info,\n                                unsigned long long default_reg)\n{\n    bool user_reg;\n    int ret;\n\n    if (info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO)\n        return 0;\n\n    /* Check if the user has assigned the reg already, if so use it */\n    user_reg = info->addr.spaprvio.has_reg;\n    if (!user_reg) {\n        info->addr.spaprvio.reg = default_reg;\n        info->addr.spaprvio.has_reg = true;\n    }\n\n    ret = virDomainDeviceInfoIterate(def, qemuDomainSpaprVIOFindByReg, info);\n    while (ret != 0) {\n        if (user_reg) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"spapr-vio address %#llx already in use\"),\n                           info->addr.spaprvio.reg);\n            return -EEXIST;\n        }\n\n        /* We assigned the reg, so try a new value */\n        info->addr.spaprvio.reg += 0x1000;\n        ret = virDomainDeviceInfoIterate(def, qemuDomainSpaprVIOFindByReg,\n                                         info);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignSpaprVIOAddress(virDomainDefPtr def,\n                                virDomainDeviceInfoPtr info,\n                                unsigned long long default_reg)\n{\n    bool user_reg;\n    int ret;\n\n    if (info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO)\n        return 0;\n\n    /* Check if the user has assigned the reg already, if so use it */\n    user_reg = info->addr.spaprvio.has_reg;\n    if (!user_reg) {\n        info->addr.spaprvio.reg = default_reg;\n        info->addr.spaprvio.has_reg = true;\n    }\n\n    ret = virDomainDeviceInfoIterate(def, qemuDomainSpaprVIOFindByReg, info);\n    while (ret != 0) {\n        if (user_reg) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"spapr-vio address %#llx already in use\"),\n                           info->addr.spaprvio.reg);\n            return -EEXIST;\n        }\n\n        /* We assigned the reg, so try a new value */\n        info->addr.spaprvio.reg += 0x1000;\n        ret = virDomainDeviceInfoIterate(def, qemuDomainSpaprVIOFindByReg,\n                                         info);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainIsPSeries",
          "args": [
            "def"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainIsPSeries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12912-12916",
          "snippet": "bool\nqemuDomainIsPSeries(const virDomainDef *def)\n{\n    return qemuDomainMachineIsPSeries(def->os.machine, def->os.arch);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainIsPSeries(const virDomainDef *def)\n{\n    return qemuDomainMachineIsPSeries(def->os.machine, def->os.arch);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\n#define VIO_ADDR_TPM 0x4000ul\n#define VIO_ADDR_NVRAM 0x3000ul\n#define VIO_ADDR_SERIAL 0x30000000ul\n#define VIO_ADDR_SCSI 0x2000ul\n#define VIO_ADDR_NET 0x1000ul\n\nstatic int\nqemuDomainAssignSpaprVIOAddresses(virDomainDefPtr def)\n{\n    size_t i;\n\n    /* Default values match QEMU. See spapr_(llan|vscsi|vty).c */\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n\n        if (net->model == VIR_DOMAIN_NET_MODEL_SPAPR_VLAN)\n            net->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n\n        if (qemuDomainAssignSpaprVIOAddress(def, &net->info, VIO_ADDR_NET) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = def->controllers[i];\n\n        if (cont->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI &&\n            cont->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI) {\n            cont->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n        }\n        if (qemuDomainAssignSpaprVIOAddress(def, &cont->info,\n                                            VIO_ADDR_SCSI) < 0) {\n            return -1;\n        }\n    }\n\n    for (i = 0; i < def->nserials; i++) {\n        if (def->serials[i]->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL &&\n            def->serials[i]->targetType == VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_SPAPR_VIO) {\n            def->serials[i]->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n        }\n        if (qemuDomainAssignSpaprVIOAddress(def, &def->serials[i]->info,\n                                            VIO_ADDR_SERIAL) < 0)\n            return -1;\n    }\n\n    if (def->nvram) {\n        if (qemuDomainIsPSeries(def))\n            def->nvram->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n        if (qemuDomainAssignSpaprVIOAddress(def, &def->nvram->info,\n                                            VIO_ADDR_NVRAM) < 0)\n            return -1;\n    }\n\n    if (def->tpm) {\n        if (qemuDomainIsPSeries(def))\n            def->tpm->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO;\n        if (qemuDomainAssignSpaprVIOAddress(def, &def->tpm->info,\n                                            VIO_ADDR_TPM) < 0)\n            return -1;\n    }\n\n    /* No other devices are currently supported on spapr-vio */\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainAssignSpaprVIOAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "186-220",
    "snippet": "static int\nqemuDomainAssignSpaprVIOAddress(virDomainDefPtr def,\n                                virDomainDeviceInfoPtr info,\n                                unsigned long long default_reg)\n{\n    bool user_reg;\n    int ret;\n\n    if (info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO)\n        return 0;\n\n    /* Check if the user has assigned the reg already, if so use it */\n    user_reg = info->addr.spaprvio.has_reg;\n    if (!user_reg) {\n        info->addr.spaprvio.reg = default_reg;\n        info->addr.spaprvio.has_reg = true;\n    }\n\n    ret = virDomainDeviceInfoIterate(def, qemuDomainSpaprVIOFindByReg, info);\n    while (ret != 0) {\n        if (user_reg) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"spapr-vio address %#llx already in use\"),\n                           info->addr.spaprvio.reg);\n            return -EEXIST;\n        }\n\n        /* We assigned the reg, so try a new value */\n        info->addr.spaprvio.reg += 0x1000;\n        ret = virDomainDeviceInfoIterate(def, qemuDomainSpaprVIOFindByReg,\n                                         info);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDeviceInfoIterate",
          "args": [
            "def",
            "qemuDomainSpaprVIOFindByReg",
            "info"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceInfoIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "4352-4358",
          "snippet": "int\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDeviceInfoIterate(virDomainDefPtr def,\n                           virDomainDeviceInfoCallback cb,\n                           void *opaque)\n{\n    return virDomainDeviceInfoIterateInternal(def, cb, 0, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"spapr-vio address %#llx already in use\")",
            "info->addr.spaprvio.reg"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"spapr-vio address %#llx already in use\""
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignSpaprVIOAddress(virDomainDefPtr def,\n                                virDomainDeviceInfoPtr info,\n                                unsigned long long default_reg)\n{\n    bool user_reg;\n    int ret;\n\n    if (info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO)\n        return 0;\n\n    /* Check if the user has assigned the reg already, if so use it */\n    user_reg = info->addr.spaprvio.has_reg;\n    if (!user_reg) {\n        info->addr.spaprvio.reg = default_reg;\n        info->addr.spaprvio.has_reg = true;\n    }\n\n    ret = virDomainDeviceInfoIterate(def, qemuDomainSpaprVIOFindByReg, info);\n    while (ret != 0) {\n        if (user_reg) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"spapr-vio address %#llx already in use\"),\n                           info->addr.spaprvio.reg);\n            return -EEXIST;\n        }\n\n        /* We assigned the reg, so try a new value */\n        info->addr.spaprvio.reg += 0x1000;\n        ret = virDomainDeviceInfoIterate(def, qemuDomainSpaprVIOFindByReg,\n                                         info);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainSpaprVIOFindByReg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "166-183",
    "snippet": "static int\nqemuDomainSpaprVIOFindByReg(virDomainDefPtr def G_GNUC_UNUSED,\n                            virDomainDeviceDefPtr device G_GNUC_UNUSED,\n                            virDomainDeviceInfoPtr info, void *opaque)\n{\n    virDomainDeviceInfoPtr target = opaque;\n\n    if (info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO)\n        return 0;\n\n    /* Match a dev that has a reg, is not us, and has a matching reg */\n    if (info->addr.spaprvio.has_reg && info != target &&\n        info->addr.spaprvio.reg == target->addr.spaprvio.reg)\n        /* Has to be < 0 so virDomainDeviceInfoIterate() will exit */\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainSpaprVIOFindByReg(virDomainDefPtr def G_GNUC_UNUSED,\n                            virDomainDeviceDefPtr device G_GNUC_UNUSED,\n                            virDomainDeviceInfoPtr info, void *opaque)\n{\n    virDomainDeviceInfoPtr target = opaque;\n\n    if (info->type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_SPAPRVIO)\n        return 0;\n\n    /* Match a dev that has a reg, is not us, and has a matching reg */\n    if (info->addr.spaprvio.has_reg && info != target &&\n        info->addr.spaprvio.reg == target->addr.spaprvio.reg)\n        /* Has to be < 0 so virDomainDeviceInfoIterate() will exit */\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainAssignVirtioSerialAddresses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "126-163",
    "snippet": "static int\nqemuDomainAssignVirtioSerialAddresses(virDomainDefPtr def)\n{\n    int ret = -1;\n    size_t i;\n    virDomainVirtioSerialAddrSetPtr addrs = NULL;\n\n    if (!(addrs = virDomainVirtioSerialAddrSetCreateFromDomain(def)))\n        goto cleanup;\n\n    VIR_DEBUG(\"Finished reserving existing ports\");\n\n    for (i = 0; i < def->nconsoles; i++) {\n        virDomainChrDefPtr chr = def->consoles[i];\n        if (chr->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE &&\n            chr->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_VIRTIO &&\n            !virDomainVirtioSerialAddrIsComplete(&chr->info) &&\n            virDomainVirtioSerialAddrAutoAssignFromCache(def, addrs,\n                                                         &chr->info, true) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < def->nchannels; i++) {\n        virDomainChrDefPtr chr = def->channels[i];\n        if (chr->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL &&\n            chr->targetType == VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO &&\n            !virDomainVirtioSerialAddrIsComplete(&chr->info) &&\n            virDomainVirtioSerialAddrAutoAssignFromCache(def, addrs,\n                                                         &chr->info, false) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virDomainVirtioSerialAddrSetFree(addrs);\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrSetFree",
          "args": [
            "addrs"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrSetFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1645-1655",
          "snippet": "void\nvirDomainVirtioSerialAddrSetFree(virDomainVirtioSerialAddrSetPtr addrs)\n{\n    size_t i;\n    if (addrs) {\n        for (i = 0; i < addrs->ncontrollers; i++)\n            virDomainVirtioSerialControllerFree(addrs->controllers[i]);\n        VIR_FREE(addrs->controllers);\n        VIR_FREE(addrs);\n    }\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirDomainVirtioSerialAddrSetFree(virDomainVirtioSerialAddrSetPtr addrs)\n{\n    size_t i;\n    if (addrs) {\n        for (i = 0; i < addrs->ncontrollers; i++)\n            virDomainVirtioSerialControllerFree(addrs->controllers[i]);\n        VIR_FREE(addrs->controllers);\n        VIR_FREE(addrs);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrAutoAssignFromCache",
          "args": [
            "def",
            "addrs",
            "&chr->info",
            "false"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrAutoAssignFromCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1880-1892",
          "snippet": "int\nvirDomainVirtioSerialAddrAutoAssignFromCache(virDomainDefPtr def,\n                                             virDomainVirtioSerialAddrSetPtr addrs,\n                                             virDomainDeviceInfoPtr info,\n                                             bool allowZero)\n{\n    bool portOnly = info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL;\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL &&\n        info->addr.vioserial.port)\n        return virDomainVirtioSerialAddrReserve(NULL, NULL, info, addrs);\n    else\n        return virDomainVirtioSerialAddrAssign(def, addrs, info, allowZero, portOnly);\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainVirtioSerialAddrAutoAssignFromCache(virDomainDefPtr def,\n                                             virDomainVirtioSerialAddrSetPtr addrs,\n                                             virDomainDeviceInfoPtr info,\n                                             bool allowZero)\n{\n    bool portOnly = info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL;\n    if (info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL &&\n        info->addr.vioserial.port)\n        return virDomainVirtioSerialAddrReserve(NULL, NULL, info, addrs);\n    else\n        return virDomainVirtioSerialAddrAssign(def, addrs, info, allowZero, portOnly);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrIsComplete",
          "args": [
            "&chr->info"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrIsComplete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1920-1925",
          "snippet": "bool\nvirDomainVirtioSerialAddrIsComplete(virDomainDeviceInfoPtr info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL &&\n        info->addr.vioserial.port != 0;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirDomainVirtioSerialAddrIsComplete(virDomainDeviceInfoPtr info)\n{\n    return info->type == VIR_DOMAIN_DEVICE_ADDRESS_TYPE_VIRTIO_SERIAL &&\n        info->addr.vioserial.port != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Finished reserving existing ports\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVirtioSerialAddrSetCreateFromDomain",
          "args": [
            "def"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVirtioSerialAddrSetCreateFromDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_addr.c",
          "lines": "1718-1738",
          "snippet": "virDomainVirtioSerialAddrSetPtr\nvirDomainVirtioSerialAddrSetCreateFromDomain(virDomainDefPtr def)\n{\n    virDomainVirtioSerialAddrSetPtr addrs = NULL;\n    virDomainVirtioSerialAddrSetPtr ret = NULL;\n\n    if (!(addrs = virDomainVirtioSerialAddrSetCreate()))\n        goto cleanup;\n\n    if (virDomainVirtioSerialAddrSetAddControllers(addrs, def) < 0)\n        goto cleanup;\n\n    if (virDomainDeviceInfoIterate(def, virDomainVirtioSerialAddrReserve,\n                                   addrs) < 0)\n        goto cleanup;\n\n    ret = g_steal_pointer(&addrs);\n cleanup:\n    virDomainVirtioSerialAddrSetFree(addrs);\n    return ret;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include \"domain_addr.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvirDomainVirtioSerialAddrSetPtr\nvirDomainVirtioSerialAddrSetCreateFromDomain(virDomainDefPtr def)\n{\n    virDomainVirtioSerialAddrSetPtr addrs = NULL;\n    virDomainVirtioSerialAddrSetPtr ret = NULL;\n\n    if (!(addrs = virDomainVirtioSerialAddrSetCreate()))\n        goto cleanup;\n\n    if (virDomainVirtioSerialAddrSetAddControllers(addrs, def) < 0)\n        goto cleanup;\n\n    if (virDomainDeviceInfoIterate(def, virDomainVirtioSerialAddrReserve,\n                                   addrs) < 0)\n        goto cleanup;\n\n    ret = g_steal_pointer(&addrs);\n cleanup:\n    virDomainVirtioSerialAddrSetFree(addrs);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nstatic int\nqemuDomainAssignVirtioSerialAddresses(virDomainDefPtr def)\n{\n    int ret = -1;\n    size_t i;\n    virDomainVirtioSerialAddrSetPtr addrs = NULL;\n\n    if (!(addrs = virDomainVirtioSerialAddrSetCreateFromDomain(def)))\n        goto cleanup;\n\n    VIR_DEBUG(\"Finished reserving existing ports\");\n\n    for (i = 0; i < def->nconsoles; i++) {\n        virDomainChrDefPtr chr = def->consoles[i];\n        if (chr->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE &&\n            chr->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_VIRTIO &&\n            !virDomainVirtioSerialAddrIsComplete(&chr->info) &&\n            virDomainVirtioSerialAddrAutoAssignFromCache(def, addrs,\n                                                         &chr->info, true) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < def->nchannels; i++) {\n        virDomainChrDefPtr chr = def->channels[i];\n        if (chr->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL &&\n            chr->targetType == VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO &&\n            !virDomainVirtioSerialAddrIsComplete(&chr->info) &&\n            virDomainVirtioSerialAddrAutoAssignFromCache(def, addrs,\n                                                         &chr->info, false) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virDomainVirtioSerialAddrSetFree(addrs);\n    return ret;\n}"
  },
  {
    "function_name": "qemuDomainFindSCSIControllerModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "109-123",
    "snippet": "int\nqemuDomainFindSCSIControllerModel(const virDomainDef *def,\n                                  virDomainDeviceInfoPtr info)\n{\n    virDomainControllerDefPtr cont;\n\n    if (!(cont = virDomainDeviceFindSCSIController(def, &info->addr.drive))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to find a SCSI controller for idx=%d\"),\n                       info->addr.drive.controller);\n        return -1;\n    }\n\n    return cont->model;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unable to find a SCSI controller for idx=%d\")",
            "info->addr.drive.controller"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to find a SCSI controller for idx=%d\""
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDeviceFindSCSIController",
          "args": [
            "def",
            "&info->addr.drive"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceFindSCSIController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "8816-8829",
          "snippet": "virDomainControllerDefPtr\nvirDomainDeviceFindSCSIController(const virDomainDef *def,\n                                  const virDomainDeviceDriveAddress *addr)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI &&\n            def->controllers[i]->idx == addr->controller)\n            return def->controllers[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainControllerDefPtr\nvirDomainDeviceFindSCSIController(const virDomainDef *def,\n                                  const virDomainDeviceDriveAddress *addr)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI &&\n            def->controllers[i]->idx == addr->controller)\n            return def->controllers[i];\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nint\nqemuDomainFindSCSIControllerModel(const virDomainDef *def,\n                                  virDomainDeviceInfoPtr info)\n{\n    virDomainControllerDefPtr cont;\n\n    if (!(cont = virDomainDeviceFindSCSIController(def, &info->addr.drive))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to find a SCSI controller for idx=%d\"),\n                       info->addr.drive.controller);\n        return -1;\n    }\n\n    return cont->model;\n}"
  },
  {
    "function_name": "qemuDomainSetSCSIControllerModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "85-97",
    "snippet": "int\nqemuDomainSetSCSIControllerModel(const virDomainDef *def,\n                                 virDomainControllerDefPtr cont,\n                                 virQEMUCapsPtr qemuCaps)\n{\n    int model = qemuDomainGetSCSIControllerModel(def, cont, qemuCaps);\n\n    if (model < 0)\n        return -1;\n\n    cont->model = model;\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainGetSCSIControllerModel",
          "args": [
            "def",
            "cont",
            "qemuCaps"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainGetSCSIControllerModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
          "lines": "51-72",
          "snippet": "int\nqemuDomainGetSCSIControllerModel(const virDomainDef *def,\n                                 const virDomainControllerDef *cont,\n                                 virQEMUCapsPtr qemuCaps)\n{\n    if (cont->model > 0)\n        return cont->model;\n\n    if (qemuDomainIsPSeries(def))\n        return VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI;\n    else if (ARCH_IS_S390(def->os.arch))\n        return VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI;\n    else if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_SCSI_LSI))\n        return VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC;\n    else if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_SCSI))\n        return VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Unable to determine model for SCSI controller idx=%d\"),\n                   cont->idx);\n    return -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nint\nqemuDomainGetSCSIControllerModel(const virDomainDef *def,\n                                 const virDomainControllerDef *cont,\n                                 virQEMUCapsPtr qemuCaps)\n{\n    if (cont->model > 0)\n        return cont->model;\n\n    if (qemuDomainIsPSeries(def))\n        return VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI;\n    else if (ARCH_IS_S390(def->os.arch))\n        return VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI;\n    else if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_SCSI_LSI))\n        return VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC;\n    else if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_SCSI))\n        return VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Unable to determine model for SCSI controller idx=%d\"),\n                   cont->idx);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nint\nqemuDomainSetSCSIControllerModel(const virDomainDef *def,\n                                 virDomainControllerDefPtr cont,\n                                 virQEMUCapsPtr qemuCaps)\n{\n    int model = qemuDomainGetSCSIControllerModel(def, cont, qemuCaps);\n\n    if (model < 0)\n        return -1;\n\n    cont->model = model;\n    return 0;\n}"
  },
  {
    "function_name": "qemuDomainGetSCSIControllerModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain_address.c",
    "lines": "51-72",
    "snippet": "int\nqemuDomainGetSCSIControllerModel(const virDomainDef *def,\n                                 const virDomainControllerDef *cont,\n                                 virQEMUCapsPtr qemuCaps)\n{\n    if (cont->model > 0)\n        return cont->model;\n\n    if (qemuDomainIsPSeries(def))\n        return VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI;\n    else if (ARCH_IS_S390(def->os.arch))\n        return VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI;\n    else if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_SCSI_LSI))\n        return VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC;\n    else if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_SCSI))\n        return VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Unable to determine model for SCSI controller idx=%d\"),\n                   cont->idx);\n    return -1;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_domain_address.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to determine model for SCSI controller idx=%d\")",
            "cont->idx"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to determine model for SCSI controller idx=%d\""
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_VIRTIO_SCSI"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_S390",
          "args": [
            "def->os.arch"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainIsPSeries",
          "args": [
            "def"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainIsPSeries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12912-12916",
          "snippet": "bool\nqemuDomainIsPSeries(const virDomainDef *def)\n{\n    return qemuDomainMachineIsPSeries(def->os.machine, def->os.arch);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainIsPSeries(const virDomainDef *def)\n{\n    return qemuDomainMachineIsPSeries(def->os.machine, def->os.arch);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include <config.h>\n\nint\nqemuDomainGetSCSIControllerModel(const virDomainDef *def,\n                                 const virDomainControllerDef *cont,\n                                 virQEMUCapsPtr qemuCaps)\n{\n    if (cont->model > 0)\n        return cont->model;\n\n    if (qemuDomainIsPSeries(def))\n        return VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI;\n    else if (ARCH_IS_S390(def->os.arch))\n        return VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI;\n    else if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_SCSI_LSI))\n        return VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC;\n    else if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_SCSI))\n        return VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Unable to determine model for SCSI controller idx=%d\"),\n                   cont->idx);\n    return -1;\n}"
  }
]