[
  {
    "function_name": "virNetLibsshSessionHasCachedData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "1436-1450",
    "snippet": "bool\nvirNetLibsshSessionHasCachedData(virNetLibsshSessionPtr sess)\n{\n    bool ret;\n\n    if (!sess)\n        return false;\n\n    virObjectLock(sess);\n\n    ret = sess->bufUsed > 0;\n\n    virObjectUnlock(sess);\n    return ret;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nbool\nvirNetLibsshSessionHasCachedData(virNetLibsshSessionPtr sess)\n{\n    bool ret;\n\n    if (!sess)\n        return false;\n\n    virObjectLock(sess);\n\n    ret = sess->bufUsed > 0;\n\n    virObjectUnlock(sess);\n    return ret;\n}"
  },
  {
    "function_name": "virNetLibsshChannelWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "1379-1434",
    "snippet": "ssize_t\nvirNetLibsshChannelWrite(virNetLibsshSessionPtr sess,\n                         const char *buf,\n                         size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sess);\n\n    if (sess->state != VIR_NET_LIBSSH_STATE_HANDSHAKE_COMPLETE) {\n        if (sess->state == VIR_NET_LIBSSH_STATE_ERROR_REMOTE)\n            virReportError(VIR_ERR_LIBSSH,\n                           _(\"Remote program terminated with non-zero code: %d\"),\n                           sess->channelCommandReturnValue);\n        else\n            virReportError(VIR_ERR_LIBSSH, \"%s\",\n                           _(\"Tried to write socket in error state\"));\n        ret = -1;\n        goto cleanup;\n    }\n\n    if (ssh_channel_is_eof(sess->channel)) {\n        if (ssh_channel_get_exit_status(sess->channel)) {\n            virReportError(VIR_ERR_LIBSSH,\n                           _(\"Remote program terminated with non-zero code: %d\"),\n                           ssh_channel_get_exit_status(sess->channel));\n            sess->state = VIR_NET_LIBSSH_STATE_ERROR_REMOTE;\n            sess->channelCommandReturnValue = ssh_channel_get_exit_status(sess->channel);\n\n            ret = -1;\n            goto cleanup;\n        }\n\n        sess->state = VIR_NET_LIBSSH_STATE_CLOSED;\n        ret = -1;\n        goto cleanup;\n    }\n\n    ret = ssh_channel_write(sess->channel, buf, len);\n    if (ret == SSH_AGAIN) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (ret < 0) {\n        const char *msg;\n        sess->state = VIR_NET_LIBSSH_STATE_ERROR;\n        msg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"write failed: %s\"), msg);\n    }\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "_(\"write failed: %s\")",
            "msg"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"write failed: %s\""
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_get_error",
          "args": [
            "sess->session"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_write",
          "args": [
            "sess->channel",
            "buf",
            "len"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_get_exit_status",
          "args": [
            "sess->channel"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "_(\"Remote program terminated with non-zero code: %d\")",
            "ssh_channel_get_exit_status(sess->channel)"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_get_exit_status",
          "args": [
            "sess->channel"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_get_exit_status",
          "args": [
            "sess->channel"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_is_eof",
          "args": [
            "sess->channel"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"Tried to write socket in error state\")"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "_(\"Remote program terminated with non-zero code: %d\")",
            "sess->channelCommandReturnValue"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nssize_t\nvirNetLibsshChannelWrite(virNetLibsshSessionPtr sess,\n                         const char *buf,\n                         size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sess);\n\n    if (sess->state != VIR_NET_LIBSSH_STATE_HANDSHAKE_COMPLETE) {\n        if (sess->state == VIR_NET_LIBSSH_STATE_ERROR_REMOTE)\n            virReportError(VIR_ERR_LIBSSH,\n                           _(\"Remote program terminated with non-zero code: %d\"),\n                           sess->channelCommandReturnValue);\n        else\n            virReportError(VIR_ERR_LIBSSH, \"%s\",\n                           _(\"Tried to write socket in error state\"));\n        ret = -1;\n        goto cleanup;\n    }\n\n    if (ssh_channel_is_eof(sess->channel)) {\n        if (ssh_channel_get_exit_status(sess->channel)) {\n            virReportError(VIR_ERR_LIBSSH,\n                           _(\"Remote program terminated with non-zero code: %d\"),\n                           ssh_channel_get_exit_status(sess->channel));\n            sess->state = VIR_NET_LIBSSH_STATE_ERROR_REMOTE;\n            sess->channelCommandReturnValue = ssh_channel_get_exit_status(sess->channel);\n\n            ret = -1;\n            goto cleanup;\n        }\n\n        sess->state = VIR_NET_LIBSSH_STATE_CLOSED;\n        ret = -1;\n        goto cleanup;\n    }\n\n    ret = ssh_channel_write(sess->channel, buf, len);\n    if (ret == SSH_AGAIN) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (ret < 0) {\n        const char *msg;\n        sess->state = VIR_NET_LIBSSH_STATE_ERROR;\n        msg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"write failed: %s\"), msg);\n    }\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}"
  },
  {
    "function_name": "virNetLibsshChannelRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "1257-1377",
    "snippet": "ssize_t\nvirNetLibsshChannelRead(virNetLibsshSessionPtr sess,\n                        char *buf,\n                        size_t len)\n{\n    int ret = -1;\n    ssize_t read_n = 0;\n\n    virObjectLock(sess);\n\n    if (sess->state != VIR_NET_LIBSSH_STATE_HANDSHAKE_COMPLETE) {\n        if (sess->state == VIR_NET_LIBSSH_STATE_ERROR_REMOTE)\n            virReportError(VIR_ERR_LIBSSH,\n                           _(\"Remote program terminated \"\n                             \"with non-zero code: %d\"),\n                           sess->channelCommandReturnValue);\n        else\n            virReportError(VIR_ERR_LIBSSH, \"%s\",\n                           _(\"Tried to write socket in error state\"));\n\n        virObjectUnlock(sess);\n        return -1;\n    }\n\n    if (sess->bufUsed > 0) {\n        /* copy the rest (or complete) internal buffer to the output buffer */\n        memcpy(buf,\n               sess->rbuf + sess->bufStart,\n               len > sess->bufUsed ? sess->bufUsed : len);\n\n        if (len >= sess->bufUsed) {\n            read_n = sess->bufUsed;\n\n            sess->bufStart = 0;\n            sess->bufUsed = 0;\n        } else {\n            read_n = len;\n            sess->bufUsed -= len;\n            sess->bufStart += len;\n\n            goto success;\n        }\n    }\n\n    /* continue reading into the buffer supplied */\n    if (read_n < len) {\n        ret = ssh_channel_read_nonblocking(sess->channel,\n                                           buf + read_n,\n                                           len - read_n,\n                                           0);\n\n        if (ret == SSH_EOF || (ret == 0 && ssh_channel_is_eof(sess->channel)))\n            goto eof;\n\n        if (ret == SSH_AGAIN)\n            goto success;\n\n        if (ret < 0)\n            goto error;\n\n        read_n += ret;\n    }\n\n    /* try to read something into the internal buffer */\n    if (sess->bufUsed == 0) {\n        ret = ssh_channel_read_nonblocking(sess->channel,\n                                           sess->rbuf,\n                                           VIR_NET_LIBSSH_BUFFER_SIZE,\n                                           0);\n\n        if (ret == SSH_EOF || (ret == 0 && ssh_channel_is_eof(sess->channel)))\n            goto eof;\n\n        if (ret == SSH_AGAIN)\n            goto success;\n\n        if (ret < 0)\n            goto error;\n\n        sess->bufUsed = ret;\n        sess->bufStart = 0;\n    }\n\n    if (read_n == 0) {\n        /* get rid of data in stderr stream */\n        ret = ssh_channel_read_nonblocking(sess->channel,\n                                           sess->rbuf,\n                                           VIR_NET_LIBSSH_BUFFER_SIZE - 1,\n                                           1);\n        if (ret > 0) {\n            sess->rbuf[ret] = '\\0';\n            VIR_DEBUG(\"flushing stderr, data='%s'\",  sess->rbuf);\n        }\n    }\n\n    if (ssh_channel_is_eof(sess->channel)) {\n eof:\n        if (ssh_channel_get_exit_status(sess->channel)) {\n            virReportError(VIR_ERR_LIBSSH,\n                           _(\"Remote command terminated with non-zero code: %d\"),\n                           ssh_channel_get_exit_status(sess->channel));\n            sess->channelCommandReturnValue = ssh_channel_get_exit_status(sess->channel);\n            sess->state = VIR_NET_LIBSSH_STATE_ERROR_REMOTE;\n            virObjectUnlock(sess);\n            return -1;\n        }\n\n        sess->state = VIR_NET_LIBSSH_STATE_CLOSED;\n        virObjectUnlock(sess);\n        return -1;\n    }\n\n success:\n    virObjectUnlock(sess);\n    return read_n;\n\n error:\n    sess->state = VIR_NET_LIBSSH_STATE_ERROR;\n    virObjectUnlock(sess);\n    return ret;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VIR_NET_LIBSSH_BUFFER_SIZE  1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_channel_get_exit_status",
          "args": [
            "sess->channel"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "_(\"Remote command terminated with non-zero code: %d\")",
            "ssh_channel_get_exit_status(sess->channel)"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_get_exit_status",
          "args": [
            "sess->channel"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Remote command terminated with non-zero code: %d\""
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_channel_get_exit_status",
          "args": [
            "sess->channel"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_is_eof",
          "args": [
            "sess->channel"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"flushing stderr, data='%s'\"",
            "sess->rbuf"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_read_nonblocking",
          "args": [
            "sess->channel",
            "sess->rbuf",
            "VIR_NET_LIBSSH_BUFFER_SIZE - 1",
            "1"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_is_eof",
          "args": [
            "sess->channel"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_read_nonblocking",
          "args": [
            "sess->channel",
            "sess->rbuf",
            "VIR_NET_LIBSSH_BUFFER_SIZE",
            "0"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_is_eof",
          "args": [
            "sess->channel"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_read_nonblocking",
          "args": [
            "sess->channel",
            "buf + read_n",
            "len - read_n",
            "0"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "sess->rbuf + sess->bufStart",
            "len > sess->bufUsed ? sess->bufUsed : len"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"Tried to write socket in error state\")"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "_(\"Remote program terminated \"\n                             \"with non-zero code: %d\")",
            "sess->channelCommandReturnValue"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\n#define VIR_NET_LIBSSH_BUFFER_SIZE  1024\n\nssize_t\nvirNetLibsshChannelRead(virNetLibsshSessionPtr sess,\n                        char *buf,\n                        size_t len)\n{\n    int ret = -1;\n    ssize_t read_n = 0;\n\n    virObjectLock(sess);\n\n    if (sess->state != VIR_NET_LIBSSH_STATE_HANDSHAKE_COMPLETE) {\n        if (sess->state == VIR_NET_LIBSSH_STATE_ERROR_REMOTE)\n            virReportError(VIR_ERR_LIBSSH,\n                           _(\"Remote program terminated \"\n                             \"with non-zero code: %d\"),\n                           sess->channelCommandReturnValue);\n        else\n            virReportError(VIR_ERR_LIBSSH, \"%s\",\n                           _(\"Tried to write socket in error state\"));\n\n        virObjectUnlock(sess);\n        return -1;\n    }\n\n    if (sess->bufUsed > 0) {\n        /* copy the rest (or complete) internal buffer to the output buffer */\n        memcpy(buf,\n               sess->rbuf + sess->bufStart,\n               len > sess->bufUsed ? sess->bufUsed : len);\n\n        if (len >= sess->bufUsed) {\n            read_n = sess->bufUsed;\n\n            sess->bufStart = 0;\n            sess->bufUsed = 0;\n        } else {\n            read_n = len;\n            sess->bufUsed -= len;\n            sess->bufStart += len;\n\n            goto success;\n        }\n    }\n\n    /* continue reading into the buffer supplied */\n    if (read_n < len) {\n        ret = ssh_channel_read_nonblocking(sess->channel,\n                                           buf + read_n,\n                                           len - read_n,\n                                           0);\n\n        if (ret == SSH_EOF || (ret == 0 && ssh_channel_is_eof(sess->channel)))\n            goto eof;\n\n        if (ret == SSH_AGAIN)\n            goto success;\n\n        if (ret < 0)\n            goto error;\n\n        read_n += ret;\n    }\n\n    /* try to read something into the internal buffer */\n    if (sess->bufUsed == 0) {\n        ret = ssh_channel_read_nonblocking(sess->channel,\n                                           sess->rbuf,\n                                           VIR_NET_LIBSSH_BUFFER_SIZE,\n                                           0);\n\n        if (ret == SSH_EOF || (ret == 0 && ssh_channel_is_eof(sess->channel)))\n            goto eof;\n\n        if (ret == SSH_AGAIN)\n            goto success;\n\n        if (ret < 0)\n            goto error;\n\n        sess->bufUsed = ret;\n        sess->bufStart = 0;\n    }\n\n    if (read_n == 0) {\n        /* get rid of data in stderr stream */\n        ret = ssh_channel_read_nonblocking(sess->channel,\n                                           sess->rbuf,\n                                           VIR_NET_LIBSSH_BUFFER_SIZE - 1,\n                                           1);\n        if (ret > 0) {\n            sess->rbuf[ret] = '\\0';\n            VIR_DEBUG(\"flushing stderr, data='%s'\",  sess->rbuf);\n        }\n    }\n\n    if (ssh_channel_is_eof(sess->channel)) {\n eof:\n        if (ssh_channel_get_exit_status(sess->channel)) {\n            virReportError(VIR_ERR_LIBSSH,\n                           _(\"Remote command terminated with non-zero code: %d\"),\n                           ssh_channel_get_exit_status(sess->channel));\n            sess->channelCommandReturnValue = ssh_channel_get_exit_status(sess->channel);\n            sess->state = VIR_NET_LIBSSH_STATE_ERROR_REMOTE;\n            virObjectUnlock(sess);\n            return -1;\n        }\n\n        sess->state = VIR_NET_LIBSSH_STATE_CLOSED;\n        virObjectUnlock(sess);\n        return -1;\n    }\n\n success:\n    virObjectUnlock(sess);\n    return read_n;\n\n error:\n    sess->state = VIR_NET_LIBSSH_STATE_ERROR;\n    virObjectUnlock(sess);\n    return ret;\n}"
  },
  {
    "function_name": "virNetLibsshSessionConnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "1190-1254",
    "snippet": "int\nvirNetLibsshSessionConnect(virNetLibsshSessionPtr sess,\n                           int sock)\n{\n    int ret;\n    const char *errmsg;\n\n    VIR_DEBUG(\"sess=%p, sock=%d\", sess, sock);\n\n    if (!sess || sess->state != VIR_NET_LIBSSH_STATE_NEW) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Invalid virNetLibsshSessionPtr\"));\n        return -1;\n    }\n\n    virObjectLock(sess);\n\n    /* check if configuration is valid */\n    if ((ret = virNetLibsshValidateConfig(sess)) < 0)\n        goto error;\n\n    /* read ~/.ssh/config */\n    if ((ret = ssh_options_parse_config(sess->session, NULL)) < 0)\n        goto error;\n\n    /* set the socket FD for the libssh session */\n    if ((ret = ssh_options_set(sess->session, SSH_OPTIONS_FD, &sock)) < 0)\n        goto error;\n\n    /* open session */\n    ret = ssh_connect(sess->session);\n    /* libssh is in blocking mode, so EAGAIN will never happen */\n    if (ret < 0) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_NO_CONNECT,\n                       _(\"SSH session handshake failed: %s\"),\n                       errmsg);\n        goto error;\n    }\n\n    /* verify the SSH host key */\n    if ((ret = virNetLibsshCheckHostKey(sess)) != 0)\n        goto error;\n\n    /* authenticate */\n    if ((ret = virNetLibsshAuthenticate(sess)) != 0)\n        goto error;\n\n    /* open channel */\n    if ((ret = virNetLibsshOpenChannel(sess)) != 0)\n        goto error;\n\n    /* all set */\n    /* switch to nonblocking mode and return */\n    ssh_set_blocking(sess->session, 0);\n    sess->state = VIR_NET_LIBSSH_STATE_HANDSHAKE_COMPLETE;\n\n    virObjectUnlock(sess);\n    return ret;\n\n error:\n    sess->state = VIR_NET_LIBSSH_STATE_ERROR;\n    virObjectUnlock(sess);\n    return ret;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_set_blocking",
          "args": [
            "sess->session",
            "0"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetLibsshOpenChannel",
          "args": [
            "sess"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshOpenChannel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "872-908",
          "snippet": "static int\nvirNetLibsshOpenChannel(virNetLibsshSessionPtr sess)\n{\n    const char *errmsg;\n\n    sess->channel = ssh_channel_new(sess->session);\n    if (!sess->channel) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to create libssh channel: %s\"),\n                       errmsg);\n        return -1;\n    }\n\n    if (ssh_channel_open_session(sess->channel) != SSH_OK) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to open ssh channel: %s\"),\n                       errmsg);\n        return -1;\n    }\n\n    if (ssh_channel_request_exec(sess->channel, sess->channelCommand) != SSH_OK) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to execute command '%s': %s\"),\n                       sess->channelCommand,\n                       errmsg);\n        return -1;\n    }\n\n    /* nonblocking mode */\n    ssh_channel_set_blocking(sess->channel, 0);\n\n    /* channel open */\n    return 0;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirNetLibsshOpenChannel(virNetLibsshSessionPtr sess)\n{\n    const char *errmsg;\n\n    sess->channel = ssh_channel_new(sess->session);\n    if (!sess->channel) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to create libssh channel: %s\"),\n                       errmsg);\n        return -1;\n    }\n\n    if (ssh_channel_open_session(sess->channel) != SSH_OK) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to open ssh channel: %s\"),\n                       errmsg);\n        return -1;\n    }\n\n    if (ssh_channel_request_exec(sess->channel, sess->channelCommand) != SSH_OK) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to execute command '%s': %s\"),\n                       sess->channelCommand,\n                       errmsg);\n        return -1;\n    }\n\n    /* nonblocking mode */\n    ssh_channel_set_blocking(sess->channel, 0);\n\n    /* channel open */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetLibsshAuthenticate",
          "args": [
            "sess"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshAuthenticate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "776-869",
          "snippet": "static int\nvirNetLibsshAuthenticate(virNetLibsshSessionPtr sess)\n{\n    virNetLibsshAuthMethodPtr auth;\n    bool no_method = false;\n    bool auth_failed = false;\n    const char *errmsg;\n    int ret;\n    int methods;\n    size_t i;\n\n    VIR_DEBUG(\"sess=%p\", sess);\n\n    /* At this point, we can assume there is at least one\n     * authentication method set -- virNetLibsshValidateConfig\n     * already checked that.\n     */\n\n    /* try to authenticate */\n    ret = ssh_userauth_none(sess->session, NULL);\n    if (ret == SSH_AUTH_ERROR) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"Failed to authenticate as 'none': %s\"),\n                       errmsg);\n        return -1;\n    }\n\n    /* obtain list of supported auth methods */\n    methods = ssh_userauth_list(sess->session, NULL);\n\n    for (i = 0; i < sess->nauths; i++) {\n        auth = sess->auths[i];\n\n        if ((methods & auth->ssh_flags) == 0) {\n            no_method = true;\n            continue;\n        }\n\n        ret = SSH_AUTH_DENIED;\n\n        switch (auth->method) {\n        case VIR_NET_LIBSSH_AUTH_KEYBOARD_INTERACTIVE:\n            /* try to authenticate using the keyboard interactive way */\n            ret = virNetLibsshAuthenticateKeyboardInteractive(sess, auth);\n            break;\n        case VIR_NET_LIBSSH_AUTH_AGENT:\n            /* try to authenticate using ssh-agent */\n            ret = ssh_userauth_agent(sess->session, NULL);\n            if (ret == SSH_AUTH_ERROR) {\n                errmsg = ssh_get_error(sess->session);\n                virReportError(VIR_ERR_LIBSSH,\n                               _(\"failed to authenticate using agent: %s\"),\n                               errmsg);\n            }\n            break;\n        case VIR_NET_LIBSSH_AUTH_PRIVKEY:\n            /* try to authenticate using the provided ssh key */\n            ret = virNetLibsshAuthenticatePrivkey(sess, auth);\n            break;\n        case VIR_NET_LIBSSH_AUTH_PASSWORD:\n            /* try to authenticate with password */\n            ret = virNetLibsshAuthenticatePassword(sess, auth);\n            break;\n        }\n\n        if (ret == SSH_AUTH_ERROR) {\n            /* virReportError is called already */\n            return -1;\n        } else if (ret == SSH_AUTH_SUCCESS) {\n            /* authenticated */\n            return 0;\n        }\n\n        auth_failed = true;\n    }\n\n    if (sess->nauths == 1) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to authenticate: %s\"),\n                       errmsg);\n    } else if (no_method && !auth_failed) {\n        virReportError(VIR_ERR_AUTH_FAILED, \"%s\",\n                       _(\"None of the requested authentication methods \"\n                         \"are supported by the server\"));\n    } else {\n        virReportError(VIR_ERR_AUTH_FAILED, \"%s\",\n                       _(\"All provided authentication methods with credentials \"\n                         \"were rejected by the server\"));\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirNetLibsshAuthenticate(virNetLibsshSessionPtr sess)\n{\n    virNetLibsshAuthMethodPtr auth;\n    bool no_method = false;\n    bool auth_failed = false;\n    const char *errmsg;\n    int ret;\n    int methods;\n    size_t i;\n\n    VIR_DEBUG(\"sess=%p\", sess);\n\n    /* At this point, we can assume there is at least one\n     * authentication method set -- virNetLibsshValidateConfig\n     * already checked that.\n     */\n\n    /* try to authenticate */\n    ret = ssh_userauth_none(sess->session, NULL);\n    if (ret == SSH_AUTH_ERROR) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"Failed to authenticate as 'none': %s\"),\n                       errmsg);\n        return -1;\n    }\n\n    /* obtain list of supported auth methods */\n    methods = ssh_userauth_list(sess->session, NULL);\n\n    for (i = 0; i < sess->nauths; i++) {\n        auth = sess->auths[i];\n\n        if ((methods & auth->ssh_flags) == 0) {\n            no_method = true;\n            continue;\n        }\n\n        ret = SSH_AUTH_DENIED;\n\n        switch (auth->method) {\n        case VIR_NET_LIBSSH_AUTH_KEYBOARD_INTERACTIVE:\n            /* try to authenticate using the keyboard interactive way */\n            ret = virNetLibsshAuthenticateKeyboardInteractive(sess, auth);\n            break;\n        case VIR_NET_LIBSSH_AUTH_AGENT:\n            /* try to authenticate using ssh-agent */\n            ret = ssh_userauth_agent(sess->session, NULL);\n            if (ret == SSH_AUTH_ERROR) {\n                errmsg = ssh_get_error(sess->session);\n                virReportError(VIR_ERR_LIBSSH,\n                               _(\"failed to authenticate using agent: %s\"),\n                               errmsg);\n            }\n            break;\n        case VIR_NET_LIBSSH_AUTH_PRIVKEY:\n            /* try to authenticate using the provided ssh key */\n            ret = virNetLibsshAuthenticatePrivkey(sess, auth);\n            break;\n        case VIR_NET_LIBSSH_AUTH_PASSWORD:\n            /* try to authenticate with password */\n            ret = virNetLibsshAuthenticatePassword(sess, auth);\n            break;\n        }\n\n        if (ret == SSH_AUTH_ERROR) {\n            /* virReportError is called already */\n            return -1;\n        } else if (ret == SSH_AUTH_SUCCESS) {\n            /* authenticated */\n            return 0;\n        }\n\n        auth_failed = true;\n    }\n\n    if (sess->nauths == 1) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to authenticate: %s\"),\n                       errmsg);\n    } else if (no_method && !auth_failed) {\n        virReportError(VIR_ERR_AUTH_FAILED, \"%s\",\n                       _(\"None of the requested authentication methods \"\n                         \"are supported by the server\"));\n    } else {\n        virReportError(VIR_ERR_AUTH_FAILED, \"%s\",\n                       _(\"All provided authentication methods with credentials \"\n                         \"were rejected by the server\"));\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetLibsshCheckHostKey",
          "args": [
            "sess"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshCheckHostKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "276-399",
          "snippet": "static int\nvirNetLibsshCheckHostKey(virNetLibsshSessionPtr sess)\n{\n    int state;\n    char *keyhashstr;\n    const char *errmsg;\n\n    if (sess->hostKeyVerify == VIR_NET_LIBSSH_HOSTKEY_VERIFY_IGNORE)\n        return 0;\n\n    state = ssh_session_is_known_server(sess->session);\n\n    switch (state) {\n    case SSH_SERVER_KNOWN_OK:\n        /* host key matches */\n        return 0;\n\n    case SSH_SERVER_FOUND_OTHER:\n    case SSH_SERVER_KNOWN_CHANGED:\n        keyhashstr = virLibsshServerKeyAsString(sess);\n        if (!keyhashstr)\n            return -1;\n\n        /* host key verification failed */\n        virReportError(VIR_ERR_AUTH_FAILED,\n                       _(\"!!! SSH HOST KEY VERIFICATION FAILED !!!: \"\n                         \"Identity of host '%s:%d' differs from stored identity. \"\n                         \"Please verify the new host key '%s' to avoid possible \"\n                         \"man in the middle attack. The key is stored in '%s'.\"),\n                       sess->hostname, sess->port,\n                       keyhashstr, sess->knownHostsFile);\n\n        ssh_string_free_char(keyhashstr);\n        return -1;\n\n    case SSH_SERVER_FILE_NOT_FOUND:\n    case SSH_SERVER_NOT_KNOWN:\n        /* key was not found, query to add it to database */\n        if (sess->hostKeyVerify == VIR_NET_LIBSSH_HOSTKEY_VERIFY_NORMAL) {\n            virConnectCredential askKey;\n            int cred_type;\n            char *tmp;\n\n            /* ask to add the key */\n            if (!sess->cred || !sess->cred->cb) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"No user interaction callback provided: \"\n                                 \"Can't verify the session host key\"));\n                return -1;\n            }\n\n            cred_type = virCredTypeForPrompt(sess->cred, 1 /* echo */);\n            if (cred_type == -1) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"no suitable callback for host key \"\n                                 \"verification\"));\n                return -1;\n            }\n\n            /* prepare data for the callback */\n            memset(&askKey, 0, sizeof(virConnectCredential));\n            askKey.type = cred_type;\n\n            keyhashstr = virLibsshServerKeyAsString(sess);\n            if (!keyhashstr)\n                return -1;\n\n            tmp = g_strdup_printf(_(\"Accept SSH host key with hash '%s' for \" \"host '%s:%d' (%s/%s)?\"),\n                                  keyhashstr, sess->hostname, sess->port, \"y\", \"n\");\n            askKey.prompt = tmp;\n\n            if (sess->cred->cb(&askKey, 1, sess->cred->cbdata)) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"failed to retrieve decision to accept \"\n                                 \"host key\"));\n                VIR_FREE(tmp);\n                ssh_string_free_char(keyhashstr);\n                return -1;\n            }\n\n            VIR_FREE(tmp);\n\n            if (!askKey.result ||\n                STRCASENEQ(askKey.result, \"y\")) {\n                virReportError(VIR_ERR_LIBSSH,\n                               _(\"SSH host key for '%s' (%s) was not accepted\"),\n                               sess->hostname, keyhashstr);\n                ssh_string_free_char(keyhashstr);\n                VIR_FREE(askKey.result);\n                return -1;\n            }\n            ssh_string_free_char(keyhashstr);\n            VIR_FREE(askKey.result);\n        }\n\n        /* write the host key file, if specified */\n        if (sess->knownHostsFile) {\n            if (ssh_session_update_known_hosts(sess->session) < 0) {\n                errmsg = ssh_get_error(sess->session);\n                virReportError(VIR_ERR_LIBSSH,\n                               _(\"failed to write known_host file '%s': %s\"),\n                               sess->knownHostsFile,\n                               errmsg);\n                return -1;\n            }\n        }\n        /* key was accepted and added */\n        return 0;\n\n    case SSH_SERVER_ERROR:\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to validate SSH host key: %s\"),\n                       errmsg);\n        return -1;\n\n    default: /* should never happen (tm) */\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Unknown state of the remote server SSH key\"));\n        return -1;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirNetLibsshCheckHostKey(virNetLibsshSessionPtr sess)\n{\n    int state;\n    char *keyhashstr;\n    const char *errmsg;\n\n    if (sess->hostKeyVerify == VIR_NET_LIBSSH_HOSTKEY_VERIFY_IGNORE)\n        return 0;\n\n    state = ssh_session_is_known_server(sess->session);\n\n    switch (state) {\n    case SSH_SERVER_KNOWN_OK:\n        /* host key matches */\n        return 0;\n\n    case SSH_SERVER_FOUND_OTHER:\n    case SSH_SERVER_KNOWN_CHANGED:\n        keyhashstr = virLibsshServerKeyAsString(sess);\n        if (!keyhashstr)\n            return -1;\n\n        /* host key verification failed */\n        virReportError(VIR_ERR_AUTH_FAILED,\n                       _(\"!!! SSH HOST KEY VERIFICATION FAILED !!!: \"\n                         \"Identity of host '%s:%d' differs from stored identity. \"\n                         \"Please verify the new host key '%s' to avoid possible \"\n                         \"man in the middle attack. The key is stored in '%s'.\"),\n                       sess->hostname, sess->port,\n                       keyhashstr, sess->knownHostsFile);\n\n        ssh_string_free_char(keyhashstr);\n        return -1;\n\n    case SSH_SERVER_FILE_NOT_FOUND:\n    case SSH_SERVER_NOT_KNOWN:\n        /* key was not found, query to add it to database */\n        if (sess->hostKeyVerify == VIR_NET_LIBSSH_HOSTKEY_VERIFY_NORMAL) {\n            virConnectCredential askKey;\n            int cred_type;\n            char *tmp;\n\n            /* ask to add the key */\n            if (!sess->cred || !sess->cred->cb) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"No user interaction callback provided: \"\n                                 \"Can't verify the session host key\"));\n                return -1;\n            }\n\n            cred_type = virCredTypeForPrompt(sess->cred, 1 /* echo */);\n            if (cred_type == -1) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"no suitable callback for host key \"\n                                 \"verification\"));\n                return -1;\n            }\n\n            /* prepare data for the callback */\n            memset(&askKey, 0, sizeof(virConnectCredential));\n            askKey.type = cred_type;\n\n            keyhashstr = virLibsshServerKeyAsString(sess);\n            if (!keyhashstr)\n                return -1;\n\n            tmp = g_strdup_printf(_(\"Accept SSH host key with hash '%s' for \" \"host '%s:%d' (%s/%s)?\"),\n                                  keyhashstr, sess->hostname, sess->port, \"y\", \"n\");\n            askKey.prompt = tmp;\n\n            if (sess->cred->cb(&askKey, 1, sess->cred->cbdata)) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"failed to retrieve decision to accept \"\n                                 \"host key\"));\n                VIR_FREE(tmp);\n                ssh_string_free_char(keyhashstr);\n                return -1;\n            }\n\n            VIR_FREE(tmp);\n\n            if (!askKey.result ||\n                STRCASENEQ(askKey.result, \"y\")) {\n                virReportError(VIR_ERR_LIBSSH,\n                               _(\"SSH host key for '%s' (%s) was not accepted\"),\n                               sess->hostname, keyhashstr);\n                ssh_string_free_char(keyhashstr);\n                VIR_FREE(askKey.result);\n                return -1;\n            }\n            ssh_string_free_char(keyhashstr);\n            VIR_FREE(askKey.result);\n        }\n\n        /* write the host key file, if specified */\n        if (sess->knownHostsFile) {\n            if (ssh_session_update_known_hosts(sess->session) < 0) {\n                errmsg = ssh_get_error(sess->session);\n                virReportError(VIR_ERR_LIBSSH,\n                               _(\"failed to write known_host file '%s': %s\"),\n                               sess->knownHostsFile,\n                               errmsg);\n                return -1;\n            }\n        }\n        /* key was accepted and added */\n        return 0;\n\n    case SSH_SERVER_ERROR:\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to validate SSH host key: %s\"),\n                       errmsg);\n        return -1;\n\n    default: /* should never happen (tm) */\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Unknown state of the remote server SSH key\"));\n        return -1;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_CONNECT",
            "_(\"SSH session handshake failed: %s\")",
            "errmsg"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"SSH session handshake failed: %s\""
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_get_error",
          "args": [
            "sess->session"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_connect",
          "args": [
            "sess->session"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_options_set",
          "args": [
            "sess->session",
            "SSH_OPTIONS_FD",
            "&sock"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_options_parse_config",
          "args": [
            "sess->session",
            "NULL"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetLibsshValidateConfig",
          "args": [
            "sess"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshValidateConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "911-946",
          "snippet": "static int\nvirNetLibsshValidateConfig(virNetLibsshSessionPtr sess)\n{\n    size_t i;\n    bool has_auths = false;\n\n    for (i = 0; i < sess->nauths; ++i) {\n        if (sess->auths[i]) {\n            has_auths = true;\n            break;\n        }\n    }\n    if (!has_auths) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"No authentication methods and credentials \"\n                         \"provided\"));\n        return -1;\n    }\n\n    if (!sess->channelCommand) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"No channel command provided\"));\n        return -1;\n    }\n\n    if (sess->hostKeyVerify != VIR_NET_LIBSSH_HOSTKEY_VERIFY_IGNORE) {\n        if (!sess->hostname) {\n            virReportError(VIR_ERR_LIBSSH, \"%s\",\n                           _(\"Hostname is needed for host key verification\"));\n            return -1;\n        }\n    }\n\n    /* everything ok */\n    return 0;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirNetLibsshValidateConfig(virNetLibsshSessionPtr sess)\n{\n    size_t i;\n    bool has_auths = false;\n\n    for (i = 0; i < sess->nauths; ++i) {\n        if (sess->auths[i]) {\n            has_auths = true;\n            break;\n        }\n    }\n    if (!has_auths) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"No authentication methods and credentials \"\n                         \"provided\"));\n        return -1;\n    }\n\n    if (!sess->channelCommand) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"No channel command provided\"));\n        return -1;\n    }\n\n    if (sess->hostKeyVerify != VIR_NET_LIBSSH_HOSTKEY_VERIFY_IGNORE) {\n        if (!sess->hostname) {\n            virReportError(VIR_ERR_LIBSSH, \"%s\",\n                           _(\"Hostname is needed for host key verification\"));\n            return -1;\n        }\n    }\n\n    /* everything ok */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"Invalid virNetLibsshSessionPtr\")"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"sess=%p, sock=%d\"",
            "sess",
            "sock"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nint\nvirNetLibsshSessionConnect(virNetLibsshSessionPtr sess,\n                           int sock)\n{\n    int ret;\n    const char *errmsg;\n\n    VIR_DEBUG(\"sess=%p, sock=%d\", sess, sock);\n\n    if (!sess || sess->state != VIR_NET_LIBSSH_STATE_NEW) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Invalid virNetLibsshSessionPtr\"));\n        return -1;\n    }\n\n    virObjectLock(sess);\n\n    /* check if configuration is valid */\n    if ((ret = virNetLibsshValidateConfig(sess)) < 0)\n        goto error;\n\n    /* read ~/.ssh/config */\n    if ((ret = ssh_options_parse_config(sess->session, NULL)) < 0)\n        goto error;\n\n    /* set the socket FD for the libssh session */\n    if ((ret = ssh_options_set(sess->session, SSH_OPTIONS_FD, &sock)) < 0)\n        goto error;\n\n    /* open session */\n    ret = ssh_connect(sess->session);\n    /* libssh is in blocking mode, so EAGAIN will never happen */\n    if (ret < 0) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_NO_CONNECT,\n                       _(\"SSH session handshake failed: %s\"),\n                       errmsg);\n        goto error;\n    }\n\n    /* verify the SSH host key */\n    if ((ret = virNetLibsshCheckHostKey(sess)) != 0)\n        goto error;\n\n    /* authenticate */\n    if ((ret = virNetLibsshAuthenticate(sess)) != 0)\n        goto error;\n\n    /* open channel */\n    if ((ret = virNetLibsshOpenChannel(sess)) != 0)\n        goto error;\n\n    /* all set */\n    /* switch to nonblocking mode and return */\n    ssh_set_blocking(sess->session, 0);\n    sess->state = VIR_NET_LIBSSH_STATE_HANDSHAKE_COMPLETE;\n\n    virObjectUnlock(sess);\n    return ret;\n\n error:\n    sess->state = VIR_NET_LIBSSH_STATE_ERROR;\n    virObjectUnlock(sess);\n    return ret;\n}"
  },
  {
    "function_name": "virNetLibsshSessionNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "1151-1188",
    "snippet": "virNetLibsshSessionPtr virNetLibsshSessionNew(const char *username)\n{\n    virNetLibsshSessionPtr sess = NULL;\n\n    if (virNetLibsshSessionInitialize() < 0)\n        goto error;\n\n    if (!(sess = virObjectLockableNew(virNetLibsshSessionClass)))\n        goto error;\n\n    /* initialize session data */\n    if (!(sess->session = ssh_new())) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Failed to initialize libssh session\"));\n        goto error;\n    }\n\n    sess->username = g_strdup(username);\n\n    VIR_DEBUG(\"virNetLibsshSessionPtr: %p, ssh_session: %p\",\n              sess, sess->session);\n\n    /* set blocking mode for libssh until handshake is complete */\n    ssh_set_blocking(sess->session, 1);\n\n    if (ssh_options_set(sess->session, SSH_OPTIONS_USER, sess->username) < 0)\n        goto error;\n\n    /* default states for config variables */\n    sess->state = VIR_NET_LIBSSH_STATE_NEW;\n    sess->hostKeyVerify = VIR_NET_LIBSSH_HOSTKEY_VERIFY_IGNORE;\n\n    return sess;\n\n error:\n    virObjectUnref(sess);\n    return NULL;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virNetLibsshSessionClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "sess"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_options_set",
          "args": [
            "sess->session",
            "SSH_OPTIONS_USER",
            "sess->username"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_set_blocking",
          "args": [
            "sess->session",
            "1"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"virNetLibsshSessionPtr: %p, ssh_session: %p\"",
            "sess",
            "sess->session"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "username"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"Failed to initialize libssh session\")"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_new",
          "args": [],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "virNetLibsshSessionClass"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetLibsshSessionInitialize",
          "args": [],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic virClassPtr virNetLibsshSessionClass;\n\nvirNetLibsshSessionPtr virNetLibsshSessionNew(const char *username)\n{\n    virNetLibsshSessionPtr sess = NULL;\n\n    if (virNetLibsshSessionInitialize() < 0)\n        goto error;\n\n    if (!(sess = virObjectLockableNew(virNetLibsshSessionClass)))\n        goto error;\n\n    /* initialize session data */\n    if (!(sess->session = ssh_new())) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Failed to initialize libssh session\"));\n        goto error;\n    }\n\n    sess->username = g_strdup(username);\n\n    VIR_DEBUG(\"virNetLibsshSessionPtr: %p, ssh_session: %p\",\n              sess, sess->session);\n\n    /* set blocking mode for libssh until handshake is complete */\n    ssh_set_blocking(sess->session, 1);\n\n    if (ssh_options_set(sess->session, SSH_OPTIONS_USER, sess->username) < 0)\n        goto error;\n\n    /* default states for config variables */\n    sess->state = VIR_NET_LIBSSH_STATE_NEW;\n    sess->hostKeyVerify = VIR_NET_LIBSSH_HOSTKEY_VERIFY_IGNORE;\n\n    return sess;\n\n error:\n    virObjectUnref(sess);\n    return NULL;\n}"
  },
  {
    "function_name": "virNetLibsshSessionSetHostKeyVerification",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "1100-1148",
    "snippet": "int\nvirNetLibsshSessionSetHostKeyVerification(virNetLibsshSessionPtr sess,\n                                          const char *hostname,\n                                          int port,\n                                          const char *hostsfile,\n                                          virNetLibsshHostkeyVerify opt)\n{\n    virObjectLock(sess);\n\n    sess->port = port;\n    sess->hostKeyVerify = opt;\n\n    VIR_FREE(sess->hostname);\n\n    sess->hostname = g_strdup(hostname);\n\n    /* set the hostname */\n    if (ssh_options_set(sess->session, SSH_OPTIONS_HOST, sess->hostname) < 0)\n        goto error;\n\n    /* set the port */\n    if (port > 0) {\n        unsigned int portU = port;\n\n        if (ssh_options_set(sess->session, SSH_OPTIONS_PORT, &portU) < 0)\n            goto error;\n    }\n\n    /* set the known hosts file, if specified */\n    if (hostsfile) {\n        if (ssh_options_set(sess->session, SSH_OPTIONS_KNOWNHOSTS, hostsfile) < 0)\n            goto error;\n\n        VIR_FREE(sess->knownHostsFile);\n        sess->knownHostsFile = g_strdup(hostsfile);\n    } else {\n        /* libssh does not support trying no known_host file at all:\n         * hence use /dev/null here, without storing it as file */\n        if (ssh_options_set(sess->session, SSH_OPTIONS_KNOWNHOSTS, \"/dev/null\") < 0)\n            goto error;\n    }\n\n    virObjectUnlock(sess);\n    return 0;\n\n error:\n    virObjectUnlock(sess);\n    return -1;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_options_set",
          "args": [
            "sess->session",
            "SSH_OPTIONS_KNOWNHOSTS",
            "\"/dev/null\""
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "hostsfile"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sess->knownHostsFile"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_options_set",
          "args": [
            "sess->session",
            "SSH_OPTIONS_KNOWNHOSTS",
            "hostsfile"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_options_set",
          "args": [
            "sess->session",
            "SSH_OPTIONS_PORT",
            "&portU"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_options_set",
          "args": [
            "sess->session",
            "SSH_OPTIONS_HOST",
            "sess->hostname"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sess->hostname"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nint\nvirNetLibsshSessionSetHostKeyVerification(virNetLibsshSessionPtr sess,\n                                          const char *hostname,\n                                          int port,\n                                          const char *hostsfile,\n                                          virNetLibsshHostkeyVerify opt)\n{\n    virObjectLock(sess);\n\n    sess->port = port;\n    sess->hostKeyVerify = opt;\n\n    VIR_FREE(sess->hostname);\n\n    sess->hostname = g_strdup(hostname);\n\n    /* set the hostname */\n    if (ssh_options_set(sess->session, SSH_OPTIONS_HOST, sess->hostname) < 0)\n        goto error;\n\n    /* set the port */\n    if (port > 0) {\n        unsigned int portU = port;\n\n        if (ssh_options_set(sess->session, SSH_OPTIONS_PORT, &portU) < 0)\n            goto error;\n    }\n\n    /* set the known hosts file, if specified */\n    if (hostsfile) {\n        if (ssh_options_set(sess->session, SSH_OPTIONS_KNOWNHOSTS, hostsfile) < 0)\n            goto error;\n\n        VIR_FREE(sess->knownHostsFile);\n        sess->knownHostsFile = g_strdup(hostsfile);\n    } else {\n        /* libssh does not support trying no known_host file at all:\n         * hence use /dev/null here, without storing it as file */\n        if (ssh_options_set(sess->session, SSH_OPTIONS_KNOWNHOSTS, \"/dev/null\") < 0)\n            goto error;\n    }\n\n    virObjectUnlock(sess);\n    return 0;\n\n error:\n    virObjectUnlock(sess);\n    return -1;\n}"
  },
  {
    "function_name": "virNetLibsshSessionSetChannelCommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "1085-1098",
    "snippet": "int\nvirNetLibsshSessionSetChannelCommand(virNetLibsshSessionPtr sess,\n                                      const char *command)\n{\n    int ret = 0;\n    virObjectLock(sess);\n\n    VIR_FREE(sess->channelCommand);\n\n    sess->channelCommand = g_strdup(command);\n\n    virObjectUnlock(sess);\n    return ret;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "command"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sess->channelCommand"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nint\nvirNetLibsshSessionSetChannelCommand(virNetLibsshSessionPtr sess,\n                                      const char *command)\n{\n    int ret = 0;\n    virObjectLock(sess);\n\n    VIR_FREE(sess->channelCommand);\n\n    sess->channelCommand = g_strdup(command);\n\n    virObjectUnlock(sess);\n    return ret;\n}"
  },
  {
    "function_name": "virNetLibsshSessionAuthAddKeyboardAuth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "1059-1083",
    "snippet": "int\nvirNetLibsshSessionAuthAddKeyboardAuth(virNetLibsshSessionPtr sess,\n                                       int tries)\n{\n    int ret;\n    virNetLibsshAuthMethodPtr auth;\n\n    virObjectLock(sess);\n\n    if (!(auth = virNetLibsshSessionAuthMethodNew(sess))) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    auth->tries = tries;\n    auth->method = VIR_NET_LIBSSH_AUTH_KEYBOARD_INTERACTIVE;\n    auth->ssh_flags = SSH_AUTH_METHOD_INTERACTIVE;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetLibsshSessionAuthMethodNew",
          "args": [
            "sess"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshSessionAuthMethodNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "183-201",
          "snippet": "static virNetLibsshAuthMethodPtr\nvirNetLibsshSessionAuthMethodNew(virNetLibsshSessionPtr sess)\n{\n    virNetLibsshAuthMethodPtr auth;\n\n    if (VIR_ALLOC(auth) < 0)\n        goto error;\n\n    if (VIR_EXPAND_N(sess->auths, sess->nauths, 1) < 0)\n        goto error;\n\n    sess->auths[sess->nauths - 1] = auth;\n\n    return auth;\n\n error:\n    VIR_FREE(auth);\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic virNetLibsshAuthMethodPtr\nvirNetLibsshSessionAuthMethodNew(virNetLibsshSessionPtr sess)\n{\n    virNetLibsshAuthMethodPtr auth;\n\n    if (VIR_ALLOC(auth) < 0)\n        goto error;\n\n    if (VIR_EXPAND_N(sess->auths, sess->nauths, 1) < 0)\n        goto error;\n\n    sess->auths[sess->nauths - 1] = auth;\n\n    return auth;\n\n error:\n    VIR_FREE(auth);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nint\nvirNetLibsshSessionAuthAddKeyboardAuth(virNetLibsshSessionPtr sess,\n                                       int tries)\n{\n    int ret;\n    virNetLibsshAuthMethodPtr auth;\n\n    virObjectLock(sess);\n\n    if (!(auth = virNetLibsshSessionAuthMethodNew(sess))) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    auth->tries = tries;\n    auth->method = VIR_NET_LIBSSH_AUTH_KEYBOARD_INTERACTIVE;\n    auth->ssh_flags = SSH_AUTH_METHOD_INTERACTIVE;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n\n}"
  },
  {
    "function_name": "virNetLibsshSessionAuthAddPrivKeyAuth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "1015-1057",
    "snippet": "int\nvirNetLibsshSessionAuthAddPrivKeyAuth(virNetLibsshSessionPtr sess,\n                                      const char *keyfile,\n                                      const char *password)\n{\n    int ret;\n    virNetLibsshAuthMethodPtr auth;\n    VIR_AUTODISPOSE_STR pass = NULL;\n    char *file = NULL;\n\n    if (!keyfile) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Key file path must be provided \"\n                         \"for private key authentication\"));\n        ret = -1;\n        goto error;\n    }\n\n    virObjectLock(sess);\n\n    file = g_strdup(keyfile);\n    pass = g_strdup(password);\n\n    if (!(auth = virNetLibsshSessionAuthMethodNew(sess))) {\n        ret = -1;\n        goto error;\n    }\n\n    auth->password = g_steal_pointer(&pass);\n    auth->filename = file;\n    auth->method = VIR_NET_LIBSSH_AUTH_PRIVKEY;\n    auth->ssh_flags = SSH_AUTH_METHOD_PUBLICKEY;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n\n error:\n    VIR_FREE(file);\n    goto cleanup;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "file"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&pass"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetLibsshSessionAuthMethodNew",
          "args": [
            "sess"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshSessionAuthMethodNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "183-201",
          "snippet": "static virNetLibsshAuthMethodPtr\nvirNetLibsshSessionAuthMethodNew(virNetLibsshSessionPtr sess)\n{\n    virNetLibsshAuthMethodPtr auth;\n\n    if (VIR_ALLOC(auth) < 0)\n        goto error;\n\n    if (VIR_EXPAND_N(sess->auths, sess->nauths, 1) < 0)\n        goto error;\n\n    sess->auths[sess->nauths - 1] = auth;\n\n    return auth;\n\n error:\n    VIR_FREE(auth);\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic virNetLibsshAuthMethodPtr\nvirNetLibsshSessionAuthMethodNew(virNetLibsshSessionPtr sess)\n{\n    virNetLibsshAuthMethodPtr auth;\n\n    if (VIR_ALLOC(auth) < 0)\n        goto error;\n\n    if (VIR_EXPAND_N(sess->auths, sess->nauths, 1) < 0)\n        goto error;\n\n    sess->auths[sess->nauths - 1] = auth;\n\n    return auth;\n\n error:\n    VIR_FREE(auth);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "password"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"Key file path must be provided \"\n                         \"for private key authentication\")"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nint\nvirNetLibsshSessionAuthAddPrivKeyAuth(virNetLibsshSessionPtr sess,\n                                      const char *keyfile,\n                                      const char *password)\n{\n    int ret;\n    virNetLibsshAuthMethodPtr auth;\n    VIR_AUTODISPOSE_STR pass = NULL;\n    char *file = NULL;\n\n    if (!keyfile) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Key file path must be provided \"\n                         \"for private key authentication\"));\n        ret = -1;\n        goto error;\n    }\n\n    virObjectLock(sess);\n\n    file = g_strdup(keyfile);\n    pass = g_strdup(password);\n\n    if (!(auth = virNetLibsshSessionAuthMethodNew(sess))) {\n        ret = -1;\n        goto error;\n    }\n\n    auth->password = g_steal_pointer(&pass);\n    auth->filename = file;\n    auth->method = VIR_NET_LIBSSH_AUTH_PRIVKEY;\n    auth->ssh_flags = SSH_AUTH_METHOD_PUBLICKEY;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n\n error:\n    VIR_FREE(file);\n    goto cleanup;\n}"
  },
  {
    "function_name": "virNetLibsshSessionAuthAddAgentAuth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "992-1013",
    "snippet": "int\nvirNetLibsshSessionAuthAddAgentAuth(virNetLibsshSessionPtr sess)\n{\n    int ret;\n    virNetLibsshAuthMethodPtr auth;\n\n    virObjectLock(sess);\n\n    if (!(auth = virNetLibsshSessionAuthMethodNew(sess))) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    auth->method = VIR_NET_LIBSSH_AUTH_AGENT;\n    auth->ssh_flags = SSH_AUTH_METHOD_PUBLICKEY;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetLibsshSessionAuthMethodNew",
          "args": [
            "sess"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshSessionAuthMethodNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "183-201",
          "snippet": "static virNetLibsshAuthMethodPtr\nvirNetLibsshSessionAuthMethodNew(virNetLibsshSessionPtr sess)\n{\n    virNetLibsshAuthMethodPtr auth;\n\n    if (VIR_ALLOC(auth) < 0)\n        goto error;\n\n    if (VIR_EXPAND_N(sess->auths, sess->nauths, 1) < 0)\n        goto error;\n\n    sess->auths[sess->nauths - 1] = auth;\n\n    return auth;\n\n error:\n    VIR_FREE(auth);\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic virNetLibsshAuthMethodPtr\nvirNetLibsshSessionAuthMethodNew(virNetLibsshSessionPtr sess)\n{\n    virNetLibsshAuthMethodPtr auth;\n\n    if (VIR_ALLOC(auth) < 0)\n        goto error;\n\n    if (VIR_EXPAND_N(sess->auths, sess->nauths, 1) < 0)\n        goto error;\n\n    sess->auths[sess->nauths - 1] = auth;\n\n    return auth;\n\n error:\n    VIR_FREE(auth);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nint\nvirNetLibsshSessionAuthAddAgentAuth(virNetLibsshSessionPtr sess)\n{\n    int ret;\n    virNetLibsshAuthMethodPtr auth;\n\n    virObjectLock(sess);\n\n    if (!(auth = virNetLibsshSessionAuthMethodNew(sess))) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    auth->method = VIR_NET_LIBSSH_AUTH_AGENT;\n    auth->ssh_flags = SSH_AUTH_METHOD_PUBLICKEY;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}"
  },
  {
    "function_name": "virNetLibsshSessionAuthAddPasswordAuth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "959-990",
    "snippet": "int\nvirNetLibsshSessionAuthAddPasswordAuth(virNetLibsshSessionPtr sess,\n                                       virURIPtr uri)\n{\n    int ret;\n    virNetLibsshAuthMethodPtr auth;\n\n    if (uri) {\n        VIR_FREE(sess->authPath);\n\n        if (virAuthGetConfigFilePathURI(uri, &sess->authPath) < 0) {\n            ret = -1;\n            goto cleanup;\n        }\n    }\n\n    virObjectLock(sess);\n\n    if (!(auth = virNetLibsshSessionAuthMethodNew(sess))) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    auth->method = VIR_NET_LIBSSH_AUTH_PASSWORD;\n    auth->ssh_flags = SSH_AUTH_METHOD_PASSWORD;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetLibsshSessionAuthMethodNew",
          "args": [
            "sess"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshSessionAuthMethodNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "183-201",
          "snippet": "static virNetLibsshAuthMethodPtr\nvirNetLibsshSessionAuthMethodNew(virNetLibsshSessionPtr sess)\n{\n    virNetLibsshAuthMethodPtr auth;\n\n    if (VIR_ALLOC(auth) < 0)\n        goto error;\n\n    if (VIR_EXPAND_N(sess->auths, sess->nauths, 1) < 0)\n        goto error;\n\n    sess->auths[sess->nauths - 1] = auth;\n\n    return auth;\n\n error:\n    VIR_FREE(auth);\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic virNetLibsshAuthMethodPtr\nvirNetLibsshSessionAuthMethodNew(virNetLibsshSessionPtr sess)\n{\n    virNetLibsshAuthMethodPtr auth;\n\n    if (VIR_ALLOC(auth) < 0)\n        goto error;\n\n    if (VIR_EXPAND_N(sess->auths, sess->nauths, 1) < 0)\n        goto error;\n\n    sess->auths[sess->nauths - 1] = auth;\n\n    return auth;\n\n error:\n    VIR_FREE(auth);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virAuthGetConfigFilePathURI",
          "args": [
            "uri",
            "&sess->authPath"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "virAuthGetConfigFilePathURI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virauth.c",
          "lines": "40-91",
          "snippet": "int\nvirAuthGetConfigFilePathURI(virURIPtr uri,\n                            char **path)\n{\n    size_t i;\n    const char *authenv = getenv(\"LIBVIRT_AUTH_FILE\");\n    g_autofree char *userdir = NULL;\n\n    *path = NULL;\n\n    VIR_DEBUG(\"Determining auth config file path\");\n\n    if (authenv) {\n        VIR_DEBUG(\"Using path from env '%s'\", authenv);\n        *path = g_strdup(authenv);\n        return 0;\n    }\n\n    if (uri) {\n        for (i = 0; i < uri->paramsCount; i++) {\n            if (STREQ_NULLABLE(uri->params[i].name, \"authfile\") &&\n                uri->params[i].value) {\n                VIR_DEBUG(\"Using path from URI '%s'\", uri->params[i].value);\n                *path = g_strdup(uri->params[i].value);\n                return 0;\n            }\n        }\n    }\n\n    userdir = virGetUserConfigDirectory();\n\n    *path = g_strdup_printf(\"%s/auth.conf\", userdir);\n\n    VIR_DEBUG(\"Checking for readability of '%s'\", *path);\n    if (access(*path, R_OK) == 0)\n        goto done;\n\n    VIR_FREE(*path);\n\n    *path = g_strdup(SYSCONFDIR \"/libvirt/auth.conf\");\n\n    VIR_DEBUG(\"Checking for readability of '%s'\", *path);\n    if (access(*path, R_OK) == 0)\n        goto done;\n\n    VIR_FREE(*path);\n\n done:\n    VIR_DEBUG(\"Using auth file '%s'\", NULLSTR(*path));\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virauthconfig.h\"",
            "#include \"configmake.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virauthconfig.h\"\n#include \"configmake.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include <config.h>\n\nint\nvirAuthGetConfigFilePathURI(virURIPtr uri,\n                            char **path)\n{\n    size_t i;\n    const char *authenv = getenv(\"LIBVIRT_AUTH_FILE\");\n    g_autofree char *userdir = NULL;\n\n    *path = NULL;\n\n    VIR_DEBUG(\"Determining auth config file path\");\n\n    if (authenv) {\n        VIR_DEBUG(\"Using path from env '%s'\", authenv);\n        *path = g_strdup(authenv);\n        return 0;\n    }\n\n    if (uri) {\n        for (i = 0; i < uri->paramsCount; i++) {\n            if (STREQ_NULLABLE(uri->params[i].name, \"authfile\") &&\n                uri->params[i].value) {\n                VIR_DEBUG(\"Using path from URI '%s'\", uri->params[i].value);\n                *path = g_strdup(uri->params[i].value);\n                return 0;\n            }\n        }\n    }\n\n    userdir = virGetUserConfigDirectory();\n\n    *path = g_strdup_printf(\"%s/auth.conf\", userdir);\n\n    VIR_DEBUG(\"Checking for readability of '%s'\", *path);\n    if (access(*path, R_OK) == 0)\n        goto done;\n\n    VIR_FREE(*path);\n\n    *path = g_strdup(SYSCONFDIR \"/libvirt/auth.conf\");\n\n    VIR_DEBUG(\"Checking for readability of '%s'\", *path);\n    if (access(*path, R_OK) == 0)\n        goto done;\n\n    VIR_FREE(*path);\n\n done:\n    VIR_DEBUG(\"Using auth file '%s'\", NULLSTR(*path));\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sess->authPath"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nint\nvirNetLibsshSessionAuthAddPasswordAuth(virNetLibsshSessionPtr sess,\n                                       virURIPtr uri)\n{\n    int ret;\n    virNetLibsshAuthMethodPtr auth;\n\n    if (uri) {\n        VIR_FREE(sess->authPath);\n\n        if (virAuthGetConfigFilePathURI(uri, &sess->authPath) < 0) {\n            ret = -1;\n            goto cleanup;\n        }\n    }\n\n    virObjectLock(sess);\n\n    if (!(auth = virNetLibsshSessionAuthMethodNew(sess))) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    auth->method = VIR_NET_LIBSSH_AUTH_PASSWORD;\n    auth->ssh_flags = SSH_AUTH_METHOD_PASSWORD;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}"
  },
  {
    "function_name": "virNetLibsshSessionAuthSetCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "949-957",
    "snippet": "int\nvirNetLibsshSessionAuthSetCallback(virNetLibsshSessionPtr sess,\n                                   virConnectAuthPtr auth)\n{\n    virObjectLock(sess);\n    sess->cred = auth;\n    virObjectUnlock(sess);\n    return 0;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nint\nvirNetLibsshSessionAuthSetCallback(virNetLibsshSessionPtr sess,\n                                   virConnectAuthPtr auth)\n{\n    virObjectLock(sess);\n    sess->cred = auth;\n    virObjectUnlock(sess);\n    return 0;\n}"
  },
  {
    "function_name": "virNetLibsshValidateConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "911-946",
    "snippet": "static int\nvirNetLibsshValidateConfig(virNetLibsshSessionPtr sess)\n{\n    size_t i;\n    bool has_auths = false;\n\n    for (i = 0; i < sess->nauths; ++i) {\n        if (sess->auths[i]) {\n            has_auths = true;\n            break;\n        }\n    }\n    if (!has_auths) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"No authentication methods and credentials \"\n                         \"provided\"));\n        return -1;\n    }\n\n    if (!sess->channelCommand) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"No channel command provided\"));\n        return -1;\n    }\n\n    if (sess->hostKeyVerify != VIR_NET_LIBSSH_HOSTKEY_VERIFY_IGNORE) {\n        if (!sess->hostname) {\n            virReportError(VIR_ERR_LIBSSH, \"%s\",\n                           _(\"Hostname is needed for host key verification\"));\n            return -1;\n        }\n    }\n\n    /* everything ok */\n    return 0;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"Hostname is needed for host key verification\")"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Hostname is needed for host key verification\""
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"No channel command provided\")"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"No authentication methods and credentials \"\n                         \"provided\")"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirNetLibsshValidateConfig(virNetLibsshSessionPtr sess)\n{\n    size_t i;\n    bool has_auths = false;\n\n    for (i = 0; i < sess->nauths; ++i) {\n        if (sess->auths[i]) {\n            has_auths = true;\n            break;\n        }\n    }\n    if (!has_auths) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"No authentication methods and credentials \"\n                         \"provided\"));\n        return -1;\n    }\n\n    if (!sess->channelCommand) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"No channel command provided\"));\n        return -1;\n    }\n\n    if (sess->hostKeyVerify != VIR_NET_LIBSSH_HOSTKEY_VERIFY_IGNORE) {\n        if (!sess->hostname) {\n            virReportError(VIR_ERR_LIBSSH, \"%s\",\n                           _(\"Hostname is needed for host key verification\"));\n            return -1;\n        }\n    }\n\n    /* everything ok */\n    return 0;\n}"
  },
  {
    "function_name": "virNetLibsshOpenChannel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "872-908",
    "snippet": "static int\nvirNetLibsshOpenChannel(virNetLibsshSessionPtr sess)\n{\n    const char *errmsg;\n\n    sess->channel = ssh_channel_new(sess->session);\n    if (!sess->channel) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to create libssh channel: %s\"),\n                       errmsg);\n        return -1;\n    }\n\n    if (ssh_channel_open_session(sess->channel) != SSH_OK) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to open ssh channel: %s\"),\n                       errmsg);\n        return -1;\n    }\n\n    if (ssh_channel_request_exec(sess->channel, sess->channelCommand) != SSH_OK) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to execute command '%s': %s\"),\n                       sess->channelCommand,\n                       errmsg);\n        return -1;\n    }\n\n    /* nonblocking mode */\n    ssh_channel_set_blocking(sess->channel, 0);\n\n    /* channel open */\n    return 0;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_channel_set_blocking",
          "args": [
            "sess->channel",
            "0"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "_(\"failed to execute command '%s': %s\")",
            "sess->channelCommand",
            "errmsg"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to execute command '%s': %s\""
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_get_error",
          "args": [
            "sess->session"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_request_exec",
          "args": [
            "sess->channel",
            "sess->channelCommand"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "_(\"failed to open ssh channel: %s\")",
            "errmsg"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_get_error",
          "args": [
            "sess->session"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_open_session",
          "args": [
            "sess->channel"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "_(\"failed to create libssh channel: %s\")",
            "errmsg"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_get_error",
          "args": [
            "sess->session"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_new",
          "args": [
            "sess->session"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirNetLibsshOpenChannel(virNetLibsshSessionPtr sess)\n{\n    const char *errmsg;\n\n    sess->channel = ssh_channel_new(sess->session);\n    if (!sess->channel) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to create libssh channel: %s\"),\n                       errmsg);\n        return -1;\n    }\n\n    if (ssh_channel_open_session(sess->channel) != SSH_OK) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to open ssh channel: %s\"),\n                       errmsg);\n        return -1;\n    }\n\n    if (ssh_channel_request_exec(sess->channel, sess->channelCommand) != SSH_OK) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to execute command '%s': %s\"),\n                       sess->channelCommand,\n                       errmsg);\n        return -1;\n    }\n\n    /* nonblocking mode */\n    ssh_channel_set_blocking(sess->channel, 0);\n\n    /* channel open */\n    return 0;\n}"
  },
  {
    "function_name": "virNetLibsshAuthenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "776-869",
    "snippet": "static int\nvirNetLibsshAuthenticate(virNetLibsshSessionPtr sess)\n{\n    virNetLibsshAuthMethodPtr auth;\n    bool no_method = false;\n    bool auth_failed = false;\n    const char *errmsg;\n    int ret;\n    int methods;\n    size_t i;\n\n    VIR_DEBUG(\"sess=%p\", sess);\n\n    /* At this point, we can assume there is at least one\n     * authentication method set -- virNetLibsshValidateConfig\n     * already checked that.\n     */\n\n    /* try to authenticate */\n    ret = ssh_userauth_none(sess->session, NULL);\n    if (ret == SSH_AUTH_ERROR) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"Failed to authenticate as 'none': %s\"),\n                       errmsg);\n        return -1;\n    }\n\n    /* obtain list of supported auth methods */\n    methods = ssh_userauth_list(sess->session, NULL);\n\n    for (i = 0; i < sess->nauths; i++) {\n        auth = sess->auths[i];\n\n        if ((methods & auth->ssh_flags) == 0) {\n            no_method = true;\n            continue;\n        }\n\n        ret = SSH_AUTH_DENIED;\n\n        switch (auth->method) {\n        case VIR_NET_LIBSSH_AUTH_KEYBOARD_INTERACTIVE:\n            /* try to authenticate using the keyboard interactive way */\n            ret = virNetLibsshAuthenticateKeyboardInteractive(sess, auth);\n            break;\n        case VIR_NET_LIBSSH_AUTH_AGENT:\n            /* try to authenticate using ssh-agent */\n            ret = ssh_userauth_agent(sess->session, NULL);\n            if (ret == SSH_AUTH_ERROR) {\n                errmsg = ssh_get_error(sess->session);\n                virReportError(VIR_ERR_LIBSSH,\n                               _(\"failed to authenticate using agent: %s\"),\n                               errmsg);\n            }\n            break;\n        case VIR_NET_LIBSSH_AUTH_PRIVKEY:\n            /* try to authenticate using the provided ssh key */\n            ret = virNetLibsshAuthenticatePrivkey(sess, auth);\n            break;\n        case VIR_NET_LIBSSH_AUTH_PASSWORD:\n            /* try to authenticate with password */\n            ret = virNetLibsshAuthenticatePassword(sess, auth);\n            break;\n        }\n\n        if (ret == SSH_AUTH_ERROR) {\n            /* virReportError is called already */\n            return -1;\n        } else if (ret == SSH_AUTH_SUCCESS) {\n            /* authenticated */\n            return 0;\n        }\n\n        auth_failed = true;\n    }\n\n    if (sess->nauths == 1) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to authenticate: %s\"),\n                       errmsg);\n    } else if (no_method && !auth_failed) {\n        virReportError(VIR_ERR_AUTH_FAILED, \"%s\",\n                       _(\"None of the requested authentication methods \"\n                         \"are supported by the server\"));\n    } else {\n        virReportError(VIR_ERR_AUTH_FAILED, \"%s\",\n                       _(\"All provided authentication methods with credentials \"\n                         \"were rejected by the server\"));\n    }\n\n    return -1;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_AUTH_FAILED",
            "\"%s\"",
            "_(\"All provided authentication methods with credentials \"\n                         \"were rejected by the server\")"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"All provided authentication methods with credentials \"\n                         \"were rejected by the server\""
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_AUTH_FAILED",
            "\"%s\"",
            "_(\"None of the requested authentication methods \"\n                         \"are supported by the server\")"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "_(\"failed to authenticate: %s\")",
            "errmsg"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_get_error",
          "args": [
            "sess->session"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetLibsshAuthenticatePassword",
          "args": [
            "sess",
            "auth"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshAuthenticatePassword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "591-639",
          "snippet": "static int\nvirNetLibsshAuthenticatePassword(virNetLibsshSessionPtr sess,\n                                 virNetLibsshAuthMethodPtr priv)\n{\n    const char *errmsg;\n    int rc = SSH_AUTH_ERROR;\n\n    VIR_DEBUG(\"sess=%p\", sess);\n\n    if (priv->password) {\n        /* tunelled password authentication */\n        if ((rc = ssh_userauth_password(sess->session, NULL,\n                                        priv->password)) == 0)\n            return SSH_AUTH_SUCCESS;\n    } else {\n        /* password authentication with interactive password request */\n        if (!sess->cred || !sess->cred->cb) {\n            virReportError(VIR_ERR_LIBSSH, \"%s\",\n                           _(\"Can't perform authentication: \"\n                             \"Authentication callback not provided\"));\n            return SSH_AUTH_ERROR;\n        }\n\n        /* Try the authenticating the set amount of times. The server breaks the\n         * connection if maximum number of bad auth tries is exceeded */\n        while (true) {\n            VIR_AUTODISPOSE_STR password = NULL;\n\n            if (!(password = virAuthGetPasswordPath(sess->authPath, sess->cred,\n                                                    \"ssh\", sess->username,\n                                                    sess->hostname)))\n                return SSH_AUTH_ERROR;\n\n            /* tunelled password authentication */\n            if ((rc = ssh_userauth_password(sess->session, NULL,\n                                            password)) == 0)\n                return SSH_AUTH_SUCCESS;\n\n            if (rc != SSH_AUTH_DENIED)\n                break;\n        }\n    }\n\n    /* error path */\n    errmsg = ssh_get_error(sess->session);\n    virReportError(VIR_ERR_AUTH_FAILED,\n                   _(\"authentication failed: %s\"), errmsg);\n    return rc;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirNetLibsshAuthenticatePassword(virNetLibsshSessionPtr sess,\n                                 virNetLibsshAuthMethodPtr priv)\n{\n    const char *errmsg;\n    int rc = SSH_AUTH_ERROR;\n\n    VIR_DEBUG(\"sess=%p\", sess);\n\n    if (priv->password) {\n        /* tunelled password authentication */\n        if ((rc = ssh_userauth_password(sess->session, NULL,\n                                        priv->password)) == 0)\n            return SSH_AUTH_SUCCESS;\n    } else {\n        /* password authentication with interactive password request */\n        if (!sess->cred || !sess->cred->cb) {\n            virReportError(VIR_ERR_LIBSSH, \"%s\",\n                           _(\"Can't perform authentication: \"\n                             \"Authentication callback not provided\"));\n            return SSH_AUTH_ERROR;\n        }\n\n        /* Try the authenticating the set amount of times. The server breaks the\n         * connection if maximum number of bad auth tries is exceeded */\n        while (true) {\n            VIR_AUTODISPOSE_STR password = NULL;\n\n            if (!(password = virAuthGetPasswordPath(sess->authPath, sess->cred,\n                                                    \"ssh\", sess->username,\n                                                    sess->hostname)))\n                return SSH_AUTH_ERROR;\n\n            /* tunelled password authentication */\n            if ((rc = ssh_userauth_password(sess->session, NULL,\n                                            password)) == 0)\n                return SSH_AUTH_SUCCESS;\n\n            if (rc != SSH_AUTH_DENIED)\n                break;\n        }\n    }\n\n    /* error path */\n    errmsg = ssh_get_error(sess->session);\n    virReportError(VIR_ERR_AUTH_FAILED,\n                   _(\"authentication failed: %s\"), errmsg);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetLibsshAuthenticatePrivkey",
          "args": [
            "sess",
            "auth"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshAuthenticatePrivkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "511-584",
          "snippet": "static int\nvirNetLibsshAuthenticatePrivkey(virNetLibsshSessionPtr sess,\n                                virNetLibsshAuthMethodPtr priv)\n{\n    int err;\n    int ret;\n    char *tmp = NULL;\n    ssh_key public_key = NULL;\n    ssh_key private_key = NULL;\n\n    VIR_DEBUG(\"sess=%p\", sess);\n\n    tmp = g_strdup_printf(\"%s.pub\", priv->filename);\n\n    /* try to open the public part of the private key */\n    ret = ssh_pki_import_pubkey_file(tmp, &public_key);\n    if (ret == SSH_ERROR) {\n        virReportError(VIR_ERR_AUTH_FAILED,\n                       _(\"error while reading public key '%s'\"),\n                       tmp);\n        err = SSH_AUTH_ERROR;\n        goto error;\n    } else if (ret == SSH_EOF) {\n        /* load the private key */\n        err = virNetLibsshImportPrivkey(sess, priv, &private_key);\n        if (err != SSH_AUTH_SUCCESS)\n            goto error;\n\n        /* create the public key from the private key */\n        ret = ssh_pki_export_privkey_to_pubkey(private_key, &public_key);\n        if (ret == SSH_ERROR) {\n            virReportError(VIR_ERR_AUTH_FAILED,\n                           _(\"cannot export the public key from the \"\n                             \"private key '%s'\"),\n                           priv->filename);\n            err = SSH_AUTH_ERROR;\n            goto error;\n        }\n    }\n\n    VIR_FREE(tmp);\n\n    ret = ssh_userauth_try_publickey(sess->session, NULL, public_key);\n    if (ret != SSH_AUTH_SUCCESS) {\n        err = SSH_AUTH_DENIED;\n        goto error;\n    }\n\n    /* load the private key, if it was not loaded yet */\n    if (private_key == NULL) {\n        err = virNetLibsshImportPrivkey(sess, priv, &private_key);\n        if (err != SSH_AUTH_SUCCESS)\n            goto error;\n    }\n\n    ret = ssh_userauth_publickey(sess->session, NULL, private_key);\n    if (ret != SSH_AUTH_SUCCESS) {\n        err = SSH_AUTH_DENIED;\n        goto error;\n    }\n\n    ssh_key_free(private_key);\n    ssh_key_free(public_key);\n\n    return SSH_AUTH_SUCCESS;\n\n error:\n    if (private_key)\n        ssh_key_free(private_key);\n    if (public_key)\n        ssh_key_free(public_key);\n    VIR_FREE(tmp);\n    return err;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirNetLibsshAuthenticatePrivkey(virNetLibsshSessionPtr sess,\n                                virNetLibsshAuthMethodPtr priv)\n{\n    int err;\n    int ret;\n    char *tmp = NULL;\n    ssh_key public_key = NULL;\n    ssh_key private_key = NULL;\n\n    VIR_DEBUG(\"sess=%p\", sess);\n\n    tmp = g_strdup_printf(\"%s.pub\", priv->filename);\n\n    /* try to open the public part of the private key */\n    ret = ssh_pki_import_pubkey_file(tmp, &public_key);\n    if (ret == SSH_ERROR) {\n        virReportError(VIR_ERR_AUTH_FAILED,\n                       _(\"error while reading public key '%s'\"),\n                       tmp);\n        err = SSH_AUTH_ERROR;\n        goto error;\n    } else if (ret == SSH_EOF) {\n        /* load the private key */\n        err = virNetLibsshImportPrivkey(sess, priv, &private_key);\n        if (err != SSH_AUTH_SUCCESS)\n            goto error;\n\n        /* create the public key from the private key */\n        ret = ssh_pki_export_privkey_to_pubkey(private_key, &public_key);\n        if (ret == SSH_ERROR) {\n            virReportError(VIR_ERR_AUTH_FAILED,\n                           _(\"cannot export the public key from the \"\n                             \"private key '%s'\"),\n                           priv->filename);\n            err = SSH_AUTH_ERROR;\n            goto error;\n        }\n    }\n\n    VIR_FREE(tmp);\n\n    ret = ssh_userauth_try_publickey(sess->session, NULL, public_key);\n    if (ret != SSH_AUTH_SUCCESS) {\n        err = SSH_AUTH_DENIED;\n        goto error;\n    }\n\n    /* load the private key, if it was not loaded yet */\n    if (private_key == NULL) {\n        err = virNetLibsshImportPrivkey(sess, priv, &private_key);\n        if (err != SSH_AUTH_SUCCESS)\n            goto error;\n    }\n\n    ret = ssh_userauth_publickey(sess->session, NULL, private_key);\n    if (ret != SSH_AUTH_SUCCESS) {\n        err = SSH_AUTH_DENIED;\n        goto error;\n    }\n\n    ssh_key_free(private_key);\n    ssh_key_free(public_key);\n\n    return SSH_AUTH_SUCCESS;\n\n error:\n    if (private_key)\n        ssh_key_free(private_key);\n    if (public_key)\n        ssh_key_free(public_key);\n    VIR_FREE(tmp);\n    return err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "_(\"failed to authenticate using agent: %s\")",
            "errmsg"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_get_error",
          "args": [
            "sess->session"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_userauth_agent",
          "args": [
            "sess->session",
            "NULL"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetLibsshAuthenticateKeyboardInteractive",
          "args": [
            "sess",
            "auth"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshAuthenticateKeyboardInteractive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "645-773",
          "snippet": "static int\nvirNetLibsshAuthenticateKeyboardInteractive(virNetLibsshSessionPtr sess,\n                                            virNetLibsshAuthMethodPtr priv)\n{\n    int ret;\n    const char *errmsg;\n    int try = 0;\n\n    /* request user's key password */\n    if (!sess->cred || !sess->cred->cb) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"No user interaction callback provided: \"\n                         \"Can't get input from keyboard interactive \"\n                         \"authentication\"));\n        return SSH_AUTH_ERROR;\n    }\n\n again:\n    ret = ssh_userauth_kbdint(sess->session, NULL, NULL);\n    while (ret == SSH_AUTH_INFO) {\n        const char *name, *instruction;\n        int nprompts, iprompt;\n        virBuffer buff = VIR_BUFFER_INITIALIZER;\n\n        name = ssh_userauth_kbdint_getname(sess->session);\n        instruction = ssh_userauth_kbdint_getinstruction(sess->session);\n        nprompts = ssh_userauth_kbdint_getnprompts(sess->session);\n\n        /* compose the main buffer with name and instruction, if present */\n        if (name && name[0])\n            virBufferAddStr(&buff, name);\n        if (instruction && instruction[0]) {\n            if (virBufferUse(&buff) > 0)\n                virBufferAddChar(&buff, '\\n');\n            virBufferAddStr(&buff, instruction);\n        }\n        if (virBufferUse(&buff) > 0)\n            virBufferAddChar(&buff, '\\n');\n\n        for (iprompt = 0; iprompt < nprompts; ++iprompt) {\n            virConnectCredential retr_passphrase;\n            const char *promptStr;\n            int promptStrLen;\n            char echo;\n            char *prompt = NULL;\n            int cred_type;\n\n            /* get the prompt */\n            promptStr = ssh_userauth_kbdint_getprompt(sess->session, iprompt,\n                                                      &echo);\n            promptStrLen = virLengthForPromptString(promptStr);\n\n            cred_type = virCredTypeForPrompt(sess->cred, echo);\n            if (cred_type == -1) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"no suitable callback for input of keyboard \"\n                                 \"response\"));\n                goto prompt_error;\n            }\n\n            /* create the prompt for the user, using the instruction\n             * buffer if specified\n             */\n            if (virBufferUse(&buff) > 0) {\n                virBuffer prompt_buff = VIR_BUFFER_INITIALIZER;\n\n                virBufferAddBuffer(&prompt_buff, &buff);\n                virBufferAdd(&prompt_buff, promptStr, promptStrLen);\n\n                prompt = virBufferContentAndReset(&prompt_buff);\n            } else {\n                prompt = g_strndup(promptStr, promptStrLen);\n            }\n\n            memset(&retr_passphrase, 0, sizeof(virConnectCredential));\n            retr_passphrase.type = cred_type;\n            retr_passphrase.prompt = prompt;\n\n            if (retr_passphrase.type == -1) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"no suitable callback for input of key \"\n                                 \"passphrase\"));\n                goto prompt_error;\n            }\n\n            if (sess->cred->cb(&retr_passphrase, 1, sess->cred->cbdata)) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"failed to retrieve keyboard interactive \"\n                                 \"result: callback has failed\"));\n                goto prompt_error;\n            }\n\n            VIR_FREE(prompt);\n\n            ret = ssh_userauth_kbdint_setanswer(sess->session, iprompt,\n                                                retr_passphrase.result);\n            VIR_DISPOSE_STRING(retr_passphrase.result);\n            if (ret < 0) {\n                errmsg = ssh_get_error(sess->session);\n                virReportError(VIR_ERR_AUTH_FAILED,\n                               _(\"authentication failed: %s\"), errmsg);\n                goto prompt_error;\n            }\n\n            continue;\n\n         prompt_error:\n            VIR_FREE(prompt);\n            virBufferFreeAndReset(&buff);\n            return SSH_AUTH_ERROR;\n        }\n\n        virBufferFreeAndReset(&buff);\n\n        ret = ssh_userauth_kbdint(sess->session, NULL, NULL);\n        ++try;\n        if (ret == SSH_AUTH_DENIED && (priv->tries < 0 || try < priv->tries))\n            goto again;\n    }\n\n    if (ret == SSH_AUTH_ERROR) {\n        /* error path */\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_AUTH_FAILED,\n                       _(\"authentication failed: %s\"), errmsg);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirNetLibsshAuthenticateKeyboardInteractive(virNetLibsshSessionPtr sess,\n                                            virNetLibsshAuthMethodPtr priv)\n{\n    int ret;\n    const char *errmsg;\n    int try = 0;\n\n    /* request user's key password */\n    if (!sess->cred || !sess->cred->cb) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"No user interaction callback provided: \"\n                         \"Can't get input from keyboard interactive \"\n                         \"authentication\"));\n        return SSH_AUTH_ERROR;\n    }\n\n again:\n    ret = ssh_userauth_kbdint(sess->session, NULL, NULL);\n    while (ret == SSH_AUTH_INFO) {\n        const char *name, *instruction;\n        int nprompts, iprompt;\n        virBuffer buff = VIR_BUFFER_INITIALIZER;\n\n        name = ssh_userauth_kbdint_getname(sess->session);\n        instruction = ssh_userauth_kbdint_getinstruction(sess->session);\n        nprompts = ssh_userauth_kbdint_getnprompts(sess->session);\n\n        /* compose the main buffer with name and instruction, if present */\n        if (name && name[0])\n            virBufferAddStr(&buff, name);\n        if (instruction && instruction[0]) {\n            if (virBufferUse(&buff) > 0)\n                virBufferAddChar(&buff, '\\n');\n            virBufferAddStr(&buff, instruction);\n        }\n        if (virBufferUse(&buff) > 0)\n            virBufferAddChar(&buff, '\\n');\n\n        for (iprompt = 0; iprompt < nprompts; ++iprompt) {\n            virConnectCredential retr_passphrase;\n            const char *promptStr;\n            int promptStrLen;\n            char echo;\n            char *prompt = NULL;\n            int cred_type;\n\n            /* get the prompt */\n            promptStr = ssh_userauth_kbdint_getprompt(sess->session, iprompt,\n                                                      &echo);\n            promptStrLen = virLengthForPromptString(promptStr);\n\n            cred_type = virCredTypeForPrompt(sess->cred, echo);\n            if (cred_type == -1) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"no suitable callback for input of keyboard \"\n                                 \"response\"));\n                goto prompt_error;\n            }\n\n            /* create the prompt for the user, using the instruction\n             * buffer if specified\n             */\n            if (virBufferUse(&buff) > 0) {\n                virBuffer prompt_buff = VIR_BUFFER_INITIALIZER;\n\n                virBufferAddBuffer(&prompt_buff, &buff);\n                virBufferAdd(&prompt_buff, promptStr, promptStrLen);\n\n                prompt = virBufferContentAndReset(&prompt_buff);\n            } else {\n                prompt = g_strndup(promptStr, promptStrLen);\n            }\n\n            memset(&retr_passphrase, 0, sizeof(virConnectCredential));\n            retr_passphrase.type = cred_type;\n            retr_passphrase.prompt = prompt;\n\n            if (retr_passphrase.type == -1) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"no suitable callback for input of key \"\n                                 \"passphrase\"));\n                goto prompt_error;\n            }\n\n            if (sess->cred->cb(&retr_passphrase, 1, sess->cred->cbdata)) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"failed to retrieve keyboard interactive \"\n                                 \"result: callback has failed\"));\n                goto prompt_error;\n            }\n\n            VIR_FREE(prompt);\n\n            ret = ssh_userauth_kbdint_setanswer(sess->session, iprompt,\n                                                retr_passphrase.result);\n            VIR_DISPOSE_STRING(retr_passphrase.result);\n            if (ret < 0) {\n                errmsg = ssh_get_error(sess->session);\n                virReportError(VIR_ERR_AUTH_FAILED,\n                               _(\"authentication failed: %s\"), errmsg);\n                goto prompt_error;\n            }\n\n            continue;\n\n         prompt_error:\n            VIR_FREE(prompt);\n            virBufferFreeAndReset(&buff);\n            return SSH_AUTH_ERROR;\n        }\n\n        virBufferFreeAndReset(&buff);\n\n        ret = ssh_userauth_kbdint(sess->session, NULL, NULL);\n        ++try;\n        if (ret == SSH_AUTH_DENIED && (priv->tries < 0 || try < priv->tries))\n            goto again;\n    }\n\n    if (ret == SSH_AUTH_ERROR) {\n        /* error path */\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_AUTH_FAILED,\n                       _(\"authentication failed: %s\"), errmsg);\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_userauth_list",
          "args": [
            "sess->session",
            "NULL"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "_(\"Failed to authenticate as 'none': %s\")",
            "errmsg"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_get_error",
          "args": [
            "sess->session"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_userauth_none",
          "args": [
            "sess->session",
            "NULL"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"sess=%p\"",
            "sess"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirNetLibsshAuthenticate(virNetLibsshSessionPtr sess)\n{\n    virNetLibsshAuthMethodPtr auth;\n    bool no_method = false;\n    bool auth_failed = false;\n    const char *errmsg;\n    int ret;\n    int methods;\n    size_t i;\n\n    VIR_DEBUG(\"sess=%p\", sess);\n\n    /* At this point, we can assume there is at least one\n     * authentication method set -- virNetLibsshValidateConfig\n     * already checked that.\n     */\n\n    /* try to authenticate */\n    ret = ssh_userauth_none(sess->session, NULL);\n    if (ret == SSH_AUTH_ERROR) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"Failed to authenticate as 'none': %s\"),\n                       errmsg);\n        return -1;\n    }\n\n    /* obtain list of supported auth methods */\n    methods = ssh_userauth_list(sess->session, NULL);\n\n    for (i = 0; i < sess->nauths; i++) {\n        auth = sess->auths[i];\n\n        if ((methods & auth->ssh_flags) == 0) {\n            no_method = true;\n            continue;\n        }\n\n        ret = SSH_AUTH_DENIED;\n\n        switch (auth->method) {\n        case VIR_NET_LIBSSH_AUTH_KEYBOARD_INTERACTIVE:\n            /* try to authenticate using the keyboard interactive way */\n            ret = virNetLibsshAuthenticateKeyboardInteractive(sess, auth);\n            break;\n        case VIR_NET_LIBSSH_AUTH_AGENT:\n            /* try to authenticate using ssh-agent */\n            ret = ssh_userauth_agent(sess->session, NULL);\n            if (ret == SSH_AUTH_ERROR) {\n                errmsg = ssh_get_error(sess->session);\n                virReportError(VIR_ERR_LIBSSH,\n                               _(\"failed to authenticate using agent: %s\"),\n                               errmsg);\n            }\n            break;\n        case VIR_NET_LIBSSH_AUTH_PRIVKEY:\n            /* try to authenticate using the provided ssh key */\n            ret = virNetLibsshAuthenticatePrivkey(sess, auth);\n            break;\n        case VIR_NET_LIBSSH_AUTH_PASSWORD:\n            /* try to authenticate with password */\n            ret = virNetLibsshAuthenticatePassword(sess, auth);\n            break;\n        }\n\n        if (ret == SSH_AUTH_ERROR) {\n            /* virReportError is called already */\n            return -1;\n        } else if (ret == SSH_AUTH_SUCCESS) {\n            /* authenticated */\n            return 0;\n        }\n\n        auth_failed = true;\n    }\n\n    if (sess->nauths == 1) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to authenticate: %s\"),\n                       errmsg);\n    } else if (no_method && !auth_failed) {\n        virReportError(VIR_ERR_AUTH_FAILED, \"%s\",\n                       _(\"None of the requested authentication methods \"\n                         \"are supported by the server\"));\n    } else {\n        virReportError(VIR_ERR_AUTH_FAILED, \"%s\",\n                       _(\"All provided authentication methods with credentials \"\n                         \"were rejected by the server\"));\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "virNetLibsshAuthenticateKeyboardInteractive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "645-773",
    "snippet": "static int\nvirNetLibsshAuthenticateKeyboardInteractive(virNetLibsshSessionPtr sess,\n                                            virNetLibsshAuthMethodPtr priv)\n{\n    int ret;\n    const char *errmsg;\n    int try = 0;\n\n    /* request user's key password */\n    if (!sess->cred || !sess->cred->cb) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"No user interaction callback provided: \"\n                         \"Can't get input from keyboard interactive \"\n                         \"authentication\"));\n        return SSH_AUTH_ERROR;\n    }\n\n again:\n    ret = ssh_userauth_kbdint(sess->session, NULL, NULL);\n    while (ret == SSH_AUTH_INFO) {\n        const char *name, *instruction;\n        int nprompts, iprompt;\n        virBuffer buff = VIR_BUFFER_INITIALIZER;\n\n        name = ssh_userauth_kbdint_getname(sess->session);\n        instruction = ssh_userauth_kbdint_getinstruction(sess->session);\n        nprompts = ssh_userauth_kbdint_getnprompts(sess->session);\n\n        /* compose the main buffer with name and instruction, if present */\n        if (name && name[0])\n            virBufferAddStr(&buff, name);\n        if (instruction && instruction[0]) {\n            if (virBufferUse(&buff) > 0)\n                virBufferAddChar(&buff, '\\n');\n            virBufferAddStr(&buff, instruction);\n        }\n        if (virBufferUse(&buff) > 0)\n            virBufferAddChar(&buff, '\\n');\n\n        for (iprompt = 0; iprompt < nprompts; ++iprompt) {\n            virConnectCredential retr_passphrase;\n            const char *promptStr;\n            int promptStrLen;\n            char echo;\n            char *prompt = NULL;\n            int cred_type;\n\n            /* get the prompt */\n            promptStr = ssh_userauth_kbdint_getprompt(sess->session, iprompt,\n                                                      &echo);\n            promptStrLen = virLengthForPromptString(promptStr);\n\n            cred_type = virCredTypeForPrompt(sess->cred, echo);\n            if (cred_type == -1) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"no suitable callback for input of keyboard \"\n                                 \"response\"));\n                goto prompt_error;\n            }\n\n            /* create the prompt for the user, using the instruction\n             * buffer if specified\n             */\n            if (virBufferUse(&buff) > 0) {\n                virBuffer prompt_buff = VIR_BUFFER_INITIALIZER;\n\n                virBufferAddBuffer(&prompt_buff, &buff);\n                virBufferAdd(&prompt_buff, promptStr, promptStrLen);\n\n                prompt = virBufferContentAndReset(&prompt_buff);\n            } else {\n                prompt = g_strndup(promptStr, promptStrLen);\n            }\n\n            memset(&retr_passphrase, 0, sizeof(virConnectCredential));\n            retr_passphrase.type = cred_type;\n            retr_passphrase.prompt = prompt;\n\n            if (retr_passphrase.type == -1) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"no suitable callback for input of key \"\n                                 \"passphrase\"));\n                goto prompt_error;\n            }\n\n            if (sess->cred->cb(&retr_passphrase, 1, sess->cred->cbdata)) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"failed to retrieve keyboard interactive \"\n                                 \"result: callback has failed\"));\n                goto prompt_error;\n            }\n\n            VIR_FREE(prompt);\n\n            ret = ssh_userauth_kbdint_setanswer(sess->session, iprompt,\n                                                retr_passphrase.result);\n            VIR_DISPOSE_STRING(retr_passphrase.result);\n            if (ret < 0) {\n                errmsg = ssh_get_error(sess->session);\n                virReportError(VIR_ERR_AUTH_FAILED,\n                               _(\"authentication failed: %s\"), errmsg);\n                goto prompt_error;\n            }\n\n            continue;\n\n         prompt_error:\n            VIR_FREE(prompt);\n            virBufferFreeAndReset(&buff);\n            return SSH_AUTH_ERROR;\n        }\n\n        virBufferFreeAndReset(&buff);\n\n        ret = ssh_userauth_kbdint(sess->session, NULL, NULL);\n        ++try;\n        if (ret == SSH_AUTH_DENIED && (priv->tries < 0 || try < priv->tries))\n            goto again;\n    }\n\n    if (ret == SSH_AUTH_ERROR) {\n        /* error path */\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_AUTH_FAILED,\n                       _(\"authentication failed: %s\"), errmsg);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_AUTH_FAILED",
            "_(\"authentication failed: %s\")",
            "errmsg"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"authentication failed: %s\""
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_get_error",
          "args": [
            "sess->session"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_userauth_kbdint",
          "args": [
            "sess->session",
            "NULL",
            "NULL"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buff"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "prompt"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_AUTH_FAILED",
            "_(\"authentication failed: %s\")",
            "errmsg"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_get_error",
          "args": [
            "sess->session"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DISPOSE_STRING",
          "args": [
            "retr_passphrase.result"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_userauth_kbdint_setanswer",
          "args": [
            "sess->session",
            "iprompt",
            "retr_passphrase.result"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "prompt"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"failed to retrieve keyboard interactive \"\n                                 \"result: callback has failed\")"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sess->cred->cb",
          "args": [
            "&retr_passphrase",
            "1",
            "sess->cred->cbdata"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"no suitable callback for input of key \"\n                                 \"passphrase\")"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&retr_passphrase",
            "0",
            "sizeof(virConnectCredential)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "promptStr",
            "promptStrLen"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&prompt_buff"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "&prompt_buff",
            "promptStr",
            "promptStrLen"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddBuffer",
          "args": [
            "&prompt_buff",
            "&buff"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "182-196",
          "snippet": "void\nvirBufferAddBuffer(virBufferPtr buf, virBufferPtr toadd)\n{\n    if (!toadd || !toadd->str)\n        return;\n\n    if (!buf)\n        goto cleanup;\n\n    virBufferInitialize(buf);\n    g_string_append_len(buf->str, toadd->str->str, toadd->str->len);\n\n cleanup:\n    virBufferFreeAndReset(toadd);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddBuffer(virBufferPtr buf, virBufferPtr toadd)\n{\n    if (!toadd || !toadd->str)\n        return;\n\n    if (!buf)\n        goto cleanup;\n\n    virBufferInitialize(buf);\n    g_string_append_len(buf->str, toadd->str->str, toadd->str->len);\n\n cleanup:\n    virBufferFreeAndReset(toadd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferUse",
          "args": [
            "&buff"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferUse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "285-292",
          "snippet": "size_t\nvirBufferUse(const virBuffer *buf)\n{\n    if (!buf || !buf->str)\n        return 0;\n\n    return buf->str->len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nsize_t\nvirBufferUse(const virBuffer *buf)\n{\n    if (!buf || !buf->str)\n        return 0;\n\n    return buf->str->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"no suitable callback for input of keyboard \"\n                                 \"response\")"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCredTypeForPrompt",
          "args": [
            "sess->cred",
            "echo"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "virCredTypeForPrompt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "237-256",
          "snippet": "static int\nvirCredTypeForPrompt(virConnectAuthPtr cred, char echo)\n{\n    size_t i;\n\n    for (i = 0; i < cred->ncredtype; ++i) {\n        int type = cred->credtype[i];\n        if (echo) {\n            if (type == VIR_CRED_ECHOPROMPT)\n                return type;\n        } else {\n            if (type == VIR_CRED_PASSPHRASE ||\n                type == VIR_CRED_NOECHOPROMPT) {\n                return type;\n            }\n        }\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirCredTypeForPrompt(virConnectAuthPtr cred, char echo)\n{\n    size_t i;\n\n    for (i = 0; i < cred->ncredtype; ++i) {\n        int type = cred->credtype[i];\n        if (echo) {\n            if (type == VIR_CRED_ECHOPROMPT)\n                return type;\n        } else {\n            if (type == VIR_CRED_PASSPHRASE ||\n                type == VIR_CRED_NOECHOPROMPT) {\n                return type;\n            }\n        }\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLengthForPromptString",
          "args": [
            "promptStr"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "virLengthForPromptString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "258-267",
          "snippet": "static int\nvirLengthForPromptString(const char *str)\n{\n    int len = strlen(str);\n\n    while (len > 0 && (str[len-1] == ' ' || str[len-1] == ':'))\n        --len;\n\n    return len;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirLengthForPromptString(const char *str)\n{\n    int len = strlen(str);\n\n    while (len > 0 && (str[len-1] == ' ' || str[len-1] == ':'))\n        --len;\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_userauth_kbdint_getprompt",
          "args": [
            "sess->session",
            "iprompt",
            "&echo"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddChar",
          "args": [
            "&buff",
            "'\\n'"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "206-210",
          "snippet": "void\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddStr",
          "args": [
            "&buff",
            "instruction"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "718-736",
          "snippet": "void\nvirBufferAddStr(virBufferPtr buf,\n                const char *str)\n{\n    const char *end;\n\n    if (!buf || !str)\n        return;\n\n    while (*str) {\n        if ((end = strchr(str, '\\n'))) {\n            virBufferAdd(buf, str, (end - str) + 1);\n            str = end + 1;\n        } else {\n            virBufferAdd(buf, str, -1);\n            break;\n        }\n    }\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddStr(virBufferPtr buf,\n                const char *str)\n{\n    const char *end;\n\n    if (!buf || !str)\n        return;\n\n    while (*str) {\n        if ((end = strchr(str, '\\n'))) {\n            virBufferAdd(buf, str, (end - str) + 1);\n            str = end + 1;\n        } else {\n            virBufferAdd(buf, str, -1);\n            break;\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_userauth_kbdint_getnprompts",
          "args": [
            "sess->session"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_userauth_kbdint_getinstruction",
          "args": [
            "sess->session"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_userauth_kbdint_getname",
          "args": [
            "sess->session"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_userauth_kbdint",
          "args": [
            "sess->session",
            "NULL",
            "NULL"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"No user interaction callback provided: \"\n                         \"Can't get input from keyboard interactive \"\n                         \"authentication\")"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirNetLibsshAuthenticateKeyboardInteractive(virNetLibsshSessionPtr sess,\n                                            virNetLibsshAuthMethodPtr priv)\n{\n    int ret;\n    const char *errmsg;\n    int try = 0;\n\n    /* request user's key password */\n    if (!sess->cred || !sess->cred->cb) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"No user interaction callback provided: \"\n                         \"Can't get input from keyboard interactive \"\n                         \"authentication\"));\n        return SSH_AUTH_ERROR;\n    }\n\n again:\n    ret = ssh_userauth_kbdint(sess->session, NULL, NULL);\n    while (ret == SSH_AUTH_INFO) {\n        const char *name, *instruction;\n        int nprompts, iprompt;\n        virBuffer buff = VIR_BUFFER_INITIALIZER;\n\n        name = ssh_userauth_kbdint_getname(sess->session);\n        instruction = ssh_userauth_kbdint_getinstruction(sess->session);\n        nprompts = ssh_userauth_kbdint_getnprompts(sess->session);\n\n        /* compose the main buffer with name and instruction, if present */\n        if (name && name[0])\n            virBufferAddStr(&buff, name);\n        if (instruction && instruction[0]) {\n            if (virBufferUse(&buff) > 0)\n                virBufferAddChar(&buff, '\\n');\n            virBufferAddStr(&buff, instruction);\n        }\n        if (virBufferUse(&buff) > 0)\n            virBufferAddChar(&buff, '\\n');\n\n        for (iprompt = 0; iprompt < nprompts; ++iprompt) {\n            virConnectCredential retr_passphrase;\n            const char *promptStr;\n            int promptStrLen;\n            char echo;\n            char *prompt = NULL;\n            int cred_type;\n\n            /* get the prompt */\n            promptStr = ssh_userauth_kbdint_getprompt(sess->session, iprompt,\n                                                      &echo);\n            promptStrLen = virLengthForPromptString(promptStr);\n\n            cred_type = virCredTypeForPrompt(sess->cred, echo);\n            if (cred_type == -1) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"no suitable callback for input of keyboard \"\n                                 \"response\"));\n                goto prompt_error;\n            }\n\n            /* create the prompt for the user, using the instruction\n             * buffer if specified\n             */\n            if (virBufferUse(&buff) > 0) {\n                virBuffer prompt_buff = VIR_BUFFER_INITIALIZER;\n\n                virBufferAddBuffer(&prompt_buff, &buff);\n                virBufferAdd(&prompt_buff, promptStr, promptStrLen);\n\n                prompt = virBufferContentAndReset(&prompt_buff);\n            } else {\n                prompt = g_strndup(promptStr, promptStrLen);\n            }\n\n            memset(&retr_passphrase, 0, sizeof(virConnectCredential));\n            retr_passphrase.type = cred_type;\n            retr_passphrase.prompt = prompt;\n\n            if (retr_passphrase.type == -1) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"no suitable callback for input of key \"\n                                 \"passphrase\"));\n                goto prompt_error;\n            }\n\n            if (sess->cred->cb(&retr_passphrase, 1, sess->cred->cbdata)) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"failed to retrieve keyboard interactive \"\n                                 \"result: callback has failed\"));\n                goto prompt_error;\n            }\n\n            VIR_FREE(prompt);\n\n            ret = ssh_userauth_kbdint_setanswer(sess->session, iprompt,\n                                                retr_passphrase.result);\n            VIR_DISPOSE_STRING(retr_passphrase.result);\n            if (ret < 0) {\n                errmsg = ssh_get_error(sess->session);\n                virReportError(VIR_ERR_AUTH_FAILED,\n                               _(\"authentication failed: %s\"), errmsg);\n                goto prompt_error;\n            }\n\n            continue;\n\n         prompt_error:\n            VIR_FREE(prompt);\n            virBufferFreeAndReset(&buff);\n            return SSH_AUTH_ERROR;\n        }\n\n        virBufferFreeAndReset(&buff);\n\n        ret = ssh_userauth_kbdint(sess->session, NULL, NULL);\n        ++try;\n        if (ret == SSH_AUTH_DENIED && (priv->tries < 0 || try < priv->tries))\n            goto again;\n    }\n\n    if (ret == SSH_AUTH_ERROR) {\n        /* error path */\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_AUTH_FAILED,\n                       _(\"authentication failed: %s\"), errmsg);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetLibsshAuthenticatePassword",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "591-639",
    "snippet": "static int\nvirNetLibsshAuthenticatePassword(virNetLibsshSessionPtr sess,\n                                 virNetLibsshAuthMethodPtr priv)\n{\n    const char *errmsg;\n    int rc = SSH_AUTH_ERROR;\n\n    VIR_DEBUG(\"sess=%p\", sess);\n\n    if (priv->password) {\n        /* tunelled password authentication */\n        if ((rc = ssh_userauth_password(sess->session, NULL,\n                                        priv->password)) == 0)\n            return SSH_AUTH_SUCCESS;\n    } else {\n        /* password authentication with interactive password request */\n        if (!sess->cred || !sess->cred->cb) {\n            virReportError(VIR_ERR_LIBSSH, \"%s\",\n                           _(\"Can't perform authentication: \"\n                             \"Authentication callback not provided\"));\n            return SSH_AUTH_ERROR;\n        }\n\n        /* Try the authenticating the set amount of times. The server breaks the\n         * connection if maximum number of bad auth tries is exceeded */\n        while (true) {\n            VIR_AUTODISPOSE_STR password = NULL;\n\n            if (!(password = virAuthGetPasswordPath(sess->authPath, sess->cred,\n                                                    \"ssh\", sess->username,\n                                                    sess->hostname)))\n                return SSH_AUTH_ERROR;\n\n            /* tunelled password authentication */\n            if ((rc = ssh_userauth_password(sess->session, NULL,\n                                            password)) == 0)\n                return SSH_AUTH_SUCCESS;\n\n            if (rc != SSH_AUTH_DENIED)\n                break;\n        }\n    }\n\n    /* error path */\n    errmsg = ssh_get_error(sess->session);\n    virReportError(VIR_ERR_AUTH_FAILED,\n                   _(\"authentication failed: %s\"), errmsg);\n    return rc;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_AUTH_FAILED",
            "_(\"authentication failed: %s\")",
            "errmsg"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"authentication failed: %s\""
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_get_error",
          "args": [
            "sess->session"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_userauth_password",
          "args": [
            "sess->session",
            "NULL",
            "password"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virAuthGetPasswordPath",
          "args": [
            "sess->authPath",
            "sess->cred",
            "\"ssh\"",
            "sess->username",
            "sess->hostname"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "virAuthGetPasswordPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virauth.c",
          "lines": "214-273",
          "snippet": "char *\nvirAuthGetPasswordPath(const char *path,\n                       virConnectAuthPtr auth,\n                       const char *servicename,\n                       const char *username,\n                       const char *hostname)\n{\n    unsigned int ncred;\n    virConnectCredential cred;\n    g_autofree char *prompt = NULL;\n    char *ret = NULL;\n\n    if (virAuthGetCredential(servicename, hostname, \"password\", path, &ret) < 0)\n        return NULL;\n    if (ret != NULL)\n        return ret;\n\n    if (!auth) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Missing authentication credentials\"));\n        return NULL;\n    }\n\n    memset(&cred, 0, sizeof(virConnectCredential));\n\n    prompt = g_strdup_printf(_(\"Enter %s's password for %s\"), username, hostname);\n\n    for (ncred = 0; ncred < auth->ncredtype; ncred++) {\n        if (auth->credtype[ncred] != VIR_CRED_PASSPHRASE &&\n            auth->credtype[ncred] != VIR_CRED_NOECHOPROMPT) {\n            continue;\n        }\n\n        if (!auth->cb) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"Missing authentication callback\"));\n            return NULL;\n        }\n\n        cred.type = auth->credtype[ncred];\n        cred.prompt = prompt;\n        cred.challenge = hostname;\n        cred.defresult = NULL;\n        cred.result = NULL;\n        cred.resultlen = 0;\n\n        if ((*(auth->cb))(&cred, 1, auth->cbdata) < 0) {\n            virReportError(VIR_ERR_AUTH_FAILED, \"%s\",\n                           _(\"Password request failed\"));\n            VIR_FREE(cred.result);\n        }\n\n        return cred.result;\n    }\n\n    virReportError(VIR_ERR_AUTH_FAILED, \"%s\",\n                   _(\"Missing VIR_CRED_PASSPHRASE or VIR_CRED_NOECHOPROMPT \"\n                     \"credential type\"));\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virauthconfig.h\"",
            "#include \"configmake.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virauthconfig.h\"\n#include \"configmake.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include <config.h>\n\nchar *\nvirAuthGetPasswordPath(const char *path,\n                       virConnectAuthPtr auth,\n                       const char *servicename,\n                       const char *username,\n                       const char *hostname)\n{\n    unsigned int ncred;\n    virConnectCredential cred;\n    g_autofree char *prompt = NULL;\n    char *ret = NULL;\n\n    if (virAuthGetCredential(servicename, hostname, \"password\", path, &ret) < 0)\n        return NULL;\n    if (ret != NULL)\n        return ret;\n\n    if (!auth) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Missing authentication credentials\"));\n        return NULL;\n    }\n\n    memset(&cred, 0, sizeof(virConnectCredential));\n\n    prompt = g_strdup_printf(_(\"Enter %s's password for %s\"), username, hostname);\n\n    for (ncred = 0; ncred < auth->ncredtype; ncred++) {\n        if (auth->credtype[ncred] != VIR_CRED_PASSPHRASE &&\n            auth->credtype[ncred] != VIR_CRED_NOECHOPROMPT) {\n            continue;\n        }\n\n        if (!auth->cb) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"Missing authentication callback\"));\n            return NULL;\n        }\n\n        cred.type = auth->credtype[ncred];\n        cred.prompt = prompt;\n        cred.challenge = hostname;\n        cred.defresult = NULL;\n        cred.result = NULL;\n        cred.resultlen = 0;\n\n        if ((*(auth->cb))(&cred, 1, auth->cbdata) < 0) {\n            virReportError(VIR_ERR_AUTH_FAILED, \"%s\",\n                           _(\"Password request failed\"));\n            VIR_FREE(cred.result);\n        }\n\n        return cred.result;\n    }\n\n    virReportError(VIR_ERR_AUTH_FAILED, \"%s\",\n                   _(\"Missing VIR_CRED_PASSPHRASE or VIR_CRED_NOECHOPROMPT \"\n                     \"credential type\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"Can't perform authentication: \"\n                             \"Authentication callback not provided\")"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_userauth_password",
          "args": [
            "sess->session",
            "NULL",
            "priv->password"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"sess=%p\"",
            "sess"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirNetLibsshAuthenticatePassword(virNetLibsshSessionPtr sess,\n                                 virNetLibsshAuthMethodPtr priv)\n{\n    const char *errmsg;\n    int rc = SSH_AUTH_ERROR;\n\n    VIR_DEBUG(\"sess=%p\", sess);\n\n    if (priv->password) {\n        /* tunelled password authentication */\n        if ((rc = ssh_userauth_password(sess->session, NULL,\n                                        priv->password)) == 0)\n            return SSH_AUTH_SUCCESS;\n    } else {\n        /* password authentication with interactive password request */\n        if (!sess->cred || !sess->cred->cb) {\n            virReportError(VIR_ERR_LIBSSH, \"%s\",\n                           _(\"Can't perform authentication: \"\n                             \"Authentication callback not provided\"));\n            return SSH_AUTH_ERROR;\n        }\n\n        /* Try the authenticating the set amount of times. The server breaks the\n         * connection if maximum number of bad auth tries is exceeded */\n        while (true) {\n            VIR_AUTODISPOSE_STR password = NULL;\n\n            if (!(password = virAuthGetPasswordPath(sess->authPath, sess->cred,\n                                                    \"ssh\", sess->username,\n                                                    sess->hostname)))\n                return SSH_AUTH_ERROR;\n\n            /* tunelled password authentication */\n            if ((rc = ssh_userauth_password(sess->session, NULL,\n                                            password)) == 0)\n                return SSH_AUTH_SUCCESS;\n\n            if (rc != SSH_AUTH_DENIED)\n                break;\n        }\n    }\n\n    /* error path */\n    errmsg = ssh_get_error(sess->session);\n    virReportError(VIR_ERR_AUTH_FAILED,\n                   _(\"authentication failed: %s\"), errmsg);\n    return rc;\n}"
  },
  {
    "function_name": "virNetLibsshAuthenticatePrivkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "511-584",
    "snippet": "static int\nvirNetLibsshAuthenticatePrivkey(virNetLibsshSessionPtr sess,\n                                virNetLibsshAuthMethodPtr priv)\n{\n    int err;\n    int ret;\n    char *tmp = NULL;\n    ssh_key public_key = NULL;\n    ssh_key private_key = NULL;\n\n    VIR_DEBUG(\"sess=%p\", sess);\n\n    tmp = g_strdup_printf(\"%s.pub\", priv->filename);\n\n    /* try to open the public part of the private key */\n    ret = ssh_pki_import_pubkey_file(tmp, &public_key);\n    if (ret == SSH_ERROR) {\n        virReportError(VIR_ERR_AUTH_FAILED,\n                       _(\"error while reading public key '%s'\"),\n                       tmp);\n        err = SSH_AUTH_ERROR;\n        goto error;\n    } else if (ret == SSH_EOF) {\n        /* load the private key */\n        err = virNetLibsshImportPrivkey(sess, priv, &private_key);\n        if (err != SSH_AUTH_SUCCESS)\n            goto error;\n\n        /* create the public key from the private key */\n        ret = ssh_pki_export_privkey_to_pubkey(private_key, &public_key);\n        if (ret == SSH_ERROR) {\n            virReportError(VIR_ERR_AUTH_FAILED,\n                           _(\"cannot export the public key from the \"\n                             \"private key '%s'\"),\n                           priv->filename);\n            err = SSH_AUTH_ERROR;\n            goto error;\n        }\n    }\n\n    VIR_FREE(tmp);\n\n    ret = ssh_userauth_try_publickey(sess->session, NULL, public_key);\n    if (ret != SSH_AUTH_SUCCESS) {\n        err = SSH_AUTH_DENIED;\n        goto error;\n    }\n\n    /* load the private key, if it was not loaded yet */\n    if (private_key == NULL) {\n        err = virNetLibsshImportPrivkey(sess, priv, &private_key);\n        if (err != SSH_AUTH_SUCCESS)\n            goto error;\n    }\n\n    ret = ssh_userauth_publickey(sess->session, NULL, private_key);\n    if (ret != SSH_AUTH_SUCCESS) {\n        err = SSH_AUTH_DENIED;\n        goto error;\n    }\n\n    ssh_key_free(private_key);\n    ssh_key_free(public_key);\n\n    return SSH_AUTH_SUCCESS;\n\n error:\n    if (private_key)\n        ssh_key_free(private_key);\n    if (public_key)\n        ssh_key_free(public_key);\n    VIR_FREE(tmp);\n    return err;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_key_free",
          "args": [
            "public_key"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_key_free",
          "args": [
            "private_key"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_key_free",
          "args": [
            "public_key"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_key_free",
          "args": [
            "private_key"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_userauth_publickey",
          "args": [
            "sess->session",
            "NULL",
            "private_key"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetLibsshImportPrivkey",
          "args": [
            "sess",
            "priv",
            "&private_key"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshImportPrivkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "464-504",
          "snippet": "static int\nvirNetLibsshImportPrivkey(virNetLibsshSessionPtr sess,\n                          virNetLibsshAuthMethodPtr priv,\n                          ssh_key *ret_key)\n{\n    int err;\n    int ret;\n    ssh_key key;\n\n    /* try open the key with the password set, first; since it can\n     * fail with SSH_ERROR also without the callback being called,\n     * reset the error so it is possible to check whether the callback\n     * failed or libssh did.\n     */\n    virResetLastError();\n    ret = ssh_pki_import_privkey_file(priv->filename, priv->password,\n                                      virNetLibsshAuthenticatePrivkeyCb,\n                                      sess, &key);\n    if (ret == SSH_EOF) {\n        virReportError(VIR_ERR_AUTH_FAILED,\n                       _(\"error while reading private key '%s'\"),\n                       priv->filename);\n        err = SSH_AUTH_ERROR;\n        goto error;\n    } else if (ret == SSH_ERROR) {\n        if (virGetLastErrorCode() == VIR_ERR_OK) {\n            virReportError(VIR_ERR_AUTH_FAILED,\n                           _(\"error while opening private key '%s', wrong \"\n                             \"passphrase?\"),\n                           priv->filename);\n        }\n        err = SSH_AUTH_ERROR;\n        goto error;\n    }\n\n    *ret_key = key;\n    return SSH_AUTH_SUCCESS;\n\n error:\n    return err;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirNetLibsshImportPrivkey(virNetLibsshSessionPtr sess,\n                          virNetLibsshAuthMethodPtr priv,\n                          ssh_key *ret_key)\n{\n    int err;\n    int ret;\n    ssh_key key;\n\n    /* try open the key with the password set, first; since it can\n     * fail with SSH_ERROR also without the callback being called,\n     * reset the error so it is possible to check whether the callback\n     * failed or libssh did.\n     */\n    virResetLastError();\n    ret = ssh_pki_import_privkey_file(priv->filename, priv->password,\n                                      virNetLibsshAuthenticatePrivkeyCb,\n                                      sess, &key);\n    if (ret == SSH_EOF) {\n        virReportError(VIR_ERR_AUTH_FAILED,\n                       _(\"error while reading private key '%s'\"),\n                       priv->filename);\n        err = SSH_AUTH_ERROR;\n        goto error;\n    } else if (ret == SSH_ERROR) {\n        if (virGetLastErrorCode() == VIR_ERR_OK) {\n            virReportError(VIR_ERR_AUTH_FAILED,\n                           _(\"error while opening private key '%s', wrong \"\n                             \"passphrase?\"),\n                           priv->filename);\n        }\n        err = SSH_AUTH_ERROR;\n        goto error;\n    }\n\n    *ret_key = key;\n    return SSH_AUTH_SUCCESS;\n\n error:\n    return err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_userauth_try_publickey",
          "args": [
            "sess->session",
            "NULL",
            "public_key"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_AUTH_FAILED",
            "_(\"cannot export the public key from the \"\n                             \"private key '%s'\")",
            "priv->filename"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot export the public key from the \"\n                             \"private key '%s'\""
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_pki_export_privkey_to_pubkey",
          "args": [
            "private_key",
            "&public_key"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_AUTH_FAILED",
            "_(\"error while reading public key '%s'\")",
            "tmp"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_pki_import_pubkey_file",
          "args": [
            "tmp",
            "&public_key"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"sess=%p\"",
            "sess"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirNetLibsshAuthenticatePrivkey(virNetLibsshSessionPtr sess,\n                                virNetLibsshAuthMethodPtr priv)\n{\n    int err;\n    int ret;\n    char *tmp = NULL;\n    ssh_key public_key = NULL;\n    ssh_key private_key = NULL;\n\n    VIR_DEBUG(\"sess=%p\", sess);\n\n    tmp = g_strdup_printf(\"%s.pub\", priv->filename);\n\n    /* try to open the public part of the private key */\n    ret = ssh_pki_import_pubkey_file(tmp, &public_key);\n    if (ret == SSH_ERROR) {\n        virReportError(VIR_ERR_AUTH_FAILED,\n                       _(\"error while reading public key '%s'\"),\n                       tmp);\n        err = SSH_AUTH_ERROR;\n        goto error;\n    } else if (ret == SSH_EOF) {\n        /* load the private key */\n        err = virNetLibsshImportPrivkey(sess, priv, &private_key);\n        if (err != SSH_AUTH_SUCCESS)\n            goto error;\n\n        /* create the public key from the private key */\n        ret = ssh_pki_export_privkey_to_pubkey(private_key, &public_key);\n        if (ret == SSH_ERROR) {\n            virReportError(VIR_ERR_AUTH_FAILED,\n                           _(\"cannot export the public key from the \"\n                             \"private key '%s'\"),\n                           priv->filename);\n            err = SSH_AUTH_ERROR;\n            goto error;\n        }\n    }\n\n    VIR_FREE(tmp);\n\n    ret = ssh_userauth_try_publickey(sess->session, NULL, public_key);\n    if (ret != SSH_AUTH_SUCCESS) {\n        err = SSH_AUTH_DENIED;\n        goto error;\n    }\n\n    /* load the private key, if it was not loaded yet */\n    if (private_key == NULL) {\n        err = virNetLibsshImportPrivkey(sess, priv, &private_key);\n        if (err != SSH_AUTH_SUCCESS)\n            goto error;\n    }\n\n    ret = ssh_userauth_publickey(sess->session, NULL, private_key);\n    if (ret != SSH_AUTH_SUCCESS) {\n        err = SSH_AUTH_DENIED;\n        goto error;\n    }\n\n    ssh_key_free(private_key);\n    ssh_key_free(public_key);\n\n    return SSH_AUTH_SUCCESS;\n\n error:\n    if (private_key)\n        ssh_key_free(private_key);\n    if (public_key)\n        ssh_key_free(public_key);\n    VIR_FREE(tmp);\n    return err;\n}"
  },
  {
    "function_name": "virNetLibsshImportPrivkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "464-504",
    "snippet": "static int\nvirNetLibsshImportPrivkey(virNetLibsshSessionPtr sess,\n                          virNetLibsshAuthMethodPtr priv,\n                          ssh_key *ret_key)\n{\n    int err;\n    int ret;\n    ssh_key key;\n\n    /* try open the key with the password set, first; since it can\n     * fail with SSH_ERROR also without the callback being called,\n     * reset the error so it is possible to check whether the callback\n     * failed or libssh did.\n     */\n    virResetLastError();\n    ret = ssh_pki_import_privkey_file(priv->filename, priv->password,\n                                      virNetLibsshAuthenticatePrivkeyCb,\n                                      sess, &key);\n    if (ret == SSH_EOF) {\n        virReportError(VIR_ERR_AUTH_FAILED,\n                       _(\"error while reading private key '%s'\"),\n                       priv->filename);\n        err = SSH_AUTH_ERROR;\n        goto error;\n    } else if (ret == SSH_ERROR) {\n        if (virGetLastErrorCode() == VIR_ERR_OK) {\n            virReportError(VIR_ERR_AUTH_FAILED,\n                           _(\"error while opening private key '%s', wrong \"\n                             \"passphrase?\"),\n                           priv->filename);\n        }\n        err = SSH_AUTH_ERROR;\n        goto error;\n    }\n\n    *ret_key = key;\n    return SSH_AUTH_SUCCESS;\n\n error:\n    return err;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_AUTH_FAILED",
            "_(\"error while opening private key '%s', wrong \"\n                             \"passphrase?\")",
            "priv->filename"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"error while opening private key '%s', wrong \"\n                             \"passphrase?\""
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetLastErrorCode",
          "args": [],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorCode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "280-287",
          "snippet": "int\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_AUTH_FAILED",
            "_(\"error while reading private key '%s'\")",
            "priv->filename"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_pki_import_privkey_file",
          "args": [
            "priv->filename",
            "priv->password",
            "virNetLibsshAuthenticatePrivkeyCb",
            "sess",
            "&key"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirNetLibsshImportPrivkey(virNetLibsshSessionPtr sess,\n                          virNetLibsshAuthMethodPtr priv,\n                          ssh_key *ret_key)\n{\n    int err;\n    int ret;\n    ssh_key key;\n\n    /* try open the key with the password set, first; since it can\n     * fail with SSH_ERROR also without the callback being called,\n     * reset the error so it is possible to check whether the callback\n     * failed or libssh did.\n     */\n    virResetLastError();\n    ret = ssh_pki_import_privkey_file(priv->filename, priv->password,\n                                      virNetLibsshAuthenticatePrivkeyCb,\n                                      sess, &key);\n    if (ret == SSH_EOF) {\n        virReportError(VIR_ERR_AUTH_FAILED,\n                       _(\"error while reading private key '%s'\"),\n                       priv->filename);\n        err = SSH_AUTH_ERROR;\n        goto error;\n    } else if (ret == SSH_ERROR) {\n        if (virGetLastErrorCode() == VIR_ERR_OK) {\n            virReportError(VIR_ERR_AUTH_FAILED,\n                           _(\"error while opening private key '%s', wrong \"\n                             \"passphrase?\"),\n                           priv->filename);\n        }\n        err = SSH_AUTH_ERROR;\n        goto error;\n    }\n\n    *ret_key = key;\n    return SSH_AUTH_SUCCESS;\n\n error:\n    return err;\n}"
  },
  {
    "function_name": "virNetLibsshAuthenticatePrivkeyCb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "404-462",
    "snippet": "static int\nvirNetLibsshAuthenticatePrivkeyCb(const char *prompt,\n                                  char *buf,\n                                  size_t len,\n                                  int echo,\n                                  int verify G_GNUC_UNUSED,\n                                  void *userdata)\n{\n    virNetLibsshSessionPtr sess = userdata;\n    virConnectCredential retr_passphrase;\n    int cred_type;\n    char *actual_prompt = NULL;\n    int p;\n\n    /* request user's key password */\n    if (!sess->cred || !sess->cred->cb) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"No user interaction callback provided: \"\n                         \"Can't retrieve private key passphrase\"));\n        return -1;\n    }\n\n    cred_type = virCredTypeForPrompt(sess->cred, echo);\n    if (cred_type == -1) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"no suitable callback for input of key passphrase\"));\n        goto error;\n    }\n\n    actual_prompt = g_strndup(prompt, virLengthForPromptString(prompt));\n\n    memset(&retr_passphrase, 0, sizeof(virConnectCredential));\n    retr_passphrase.type = cred_type;\n    retr_passphrase.prompt = actual_prompt;\n\n    if (sess->cred->cb(&retr_passphrase, 1, sess->cred->cbdata)) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"failed to retrieve private key passphrase: \"\n                         \"callback has failed\"));\n        goto error;\n    }\n\n    p = virStrncpy(buf, retr_passphrase.result,\n                   retr_passphrase.resultlen, len);\n    VIR_DISPOSE_STRING(retr_passphrase.result);\n    if (p < 0) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"passphrase is too long for the buffer\"));\n        goto error;\n    }\n\n    VIR_FREE(actual_prompt);\n\n    return 0;\n\n error:\n    VIR_FREE(actual_prompt);\n    return -1;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "actual_prompt"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "actual_prompt"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"passphrase is too long for the buffer\")"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"passphrase is too long for the buffer\""
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DISPOSE_STRING",
          "args": [
            "retr_passphrase.result"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrncpy",
          "args": [
            "buf",
            "retr_passphrase.result",
            "retr_passphrase.resultlen",
            "len"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "virStrncpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "746-765",
          "snippet": "int\nvirStrncpy(char *dest, const char *src, size_t n, size_t destbytes)\n{\n    size_t src_len = strlen(src);\n\n    /* As a special case, -1 means \"copy the entire string\".\n     *\n     * This is to avoid calling strlen() twice, once in the virStrcpy()\n     * wrapper and once here for bound checking purposes. */\n    if (n == -1)\n        n = src_len;\n\n    if (n > src_len || n > (destbytes - 1))\n        return -1;\n\n    memcpy(dest, src, n);\n    dest[n] = '\\0';\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrncpy(char *dest, const char *src, size_t n, size_t destbytes)\n{\n    size_t src_len = strlen(src);\n\n    /* As a special case, -1 means \"copy the entire string\".\n     *\n     * This is to avoid calling strlen() twice, once in the virStrcpy()\n     * wrapper and once here for bound checking purposes. */\n    if (n == -1)\n        n = src_len;\n\n    if (n > src_len || n > (destbytes - 1))\n        return -1;\n\n    memcpy(dest, src, n);\n    dest[n] = '\\0';\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"failed to retrieve private key passphrase: \"\n                         \"callback has failed\")"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sess->cred->cb",
          "args": [
            "&retr_passphrase",
            "1",
            "sess->cred->cbdata"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&retr_passphrase",
            "0",
            "sizeof(virConnectCredential)"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "prompt",
            "virLengthForPromptString(prompt)"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLengthForPromptString",
          "args": [
            "prompt"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "virLengthForPromptString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "258-267",
          "snippet": "static int\nvirLengthForPromptString(const char *str)\n{\n    int len = strlen(str);\n\n    while (len > 0 && (str[len-1] == ' ' || str[len-1] == ':'))\n        --len;\n\n    return len;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirLengthForPromptString(const char *str)\n{\n    int len = strlen(str);\n\n    while (len > 0 && (str[len-1] == ' ' || str[len-1] == ':'))\n        --len;\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"no suitable callback for input of key passphrase\")"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCredTypeForPrompt",
          "args": [
            "sess->cred",
            "echo"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "virCredTypeForPrompt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "237-256",
          "snippet": "static int\nvirCredTypeForPrompt(virConnectAuthPtr cred, char echo)\n{\n    size_t i;\n\n    for (i = 0; i < cred->ncredtype; ++i) {\n        int type = cred->credtype[i];\n        if (echo) {\n            if (type == VIR_CRED_ECHOPROMPT)\n                return type;\n        } else {\n            if (type == VIR_CRED_PASSPHRASE ||\n                type == VIR_CRED_NOECHOPROMPT) {\n                return type;\n            }\n        }\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirCredTypeForPrompt(virConnectAuthPtr cred, char echo)\n{\n    size_t i;\n\n    for (i = 0; i < cred->ncredtype; ++i) {\n        int type = cred->credtype[i];\n        if (echo) {\n            if (type == VIR_CRED_ECHOPROMPT)\n                return type;\n        } else {\n            if (type == VIR_CRED_PASSPHRASE ||\n                type == VIR_CRED_NOECHOPROMPT) {\n                return type;\n            }\n        }\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"No user interaction callback provided: \"\n                         \"Can't retrieve private key passphrase\")"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirNetLibsshAuthenticatePrivkeyCb(const char *prompt,\n                                  char *buf,\n                                  size_t len,\n                                  int echo,\n                                  int verify G_GNUC_UNUSED,\n                                  void *userdata)\n{\n    virNetLibsshSessionPtr sess = userdata;\n    virConnectCredential retr_passphrase;\n    int cred_type;\n    char *actual_prompt = NULL;\n    int p;\n\n    /* request user's key password */\n    if (!sess->cred || !sess->cred->cb) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"No user interaction callback provided: \"\n                         \"Can't retrieve private key passphrase\"));\n        return -1;\n    }\n\n    cred_type = virCredTypeForPrompt(sess->cred, echo);\n    if (cred_type == -1) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"no suitable callback for input of key passphrase\"));\n        goto error;\n    }\n\n    actual_prompt = g_strndup(prompt, virLengthForPromptString(prompt));\n\n    memset(&retr_passphrase, 0, sizeof(virConnectCredential));\n    retr_passphrase.type = cred_type;\n    retr_passphrase.prompt = actual_prompt;\n\n    if (sess->cred->cb(&retr_passphrase, 1, sess->cred->cbdata)) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"failed to retrieve private key passphrase: \"\n                         \"callback has failed\"));\n        goto error;\n    }\n\n    p = virStrncpy(buf, retr_passphrase.result,\n                   retr_passphrase.resultlen, len);\n    VIR_DISPOSE_STRING(retr_passphrase.result);\n    if (p < 0) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"passphrase is too long for the buffer\"));\n        goto error;\n    }\n\n    VIR_FREE(actual_prompt);\n\n    return 0;\n\n error:\n    VIR_FREE(actual_prompt);\n    return -1;\n}"
  },
  {
    "function_name": "virNetLibsshCheckHostKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "276-399",
    "snippet": "static int\nvirNetLibsshCheckHostKey(virNetLibsshSessionPtr sess)\n{\n    int state;\n    char *keyhashstr;\n    const char *errmsg;\n\n    if (sess->hostKeyVerify == VIR_NET_LIBSSH_HOSTKEY_VERIFY_IGNORE)\n        return 0;\n\n    state = ssh_session_is_known_server(sess->session);\n\n    switch (state) {\n    case SSH_SERVER_KNOWN_OK:\n        /* host key matches */\n        return 0;\n\n    case SSH_SERVER_FOUND_OTHER:\n    case SSH_SERVER_KNOWN_CHANGED:\n        keyhashstr = virLibsshServerKeyAsString(sess);\n        if (!keyhashstr)\n            return -1;\n\n        /* host key verification failed */\n        virReportError(VIR_ERR_AUTH_FAILED,\n                       _(\"!!! SSH HOST KEY VERIFICATION FAILED !!!: \"\n                         \"Identity of host '%s:%d' differs from stored identity. \"\n                         \"Please verify the new host key '%s' to avoid possible \"\n                         \"man in the middle attack. The key is stored in '%s'.\"),\n                       sess->hostname, sess->port,\n                       keyhashstr, sess->knownHostsFile);\n\n        ssh_string_free_char(keyhashstr);\n        return -1;\n\n    case SSH_SERVER_FILE_NOT_FOUND:\n    case SSH_SERVER_NOT_KNOWN:\n        /* key was not found, query to add it to database */\n        if (sess->hostKeyVerify == VIR_NET_LIBSSH_HOSTKEY_VERIFY_NORMAL) {\n            virConnectCredential askKey;\n            int cred_type;\n            char *tmp;\n\n            /* ask to add the key */\n            if (!sess->cred || !sess->cred->cb) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"No user interaction callback provided: \"\n                                 \"Can't verify the session host key\"));\n                return -1;\n            }\n\n            cred_type = virCredTypeForPrompt(sess->cred, 1 /* echo */);\n            if (cred_type == -1) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"no suitable callback for host key \"\n                                 \"verification\"));\n                return -1;\n            }\n\n            /* prepare data for the callback */\n            memset(&askKey, 0, sizeof(virConnectCredential));\n            askKey.type = cred_type;\n\n            keyhashstr = virLibsshServerKeyAsString(sess);\n            if (!keyhashstr)\n                return -1;\n\n            tmp = g_strdup_printf(_(\"Accept SSH host key with hash '%s' for \" \"host '%s:%d' (%s/%s)?\"),\n                                  keyhashstr, sess->hostname, sess->port, \"y\", \"n\");\n            askKey.prompt = tmp;\n\n            if (sess->cred->cb(&askKey, 1, sess->cred->cbdata)) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"failed to retrieve decision to accept \"\n                                 \"host key\"));\n                VIR_FREE(tmp);\n                ssh_string_free_char(keyhashstr);\n                return -1;\n            }\n\n            VIR_FREE(tmp);\n\n            if (!askKey.result ||\n                STRCASENEQ(askKey.result, \"y\")) {\n                virReportError(VIR_ERR_LIBSSH,\n                               _(\"SSH host key for '%s' (%s) was not accepted\"),\n                               sess->hostname, keyhashstr);\n                ssh_string_free_char(keyhashstr);\n                VIR_FREE(askKey.result);\n                return -1;\n            }\n            ssh_string_free_char(keyhashstr);\n            VIR_FREE(askKey.result);\n        }\n\n        /* write the host key file, if specified */\n        if (sess->knownHostsFile) {\n            if (ssh_session_update_known_hosts(sess->session) < 0) {\n                errmsg = ssh_get_error(sess->session);\n                virReportError(VIR_ERR_LIBSSH,\n                               _(\"failed to write known_host file '%s': %s\"),\n                               sess->knownHostsFile,\n                               errmsg);\n                return -1;\n            }\n        }\n        /* key was accepted and added */\n        return 0;\n\n    case SSH_SERVER_ERROR:\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to validate SSH host key: %s\"),\n                       errmsg);\n        return -1;\n\n    default: /* should never happen (tm) */\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Unknown state of the remote server SSH key\"));\n        return -1;\n    }\n\n    return -1;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"Unknown state of the remote server SSH key\")"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown state of the remote server SSH key\""
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "_(\"failed to validate SSH host key: %s\")",
            "errmsg"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_get_error",
          "args": [
            "sess->session"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "_(\"failed to write known_host file '%s': %s\")",
            "sess->knownHostsFile",
            "errmsg"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_get_error",
          "args": [
            "sess->session"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_session_update_known_hosts",
          "args": [
            "sess->session"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "askKey.result"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_string_free_char",
          "args": [
            "keyhashstr"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "askKey.result"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_string_free_char",
          "args": [
            "keyhashstr"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "_(\"SSH host key for '%s' (%s) was not accepted\")",
            "sess->hostname",
            "keyhashstr"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASENEQ",
          "args": [
            "askKey.result",
            "\"y\""
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_string_free_char",
          "args": [
            "keyhashstr"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"failed to retrieve decision to accept \"\n                                 \"host key\")"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sess->cred->cb",
          "args": [
            "&askKey",
            "1",
            "sess->cred->cbdata"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLibsshServerKeyAsString",
          "args": [
            "sess"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "virLibsshServerKeyAsString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "204-235",
          "snippet": "static char *\nvirLibsshServerKeyAsString(virNetLibsshSessionPtr sess)\n{\n    int ret;\n    ssh_key key;\n    unsigned char *keyhash;\n    size_t keyhashlen;\n    char *str;\n\n    if (ssh_get_server_publickey(sess->session, &key) != SSH_OK) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"failed to get the key of the current \"\n                         \"session\"));\n        return NULL;\n    }\n\n    /* calculate remote key hash, using SHA1 algorithm that is\n     * usual in OpenSSH. The returned value must be freed */\n    ret = ssh_get_publickey_hash(key, SSH_PUBLICKEY_HASH_SHA1,\n                                 &keyhash, &keyhashlen);\n    ssh_key_free(key);\n    if (ret < 0) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"failed to calculate ssh host key hash\"));\n        return NULL;\n    }\n    /* format the host key into a nice userfriendly string. */\n    str = ssh_get_hexa(keyhash, keyhashlen);\n    ssh_clean_pubkey_hash(&keyhash);\n\n    return str;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic char *\nvirLibsshServerKeyAsString(virNetLibsshSessionPtr sess)\n{\n    int ret;\n    ssh_key key;\n    unsigned char *keyhash;\n    size_t keyhashlen;\n    char *str;\n\n    if (ssh_get_server_publickey(sess->session, &key) != SSH_OK) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"failed to get the key of the current \"\n                         \"session\"));\n        return NULL;\n    }\n\n    /* calculate remote key hash, using SHA1 algorithm that is\n     * usual in OpenSSH. The returned value must be freed */\n    ret = ssh_get_publickey_hash(key, SSH_PUBLICKEY_HASH_SHA1,\n                                 &keyhash, &keyhashlen);\n    ssh_key_free(key);\n    if (ret < 0) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"failed to calculate ssh host key hash\"));\n        return NULL;\n    }\n    /* format the host key into a nice userfriendly string. */\n    str = ssh_get_hexa(keyhash, keyhashlen);\n    ssh_clean_pubkey_hash(&keyhash);\n\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&askKey",
            "0",
            "sizeof(virConnectCredential)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"no suitable callback for host key \"\n                                 \"verification\")"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCredTypeForPrompt",
          "args": [
            "sess->cred",
            "1/* echo */"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "virCredTypeForPrompt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "237-256",
          "snippet": "static int\nvirCredTypeForPrompt(virConnectAuthPtr cred, char echo)\n{\n    size_t i;\n\n    for (i = 0; i < cred->ncredtype; ++i) {\n        int type = cred->credtype[i];\n        if (echo) {\n            if (type == VIR_CRED_ECHOPROMPT)\n                return type;\n        } else {\n            if (type == VIR_CRED_PASSPHRASE ||\n                type == VIR_CRED_NOECHOPROMPT) {\n                return type;\n            }\n        }\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirCredTypeForPrompt(virConnectAuthPtr cred, char echo)\n{\n    size_t i;\n\n    for (i = 0; i < cred->ncredtype; ++i) {\n        int type = cred->credtype[i];\n        if (echo) {\n            if (type == VIR_CRED_ECHOPROMPT)\n                return type;\n        } else {\n            if (type == VIR_CRED_PASSPHRASE ||\n                type == VIR_CRED_NOECHOPROMPT) {\n                return type;\n            }\n        }\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"No user interaction callback provided: \"\n                                 \"Can't verify the session host key\")"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_string_free_char",
          "args": [
            "keyhashstr"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_AUTH_FAILED",
            "_(\"!!! SSH HOST KEY VERIFICATION FAILED !!!: \"\n                         \"Identity of host '%s:%d' differs from stored identity. \"\n                         \"Please verify the new host key '%s' to avoid possible \"\n                         \"man in the middle attack. The key is stored in '%s'.\")",
            "sess->hostname",
            "sess->port",
            "keyhashstr",
            "sess->knownHostsFile"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_session_is_known_server",
          "args": [
            "sess->session"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirNetLibsshCheckHostKey(virNetLibsshSessionPtr sess)\n{\n    int state;\n    char *keyhashstr;\n    const char *errmsg;\n\n    if (sess->hostKeyVerify == VIR_NET_LIBSSH_HOSTKEY_VERIFY_IGNORE)\n        return 0;\n\n    state = ssh_session_is_known_server(sess->session);\n\n    switch (state) {\n    case SSH_SERVER_KNOWN_OK:\n        /* host key matches */\n        return 0;\n\n    case SSH_SERVER_FOUND_OTHER:\n    case SSH_SERVER_KNOWN_CHANGED:\n        keyhashstr = virLibsshServerKeyAsString(sess);\n        if (!keyhashstr)\n            return -1;\n\n        /* host key verification failed */\n        virReportError(VIR_ERR_AUTH_FAILED,\n                       _(\"!!! SSH HOST KEY VERIFICATION FAILED !!!: \"\n                         \"Identity of host '%s:%d' differs from stored identity. \"\n                         \"Please verify the new host key '%s' to avoid possible \"\n                         \"man in the middle attack. The key is stored in '%s'.\"),\n                       sess->hostname, sess->port,\n                       keyhashstr, sess->knownHostsFile);\n\n        ssh_string_free_char(keyhashstr);\n        return -1;\n\n    case SSH_SERVER_FILE_NOT_FOUND:\n    case SSH_SERVER_NOT_KNOWN:\n        /* key was not found, query to add it to database */\n        if (sess->hostKeyVerify == VIR_NET_LIBSSH_HOSTKEY_VERIFY_NORMAL) {\n            virConnectCredential askKey;\n            int cred_type;\n            char *tmp;\n\n            /* ask to add the key */\n            if (!sess->cred || !sess->cred->cb) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"No user interaction callback provided: \"\n                                 \"Can't verify the session host key\"));\n                return -1;\n            }\n\n            cred_type = virCredTypeForPrompt(sess->cred, 1 /* echo */);\n            if (cred_type == -1) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"no suitable callback for host key \"\n                                 \"verification\"));\n                return -1;\n            }\n\n            /* prepare data for the callback */\n            memset(&askKey, 0, sizeof(virConnectCredential));\n            askKey.type = cred_type;\n\n            keyhashstr = virLibsshServerKeyAsString(sess);\n            if (!keyhashstr)\n                return -1;\n\n            tmp = g_strdup_printf(_(\"Accept SSH host key with hash '%s' for \" \"host '%s:%d' (%s/%s)?\"),\n                                  keyhashstr, sess->hostname, sess->port, \"y\", \"n\");\n            askKey.prompt = tmp;\n\n            if (sess->cred->cb(&askKey, 1, sess->cred->cbdata)) {\n                virReportError(VIR_ERR_LIBSSH, \"%s\",\n                               _(\"failed to retrieve decision to accept \"\n                                 \"host key\"));\n                VIR_FREE(tmp);\n                ssh_string_free_char(keyhashstr);\n                return -1;\n            }\n\n            VIR_FREE(tmp);\n\n            if (!askKey.result ||\n                STRCASENEQ(askKey.result, \"y\")) {\n                virReportError(VIR_ERR_LIBSSH,\n                               _(\"SSH host key for '%s' (%s) was not accepted\"),\n                               sess->hostname, keyhashstr);\n                ssh_string_free_char(keyhashstr);\n                VIR_FREE(askKey.result);\n                return -1;\n            }\n            ssh_string_free_char(keyhashstr);\n            VIR_FREE(askKey.result);\n        }\n\n        /* write the host key file, if specified */\n        if (sess->knownHostsFile) {\n            if (ssh_session_update_known_hosts(sess->session) < 0) {\n                errmsg = ssh_get_error(sess->session);\n                virReportError(VIR_ERR_LIBSSH,\n                               _(\"failed to write known_host file '%s': %s\"),\n                               sess->knownHostsFile,\n                               errmsg);\n                return -1;\n            }\n        }\n        /* key was accepted and added */\n        return 0;\n\n    case SSH_SERVER_ERROR:\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"failed to validate SSH host key: %s\"),\n                       errmsg);\n        return -1;\n\n    default: /* should never happen (tm) */\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Unknown state of the remote server SSH key\"));\n        return -1;\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "virLengthForPromptString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "258-267",
    "snippet": "static int\nvirLengthForPromptString(const char *str)\n{\n    int len = strlen(str);\n\n    while (len > 0 && (str[len-1] == ' ' || str[len-1] == ':'))\n        --len;\n\n    return len;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirLengthForPromptString(const char *str)\n{\n    int len = strlen(str);\n\n    while (len > 0 && (str[len-1] == ' ' || str[len-1] == ':'))\n        --len;\n\n    return len;\n}"
  },
  {
    "function_name": "virCredTypeForPrompt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "237-256",
    "snippet": "static int\nvirCredTypeForPrompt(virConnectAuthPtr cred, char echo)\n{\n    size_t i;\n\n    for (i = 0; i < cred->ncredtype; ++i) {\n        int type = cred->credtype[i];\n        if (echo) {\n            if (type == VIR_CRED_ECHOPROMPT)\n                return type;\n        } else {\n            if (type == VIR_CRED_PASSPHRASE ||\n                type == VIR_CRED_NOECHOPROMPT) {\n                return type;\n            }\n        }\n    }\n\n    return -1;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic int\nvirCredTypeForPrompt(virConnectAuthPtr cred, char echo)\n{\n    size_t i;\n\n    for (i = 0; i < cred->ncredtype; ++i) {\n        int type = cred->credtype[i];\n        if (echo) {\n            if (type == VIR_CRED_ECHOPROMPT)\n                return type;\n        } else {\n            if (type == VIR_CRED_PASSPHRASE ||\n                type == VIR_CRED_NOECHOPROMPT) {\n                return type;\n            }\n        }\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "virLibsshServerKeyAsString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "204-235",
    "snippet": "static char *\nvirLibsshServerKeyAsString(virNetLibsshSessionPtr sess)\n{\n    int ret;\n    ssh_key key;\n    unsigned char *keyhash;\n    size_t keyhashlen;\n    char *str;\n\n    if (ssh_get_server_publickey(sess->session, &key) != SSH_OK) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"failed to get the key of the current \"\n                         \"session\"));\n        return NULL;\n    }\n\n    /* calculate remote key hash, using SHA1 algorithm that is\n     * usual in OpenSSH. The returned value must be freed */\n    ret = ssh_get_publickey_hash(key, SSH_PUBLICKEY_HASH_SHA1,\n                                 &keyhash, &keyhashlen);\n    ssh_key_free(key);\n    if (ret < 0) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"failed to calculate ssh host key hash\"));\n        return NULL;\n    }\n    /* format the host key into a nice userfriendly string. */\n    str = ssh_get_hexa(keyhash, keyhashlen);\n    ssh_clean_pubkey_hash(&keyhash);\n\n    return str;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_clean_pubkey_hash",
          "args": [
            "&keyhash"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_get_hexa",
          "args": [
            "keyhash",
            "keyhashlen"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"failed to calculate ssh host key hash\")"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to calculate ssh host key hash\""
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_key_free",
          "args": [
            "key"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_get_publickey_hash",
          "args": [
            "key",
            "SSH_PUBLICKEY_HASH_SHA1",
            "&keyhash",
            "&keyhashlen"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"failed to get the key of the current \"\n                         \"session\")"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_get_server_publickey",
          "args": [
            "sess->session",
            "&key"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic char *\nvirLibsshServerKeyAsString(virNetLibsshSessionPtr sess)\n{\n    int ret;\n    ssh_key key;\n    unsigned char *keyhash;\n    size_t keyhashlen;\n    char *str;\n\n    if (ssh_get_server_publickey(sess->session, &key) != SSH_OK) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"failed to get the key of the current \"\n                         \"session\"));\n        return NULL;\n    }\n\n    /* calculate remote key hash, using SHA1 algorithm that is\n     * usual in OpenSSH. The returned value must be freed */\n    ret = ssh_get_publickey_hash(key, SSH_PUBLICKEY_HASH_SHA1,\n                                 &keyhash, &keyhashlen);\n    ssh_key_free(key);\n    if (ret < 0) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"failed to calculate ssh host key hash\"));\n        return NULL;\n    }\n    /* format the host key into a nice userfriendly string. */\n    str = ssh_get_hexa(keyhash, keyhashlen);\n    ssh_clean_pubkey_hash(&keyhash);\n\n    return str;\n}"
  },
  {
    "function_name": "virNetLibsshSessionAuthMethodNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "183-201",
    "snippet": "static virNetLibsshAuthMethodPtr\nvirNetLibsshSessionAuthMethodNew(virNetLibsshSessionPtr sess)\n{\n    virNetLibsshAuthMethodPtr auth;\n\n    if (VIR_ALLOC(auth) < 0)\n        goto error;\n\n    if (VIR_EXPAND_N(sess->auths, sess->nauths, 1) < 0)\n        goto error;\n\n    sess->auths[sess->nauths - 1] = auth;\n\n    return auth;\n\n error:\n    VIR_FREE(auth);\n    return NULL;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "auth"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "sess->auths",
            "sess->nauths",
            "1"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "auth"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic virNetLibsshAuthMethodPtr\nvirNetLibsshSessionAuthMethodNew(virNetLibsshSessionPtr sess)\n{\n    virNetLibsshAuthMethodPtr auth;\n\n    if (VIR_ALLOC(auth) < 0)\n        goto error;\n\n    if (VIR_EXPAND_N(sess->auths, sess->nauths, 1) < 0)\n        goto error;\n\n    sess->auths[sess->nauths - 1] = auth;\n\n    return auth;\n\n error:\n    VIR_FREE(auth);\n    return NULL;\n}"
  },
  {
    "function_name": "virNetLibsshSessionOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "155-180",
    "snippet": "static int\nvirNetLibsshSessionOnceInit(void)\n{\n    const char *dbgLevelStr;\n    int dbgLevel;\n\n    if (!VIR_CLASS_NEW(virNetLibsshSession, virClassForObjectLockable()))\n        return -1;\n\n    if (ssh_init() < 0) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"failed to initialize libssh\"));\n        return -1;\n    }\n\n#if TRACE_LIBSSH != 0\n    ssh_set_log_level(TRACE_LIBSSH);\n#endif\n\n    dbgLevelStr = getenv(\"LIBVIRT_LIBSSH_DEBUG\");\n    if (dbgLevelStr &&\n        virStrToLong_i(dbgLevelStr, NULL, 10, &dbgLevel) >= 0)\n        ssh_set_log_level(dbgLevel);\n\n    return 0;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define TRACE_LIBSSH  0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_set_log_level",
          "args": [
            "dbgLevel"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "dbgLevelStr",
            "NULL",
            "10",
            "&dbgLevel"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LIBVIRT_LIBSSH_DEBUG\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_set_log_level",
          "args": [
            "TRACE_LIBSSH"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"failed to initialize libssh\")"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to initialize libssh\""
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_init",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virNetLibsshSession",
            "virClassForObjectLockable()"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObjectLockable",
          "args": [],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "116-123",
          "snippet": "virClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectLockableClass;\n\nvirClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\n#define TRACE_LIBSSH  0\n\nstatic int\nvirNetLibsshSessionOnceInit(void)\n{\n    const char *dbgLevelStr;\n    int dbgLevel;\n\n    if (!VIR_CLASS_NEW(virNetLibsshSession, virClassForObjectLockable()))\n        return -1;\n\n    if (ssh_init() < 0) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"failed to initialize libssh\"));\n        return -1;\n    }\n\n#if TRACE_LIBSSH != 0\n    ssh_set_log_level(TRACE_LIBSSH);\n#endif\n\n    dbgLevelStr = getenv(\"LIBVIRT_LIBSSH_DEBUG\");\n    if (dbgLevelStr &&\n        virStrToLong_i(dbgLevelStr, NULL, 10, &dbgLevel) >= 0)\n        ssh_set_log_level(dbgLevel);\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetLibsshSessionDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "125-152",
    "snippet": "static void\nvirNetLibsshSessionDispose(void *obj)\n{\n    virNetLibsshSessionPtr sess = obj;\n    VIR_DEBUG(\"sess=0x%p\", sess);\n\n    if (!sess)\n        return;\n\n    if (sess->channel) {\n        ssh_channel_send_eof(sess->channel);\n        ssh_channel_close(sess->channel);\n        ssh_channel_free(sess->channel);\n    }\n\n    if (sess->session) {\n        ssh_disconnect(sess->session);\n        ssh_free(sess->session);\n    }\n\n    virNetLibsshSessionAuthMethodsFree(sess);\n\n    VIR_FREE(sess->channelCommand);\n    VIR_FREE(sess->hostname);\n    VIR_FREE(sess->knownHostsFile);\n    VIR_FREE(sess->authPath);\n    VIR_FREE(sess->username);\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sess->username"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sess->authPath"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sess->knownHostsFile"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sess->hostname"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sess->channelCommand"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetLibsshSessionAuthMethodsFree",
          "args": [
            "sess"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshSessionAuthMethodsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "110-123",
          "snippet": "static void\nvirNetLibsshSessionAuthMethodsFree(virNetLibsshSessionPtr sess)\n{\n    size_t i;\n\n    for (i = 0; i < sess->nauths; i++) {\n        VIR_DISPOSE_STRING(sess->auths[i]->password);\n        VIR_FREE(sess->auths[i]->filename);\n        VIR_FREE(sess->auths[i]);\n    }\n\n    VIR_FREE(sess->auths);\n    sess->nauths = 0;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic void\nvirNetLibsshSessionAuthMethodsFree(virNetLibsshSessionPtr sess)\n{\n    size_t i;\n\n    for (i = 0; i < sess->nauths; i++) {\n        VIR_DISPOSE_STRING(sess->auths[i]->password);\n        VIR_FREE(sess->auths[i]->filename);\n        VIR_FREE(sess->auths[i]);\n    }\n\n    VIR_FREE(sess->auths);\n    sess->nauths = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_free",
          "args": [
            "sess->session"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_disconnect",
          "args": [
            "sess->session"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_free",
          "args": [
            "sess->channel"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_close",
          "args": [
            "sess->channel"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_channel_send_eof",
          "args": [
            "sess->channel"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"sess=0x%p\"",
            "sess"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic void\nvirNetLibsshSessionDispose(void *obj)\n{\n    virNetLibsshSessionPtr sess = obj;\n    VIR_DEBUG(\"sess=0x%p\", sess);\n\n    if (!sess)\n        return;\n\n    if (sess->channel) {\n        ssh_channel_send_eof(sess->channel);\n        ssh_channel_close(sess->channel);\n        ssh_channel_free(sess->channel);\n    }\n\n    if (sess->session) {\n        ssh_disconnect(sess->session);\n        ssh_free(sess->session);\n    }\n\n    virNetLibsshSessionAuthMethodsFree(sess);\n\n    VIR_FREE(sess->channelCommand);\n    VIR_FREE(sess->hostname);\n    VIR_FREE(sess->knownHostsFile);\n    VIR_FREE(sess->authPath);\n    VIR_FREE(sess->username);\n}"
  },
  {
    "function_name": "virNetLibsshSessionAuthMethodsFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
    "lines": "110-123",
    "snippet": "static void\nvirNetLibsshSessionAuthMethodsFree(virNetLibsshSessionPtr sess)\n{\n    size_t i;\n\n    for (i = 0; i < sess->nauths; i++) {\n        VIR_DISPOSE_STRING(sess->auths[i]->password);\n        VIR_FREE(sess->auths[i]->filename);\n        VIR_FREE(sess->auths[i]);\n    }\n\n    VIR_FREE(sess->auths);\n    sess->nauths = 0;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"virauth.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virerror.h\"",
      "#include \"configmake.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include \"virnetlibsshsession.h\"",
      "#include <libssh/libssh.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sess->auths"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sess->auths[i]"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sess->auths[i]->filename"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DISPOSE_STRING",
          "args": [
            "sess->auths[i]->password"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic void\nvirNetLibsshSessionAuthMethodsFree(virNetLibsshSessionPtr sess)\n{\n    size_t i;\n\n    for (i = 0; i < sess->nauths; i++) {\n        VIR_DISPOSE_STRING(sess->auths[i]->password);\n        VIR_FREE(sess->auths[i]->filename);\n        VIR_FREE(sess->auths[i]);\n    }\n\n    VIR_FREE(sess->auths);\n    sess->nauths = 0;\n}"
  }
]