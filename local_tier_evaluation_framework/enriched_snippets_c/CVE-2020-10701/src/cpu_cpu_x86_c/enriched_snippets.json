[
  {
    "function_name": "virCPUx86FeatureFilterDropMSR",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "3420-3426",
    "snippet": "bool\nvirCPUx86FeatureFilterDropMSR(const char *name,\n                              virCPUFeaturePolicy policy G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED)\n{\n    return !virCPUx86FeatureIsMSR(name);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86FeatureIsMSR",
          "args": [
            "name"
          ],
          "line": 3425
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86FeatureIsMSR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3370-3392",
          "snippet": "static bool\nvirCPUx86FeatureIsMSR(const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return false;\n\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return false;\n\n    virCPUx86DataIteratorInit(&iter, &feature->data);\n    while ((item = virCPUx86DataNext(&iter))) {\n        if (item->type == VIR_CPU_X86_DATA_MSR)\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nvirCPUx86FeatureIsMSR(const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return false;\n\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return false;\n\n    virCPUx86DataIteratorInit(&iter, &feature->data);\n    while ((item = virCPUx86DataNext(&iter))) {\n        if (item->type == VIR_CPU_X86_DATA_MSR)\n            return true;\n    }\n\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nbool\nvirCPUx86FeatureFilterDropMSR(const char *name,\n                              virCPUFeaturePolicy policy G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED)\n{\n    return !virCPUx86FeatureIsMSR(name);\n}"
  },
  {
    "function_name": "virCPUx86FeatureFilterSelectMSR",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "3403-3409",
    "snippet": "bool\nvirCPUx86FeatureFilterSelectMSR(const char *name,\n                                virCPUFeaturePolicy policy G_GNUC_UNUSED,\n                                void *opaque G_GNUC_UNUSED)\n{\n    return virCPUx86FeatureIsMSR(name);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86FeatureIsMSR",
          "args": [
            "name"
          ],
          "line": 3408
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86FeatureIsMSR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3370-3392",
          "snippet": "static bool\nvirCPUx86FeatureIsMSR(const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return false;\n\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return false;\n\n    virCPUx86DataIteratorInit(&iter, &feature->data);\n    while ((item = virCPUx86DataNext(&iter))) {\n        if (item->type == VIR_CPU_X86_DATA_MSR)\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nvirCPUx86FeatureIsMSR(const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return false;\n\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return false;\n\n    virCPUx86DataIteratorInit(&iter, &feature->data);\n    while ((item = virCPUx86DataNext(&iter))) {\n        if (item->type == VIR_CPU_X86_DATA_MSR)\n            return true;\n    }\n\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nbool\nvirCPUx86FeatureFilterSelectMSR(const char *name,\n                                virCPUFeaturePolicy policy G_GNUC_UNUSED,\n                                void *opaque G_GNUC_UNUSED)\n{\n    return virCPUx86FeatureIsMSR(name);\n}"
  },
  {
    "function_name": "virCPUx86FeatureIsMSR",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "3370-3392",
    "snippet": "static bool\nvirCPUx86FeatureIsMSR(const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return false;\n\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return false;\n\n    virCPUx86DataIteratorInit(&iter, &feature->data);\n    while ((item = virCPUx86DataNext(&iter))) {\n        if (item->type == VIR_CPU_X86_DATA_MSR)\n            return true;\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataNext",
          "args": [
            "&iter"
          ],
          "line": 3386
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "428-445",
          "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataIteratorInit",
          "args": [
            "&iter",
            "&feature->data"
          ],
          "line": 3385
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "169-175",
          "snippet": "static void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86FeatureFindInternal",
          "args": [
            "name"
          ],
          "line": 3382
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureFindInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "363-375",
          "snippet": "static virCPUx86FeaturePtr\nx86FeatureFindInternal(const char *name)\n{\n    size_t i;\n    size_t count = G_N_ELEMENTS(x86_kvm_features);\n\n    for (i = 0; i < count; i++) {\n        if (STREQ(x86_kvm_features[i].name, name))\n            return x86_kvm_features + i;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86Feature x86_kvm_features[] =\n{\n    KVM_FEATURE(VIR_CPU_x86_KVM_PV_UNHALT),\n    KVM_FEATURE(VIR_CPU_x86_HV_RUNTIME),\n    KVM_FEATURE(VIR_CPU_x86_HV_SYNIC),\n    KVM_FEATURE(VIR_CPU_x86_HV_STIMER),\n    KVM_FEATURE(VIR_CPU_x86_HV_RELAXED),\n    KVM_FEATURE(VIR_CPU_x86_HV_VAPIC),\n    KVM_FEATURE(VIR_CPU_x86_HV_VPINDEX),\n    KVM_FEATURE(VIR_CPU_x86_HV_RESET),\n    KVM_FEATURE(VIR_CPU_x86_HV_FREQUENCIES),\n    KVM_FEATURE(VIR_CPU_x86_HV_REENLIGHTENMENT),\n    KVM_FEATURE(VIR_CPU_x86_HV_TLBFLUSH),\n    KVM_FEATURE(VIR_CPU_x86_HV_IPI),\n    KVM_FEATURE(VIR_CPU_x86_HV_EVMCS),\n    KVM_FEATURE(VIR_CPU_x86_HV_STIMER_DIRECT),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86Feature x86_kvm_features[] =\n{\n    KVM_FEATURE(VIR_CPU_x86_KVM_PV_UNHALT),\n    KVM_FEATURE(VIR_CPU_x86_HV_RUNTIME),\n    KVM_FEATURE(VIR_CPU_x86_HV_SYNIC),\n    KVM_FEATURE(VIR_CPU_x86_HV_STIMER),\n    KVM_FEATURE(VIR_CPU_x86_HV_RELAXED),\n    KVM_FEATURE(VIR_CPU_x86_HV_VAPIC),\n    KVM_FEATURE(VIR_CPU_x86_HV_VPINDEX),\n    KVM_FEATURE(VIR_CPU_x86_HV_RESET),\n    KVM_FEATURE(VIR_CPU_x86_HV_FREQUENCIES),\n    KVM_FEATURE(VIR_CPU_x86_HV_REENLIGHTENMENT),\n    KVM_FEATURE(VIR_CPU_x86_HV_TLBFLUSH),\n    KVM_FEATURE(VIR_CPU_x86_HV_IPI),\n    KVM_FEATURE(VIR_CPU_x86_HV_EVMCS),\n    KVM_FEATURE(VIR_CPU_x86_HV_STIMER_DIRECT),\n};\n\nstatic virCPUx86FeaturePtr\nx86FeatureFindInternal(const char *name)\n{\n    size_t i;\n    size_t count = G_N_ELEMENTS(x86_kvm_features);\n\n    for (i = 0; i < count; i++) {\n        if (STREQ(x86_kvm_features[i].name, name))\n            return x86_kvm_features + i;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86FeatureFind",
          "args": [
            "map",
            "name"
          ],
          "line": 3381
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "348-360",
          "snippet": "static virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86GetMap",
          "args": [],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86GetMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1605-1612",
          "snippet": "static virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86MapPtr cpuMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\n\nstatic virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nvirCPUx86FeatureIsMSR(const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return false;\n\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return false;\n\n    virCPUx86DataIteratorInit(&iter, &feature->data);\n    while ((item = virCPUx86DataNext(&iter))) {\n        if (item->type == VIR_CPU_X86_DATA_MSR)\n            return true;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virCPUx86DataAddFeature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "3348-3367",
    "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86DataAdd",
          "args": [
            "&cpuData->data.x86",
            "&feature->data"
          ],
          "line": 3363
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "x86FeatureFindInternal",
          "args": [
            "name"
          ],
          "line": 3360
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureFindInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "363-375",
          "snippet": "static virCPUx86FeaturePtr\nx86FeatureFindInternal(const char *name)\n{\n    size_t i;\n    size_t count = G_N_ELEMENTS(x86_kvm_features);\n\n    for (i = 0; i < count; i++) {\n        if (STREQ(x86_kvm_features[i].name, name))\n            return x86_kvm_features + i;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86Feature x86_kvm_features[] =\n{\n    KVM_FEATURE(VIR_CPU_x86_KVM_PV_UNHALT),\n    KVM_FEATURE(VIR_CPU_x86_HV_RUNTIME),\n    KVM_FEATURE(VIR_CPU_x86_HV_SYNIC),\n    KVM_FEATURE(VIR_CPU_x86_HV_STIMER),\n    KVM_FEATURE(VIR_CPU_x86_HV_RELAXED),\n    KVM_FEATURE(VIR_CPU_x86_HV_VAPIC),\n    KVM_FEATURE(VIR_CPU_x86_HV_VPINDEX),\n    KVM_FEATURE(VIR_CPU_x86_HV_RESET),\n    KVM_FEATURE(VIR_CPU_x86_HV_FREQUENCIES),\n    KVM_FEATURE(VIR_CPU_x86_HV_REENLIGHTENMENT),\n    KVM_FEATURE(VIR_CPU_x86_HV_TLBFLUSH),\n    KVM_FEATURE(VIR_CPU_x86_HV_IPI),\n    KVM_FEATURE(VIR_CPU_x86_HV_EVMCS),\n    KVM_FEATURE(VIR_CPU_x86_HV_STIMER_DIRECT),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86Feature x86_kvm_features[] =\n{\n    KVM_FEATURE(VIR_CPU_x86_KVM_PV_UNHALT),\n    KVM_FEATURE(VIR_CPU_x86_HV_RUNTIME),\n    KVM_FEATURE(VIR_CPU_x86_HV_SYNIC),\n    KVM_FEATURE(VIR_CPU_x86_HV_STIMER),\n    KVM_FEATURE(VIR_CPU_x86_HV_RELAXED),\n    KVM_FEATURE(VIR_CPU_x86_HV_VAPIC),\n    KVM_FEATURE(VIR_CPU_x86_HV_VPINDEX),\n    KVM_FEATURE(VIR_CPU_x86_HV_RESET),\n    KVM_FEATURE(VIR_CPU_x86_HV_FREQUENCIES),\n    KVM_FEATURE(VIR_CPU_x86_HV_REENLIGHTENMENT),\n    KVM_FEATURE(VIR_CPU_x86_HV_TLBFLUSH),\n    KVM_FEATURE(VIR_CPU_x86_HV_IPI),\n    KVM_FEATURE(VIR_CPU_x86_HV_EVMCS),\n    KVM_FEATURE(VIR_CPU_x86_HV_STIMER_DIRECT),\n};\n\nstatic virCPUx86FeaturePtr\nx86FeatureFindInternal(const char *name)\n{\n    size_t i;\n    size_t count = G_N_ELEMENTS(x86_kvm_features);\n\n    for (i = 0; i < count; i++) {\n        if (STREQ(x86_kvm_features[i].name, name))\n            return x86_kvm_features + i;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86FeatureFind",
          "args": [
            "map",
            "name"
          ],
          "line": 3359
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "348-360",
          "snippet": "static virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86GetMap",
          "args": [],
          "line": 3355
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86GetMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1605-1612",
          "snippet": "static virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86MapPtr cpuMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\n\nstatic virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virCPUx86DataSetVendor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "3335-3345",
    "snippet": "int\nvirCPUx86DataSetVendor(virCPUDataPtr cpuData,\n                       const char *vendor)\n{\n    virCPUx86DataItem item = CPUID(0);\n\n    if (virCPUx86VendorToData(vendor, &item) < 0)\n        return -1;\n\n    return virCPUx86DataAdd(cpuData, &item);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataAdd",
          "args": [
            "cpuData",
            "&item"
          ],
          "line": 3344
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86VendorToData",
          "args": [
            "vendor",
            "&item"
          ],
          "line": 3341
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86VendorToData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "645-666",
          "snippet": "static int\nvirCPUx86VendorToData(const char *vendor,\n                      virCPUx86DataItemPtr item)\n{\n    virCPUx86CPUIDPtr cpuid;\n\n    if (strlen(vendor) != VENDOR_STRING_LENGTH) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid CPU vendor string '%s'\"), vendor);\n        return -1;\n    }\n\n    item->type = VIR_CPU_X86_DATA_CPUID;\n    cpuid = &item->data.cpuid;\n    cpuid->eax_in = 0;\n    cpuid->ecx_in = 0;\n    cpuid->ebx = virReadBufInt32LE(vendor);\n    cpuid->edx = virReadBufInt32LE(vendor + 4);\n    cpuid->ecx = virReadBufInt32LE(vendor + 8);\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VENDOR_STRING_LENGTH    12"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\n#define VENDOR_STRING_LENGTH    12\n\nstatic int\nvirCPUx86VendorToData(const char *vendor,\n                      virCPUx86DataItemPtr item)\n{\n    virCPUx86CPUIDPtr cpuid;\n\n    if (strlen(vendor) != VENDOR_STRING_LENGTH) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid CPU vendor string '%s'\"), vendor);\n        return -1;\n    }\n\n    item->type = VIR_CPU_X86_DATA_CPUID;\n    cpuid = &item->data.cpuid;\n    cpuid->eax_in = 0;\n    cpuid->ecx_in = 0;\n    cpuid->ebx = virReadBufInt32LE(vendor);\n    cpuid->edx = virReadBufInt32LE(vendor + 4);\n    cpuid->ecx = virReadBufInt32LE(vendor + 8);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUID",
          "args": [
            "0"
          ],
          "line": 3339
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetMaxCPUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1057-1072",
          "snippet": "unsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUx86DataSetVendor(virCPUDataPtr cpuData,\n                       const char *vendor)\n{\n    virCPUx86DataItem item = CPUID(0);\n\n    if (virCPUx86VendorToData(vendor, &item) < 0)\n        return -1;\n\n    return virCPUx86DataAdd(cpuData, &item);\n}"
  },
  {
    "function_name": "virCPUx86DataGetSignature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "3323-3332",
    "snippet": "uint32_t\nvirCPUx86DataGetSignature(virCPUDataPtr cpuData,\n                          unsigned int *family,\n                          unsigned int *model,\n                          unsigned int *stepping)\n{\n    x86DataToSignatureFull(&cpuData->data.x86, family, model, stepping);\n\n    return x86MakeSignature(*family, *model, *stepping);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86MakeSignature",
          "args": [
            "*family",
            "*model",
            "*stepping"
          ],
          "line": 3331
        },
        "resolved": true,
        "details": {
          "function_name": "x86MakeSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "669-716",
          "snippet": "static uint32_t\nx86MakeSignature(unsigned int family,\n                 unsigned int model,\n                 unsigned int stepping)\n{\n    uint32_t sig = 0;\n\n    /*\n     * CPU signature (eax from 0x1 CPUID leaf):\n     *\n     * |31 .. 28|27 .. 20|19 .. 16|15 .. 14|13 .. 12|11 .. 8|7 .. 4|3 .. 0|\n     * |   R    | extFam | extMod |   R    | PType  |  Fam  | Mod  | Step |\n     *\n     * R        reserved\n     * extFam   extended family (valid only if Fam == 0xf)\n     * extMod   extended model\n     * PType    processor type\n     * Fam      family\n     * Mod      model\n     * Step     stepping\n     *\n     * family = eax[27:20] + eax[11:8]\n     * model = eax[19:16] << 4 + eax[7:4]\n     * stepping = eax[3:0]\n     */\n\n    /* extFam */\n    if (family > 0xf) {\n        sig |= (family - 0xf) << 20;\n        family = 0xf;\n    }\n\n    /* extMod */\n    sig |= (model >> 4) << 16;\n\n    /* PType is always 0 */\n\n    /* Fam */\n    sig |= family << 8;\n\n    /* Mod */\n    sig |= (model & 0xf) << 4;\n\n    /* Step */\n    sig |= stepping & 0xf;\n\n    return sig;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic uint32_t\nx86MakeSignature(unsigned int family,\n                 unsigned int model,\n                 unsigned int stepping)\n{\n    uint32_t sig = 0;\n\n    /*\n     * CPU signature (eax from 0x1 CPUID leaf):\n     *\n     * |31 .. 28|27 .. 20|19 .. 16|15 .. 14|13 .. 12|11 .. 8|7 .. 4|3 .. 0|\n     * |   R    | extFam | extMod |   R    | PType  |  Fam  | Mod  | Step |\n     *\n     * R        reserved\n     * extFam   extended family (valid only if Fam == 0xf)\n     * extMod   extended model\n     * PType    processor type\n     * Fam      family\n     * Mod      model\n     * Step     stepping\n     *\n     * family = eax[27:20] + eax[11:8]\n     * model = eax[19:16] << 4 + eax[7:4]\n     * stepping = eax[3:0]\n     */\n\n    /* extFam */\n    if (family > 0xf) {\n        sig |= (family - 0xf) << 20;\n        family = 0xf;\n    }\n\n    /* extMod */\n    sig |= (model >> 4) << 16;\n\n    /* PType is always 0 */\n\n    /* Fam */\n    sig |= family << 8;\n\n    /* Mod */\n    sig |= (model & 0xf) << 4;\n\n    /* Step */\n    sig |= stepping & 0xf;\n\n    return sig;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataToSignatureFull",
          "args": [
            "&cpuData->data.x86",
            "family",
            "model",
            "stepping"
          ],
          "line": 3329
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataToSignatureFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "719-738",
          "snippet": "static void\nx86DataToSignatureFull(const virCPUx86Data *data,\n                       unsigned int *family,\n                       unsigned int *model,\n                       unsigned int *stepping)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1);\n    virCPUx86DataItemPtr item;\n    virCPUx86CPUIDPtr cpuid;\n\n    *family = *model = *stepping = 0;\n\n    if (!(item = virCPUx86DataGet(data, &leaf1)))\n        return;\n\n    cpuid = &item->data.cpuid;\n    *family = ((cpuid->eax >> 20) & 0xff) + ((cpuid->eax >> 8) & 0xf);\n    *model = ((cpuid->eax >> 12) & 0xf0) + ((cpuid->eax >> 4) & 0xf);\n    *stepping = cpuid->eax & 0xf;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86DataToSignatureFull(const virCPUx86Data *data,\n                       unsigned int *family,\n                       unsigned int *model,\n                       unsigned int *stepping)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1);\n    virCPUx86DataItemPtr item;\n    virCPUx86CPUIDPtr cpuid;\n\n    *family = *model = *stepping = 0;\n\n    if (!(item = virCPUx86DataGet(data, &leaf1)))\n        return;\n\n    cpuid = &item->data.cpuid;\n    *family = ((cpuid->eax >> 20) & 0xff) + ((cpuid->eax >> 8) & 0xf);\n    *model = ((cpuid->eax >> 12) & 0xf0) + ((cpuid->eax >> 4) & 0xf);\n    *stepping = cpuid->eax & 0xf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nuint32_t\nvirCPUx86DataGetSignature(virCPUDataPtr cpuData,\n                          unsigned int *family,\n                          unsigned int *model,\n                          unsigned int *stepping)\n{\n    x86DataToSignatureFull(&cpuData->data.x86, family, model, stepping);\n\n    return x86MakeSignature(*family, *model, *stepping);\n}"
  },
  {
    "function_name": "virCPUx86DataSetSignature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "3311-3320",
    "snippet": "int\nvirCPUx86DataSetSignature(virCPUDataPtr cpuData,\n                          unsigned int family,\n                          unsigned int model,\n                          unsigned int stepping)\n{\n    uint32_t signature = x86MakeSignature(family, model, stepping);\n\n    return x86DataAddSignature(&cpuData->data.x86, signature);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86DataAddSignature",
          "args": [
            "&cpuData->data.x86",
            "signature"
          ],
          "line": 3319
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataAddSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "757-764",
          "snippet": "static int\nx86DataAddSignature(virCPUx86Data *data,\n                    uint32_t signature)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1, .eax = signature);\n\n    return virCPUx86DataAddItem(data, &leaf1);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DataAddSignature(virCPUx86Data *data,\n                    uint32_t signature)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1, .eax = signature);\n\n    return virCPUx86DataAddItem(data, &leaf1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86MakeSignature",
          "args": [
            "family",
            "model",
            "stepping"
          ],
          "line": 3317
        },
        "resolved": true,
        "details": {
          "function_name": "x86MakeSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "669-716",
          "snippet": "static uint32_t\nx86MakeSignature(unsigned int family,\n                 unsigned int model,\n                 unsigned int stepping)\n{\n    uint32_t sig = 0;\n\n    /*\n     * CPU signature (eax from 0x1 CPUID leaf):\n     *\n     * |31 .. 28|27 .. 20|19 .. 16|15 .. 14|13 .. 12|11 .. 8|7 .. 4|3 .. 0|\n     * |   R    | extFam | extMod |   R    | PType  |  Fam  | Mod  | Step |\n     *\n     * R        reserved\n     * extFam   extended family (valid only if Fam == 0xf)\n     * extMod   extended model\n     * PType    processor type\n     * Fam      family\n     * Mod      model\n     * Step     stepping\n     *\n     * family = eax[27:20] + eax[11:8]\n     * model = eax[19:16] << 4 + eax[7:4]\n     * stepping = eax[3:0]\n     */\n\n    /* extFam */\n    if (family > 0xf) {\n        sig |= (family - 0xf) << 20;\n        family = 0xf;\n    }\n\n    /* extMod */\n    sig |= (model >> 4) << 16;\n\n    /* PType is always 0 */\n\n    /* Fam */\n    sig |= family << 8;\n\n    /* Mod */\n    sig |= (model & 0xf) << 4;\n\n    /* Step */\n    sig |= stepping & 0xf;\n\n    return sig;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic uint32_t\nx86MakeSignature(unsigned int family,\n                 unsigned int model,\n                 unsigned int stepping)\n{\n    uint32_t sig = 0;\n\n    /*\n     * CPU signature (eax from 0x1 CPUID leaf):\n     *\n     * |31 .. 28|27 .. 20|19 .. 16|15 .. 14|13 .. 12|11 .. 8|7 .. 4|3 .. 0|\n     * |   R    | extFam | extMod |   R    | PType  |  Fam  | Mod  | Step |\n     *\n     * R        reserved\n     * extFam   extended family (valid only if Fam == 0xf)\n     * extMod   extended model\n     * PType    processor type\n     * Fam      family\n     * Mod      model\n     * Step     stepping\n     *\n     * family = eax[27:20] + eax[11:8]\n     * model = eax[19:16] << 4 + eax[7:4]\n     * stepping = eax[3:0]\n     */\n\n    /* extFam */\n    if (family > 0xf) {\n        sig |= (family - 0xf) << 20;\n        family = 0xf;\n    }\n\n    /* extMod */\n    sig |= (model >> 4) << 16;\n\n    /* PType is always 0 */\n\n    /* Fam */\n    sig |= family << 8;\n\n    /* Mod */\n    sig |= (model & 0xf) << 4;\n\n    /* Step */\n    sig |= stepping & 0xf;\n\n    return sig;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUx86DataSetSignature(virCPUDataPtr cpuData,\n                          unsigned int family,\n                          unsigned int model,\n                          unsigned int stepping)\n{\n    uint32_t signature = x86MakeSignature(family, model, stepping);\n\n    return x86DataAddSignature(&cpuData->data.x86, signature);\n}"
  },
  {
    "function_name": "virCPUx86DataAdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "3303-3308",
    "snippet": "int\nvirCPUx86DataAdd(virCPUDataPtr cpuData,\n                 const virCPUx86DataItem *item)\n{\n    return virCPUx86DataAddItem(&cpuData->data.x86, item);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataAddItem",
          "args": [
            "&cpuData->data.x86",
            "item"
          ],
          "line": 3307
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddItem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "500-518",
          "snippet": "static int\nvirCPUx86DataAddItem(virCPUx86Data *data,\n                     const virCPUx86DataItem *item)\n{\n    virCPUx86DataItemPtr existing;\n\n    if ((existing = virCPUx86DataGet(data, item))) {\n        virCPUx86DataItemSetBits(existing, item);\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(data->items, data->len,\n                                    *((virCPUx86DataItemPtr)item)) < 0)\n            return -1;\n\n        qsort(data->items, data->len,\n              sizeof(virCPUx86DataItem), virCPUx86DataSorter);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddItem(virCPUx86Data *data,\n                     const virCPUx86DataItem *item)\n{\n    virCPUx86DataItemPtr existing;\n\n    if ((existing = virCPUx86DataGet(data, item))) {\n        virCPUx86DataItemSetBits(existing, item);\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(data->items, data->len,\n                                    *((virCPUx86DataItemPtr)item)) < 0)\n            return -1;\n\n        qsort(data->items, data->len,\n              sizeof(virCPUx86DataItem), virCPUx86DataSorter);\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUx86DataAdd(virCPUDataPtr cpuData,\n                 const virCPUx86DataItem *item)\n{\n    return virCPUx86DataAddItem(&cpuData->data.x86, item);\n}"
  },
  {
    "function_name": "virCPUx86ValidateFeatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "3281-3300",
    "snippet": "static int\nvirCPUx86ValidateFeatures(virCPUDefPtr cpu)\n{\n    virCPUx86MapPtr map;\n    size_t i;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        if (!x86FeatureFind(map, cpu->features[i].name)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown CPU feature: %s\"),\n                           cpu->features[i].name);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unknown CPU feature: %s\")",
            "cpu->features[i].name"
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown CPU feature: %s\""
          ],
          "line": 3293
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86FeatureFind",
          "args": [
            "map",
            "cpu->features[i].name"
          ],
          "line": 3291
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "348-360",
          "snippet": "static virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86GetMap",
          "args": [],
          "line": 3287
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86GetMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1605-1612",
          "snippet": "static virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86MapPtr cpuMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\n\nstatic virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86ValidateFeatures(virCPUDefPtr cpu)\n{\n    virCPUx86MapPtr map;\n    size_t i;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        if (!x86FeatureFind(map, cpu->features[i].name)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown CPU feature: %s\"),\n                           cpu->features[i].name);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virCPUx86CopyMigratable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "3257-3278",
    "snippet": "static virCPUDefPtr\nvirCPUx86CopyMigratable(virCPUDefPtr cpu)\n{\n    virCPUDefPtr copy;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return NULL;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModelFilter(copy, cpu, false,\n                                 x86FeatureFilterMigratable, map) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "copy"
          ],
          "line": 3276
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefCopyModelFilter",
          "args": [
            "copy",
            "cpu",
            "false",
            "x86FeatureFilterMigratable",
            "map"
          ],
          "line": 3269
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefCopyModelFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "144-184",
          "snippet": "int\nvirCPUDefCopyModelFilter(virCPUDefPtr dst,\n                         const virCPUDef *src,\n                         bool resetPolicy,\n                         virCPUDefFeatureFilter filter,\n                         void *opaque)\n{\n    size_t i;\n    size_t n;\n\n    if (VIR_ALLOC_N(dst->features, src->nfeatures) < 0)\n        return -1;\n\n    dst->model = g_strdup(src->model);\n    dst->vendor = g_strdup(src->vendor);\n    dst->vendor_id = g_strdup(src->vendor_id);\n    dst->microcodeVersion = src->microcodeVersion;\n    dst->nfeatures_max = src->nfeatures;\n    dst->nfeatures = 0;\n\n    for (i = 0; i < src->nfeatures; i++) {\n        if (filter && !filter(src->features[i].name, src->features[i].policy, opaque))\n            continue;\n\n        n = dst->nfeatures++;\n        if (dst->type != src->type && resetPolicy) {\n            if (dst->type == VIR_CPU_TYPE_HOST)\n                dst->features[n].policy = -1;\n            else if (src->features[i].policy == -1)\n                dst->features[n].policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                dst->features[n].policy = src->features[i].policy;\n        } else {\n            dst->features[n].policy = src->features[i].policy;\n        }\n\n        dst->features[n].name = g_strdup(src->features[i].name);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefCopyModelFilter(virCPUDefPtr dst,\n                         const virCPUDef *src,\n                         bool resetPolicy,\n                         virCPUDefFeatureFilter filter,\n                         void *opaque)\n{\n    size_t i;\n    size_t n;\n\n    if (VIR_ALLOC_N(dst->features, src->nfeatures) < 0)\n        return -1;\n\n    dst->model = g_strdup(src->model);\n    dst->vendor = g_strdup(src->vendor);\n    dst->vendor_id = g_strdup(src->vendor_id);\n    dst->microcodeVersion = src->microcodeVersion;\n    dst->nfeatures_max = src->nfeatures;\n    dst->nfeatures = 0;\n\n    for (i = 0; i < src->nfeatures; i++) {\n        if (filter && !filter(src->features[i].name, src->features[i].policy, opaque))\n            continue;\n\n        n = dst->nfeatures++;\n        if (dst->type != src->type && resetPolicy) {\n            if (dst->type == VIR_CPU_TYPE_HOST)\n                dst->features[n].policy = -1;\n            else if (src->features[i].policy == -1)\n                dst->features[n].policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                dst->features[n].policy = src->features[i].policy;\n        } else {\n            dst->features[n].policy = src->features[i].policy;\n        }\n\n        dst->features[n].name = g_strdup(src->features[i].name);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefCopyWithoutModel",
          "args": [
            "cpu"
          ],
          "line": 3266
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefCopyWithoutModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "227-266",
          "snippet": "virCPUDefPtr\nvirCPUDefCopyWithoutModel(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!cpu)\n        return NULL;\n\n    copy = virCPUDefNew();\n    copy->type = cpu->type;\n    copy->mode = cpu->mode;\n    copy->match = cpu->match;\n    copy->check = cpu->check;\n    copy->fallback = cpu->fallback;\n    copy->sockets = cpu->sockets;\n    copy->dies = cpu->dies;\n    copy->cores = cpu->cores;\n    copy->threads = cpu->threads;\n    copy->arch = cpu->arch;\n\n    if (cpu->cache) {\n        if (VIR_ALLOC(copy->cache) < 0)\n            goto error;\n\n        *copy->cache = *cpu->cache;\n    }\n\n    if (cpu->tsc) {\n        if (VIR_ALLOC(copy->tsc) < 0)\n            goto error;\n\n        *copy->tsc = *cpu->tsc;\n    }\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUDefCopyWithoutModel(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!cpu)\n        return NULL;\n\n    copy = virCPUDefNew();\n    copy->type = cpu->type;\n    copy->mode = cpu->mode;\n    copy->match = cpu->match;\n    copy->check = cpu->check;\n    copy->fallback = cpu->fallback;\n    copy->sockets = cpu->sockets;\n    copy->dies = cpu->dies;\n    copy->cores = cpu->cores;\n    copy->threads = cpu->threads;\n    copy->arch = cpu->arch;\n\n    if (cpu->cache) {\n        if (VIR_ALLOC(copy->cache) < 0)\n            goto error;\n\n        *copy->cache = *cpu->cache;\n    }\n\n    if (cpu->tsc) {\n        if (VIR_ALLOC(copy->tsc) < 0)\n            goto error;\n\n        *copy->tsc = *cpu->tsc;\n    }\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86GetMap",
          "args": [],
          "line": 3263
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86GetMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1605-1612",
          "snippet": "static virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86MapPtr cpuMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\n\nstatic virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUDefPtr\nvirCPUx86CopyMigratable(virCPUDefPtr cpu)\n{\n    virCPUDefPtr copy;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return NULL;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModelFilter(copy, cpu, false,\n                                 x86FeatureFilterMigratable, map) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}"
  },
  {
    "function_name": "x86FeatureFilterMigratable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "3248-3254",
    "snippet": "static bool\nx86FeatureFilterMigratable(const char *name,\n                           virCPUFeaturePolicy policy G_GNUC_UNUSED,\n                           void *cpu_map)\n{\n    return x86FeatureIsMigratable(name, cpu_map);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86FeatureIsMigratable",
          "args": [
            "name",
            "cpu_map"
          ],
          "line": 3253
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureIsMigratable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "942-955",
          "snippet": "static bool\nx86FeatureIsMigratable(const char *name,\n                       void *cpu_map)\n{\n    virCPUx86MapPtr map = cpu_map;\n    size_t i;\n\n    for (i = 0; i < map->nblockers; i++) {\n        if (STREQ(name, map->migrate_blockers[i]->name))\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nx86FeatureIsMigratable(const char *name,\n                       void *cpu_map)\n{\n    virCPUx86MapPtr map = cpu_map;\n    size_t i;\n\n    for (i = 0; i < map->nblockers; i++) {\n        if (STREQ(name, map->migrate_blockers[i]->name))\n            return false;\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nx86FeatureFilterMigratable(const char *name,\n                           virCPUFeaturePolicy policy G_GNUC_UNUSED,\n                           void *cpu_map)\n{\n    return x86FeatureIsMigratable(name, cpu_map);\n}"
  },
  {
    "function_name": "virCPUx86ExpandFeatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "3196-3245",
    "snippet": "static int\nvirCPUx86ExpandFeatures(virCPUDefPtr cpu)\n{\n    virCPUx86MapPtr map;\n    virCPUDefPtr expanded = NULL;\n    virCPUx86ModelPtr model = NULL;\n    bool host = cpu->type == VIR_CPU_TYPE_HOST;\n    size_t i;\n    int ret = -1;\n\n    if (!(map = virCPUx86GetMap()))\n        goto cleanup;\n\n    if (!(expanded = virCPUDefCopy(cpu)))\n        goto cleanup;\n\n    virCPUDefFreeFeatures(expanded);\n\n    if (!(model = x86ModelFind(map, cpu->model))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown CPU model %s\"), cpu->model);\n        goto cleanup;\n    }\n\n    if (!(model = x86ModelCopy(model)) ||\n        x86DataToCPUFeatures(expanded, host ? -1 : VIR_CPU_FEATURE_REQUIRE,\n                             &model->data, map) < 0)\n        goto cleanup;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUFeatureDefPtr f = cpu->features + i;\n\n        if (!host &&\n            f->policy != VIR_CPU_FEATURE_REQUIRE &&\n            f->policy != VIR_CPU_FEATURE_DISABLE)\n            continue;\n\n        if (virCPUDefUpdateFeature(expanded, f->name, f->policy) < 0)\n            goto cleanup;\n    }\n\n    virCPUDefFreeModel(cpu);\n\n    ret = virCPUDefCopyModel(cpu, expanded, false);\n\n cleanup:\n    virCPUDefFree(expanded);\n    x86ModelFree(model);\n    return ret;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86ModelFree",
          "args": [
            "model"
          ],
          "line": 3243
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1141-1151",
          "snippet": "static void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "expanded"
          ],
          "line": 3242
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefCopyModel",
          "args": [
            "cpu",
            "expanded",
            "false"
          ],
          "line": 3239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefFreeModel",
          "args": [
            "cpu"
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefUpdateFeature",
          "args": [
            "expanded",
            "f->name",
            "f->policy"
          ],
          "line": 3233
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefUpdateFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "920-926",
          "snippet": "int\nvirCPUDefUpdateFeature(virCPUDefPtr def,\n                       const char *name,\n                       int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, true);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefUpdateFeature(virCPUDefPtr def,\n                       const char *name,\n                       int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataToCPUFeatures",
          "args": [
            "expanded",
            "host ? -1 : VIR_CPU_FEATURE_REQUIRE",
            "&model->data",
            "map"
          ],
          "line": 3221
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataToCPUFeatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "603-621",
          "snippet": "static int\nx86DataToCPUFeatures(virCPUDefPtr cpu,\n                     int policy,\n                     virCPUx86Data *data,\n                     virCPUx86MapPtr map)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        virCPUx86FeaturePtr feature = map->features[i];\n        if (x86DataIsSubset(data, &feature->data)) {\n            x86DataSubtract(data, &feature->data);\n            if (virCPUDefAddFeature(cpu, feature->name, policy) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DataToCPUFeatures(virCPUDefPtr cpu,\n                     int policy,\n                     virCPUx86Data *data,\n                     virCPUx86MapPtr map)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        virCPUx86FeaturePtr feature = map->features[i];\n        if (x86DataIsSubset(data, &feature->data)) {\n            x86DataSubtract(data, &feature->data);\n            if (virCPUDefAddFeature(cpu, feature->name, policy) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelCopy",
          "args": [
            "model"
          ],
          "line": 3220
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1174-1193",
          "snippet": "static virCPUx86ModelPtr\nx86ModelCopy(virCPUx86ModelPtr model)\n{\n    virCPUx86ModelPtr copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        return NULL;\n\n    copy->name = g_strdup(model->name);\n\n    if (x86ModelCopySignatures(copy, model) < 0 ||\n        x86DataCopy(&copy->data, &model->data) < 0) {\n        x86ModelFree(copy);\n        return NULL;\n    }\n\n    copy->vendor = model->vendor;\n\n    return copy;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelCopy(virCPUx86ModelPtr model)\n{\n    virCPUx86ModelPtr copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        return NULL;\n\n    copy->name = g_strdup(model->name);\n\n    if (x86ModelCopySignatures(copy, model) < 0 ||\n        x86DataCopy(&copy->data, &model->data) < 0) {\n        x86ModelFree(copy);\n        return NULL;\n    }\n\n    copy->vendor = model->vendor;\n\n    return copy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown CPU model %s\")",
            "cpu->model"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown CPU model %s\""
          ],
          "line": 3216
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelFind",
          "args": [
            "map",
            "cpu->model"
          ],
          "line": 3214
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1196-1208",
          "snippet": "static virCPUx86ModelPtr\nx86ModelFind(virCPUx86MapPtr map,\n             const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nmodels; i++) {\n        if (STREQ(map->models[i]->name, name))\n            return map->models[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelFind(virCPUx86MapPtr map,\n             const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nmodels; i++) {\n        if (STREQ(map->models[i]->name, name))\n            return map->models[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefFreeFeatures",
          "args": [
            "expanded"
          ],
          "line": 3212
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFreeFeatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "92-102",
          "snippet": "void\nvirCPUDefFreeFeatures(virCPUDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nfeatures; i++)\n        VIR_FREE(def->features[i].name);\n    VIR_FREE(def->features);\n\n    def->nfeatures = def->nfeatures_max = 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFreeFeatures(virCPUDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nfeatures; i++)\n        VIR_FREE(def->features[i].name);\n    VIR_FREE(def->features);\n\n    def->nfeatures = def->nfeatures_max = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefCopy",
          "args": [
            "cpu"
          ],
          "line": 3209
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "269-285",
          "snippet": "virCPUDefPtr\nvirCPUDefCopy(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModel(copy, cpu, false) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUDefCopy(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModel(copy, cpu, false) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86GetMap",
          "args": [],
          "line": 3206
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86GetMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1605-1612",
          "snippet": "static virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86MapPtr cpuMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\n\nstatic virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86ExpandFeatures(virCPUDefPtr cpu)\n{\n    virCPUx86MapPtr map;\n    virCPUDefPtr expanded = NULL;\n    virCPUx86ModelPtr model = NULL;\n    bool host = cpu->type == VIR_CPU_TYPE_HOST;\n    size_t i;\n    int ret = -1;\n\n    if (!(map = virCPUx86GetMap()))\n        goto cleanup;\n\n    if (!(expanded = virCPUDefCopy(cpu)))\n        goto cleanup;\n\n    virCPUDefFreeFeatures(expanded);\n\n    if (!(model = x86ModelFind(map, cpu->model))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown CPU model %s\"), cpu->model);\n        goto cleanup;\n    }\n\n    if (!(model = x86ModelCopy(model)) ||\n        x86DataToCPUFeatures(expanded, host ? -1 : VIR_CPU_FEATURE_REQUIRE,\n                             &model->data, map) < 0)\n        goto cleanup;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUFeatureDefPtr f = cpu->features + i;\n\n        if (!host &&\n            f->policy != VIR_CPU_FEATURE_REQUIRE &&\n            f->policy != VIR_CPU_FEATURE_DISABLE)\n            continue;\n\n        if (virCPUDefUpdateFeature(expanded, f->name, f->policy) < 0)\n            goto cleanup;\n    }\n\n    virCPUDefFreeModel(cpu);\n\n    ret = virCPUDefCopyModel(cpu, expanded, false);\n\n cleanup:\n    virCPUDefFree(expanded);\n    x86ModelFree(model);\n    return ret;\n}"
  },
  {
    "function_name": "virCPUx86Translate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "3150-3193",
    "snippet": "static int\nvirCPUx86Translate(virCPUDefPtr cpu,\n                   virDomainCapsCPUModelsPtr models)\n{\n    virCPUDefPtr translated = NULL;\n    virCPUx86MapPtr map;\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!(map = virCPUx86GetMap()))\n        goto cleanup;\n\n    if (!(model = x86ModelFromCPU(cpu, map, -1)))\n        goto cleanup;\n\n    if (model->vendor &&\n        virCPUx86DataAddItem(&model->data, &model->vendor->data) < 0)\n        goto cleanup;\n\n    if (model->signatures &&\n        x86DataAddSignature(&model->data, model->signatures[0]) < 0)\n        goto cleanup;\n\n    if (!(translated = virCPUDefCopyWithoutModel(cpu)))\n        goto cleanup;\n\n    if (x86Decode(translated, &model->data, models, NULL, false) < 0)\n        goto cleanup;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUFeatureDefPtr f = cpu->features + i;\n        if (virCPUDefUpdateFeature(translated, f->name, f->policy) < 0)\n            goto cleanup;\n    }\n\n    virCPUDefStealModel(cpu, translated, true);\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(translated);\n    x86ModelFree(model);\n    return ret;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86ModelFree",
          "args": [
            "model"
          ],
          "line": 3191
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1141-1151",
          "snippet": "static void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "translated"
          ],
          "line": 3190
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefStealModel",
          "args": [
            "cpu",
            "translated",
            "true"
          ],
          "line": 3186
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefStealModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "194-224",
          "snippet": "void\nvirCPUDefStealModel(virCPUDefPtr dst,\n                    virCPUDefPtr src,\n                    bool keepVendor)\n{\n    char *vendor = NULL;\n    char *vendor_id = NULL;\n\n    if (keepVendor) {\n        vendor = g_steal_pointer(&dst->vendor);\n        vendor_id = g_steal_pointer(&dst->vendor_id);\n    }\n\n    virCPUDefFreeModel(dst);\n\n    dst->model = g_steal_pointer(&src->model);\n    dst->features = g_steal_pointer(&src->features);\n    dst->microcodeVersion = src->microcodeVersion;\n    dst->nfeatures_max = src->nfeatures_max;\n    src->nfeatures_max = 0;\n    dst->nfeatures = src->nfeatures;\n    src->nfeatures = 0;\n\n    if (keepVendor) {\n        dst->vendor = vendor;\n        dst->vendor_id = vendor_id;\n    } else {\n        dst->vendor = g_steal_pointer(&src->vendor);\n        dst->vendor_id = g_steal_pointer(&src->vendor_id);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefStealModel(virCPUDefPtr dst,\n                    virCPUDefPtr src,\n                    bool keepVendor)\n{\n    char *vendor = NULL;\n    char *vendor_id = NULL;\n\n    if (keepVendor) {\n        vendor = g_steal_pointer(&dst->vendor);\n        vendor_id = g_steal_pointer(&dst->vendor_id);\n    }\n\n    virCPUDefFreeModel(dst);\n\n    dst->model = g_steal_pointer(&src->model);\n    dst->features = g_steal_pointer(&src->features);\n    dst->microcodeVersion = src->microcodeVersion;\n    dst->nfeatures_max = src->nfeatures_max;\n    src->nfeatures_max = 0;\n    dst->nfeatures = src->nfeatures;\n    src->nfeatures = 0;\n\n    if (keepVendor) {\n        dst->vendor = vendor;\n        dst->vendor_id = vendor_id;\n    } else {\n        dst->vendor = g_steal_pointer(&src->vendor);\n        dst->vendor_id = g_steal_pointer(&src->vendor_id);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefUpdateFeature",
          "args": [
            "translated",
            "f->name",
            "f->policy"
          ],
          "line": 3182
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefUpdateFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "920-926",
          "snippet": "int\nvirCPUDefUpdateFeature(virCPUDefPtr def,\n                       const char *name,\n                       int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, true);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefUpdateFeature(virCPUDefPtr def,\n                       const char *name,\n                       int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86Decode",
          "args": [
            "translated",
            "&model->data",
            "models",
            "NULL",
            "false"
          ],
          "line": 3177
        },
        "resolved": true,
        "details": {
          "function_name": "x86Decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2095-2226",
          "snippet": "static int\nx86Decode(virCPUDefPtr cpu,\n          const virCPUx86Data *cpuData,\n          virDomainCapsCPUModelsPtr models,\n          const char *preferred,\n          bool migratable)\n{\n    int ret = -1;\n    virCPUx86MapPtr map;\n    virCPUx86ModelPtr candidate;\n    virCPUDefPtr cpuCandidate;\n    virCPUx86ModelPtr model = NULL;\n    virCPUDefPtr cpuModel = NULL;\n    virCPUx86Data data = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data copy = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data features = VIR_CPU_X86_DATA_INIT;\n    virCPUx86VendorPtr vendor;\n    virDomainCapsCPUModelPtr hvModel = NULL;\n    g_autofree char *sigs = NULL;\n    uint32_t signature;\n    ssize_t i;\n    int rc;\n\n    if (!cpuData || x86DataCopy(&data, cpuData) < 0)\n        return -1;\n\n    if (!(map = virCPUx86GetMap()))\n        goto cleanup;\n\n    vendor = x86DataToVendor(&data, map);\n    signature = x86DataToSignature(&data);\n\n    x86DataFilterTSX(&data, vendor, map);\n\n    /* Walk through the CPU models in reverse order to check newest\n     * models first.\n     */\n    for (i = map->nmodels - 1; i >= 0; i--) {\n        candidate = map->models[i];\n        if (models &&\n            !(hvModel = virDomainCapsCPUModelsGet(models, candidate->name))) {\n            if (preferred && STREQ(candidate->name, preferred)) {\n                if (cpu->fallback != VIR_CPU_FALLBACK_ALLOW) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"CPU model %s is not supported by hypervisor\"),\n                                   preferred);\n                    goto cleanup;\n                } else {\n                    VIR_WARN(\"Preferred CPU model %s not allowed by\"\n                             \" hypervisor; closest supported model will be\"\n                             \" used\", preferred);\n                }\n            } else {\n                VIR_DEBUG(\"CPU model %s not allowed by hypervisor; ignoring\",\n                          candidate->name);\n            }\n            continue;\n        }\n\n        /* Both vendor and candidate->vendor are pointers to a single list of\n         * known vendors stored in the map.\n         */\n        if (vendor && candidate->vendor && vendor != candidate->vendor) {\n            VIR_DEBUG(\"CPU vendor %s of model %s differs from %s; ignoring\",\n                      candidate->vendor->name, candidate->name, vendor->name);\n            continue;\n        }\n\n        if (!(cpuCandidate = x86DataToCPU(&data, candidate, map, hvModel)))\n            goto cleanup;\n        cpuCandidate->type = cpu->type;\n\n        if ((rc = x86DecodeUseCandidate(model, cpuModel,\n                                        candidate, cpuCandidate,\n                                        signature, preferred,\n                                        cpu->type == VIR_CPU_TYPE_HOST))) {\n            virCPUDefFree(cpuModel);\n            cpuModel = cpuCandidate;\n            model = candidate;\n            if (rc == 2)\n                break;\n        } else {\n            virCPUDefFree(cpuCandidate);\n        }\n    }\n\n    if (!cpuModel) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Cannot find suitable CPU model for given data\"));\n        goto cleanup;\n    }\n\n    /* Remove non-migratable features if requested\n     * Note: this only works as long as no CPU model contains non-migratable\n     * features directly */\n    if (migratable) {\n        i = 0;\n        while (i < cpuModel->nfeatures) {\n            if (x86FeatureIsMigratable(cpuModel->features[i].name, map)) {\n                i++;\n            } else {\n                VIR_FREE(cpuModel->features[i].name);\n                VIR_DELETE_ELEMENT_INPLACE(cpuModel->features, i,\n                                           cpuModel->nfeatures);\n            }\n        }\n    }\n\n    if (vendor)\n        cpu->vendor = g_strdup(vendor->name);\n\n    sigs = x86FormatSignatures(model);\n\n    VIR_DEBUG(\"Using CPU model %s (signatures %s) for CPU with signature %06lx\",\n              model->name, NULLSTR(sigs), (unsigned long)signature);\n\n    cpu->model = g_steal_pointer(&cpuModel->model);\n    cpu->features = g_steal_pointer(&cpuModel->features);\n    cpu->nfeatures = cpuModel->nfeatures;\n    cpuModel->nfeatures = 0;\n    cpu->nfeatures_max = cpuModel->nfeatures_max;\n    cpuModel->nfeatures_max = 0;\n\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(cpuModel);\n    virCPUx86DataClear(&data);\n    virCPUx86DataClear(&copy);\n    virCPUx86DataClear(&features);\n    return ret;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86Decode(virCPUDefPtr cpu,\n          const virCPUx86Data *cpuData,\n          virDomainCapsCPUModelsPtr models,\n          const char *preferred,\n          bool migratable)\n{\n    int ret = -1;\n    virCPUx86MapPtr map;\n    virCPUx86ModelPtr candidate;\n    virCPUDefPtr cpuCandidate;\n    virCPUx86ModelPtr model = NULL;\n    virCPUDefPtr cpuModel = NULL;\n    virCPUx86Data data = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data copy = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data features = VIR_CPU_X86_DATA_INIT;\n    virCPUx86VendorPtr vendor;\n    virDomainCapsCPUModelPtr hvModel = NULL;\n    g_autofree char *sigs = NULL;\n    uint32_t signature;\n    ssize_t i;\n    int rc;\n\n    if (!cpuData || x86DataCopy(&data, cpuData) < 0)\n        return -1;\n\n    if (!(map = virCPUx86GetMap()))\n        goto cleanup;\n\n    vendor = x86DataToVendor(&data, map);\n    signature = x86DataToSignature(&data);\n\n    x86DataFilterTSX(&data, vendor, map);\n\n    /* Walk through the CPU models in reverse order to check newest\n     * models first.\n     */\n    for (i = map->nmodels - 1; i >= 0; i--) {\n        candidate = map->models[i];\n        if (models &&\n            !(hvModel = virDomainCapsCPUModelsGet(models, candidate->name))) {\n            if (preferred && STREQ(candidate->name, preferred)) {\n                if (cpu->fallback != VIR_CPU_FALLBACK_ALLOW) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"CPU model %s is not supported by hypervisor\"),\n                                   preferred);\n                    goto cleanup;\n                } else {\n                    VIR_WARN(\"Preferred CPU model %s not allowed by\"\n                             \" hypervisor; closest supported model will be\"\n                             \" used\", preferred);\n                }\n            } else {\n                VIR_DEBUG(\"CPU model %s not allowed by hypervisor; ignoring\",\n                          candidate->name);\n            }\n            continue;\n        }\n\n        /* Both vendor and candidate->vendor are pointers to a single list of\n         * known vendors stored in the map.\n         */\n        if (vendor && candidate->vendor && vendor != candidate->vendor) {\n            VIR_DEBUG(\"CPU vendor %s of model %s differs from %s; ignoring\",\n                      candidate->vendor->name, candidate->name, vendor->name);\n            continue;\n        }\n\n        if (!(cpuCandidate = x86DataToCPU(&data, candidate, map, hvModel)))\n            goto cleanup;\n        cpuCandidate->type = cpu->type;\n\n        if ((rc = x86DecodeUseCandidate(model, cpuModel,\n                                        candidate, cpuCandidate,\n                                        signature, preferred,\n                                        cpu->type == VIR_CPU_TYPE_HOST))) {\n            virCPUDefFree(cpuModel);\n            cpuModel = cpuCandidate;\n            model = candidate;\n            if (rc == 2)\n                break;\n        } else {\n            virCPUDefFree(cpuCandidate);\n        }\n    }\n\n    if (!cpuModel) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Cannot find suitable CPU model for given data\"));\n        goto cleanup;\n    }\n\n    /* Remove non-migratable features if requested\n     * Note: this only works as long as no CPU model contains non-migratable\n     * features directly */\n    if (migratable) {\n        i = 0;\n        while (i < cpuModel->nfeatures) {\n            if (x86FeatureIsMigratable(cpuModel->features[i].name, map)) {\n                i++;\n            } else {\n                VIR_FREE(cpuModel->features[i].name);\n                VIR_DELETE_ELEMENT_INPLACE(cpuModel->features, i,\n                                           cpuModel->nfeatures);\n            }\n        }\n    }\n\n    if (vendor)\n        cpu->vendor = g_strdup(vendor->name);\n\n    sigs = x86FormatSignatures(model);\n\n    VIR_DEBUG(\"Using CPU model %s (signatures %s) for CPU with signature %06lx\",\n              model->name, NULLSTR(sigs), (unsigned long)signature);\n\n    cpu->model = g_steal_pointer(&cpuModel->model);\n    cpu->features = g_steal_pointer(&cpuModel->features);\n    cpu->nfeatures = cpuModel->nfeatures;\n    cpuModel->nfeatures = 0;\n    cpu->nfeatures_max = cpuModel->nfeatures_max;\n    cpuModel->nfeatures_max = 0;\n\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(cpuModel);\n    virCPUx86DataClear(&data);\n    virCPUx86DataClear(&copy);\n    virCPUx86DataClear(&features);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefCopyWithoutModel",
          "args": [
            "cpu"
          ],
          "line": 3174
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefCopyWithoutModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "227-266",
          "snippet": "virCPUDefPtr\nvirCPUDefCopyWithoutModel(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!cpu)\n        return NULL;\n\n    copy = virCPUDefNew();\n    copy->type = cpu->type;\n    copy->mode = cpu->mode;\n    copy->match = cpu->match;\n    copy->check = cpu->check;\n    copy->fallback = cpu->fallback;\n    copy->sockets = cpu->sockets;\n    copy->dies = cpu->dies;\n    copy->cores = cpu->cores;\n    copy->threads = cpu->threads;\n    copy->arch = cpu->arch;\n\n    if (cpu->cache) {\n        if (VIR_ALLOC(copy->cache) < 0)\n            goto error;\n\n        *copy->cache = *cpu->cache;\n    }\n\n    if (cpu->tsc) {\n        if (VIR_ALLOC(copy->tsc) < 0)\n            goto error;\n\n        *copy->tsc = *cpu->tsc;\n    }\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUDefCopyWithoutModel(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!cpu)\n        return NULL;\n\n    copy = virCPUDefNew();\n    copy->type = cpu->type;\n    copy->mode = cpu->mode;\n    copy->match = cpu->match;\n    copy->check = cpu->check;\n    copy->fallback = cpu->fallback;\n    copy->sockets = cpu->sockets;\n    copy->dies = cpu->dies;\n    copy->cores = cpu->cores;\n    copy->threads = cpu->threads;\n    copy->arch = cpu->arch;\n\n    if (cpu->cache) {\n        if (VIR_ALLOC(copy->cache) < 0)\n            goto error;\n\n        *copy->cache = *cpu->cache;\n    }\n\n    if (cpu->tsc) {\n        if (VIR_ALLOC(copy->tsc) < 0)\n            goto error;\n\n        *copy->tsc = *cpu->tsc;\n    }\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataAddSignature",
          "args": [
            "&model->data",
            "model->signatures[0]"
          ],
          "line": 3171
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataAddSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "757-764",
          "snippet": "static int\nx86DataAddSignature(virCPUx86Data *data,\n                    uint32_t signature)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1, .eax = signature);\n\n    return virCPUx86DataAddItem(data, &leaf1);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DataAddSignature(virCPUx86Data *data,\n                    uint32_t signature)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1, .eax = signature);\n\n    return virCPUx86DataAddItem(data, &leaf1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataAddItem",
          "args": [
            "&model->data",
            "&model->vendor->data"
          ],
          "line": 3167
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddItem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "500-518",
          "snippet": "static int\nvirCPUx86DataAddItem(virCPUx86Data *data,\n                     const virCPUx86DataItem *item)\n{\n    virCPUx86DataItemPtr existing;\n\n    if ((existing = virCPUx86DataGet(data, item))) {\n        virCPUx86DataItemSetBits(existing, item);\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(data->items, data->len,\n                                    *((virCPUx86DataItemPtr)item)) < 0)\n            return -1;\n\n        qsort(data->items, data->len,\n              sizeof(virCPUx86DataItem), virCPUx86DataSorter);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddItem(virCPUx86Data *data,\n                     const virCPUx86DataItem *item)\n{\n    virCPUx86DataItemPtr existing;\n\n    if ((existing = virCPUx86DataGet(data, item))) {\n        virCPUx86DataItemSetBits(existing, item);\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(data->items, data->len,\n                                    *((virCPUx86DataItemPtr)item)) < 0)\n            return -1;\n\n        qsort(data->items, data->len,\n              sizeof(virCPUx86DataItem), virCPUx86DataSorter);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelFromCPU",
          "args": [
            "cpu",
            "map",
            "-1"
          ],
          "line": 3163
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFromCPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1220-1299",
          "snippet": "static virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86GetMap",
          "args": [],
          "line": 3160
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86GetMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1605-1612",
          "snippet": "static virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86MapPtr cpuMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\n\nstatic virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86Translate(virCPUDefPtr cpu,\n                   virDomainCapsCPUModelsPtr models)\n{\n    virCPUDefPtr translated = NULL;\n    virCPUx86MapPtr map;\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!(map = virCPUx86GetMap()))\n        goto cleanup;\n\n    if (!(model = x86ModelFromCPU(cpu, map, -1)))\n        goto cleanup;\n\n    if (model->vendor &&\n        virCPUx86DataAddItem(&model->data, &model->vendor->data) < 0)\n        goto cleanup;\n\n    if (model->signatures &&\n        x86DataAddSignature(&model->data, model->signatures[0]) < 0)\n        goto cleanup;\n\n    if (!(translated = virCPUDefCopyWithoutModel(cpu)))\n        goto cleanup;\n\n    if (x86Decode(translated, &model->data, models, NULL, false) < 0)\n        goto cleanup;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUFeatureDefPtr f = cpu->features + i;\n        if (virCPUDefUpdateFeature(translated, f->name, f->policy) < 0)\n            goto cleanup;\n    }\n\n    virCPUDefStealModel(cpu, translated, true);\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(translated);\n    x86ModelFree(model);\n    return ret;\n}"
  },
  {
    "function_name": "virCPUx86GetModels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "3122-3147",
    "snippet": "static int\nvirCPUx86GetModels(char ***models)\n{\n    virCPUx86MapPtr map;\n    size_t i;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    if (models) {\n        if (VIR_ALLOC_N(*models, map->nmodels + 1) < 0)\n            goto error;\n\n        for (i = 0; i < map->nmodels; i++)\n            (*models)[i] = g_strdup(map->models[i]->name);\n    }\n\n    return map->nmodels;\n\n error:\n    if (models) {\n        virStringListFree(*models);\n        *models = NULL;\n    }\n    return -1;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "*models"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "map->models[i]->name"
          ],
          "line": 3136
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*models",
            "map->nmodels + 1"
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUx86GetMap",
          "args": [],
          "line": 3128
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86GetMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1605-1612",
          "snippet": "static virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86MapPtr cpuMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\n\nstatic virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86GetModels(char ***models)\n{\n    virCPUx86MapPtr map;\n    size_t i;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    if (models) {\n        if (VIR_ALLOC_N(*models, map->nmodels + 1) < 0)\n            goto error;\n\n        for (i = 0; i < map->nmodels; i++)\n            (*models)[i] = g_strdup(map->models[i]->name);\n    }\n\n    return map->nmodels;\n\n error:\n    if (models) {\n        virStringListFree(*models);\n        *models = NULL;\n    }\n    return -1;\n}"
  },
  {
    "function_name": "virCPUx86UpdateLive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "3007-3119",
    "snippet": "static int\nvirCPUx86UpdateLive(virCPUDefPtr cpu,\n                    virCPUDataPtr dataEnabled,\n                    virCPUDataPtr dataDisabled)\n{\n    bool hostPassthrough = cpu->mode == VIR_CPU_MODE_HOST_PASSTHROUGH;\n    virCPUx86MapPtr map;\n    virCPUx86ModelPtr model = NULL;\n    virCPUx86ModelPtr modelDisabled = NULL;\n    virCPUx86Data enabled = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data disabled = VIR_CPU_X86_DATA_INIT;\n    virBuffer bufAdded = VIR_BUFFER_INITIALIZER;\n    virBuffer bufRemoved = VIR_BUFFER_INITIALIZER;\n    char *added = NULL;\n    char *removed = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    if (!(model = x86ModelFromCPU(cpu, map, -1)))\n        goto cleanup;\n\n    if (hostPassthrough &&\n        !(modelDisabled = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_DISABLE)))\n        goto cleanup;\n\n    if (dataEnabled &&\n        x86DataCopy(&enabled, &dataEnabled->data.x86) < 0)\n        goto cleanup;\n\n    if (dataDisabled &&\n        x86DataCopy(&disabled, &dataDisabled->data.x86) < 0)\n        goto cleanup;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        virCPUx86FeaturePtr feature = map->features[i];\n        virCPUFeaturePolicy expected = VIR_CPU_FEATURE_LAST;\n\n        if (x86DataIsSubset(&model->data, &feature->data))\n            expected = VIR_CPU_FEATURE_REQUIRE;\n        else if (!hostPassthrough ||\n                 x86DataIsSubset(&modelDisabled->data, &feature->data))\n            expected = VIR_CPU_FEATURE_DISABLE;\n\n        if (expected == VIR_CPU_FEATURE_DISABLE &&\n            x86DataIsSubset(&enabled, &feature->data)) {\n            VIR_DEBUG(\"Feature '%s' enabled by the hypervisor\", feature->name);\n            if (cpu->check == VIR_CPU_CHECK_FULL)\n                virBufferAsprintf(&bufAdded, \"%s,\", feature->name);\n            else if (virCPUDefUpdateFeature(cpu, feature->name,\n                                            VIR_CPU_FEATURE_REQUIRE) < 0)\n                goto cleanup;\n        }\n\n        if (x86DataIsSubset(&disabled, &feature->data) ||\n            (expected == VIR_CPU_FEATURE_REQUIRE &&\n             !x86DataIsSubset(&enabled, &feature->data))) {\n            VIR_DEBUG(\"Feature '%s' disabled by the hypervisor\", feature->name);\n            if (cpu->check == VIR_CPU_CHECK_FULL)\n                virBufferAsprintf(&bufRemoved, \"%s,\", feature->name);\n            else if (virCPUDefUpdateFeature(cpu, feature->name,\n                                            VIR_CPU_FEATURE_DISABLE) < 0)\n                goto cleanup;\n        }\n    }\n\n    virBufferTrim(&bufAdded, \",\");\n    virBufferTrim(&bufRemoved, \",\");\n\n    added = virBufferContentAndReset(&bufAdded);\n    removed = virBufferContentAndReset(&bufRemoved);\n\n    if (added || removed) {\n        if (added && removed)\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"guest CPU doesn't match specification: \"\n                             \"extra features: %s, missing features: %s\"),\n                           added, removed);\n        else if (added)\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"guest CPU doesn't match specification: \"\n                             \"extra features: %s\"),\n                           added);\n        else\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"guest CPU doesn't match specification: \"\n                             \"missing features: %s\"),\n                           removed);\n        goto cleanup;\n    }\n\n    if (cpu->check == VIR_CPU_CHECK_FULL &&\n        !x86DataIsEmpty(&disabled)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"guest CPU doesn't match specification\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    x86ModelFree(model);\n    x86ModelFree(modelDisabled);\n    virCPUx86DataClear(&enabled);\n    virCPUx86DataClear(&disabled);\n    VIR_FREE(added);\n    VIR_FREE(removed);\n    virBufferFreeAndReset(&bufAdded);\n    virBufferFreeAndReset(&bufRemoved);\n    return ret;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&bufRemoved"
          ],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "removed"
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "added"
          ],
          "line": 3114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUx86DataClear",
          "args": [
            "&disabled"
          ],
          "line": 3113
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "463-470",
          "snippet": "static void\nvirCPUx86DataClear(virCPUx86Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->items);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataClear(virCPUx86Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->items);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelFree",
          "args": [
            "modelDisabled"
          ],
          "line": 3111
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1141-1151",
          "snippet": "static void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"guest CPU doesn't match specification\")"
          ],
          "line": 3102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"guest CPU doesn't match specification\""
          ],
          "line": 3103
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataIsEmpty",
          "args": [
            "&disabled"
          ],
          "line": 3101
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "573-580",
          "snippet": "static bool\nx86DataIsEmpty(virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter;\n\n    virCPUx86DataIteratorInit(&iter, data);\n    return !virCPUx86DataNext(&iter);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nx86DataIsEmpty(virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter;\n\n    virCPUx86DataIteratorInit(&iter, data);\n    return !virCPUx86DataNext(&iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"guest CPU doesn't match specification: \"\n                             \"missing features: %s\")",
            "removed"
          ],
          "line": 3093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"guest CPU doesn't match specification: \"\n                             \"extra features: %s\")",
            "added"
          ],
          "line": 3088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"guest CPU doesn't match specification: \"\n                             \"extra features: %s, missing features: %s\")",
            "added",
            "removed"
          ],
          "line": 3083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&bufRemoved"
          ],
          "line": 3079
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferTrim",
          "args": [
            "&bufRemoved",
            "\",\""
          ],
          "line": 3076
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferTrimLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "698-708",
          "snippet": "void\nvirBufferTrimLen(virBufferPtr buf, int len)\n{\n    if (!buf || !buf->str)\n        return;\n\n    if (len > buf->str->len)\n        return;\n\n    g_string_truncate(buf->str, buf->str->len - len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferTrimLen(virBufferPtr buf, int len)\n{\n    if (!buf || !buf->str)\n        return;\n\n    if (len > buf->str->len)\n        return;\n\n    g_string_truncate(buf->str, buf->str->len - len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefUpdateFeature",
          "args": [
            "cpu",
            "feature->name",
            "VIR_CPU_FEATURE_DISABLE"
          ],
          "line": 3069
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefUpdateFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "920-926",
          "snippet": "int\nvirCPUDefUpdateFeature(virCPUDefPtr def,\n                       const char *name,\n                       int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, true);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefUpdateFeature(virCPUDefPtr def,\n                       const char *name,\n                       int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&bufRemoved",
            "\"%s,\"",
            "feature->name"
          ],
          "line": 3068
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Feature '%s' disabled by the hypervisor\"",
            "feature->name"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86DataIsSubset",
          "args": [
            "&enabled",
            "&feature->data"
          ],
          "line": 3065
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataIsSubset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "583-599",
          "snippet": "static bool\nx86DataIsSubset(const virCPUx86Data *data,\n                const virCPUx86Data *subset)\n{\n    virCPUx86DataIterator iter;\n    const virCPUx86DataItem *item;\n    const virCPUx86DataItem *itemSubset;\n\n    virCPUx86DataIteratorInit(&iter, subset);\n    while ((itemSubset = virCPUx86DataNext(&iter))) {\n        if (!(item = virCPUx86DataGet(data, itemSubset)) ||\n            !virCPUx86DataItemMatchMasked(item, itemSubset))\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nx86DataIsSubset(const virCPUx86Data *data,\n                const virCPUx86Data *subset)\n{\n    virCPUx86DataIterator iter;\n    const virCPUx86DataItem *item;\n    const virCPUx86DataItem *itemSubset;\n\n    virCPUx86DataIteratorInit(&iter, subset);\n    while ((itemSubset = virCPUx86DataNext(&iter))) {\n        if (!(item = virCPUx86DataGet(data, itemSubset)) ||\n            !virCPUx86DataItemMatchMasked(item, itemSubset))\n            return false;\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Feature '%s' enabled by the hypervisor\"",
            "feature->name"
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86DataCopy",
          "args": [
            "&disabled",
            "&dataDisabled->data.x86"
          ],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "484-497",
          "snippet": "static int\nx86DataCopy(virCPUx86Data *dst, const virCPUx86Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->items, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n    for (i = 0; i < src->len; i++)\n        dst->items[i] = src->items[i];\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DataCopy(virCPUx86Data *dst, const virCPUx86Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->items, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n    for (i = 0; i < src->len; i++)\n        dst->items[i] = src->items[i];\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelFromCPU",
          "args": [
            "cpu",
            "map",
            "VIR_CPU_FEATURE_DISABLE"
          ],
          "line": 3032
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFromCPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1220-1299",
          "snippet": "static virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86GetMap",
          "args": [],
          "line": 3025
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86GetMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1605-1612",
          "snippet": "static virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86MapPtr cpuMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\n\nstatic virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86UpdateLive(virCPUDefPtr cpu,\n                    virCPUDataPtr dataEnabled,\n                    virCPUDataPtr dataDisabled)\n{\n    bool hostPassthrough = cpu->mode == VIR_CPU_MODE_HOST_PASSTHROUGH;\n    virCPUx86MapPtr map;\n    virCPUx86ModelPtr model = NULL;\n    virCPUx86ModelPtr modelDisabled = NULL;\n    virCPUx86Data enabled = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data disabled = VIR_CPU_X86_DATA_INIT;\n    virBuffer bufAdded = VIR_BUFFER_INITIALIZER;\n    virBuffer bufRemoved = VIR_BUFFER_INITIALIZER;\n    char *added = NULL;\n    char *removed = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    if (!(model = x86ModelFromCPU(cpu, map, -1)))\n        goto cleanup;\n\n    if (hostPassthrough &&\n        !(modelDisabled = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_DISABLE)))\n        goto cleanup;\n\n    if (dataEnabled &&\n        x86DataCopy(&enabled, &dataEnabled->data.x86) < 0)\n        goto cleanup;\n\n    if (dataDisabled &&\n        x86DataCopy(&disabled, &dataDisabled->data.x86) < 0)\n        goto cleanup;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        virCPUx86FeaturePtr feature = map->features[i];\n        virCPUFeaturePolicy expected = VIR_CPU_FEATURE_LAST;\n\n        if (x86DataIsSubset(&model->data, &feature->data))\n            expected = VIR_CPU_FEATURE_REQUIRE;\n        else if (!hostPassthrough ||\n                 x86DataIsSubset(&modelDisabled->data, &feature->data))\n            expected = VIR_CPU_FEATURE_DISABLE;\n\n        if (expected == VIR_CPU_FEATURE_DISABLE &&\n            x86DataIsSubset(&enabled, &feature->data)) {\n            VIR_DEBUG(\"Feature '%s' enabled by the hypervisor\", feature->name);\n            if (cpu->check == VIR_CPU_CHECK_FULL)\n                virBufferAsprintf(&bufAdded, \"%s,\", feature->name);\n            else if (virCPUDefUpdateFeature(cpu, feature->name,\n                                            VIR_CPU_FEATURE_REQUIRE) < 0)\n                goto cleanup;\n        }\n\n        if (x86DataIsSubset(&disabled, &feature->data) ||\n            (expected == VIR_CPU_FEATURE_REQUIRE &&\n             !x86DataIsSubset(&enabled, &feature->data))) {\n            VIR_DEBUG(\"Feature '%s' disabled by the hypervisor\", feature->name);\n            if (cpu->check == VIR_CPU_CHECK_FULL)\n                virBufferAsprintf(&bufRemoved, \"%s,\", feature->name);\n            else if (virCPUDefUpdateFeature(cpu, feature->name,\n                                            VIR_CPU_FEATURE_DISABLE) < 0)\n                goto cleanup;\n        }\n    }\n\n    virBufferTrim(&bufAdded, \",\");\n    virBufferTrim(&bufRemoved, \",\");\n\n    added = virBufferContentAndReset(&bufAdded);\n    removed = virBufferContentAndReset(&bufRemoved);\n\n    if (added || removed) {\n        if (added && removed)\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"guest CPU doesn't match specification: \"\n                             \"extra features: %s, missing features: %s\"),\n                           added, removed);\n        else if (added)\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"guest CPU doesn't match specification: \"\n                             \"extra features: %s\"),\n                           added);\n        else\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"guest CPU doesn't match specification: \"\n                             \"missing features: %s\"),\n                           removed);\n        goto cleanup;\n    }\n\n    if (cpu->check == VIR_CPU_CHECK_FULL &&\n        !x86DataIsEmpty(&disabled)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"guest CPU doesn't match specification\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    x86ModelFree(model);\n    x86ModelFree(modelDisabled);\n    virCPUx86DataClear(&enabled);\n    virCPUx86DataClear(&disabled);\n    VIR_FREE(added);\n    VIR_FREE(removed);\n    virBufferFreeAndReset(&bufAdded);\n    virBufferFreeAndReset(&bufRemoved);\n    return ret;\n}"
  },
  {
    "function_name": "virCPUx86Update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2961-3004",
    "snippet": "static int\nvirCPUx86Update(virCPUDefPtr guest,\n                const virCPUDef *host)\n{\n    virCPUx86ModelPtr model = NULL;\n    virCPUx86MapPtr map;\n    int ret = -1;\n    size_t i;\n\n    if (!host) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unknown host CPU model\"));\n        return -1;\n    }\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    if (!(model = x86ModelFromCPU(host, map, -1)))\n        goto cleanup;\n\n    for (i = 0; i < guest->nfeatures; i++) {\n        if (guest->features[i].policy == VIR_CPU_FEATURE_OPTIONAL) {\n            int supported = x86FeatureInData(guest->features[i].name,\n                                             &model->data, map);\n            if (supported < 0)\n                goto cleanup;\n            else if (supported)\n                guest->features[i].policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                guest->features[i].policy = VIR_CPU_FEATURE_DISABLE;\n        }\n    }\n\n    if (guest->mode == VIR_CPU_MODE_HOST_MODEL ||\n        guest->match == VIR_CPU_MATCH_MINIMUM)\n        ret = x86UpdateHostModel(guest, host);\n    else\n        ret = 0;\n\n cleanup:\n    x86ModelFree(model);\n    return ret;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86ModelFree",
          "args": [
            "model"
          ],
          "line": 3002
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1141-1151",
          "snippet": "static void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86UpdateHostModel",
          "args": [
            "guest",
            "host"
          ],
          "line": 2997
        },
        "resolved": true,
        "details": {
          "function_name": "x86UpdateHostModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2921-2958",
          "snippet": "static int\nx86UpdateHostModel(virCPUDefPtr guest,\n                   const virCPUDef *host)\n{\n    virCPUDefPtr updated = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!(updated = virCPUDefCopyWithoutModel(host)))\n        goto cleanup;\n\n    updated->type = VIR_CPU_TYPE_GUEST;\n    updated->mode = VIR_CPU_MODE_CUSTOM;\n    if (virCPUDefCopyModel(updated, host, true) < 0)\n        goto cleanup;\n\n    if (guest->vendor_id) {\n        VIR_FREE(updated->vendor_id);\n        updated->vendor_id = g_strdup(guest->vendor_id);\n    }\n\n    for (i = 0; i < guest->nfeatures; i++) {\n        if (virCPUDefUpdateFeature(updated,\n                                   guest->features[i].name,\n                                   guest->features[i].policy) < 0)\n            goto cleanup;\n    }\n\n    virCPUDefStealModel(guest, updated,\n                        guest->mode == VIR_CPU_MODE_CUSTOM);\n    guest->mode = VIR_CPU_MODE_CUSTOM;\n    guest->match = VIR_CPU_MATCH_EXACT;\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(updated);\n    return ret;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86UpdateHostModel(virCPUDefPtr guest,\n                   const virCPUDef *host)\n{\n    virCPUDefPtr updated = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!(updated = virCPUDefCopyWithoutModel(host)))\n        goto cleanup;\n\n    updated->type = VIR_CPU_TYPE_GUEST;\n    updated->mode = VIR_CPU_MODE_CUSTOM;\n    if (virCPUDefCopyModel(updated, host, true) < 0)\n        goto cleanup;\n\n    if (guest->vendor_id) {\n        VIR_FREE(updated->vendor_id);\n        updated->vendor_id = g_strdup(guest->vendor_id);\n    }\n\n    for (i = 0; i < guest->nfeatures; i++) {\n        if (virCPUDefUpdateFeature(updated,\n                                   guest->features[i].name,\n                                   guest->features[i].policy) < 0)\n            goto cleanup;\n    }\n\n    virCPUDefStealModel(guest, updated,\n                        guest->mode == VIR_CPU_MODE_CUSTOM);\n    guest->mode = VIR_CPU_MODE_CUSTOM;\n    guest->match = VIR_CPU_MATCH_EXACT;\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(updated);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86FeatureInData",
          "args": [
            "guest->features[i].name",
            "&model->data",
            "map"
          ],
          "line": 2984
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureInData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "921-939",
          "snippet": "static int\nx86FeatureInData(const char *name,\n                 const virCPUx86Data *data,\n                 virCPUx86MapPtr map)\n{\n    virCPUx86FeaturePtr feature;\n\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown CPU feature %s\"), name);\n        return -1;\n    }\n\n    if (x86DataIsSubset(data, &feature->data))\n        return 1;\n    else\n        return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86FeatureInData(const char *name,\n                 const virCPUx86Data *data,\n                 virCPUx86MapPtr map)\n{\n    virCPUx86FeaturePtr feature;\n\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown CPU feature %s\"), name);\n        return -1;\n    }\n\n    if (x86DataIsSubset(data, &feature->data))\n        return 1;\n    else\n        return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelFromCPU",
          "args": [
            "host",
            "map",
            "-1"
          ],
          "line": 2979
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFromCPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1220-1299",
          "snippet": "static virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86GetMap",
          "args": [],
          "line": 2976
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86GetMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1605-1612",
          "snippet": "static virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86MapPtr cpuMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\n\nstatic virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unknown host CPU model\")"
          ],
          "line": 2971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown host CPU model\""
          ],
          "line": 2972
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86Update(virCPUDefPtr guest,\n                const virCPUDef *host)\n{\n    virCPUx86ModelPtr model = NULL;\n    virCPUx86MapPtr map;\n    int ret = -1;\n    size_t i;\n\n    if (!host) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"unknown host CPU model\"));\n        return -1;\n    }\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    if (!(model = x86ModelFromCPU(host, map, -1)))\n        goto cleanup;\n\n    for (i = 0; i < guest->nfeatures; i++) {\n        if (guest->features[i].policy == VIR_CPU_FEATURE_OPTIONAL) {\n            int supported = x86FeatureInData(guest->features[i].name,\n                                             &model->data, map);\n            if (supported < 0)\n                goto cleanup;\n            else if (supported)\n                guest->features[i].policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                guest->features[i].policy = VIR_CPU_FEATURE_DISABLE;\n        }\n    }\n\n    if (guest->mode == VIR_CPU_MODE_HOST_MODEL ||\n        guest->match == VIR_CPU_MATCH_MINIMUM)\n        ret = x86UpdateHostModel(guest, host);\n    else\n        ret = 0;\n\n cleanup:\n    x86ModelFree(model);\n    return ret;\n}"
  },
  {
    "function_name": "x86UpdateHostModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2921-2958",
    "snippet": "static int\nx86UpdateHostModel(virCPUDefPtr guest,\n                   const virCPUDef *host)\n{\n    virCPUDefPtr updated = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!(updated = virCPUDefCopyWithoutModel(host)))\n        goto cleanup;\n\n    updated->type = VIR_CPU_TYPE_GUEST;\n    updated->mode = VIR_CPU_MODE_CUSTOM;\n    if (virCPUDefCopyModel(updated, host, true) < 0)\n        goto cleanup;\n\n    if (guest->vendor_id) {\n        VIR_FREE(updated->vendor_id);\n        updated->vendor_id = g_strdup(guest->vendor_id);\n    }\n\n    for (i = 0; i < guest->nfeatures; i++) {\n        if (virCPUDefUpdateFeature(updated,\n                                   guest->features[i].name,\n                                   guest->features[i].policy) < 0)\n            goto cleanup;\n    }\n\n    virCPUDefStealModel(guest, updated,\n                        guest->mode == VIR_CPU_MODE_CUSTOM);\n    guest->mode = VIR_CPU_MODE_CUSTOM;\n    guest->match = VIR_CPU_MATCH_EXACT;\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(updated);\n    return ret;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "updated"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefStealModel",
          "args": [
            "guest",
            "updated",
            "guest->mode == VIR_CPU_MODE_CUSTOM"
          ],
          "line": 2949
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefStealModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "194-224",
          "snippet": "void\nvirCPUDefStealModel(virCPUDefPtr dst,\n                    virCPUDefPtr src,\n                    bool keepVendor)\n{\n    char *vendor = NULL;\n    char *vendor_id = NULL;\n\n    if (keepVendor) {\n        vendor = g_steal_pointer(&dst->vendor);\n        vendor_id = g_steal_pointer(&dst->vendor_id);\n    }\n\n    virCPUDefFreeModel(dst);\n\n    dst->model = g_steal_pointer(&src->model);\n    dst->features = g_steal_pointer(&src->features);\n    dst->microcodeVersion = src->microcodeVersion;\n    dst->nfeatures_max = src->nfeatures_max;\n    src->nfeatures_max = 0;\n    dst->nfeatures = src->nfeatures;\n    src->nfeatures = 0;\n\n    if (keepVendor) {\n        dst->vendor = vendor;\n        dst->vendor_id = vendor_id;\n    } else {\n        dst->vendor = g_steal_pointer(&src->vendor);\n        dst->vendor_id = g_steal_pointer(&src->vendor_id);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefStealModel(virCPUDefPtr dst,\n                    virCPUDefPtr src,\n                    bool keepVendor)\n{\n    char *vendor = NULL;\n    char *vendor_id = NULL;\n\n    if (keepVendor) {\n        vendor = g_steal_pointer(&dst->vendor);\n        vendor_id = g_steal_pointer(&dst->vendor_id);\n    }\n\n    virCPUDefFreeModel(dst);\n\n    dst->model = g_steal_pointer(&src->model);\n    dst->features = g_steal_pointer(&src->features);\n    dst->microcodeVersion = src->microcodeVersion;\n    dst->nfeatures_max = src->nfeatures_max;\n    src->nfeatures_max = 0;\n    dst->nfeatures = src->nfeatures;\n    src->nfeatures = 0;\n\n    if (keepVendor) {\n        dst->vendor = vendor;\n        dst->vendor_id = vendor_id;\n    } else {\n        dst->vendor = g_steal_pointer(&src->vendor);\n        dst->vendor_id = g_steal_pointer(&src->vendor_id);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefUpdateFeature",
          "args": [
            "updated",
            "guest->features[i].name",
            "guest->features[i].policy"
          ],
          "line": 2943
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefUpdateFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "920-926",
          "snippet": "int\nvirCPUDefUpdateFeature(virCPUDefPtr def,\n                       const char *name,\n                       int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, true);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefUpdateFeature(virCPUDefPtr def,\n                       const char *name,\n                       int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "guest->vendor_id"
          ],
          "line": 2939
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "updated->vendor_id"
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefCopyModel",
          "args": [
            "updated",
            "host",
            "true"
          ],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefCopyWithoutModel",
          "args": [
            "host"
          ],
          "line": 2929
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefCopyWithoutModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "227-266",
          "snippet": "virCPUDefPtr\nvirCPUDefCopyWithoutModel(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!cpu)\n        return NULL;\n\n    copy = virCPUDefNew();\n    copy->type = cpu->type;\n    copy->mode = cpu->mode;\n    copy->match = cpu->match;\n    copy->check = cpu->check;\n    copy->fallback = cpu->fallback;\n    copy->sockets = cpu->sockets;\n    copy->dies = cpu->dies;\n    copy->cores = cpu->cores;\n    copy->threads = cpu->threads;\n    copy->arch = cpu->arch;\n\n    if (cpu->cache) {\n        if (VIR_ALLOC(copy->cache) < 0)\n            goto error;\n\n        *copy->cache = *cpu->cache;\n    }\n\n    if (cpu->tsc) {\n        if (VIR_ALLOC(copy->tsc) < 0)\n            goto error;\n\n        *copy->tsc = *cpu->tsc;\n    }\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUDefCopyWithoutModel(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!cpu)\n        return NULL;\n\n    copy = virCPUDefNew();\n    copy->type = cpu->type;\n    copy->mode = cpu->mode;\n    copy->match = cpu->match;\n    copy->check = cpu->check;\n    copy->fallback = cpu->fallback;\n    copy->sockets = cpu->sockets;\n    copy->dies = cpu->dies;\n    copy->cores = cpu->cores;\n    copy->threads = cpu->threads;\n    copy->arch = cpu->arch;\n\n    if (cpu->cache) {\n        if (VIR_ALLOC(copy->cache) < 0)\n            goto error;\n\n        *copy->cache = *cpu->cache;\n    }\n\n    if (cpu->tsc) {\n        if (VIR_ALLOC(copy->tsc) < 0)\n            goto error;\n\n        *copy->tsc = *cpu->tsc;\n    }\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86UpdateHostModel(virCPUDefPtr guest,\n                   const virCPUDef *host)\n{\n    virCPUDefPtr updated = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!(updated = virCPUDefCopyWithoutModel(host)))\n        goto cleanup;\n\n    updated->type = VIR_CPU_TYPE_GUEST;\n    updated->mode = VIR_CPU_MODE_CUSTOM;\n    if (virCPUDefCopyModel(updated, host, true) < 0)\n        goto cleanup;\n\n    if (guest->vendor_id) {\n        VIR_FREE(updated->vendor_id);\n        updated->vendor_id = g_strdup(guest->vendor_id);\n    }\n\n    for (i = 0; i < guest->nfeatures; i++) {\n        if (virCPUDefUpdateFeature(updated,\n                                   guest->features[i].name,\n                                   guest->features[i].policy) < 0)\n            goto cleanup;\n    }\n\n    virCPUDefStealModel(guest, updated,\n                        guest->mode == VIR_CPU_MODE_CUSTOM);\n    guest->mode = VIR_CPU_MODE_CUSTOM;\n    guest->match = VIR_CPU_MATCH_EXACT;\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(updated);\n    return ret;\n}"
  },
  {
    "function_name": "virCPUx86Baseline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2785-2918",
    "snippet": "static virCPUDefPtr\nvirCPUx86Baseline(virCPUDefPtr *cpus,\n                  unsigned int ncpus,\n                  virDomainCapsCPUModelsPtr models,\n                  const char **features,\n                  bool migratable)\n{\n    virCPUx86MapPtr map = NULL;\n    virCPUx86ModelPtr base_model = NULL;\n    virCPUDefPtr cpu = NULL;\n    size_t i;\n    virCPUx86VendorPtr vendor = NULL;\n    virCPUx86ModelPtr model = NULL;\n    bool outputVendor = true;\n    const char *modelName;\n    bool matchingNames = true;\n    virCPUDataPtr featData = NULL;\n\n    if (!(map = virCPUx86GetMap()))\n        goto error;\n\n    if (!(base_model = x86ModelFromCPU(cpus[0], map, -1)))\n        goto error;\n\n    cpu = virCPUDefNew();\n\n    cpu->type = VIR_CPU_TYPE_GUEST;\n    cpu->match = VIR_CPU_MATCH_EXACT;\n\n    if (!cpus[0]->vendor) {\n        outputVendor = false;\n    } else if (!(vendor = x86VendorFind(map, cpus[0]->vendor))) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Unknown CPU vendor %s\"), cpus[0]->vendor);\n        goto error;\n    }\n\n    modelName = cpus[0]->model;\n    for (i = 1; i < ncpus; i++) {\n        const char *vn = NULL;\n\n        if (matchingNames && cpus[i]->model) {\n            if (!modelName) {\n                modelName = cpus[i]->model;\n            } else if (STRNEQ(modelName, cpus[i]->model)) {\n                modelName = NULL;\n                matchingNames = false;\n            }\n        }\n\n        if (!(model = x86ModelFromCPU(cpus[i], map, -1)))\n            goto error;\n\n        if (cpus[i]->vendor && model->vendor &&\n            STRNEQ(cpus[i]->vendor, model->vendor->name)) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"CPU vendor %s of model %s differs from vendor %s\"),\n                           model->vendor->name, model->name, cpus[i]->vendor);\n            goto error;\n        }\n\n        if (cpus[i]->vendor) {\n            vn = cpus[i]->vendor;\n        } else {\n            outputVendor = false;\n            if (model->vendor)\n                vn = model->vendor->name;\n        }\n\n        if (vn) {\n            if (!vendor) {\n                if (!(vendor = x86VendorFind(map, vn))) {\n                    virReportError(VIR_ERR_OPERATION_FAILED,\n                                   _(\"Unknown CPU vendor %s\"), vn);\n                    goto error;\n                }\n            } else if (STRNEQ(vendor->name, vn)) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               \"%s\", _(\"CPU vendors do not match\"));\n                goto error;\n            }\n        }\n\n        x86DataIntersect(&base_model->data, &model->data);\n        x86ModelFree(model);\n        model = NULL;\n    }\n\n    if (features) {\n        virCPUx86FeaturePtr feat;\n\n        if (!(featData = virCPUDataNew(archs[0])))\n            goto cleanup;\n\n        for (i = 0; features[i]; i++) {\n            if ((feat = x86FeatureFind(map, features[i])) &&\n                x86DataAdd(&featData->data.x86, &feat->data) < 0)\n                goto cleanup;\n        }\n\n        x86DataIntersect(&base_model->data, &featData->data.x86);\n    }\n\n    if (x86DataIsEmpty(&base_model->data)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       \"%s\", _(\"CPUs are incompatible\"));\n        goto error;\n    }\n\n    if (vendor &&\n        virCPUx86DataAddItem(&base_model->data, &vendor->data) < 0)\n        goto error;\n\n    if (x86Decode(cpu, &base_model->data, models, modelName, migratable) < 0)\n        goto error;\n\n    if (STREQ_NULLABLE(cpu->model, modelName))\n        cpu->fallback = VIR_CPU_FALLBACK_FORBID;\n\n    if (!outputVendor)\n        VIR_FREE(cpu->vendor);\n\n cleanup:\n    x86ModelFree(base_model);\n    virCPUx86DataFree(featData);\n\n    return cpu;\n\n error:\n    x86ModelFree(model);\n    virCPUDefFree(cpu);\n    cpu = NULL;\n    goto cleanup;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const virArch archs[] = { VIR_ARCH_I686, VIR_ARCH_X86_64 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "cpu"
          ],
          "line": 2915
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelFree",
          "args": [
            "model"
          ],
          "line": 2914
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1141-1151",
          "snippet": "static void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataFree",
          "args": [
            "featData"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "473-481",
          "snippet": "static void\nvirCPUx86DataFree(virCPUDataPtr data)\n{\n    if (!data)\n        return;\n\n    virCPUx86DataClear(&data->data.x86);\n    VIR_FREE(data);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataFree(virCPUDataPtr data)\n{\n    if (!data)\n        return;\n\n    virCPUx86DataClear(&data->data.x86);\n    VIR_FREE(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpu->vendor"
          ],
          "line": 2905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "cpu->model",
            "modelName"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86Decode",
          "args": [
            "cpu",
            "&base_model->data",
            "models",
            "modelName",
            "migratable"
          ],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "x86Decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2095-2226",
          "snippet": "static int\nx86Decode(virCPUDefPtr cpu,\n          const virCPUx86Data *cpuData,\n          virDomainCapsCPUModelsPtr models,\n          const char *preferred,\n          bool migratable)\n{\n    int ret = -1;\n    virCPUx86MapPtr map;\n    virCPUx86ModelPtr candidate;\n    virCPUDefPtr cpuCandidate;\n    virCPUx86ModelPtr model = NULL;\n    virCPUDefPtr cpuModel = NULL;\n    virCPUx86Data data = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data copy = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data features = VIR_CPU_X86_DATA_INIT;\n    virCPUx86VendorPtr vendor;\n    virDomainCapsCPUModelPtr hvModel = NULL;\n    g_autofree char *sigs = NULL;\n    uint32_t signature;\n    ssize_t i;\n    int rc;\n\n    if (!cpuData || x86DataCopy(&data, cpuData) < 0)\n        return -1;\n\n    if (!(map = virCPUx86GetMap()))\n        goto cleanup;\n\n    vendor = x86DataToVendor(&data, map);\n    signature = x86DataToSignature(&data);\n\n    x86DataFilterTSX(&data, vendor, map);\n\n    /* Walk through the CPU models in reverse order to check newest\n     * models first.\n     */\n    for (i = map->nmodels - 1; i >= 0; i--) {\n        candidate = map->models[i];\n        if (models &&\n            !(hvModel = virDomainCapsCPUModelsGet(models, candidate->name))) {\n            if (preferred && STREQ(candidate->name, preferred)) {\n                if (cpu->fallback != VIR_CPU_FALLBACK_ALLOW) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"CPU model %s is not supported by hypervisor\"),\n                                   preferred);\n                    goto cleanup;\n                } else {\n                    VIR_WARN(\"Preferred CPU model %s not allowed by\"\n                             \" hypervisor; closest supported model will be\"\n                             \" used\", preferred);\n                }\n            } else {\n                VIR_DEBUG(\"CPU model %s not allowed by hypervisor; ignoring\",\n                          candidate->name);\n            }\n            continue;\n        }\n\n        /* Both vendor and candidate->vendor are pointers to a single list of\n         * known vendors stored in the map.\n         */\n        if (vendor && candidate->vendor && vendor != candidate->vendor) {\n            VIR_DEBUG(\"CPU vendor %s of model %s differs from %s; ignoring\",\n                      candidate->vendor->name, candidate->name, vendor->name);\n            continue;\n        }\n\n        if (!(cpuCandidate = x86DataToCPU(&data, candidate, map, hvModel)))\n            goto cleanup;\n        cpuCandidate->type = cpu->type;\n\n        if ((rc = x86DecodeUseCandidate(model, cpuModel,\n                                        candidate, cpuCandidate,\n                                        signature, preferred,\n                                        cpu->type == VIR_CPU_TYPE_HOST))) {\n            virCPUDefFree(cpuModel);\n            cpuModel = cpuCandidate;\n            model = candidate;\n            if (rc == 2)\n                break;\n        } else {\n            virCPUDefFree(cpuCandidate);\n        }\n    }\n\n    if (!cpuModel) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Cannot find suitable CPU model for given data\"));\n        goto cleanup;\n    }\n\n    /* Remove non-migratable features if requested\n     * Note: this only works as long as no CPU model contains non-migratable\n     * features directly */\n    if (migratable) {\n        i = 0;\n        while (i < cpuModel->nfeatures) {\n            if (x86FeatureIsMigratable(cpuModel->features[i].name, map)) {\n                i++;\n            } else {\n                VIR_FREE(cpuModel->features[i].name);\n                VIR_DELETE_ELEMENT_INPLACE(cpuModel->features, i,\n                                           cpuModel->nfeatures);\n            }\n        }\n    }\n\n    if (vendor)\n        cpu->vendor = g_strdup(vendor->name);\n\n    sigs = x86FormatSignatures(model);\n\n    VIR_DEBUG(\"Using CPU model %s (signatures %s) for CPU with signature %06lx\",\n              model->name, NULLSTR(sigs), (unsigned long)signature);\n\n    cpu->model = g_steal_pointer(&cpuModel->model);\n    cpu->features = g_steal_pointer(&cpuModel->features);\n    cpu->nfeatures = cpuModel->nfeatures;\n    cpuModel->nfeatures = 0;\n    cpu->nfeatures_max = cpuModel->nfeatures_max;\n    cpuModel->nfeatures_max = 0;\n\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(cpuModel);\n    virCPUx86DataClear(&data);\n    virCPUx86DataClear(&copy);\n    virCPUx86DataClear(&features);\n    return ret;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86Decode(virCPUDefPtr cpu,\n          const virCPUx86Data *cpuData,\n          virDomainCapsCPUModelsPtr models,\n          const char *preferred,\n          bool migratable)\n{\n    int ret = -1;\n    virCPUx86MapPtr map;\n    virCPUx86ModelPtr candidate;\n    virCPUDefPtr cpuCandidate;\n    virCPUx86ModelPtr model = NULL;\n    virCPUDefPtr cpuModel = NULL;\n    virCPUx86Data data = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data copy = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data features = VIR_CPU_X86_DATA_INIT;\n    virCPUx86VendorPtr vendor;\n    virDomainCapsCPUModelPtr hvModel = NULL;\n    g_autofree char *sigs = NULL;\n    uint32_t signature;\n    ssize_t i;\n    int rc;\n\n    if (!cpuData || x86DataCopy(&data, cpuData) < 0)\n        return -1;\n\n    if (!(map = virCPUx86GetMap()))\n        goto cleanup;\n\n    vendor = x86DataToVendor(&data, map);\n    signature = x86DataToSignature(&data);\n\n    x86DataFilterTSX(&data, vendor, map);\n\n    /* Walk through the CPU models in reverse order to check newest\n     * models first.\n     */\n    for (i = map->nmodels - 1; i >= 0; i--) {\n        candidate = map->models[i];\n        if (models &&\n            !(hvModel = virDomainCapsCPUModelsGet(models, candidate->name))) {\n            if (preferred && STREQ(candidate->name, preferred)) {\n                if (cpu->fallback != VIR_CPU_FALLBACK_ALLOW) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"CPU model %s is not supported by hypervisor\"),\n                                   preferred);\n                    goto cleanup;\n                } else {\n                    VIR_WARN(\"Preferred CPU model %s not allowed by\"\n                             \" hypervisor; closest supported model will be\"\n                             \" used\", preferred);\n                }\n            } else {\n                VIR_DEBUG(\"CPU model %s not allowed by hypervisor; ignoring\",\n                          candidate->name);\n            }\n            continue;\n        }\n\n        /* Both vendor and candidate->vendor are pointers to a single list of\n         * known vendors stored in the map.\n         */\n        if (vendor && candidate->vendor && vendor != candidate->vendor) {\n            VIR_DEBUG(\"CPU vendor %s of model %s differs from %s; ignoring\",\n                      candidate->vendor->name, candidate->name, vendor->name);\n            continue;\n        }\n\n        if (!(cpuCandidate = x86DataToCPU(&data, candidate, map, hvModel)))\n            goto cleanup;\n        cpuCandidate->type = cpu->type;\n\n        if ((rc = x86DecodeUseCandidate(model, cpuModel,\n                                        candidate, cpuCandidate,\n                                        signature, preferred,\n                                        cpu->type == VIR_CPU_TYPE_HOST))) {\n            virCPUDefFree(cpuModel);\n            cpuModel = cpuCandidate;\n            model = candidate;\n            if (rc == 2)\n                break;\n        } else {\n            virCPUDefFree(cpuCandidate);\n        }\n    }\n\n    if (!cpuModel) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Cannot find suitable CPU model for given data\"));\n        goto cleanup;\n    }\n\n    /* Remove non-migratable features if requested\n     * Note: this only works as long as no CPU model contains non-migratable\n     * features directly */\n    if (migratable) {\n        i = 0;\n        while (i < cpuModel->nfeatures) {\n            if (x86FeatureIsMigratable(cpuModel->features[i].name, map)) {\n                i++;\n            } else {\n                VIR_FREE(cpuModel->features[i].name);\n                VIR_DELETE_ELEMENT_INPLACE(cpuModel->features, i,\n                                           cpuModel->nfeatures);\n            }\n        }\n    }\n\n    if (vendor)\n        cpu->vendor = g_strdup(vendor->name);\n\n    sigs = x86FormatSignatures(model);\n\n    VIR_DEBUG(\"Using CPU model %s (signatures %s) for CPU with signature %06lx\",\n              model->name, NULLSTR(sigs), (unsigned long)signature);\n\n    cpu->model = g_steal_pointer(&cpuModel->model);\n    cpu->features = g_steal_pointer(&cpuModel->features);\n    cpu->nfeatures = cpuModel->nfeatures;\n    cpuModel->nfeatures = 0;\n    cpu->nfeatures_max = cpuModel->nfeatures_max;\n    cpuModel->nfeatures_max = 0;\n\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(cpuModel);\n    virCPUx86DataClear(&data);\n    virCPUx86DataClear(&copy);\n    virCPUx86DataClear(&features);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataAddItem",
          "args": [
            "&base_model->data",
            "&vendor->data"
          ],
          "line": 2895
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddItem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "500-518",
          "snippet": "static int\nvirCPUx86DataAddItem(virCPUx86Data *data,\n                     const virCPUx86DataItem *item)\n{\n    virCPUx86DataItemPtr existing;\n\n    if ((existing = virCPUx86DataGet(data, item))) {\n        virCPUx86DataItemSetBits(existing, item);\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(data->items, data->len,\n                                    *((virCPUx86DataItemPtr)item)) < 0)\n            return -1;\n\n        qsort(data->items, data->len,\n              sizeof(virCPUx86DataItem), virCPUx86DataSorter);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddItem(virCPUx86Data *data,\n                     const virCPUx86DataItem *item)\n{\n    virCPUx86DataItemPtr existing;\n\n    if ((existing = virCPUx86DataGet(data, item))) {\n        virCPUx86DataItemSetBits(existing, item);\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(data->items, data->len,\n                                    *((virCPUx86DataItemPtr)item)) < 0)\n            return -1;\n\n        qsort(data->items, data->len,\n              sizeof(virCPUx86DataItem), virCPUx86DataSorter);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"CPUs are incompatible\")"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"CPUs are incompatible\""
          ],
          "line": 2890
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataIsEmpty",
          "args": [
            "&base_model->data"
          ],
          "line": 2888
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "573-580",
          "snippet": "static bool\nx86DataIsEmpty(virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter;\n\n    virCPUx86DataIteratorInit(&iter, data);\n    return !virCPUx86DataNext(&iter);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nx86DataIsEmpty(virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter;\n\n    virCPUx86DataIteratorInit(&iter, data);\n    return !virCPUx86DataNext(&iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataIntersect",
          "args": [
            "&base_model->data",
            "&featData->data.x86"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataIntersect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "554-570",
          "snippet": "static void\nx86DataIntersect(virCPUx86Data *data1,\n                 const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        if (item2)\n            virCPUx86DataItemAndBits(item1, item2);\n        else\n            virCPUx86DataItemClearBits(item1, item1);\n    }\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86DataIntersect(virCPUx86Data *data1,\n                 const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        if (item2)\n            virCPUx86DataItemAndBits(item1, item2);\n        else\n            virCPUx86DataItemClearBits(item1, item1);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataAdd",
          "args": [
            "&featData->data.x86",
            "&feat->data"
          ],
          "line": 2881
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86FeatureFind",
          "args": [
            "map",
            "features[i]"
          ],
          "line": 2880
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "348-360",
          "snippet": "static virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDataNew",
          "args": [
            "archs[0]"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDataNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "290-301",
          "snippet": "virCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"CPU vendors do not match\")"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "vendor->name",
            "vn"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Unknown CPU vendor %s\")",
            "vn"
          ],
          "line": 2857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86VendorFind",
          "args": [
            "map",
            "vn"
          ],
          "line": 2856
        },
        "resolved": true,
        "details": {
          "function_name": "x86VendorFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "838-850",
          "snippet": "static virCPUx86VendorPtr\nx86VendorFind(virCPUx86MapPtr map,\n              const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86VendorPtr\nx86VendorFind(virCPUx86MapPtr map,\n              const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"CPU vendor %s of model %s differs from vendor %s\")",
            "model->vendor->name",
            "model->name",
            "cpus[i]->vendor"
          ],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "cpus[i]->vendor",
            "model->vendor->name"
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86ModelFromCPU",
          "args": [
            "cpus[i]",
            "map",
            "-1"
          ],
          "line": 2835
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFromCPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1220-1299",
          "snippet": "static virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "modelName",
            "cpus[i]->model"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Unknown CPU vendor %s\")",
            "cpus[0]->vendor"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefNew",
          "args": [],
          "line": 2809
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "85-90",
          "snippet": "virCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86GetMap",
          "args": [],
          "line": 2803
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86GetMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1605-1612",
          "snippet": "static virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86MapPtr cpuMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\n\nstatic virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic const virArch archs[] = { VIR_ARCH_I686, VIR_ARCH_X86_64 };\n\nstatic virCPUDefPtr\nvirCPUx86Baseline(virCPUDefPtr *cpus,\n                  unsigned int ncpus,\n                  virDomainCapsCPUModelsPtr models,\n                  const char **features,\n                  bool migratable)\n{\n    virCPUx86MapPtr map = NULL;\n    virCPUx86ModelPtr base_model = NULL;\n    virCPUDefPtr cpu = NULL;\n    size_t i;\n    virCPUx86VendorPtr vendor = NULL;\n    virCPUx86ModelPtr model = NULL;\n    bool outputVendor = true;\n    const char *modelName;\n    bool matchingNames = true;\n    virCPUDataPtr featData = NULL;\n\n    if (!(map = virCPUx86GetMap()))\n        goto error;\n\n    if (!(base_model = x86ModelFromCPU(cpus[0], map, -1)))\n        goto error;\n\n    cpu = virCPUDefNew();\n\n    cpu->type = VIR_CPU_TYPE_GUEST;\n    cpu->match = VIR_CPU_MATCH_EXACT;\n\n    if (!cpus[0]->vendor) {\n        outputVendor = false;\n    } else if (!(vendor = x86VendorFind(map, cpus[0]->vendor))) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Unknown CPU vendor %s\"), cpus[0]->vendor);\n        goto error;\n    }\n\n    modelName = cpus[0]->model;\n    for (i = 1; i < ncpus; i++) {\n        const char *vn = NULL;\n\n        if (matchingNames && cpus[i]->model) {\n            if (!modelName) {\n                modelName = cpus[i]->model;\n            } else if (STRNEQ(modelName, cpus[i]->model)) {\n                modelName = NULL;\n                matchingNames = false;\n            }\n        }\n\n        if (!(model = x86ModelFromCPU(cpus[i], map, -1)))\n            goto error;\n\n        if (cpus[i]->vendor && model->vendor &&\n            STRNEQ(cpus[i]->vendor, model->vendor->name)) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"CPU vendor %s of model %s differs from vendor %s\"),\n                           model->vendor->name, model->name, cpus[i]->vendor);\n            goto error;\n        }\n\n        if (cpus[i]->vendor) {\n            vn = cpus[i]->vendor;\n        } else {\n            outputVendor = false;\n            if (model->vendor)\n                vn = model->vendor->name;\n        }\n\n        if (vn) {\n            if (!vendor) {\n                if (!(vendor = x86VendorFind(map, vn))) {\n                    virReportError(VIR_ERR_OPERATION_FAILED,\n                                   _(\"Unknown CPU vendor %s\"), vn);\n                    goto error;\n                }\n            } else if (STRNEQ(vendor->name, vn)) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               \"%s\", _(\"CPU vendors do not match\"));\n                goto error;\n            }\n        }\n\n        x86DataIntersect(&base_model->data, &model->data);\n        x86ModelFree(model);\n        model = NULL;\n    }\n\n    if (features) {\n        virCPUx86FeaturePtr feat;\n\n        if (!(featData = virCPUDataNew(archs[0])))\n            goto cleanup;\n\n        for (i = 0; features[i]; i++) {\n            if ((feat = x86FeatureFind(map, features[i])) &&\n                x86DataAdd(&featData->data.x86, &feat->data) < 0)\n                goto cleanup;\n        }\n\n        x86DataIntersect(&base_model->data, &featData->data.x86);\n    }\n\n    if (x86DataIsEmpty(&base_model->data)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       \"%s\", _(\"CPUs are incompatible\"));\n        goto error;\n    }\n\n    if (vendor &&\n        virCPUx86DataAddItem(&base_model->data, &vendor->data) < 0)\n        goto error;\n\n    if (x86Decode(cpu, &base_model->data, models, modelName, migratable) < 0)\n        goto error;\n\n    if (STREQ_NULLABLE(cpu->model, modelName))\n        cpu->fallback = VIR_CPU_FALLBACK_FORBID;\n\n    if (!outputVendor)\n        VIR_FREE(cpu->vendor);\n\n cleanup:\n    x86ModelFree(base_model);\n    virCPUx86DataFree(featData);\n\n    return cpu;\n\n error:\n    x86ModelFree(model);\n    virCPUDefFree(cpu);\n    cpu = NULL;\n    goto cleanup;\n}"
  },
  {
    "function_name": "virCPUx86GetHost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2727-2781",
    "snippet": "static int\nvirCPUx86GetHost(virCPUDefPtr cpu,\n                 virDomainCapsCPUModelsPtr models)\n{\n    virCPUDataPtr cpuData = NULL;\n    int ret = -1;\n\n    if (virCPUx86DriverInitialize() < 0)\n        goto cleanup;\n\n    if (!(cpuData = virCPUDataNew(archs[0])))\n        goto cleanup;\n\n    if (cpuidSet(CPUX86_BASIC, cpuData) < 0 ||\n        cpuidSet(CPUX86_EXTENDED, cpuData) < 0)\n        goto cleanup;\n\n    /* Read the IA32_ARCH_CAPABILITIES MSR (0x10a) if supported.\n     * This is best effort since there might be no way to read the MSR\n     * when we are not running as root. */\n    if (virCPUx86DataCheckFeature(cpuData, \"arch-capabilities\") == 1) {\n        uint64_t msr;\n        unsigned long index = 0x10a;\n\n        if (virHostCPUGetMSR(index, &msr) == 0) {\n            virCPUx86DataItem item = {\n                .type = VIR_CPU_X86_DATA_MSR,\n                .data.msr = {\n                    .index = index,\n                    .eax = msr & 0xffffffff,\n                    .edx = msr >> 32,\n                },\n            };\n\n            if (virCPUx86DataAdd(cpuData, &item) < 0)\n                goto cleanup;\n        }\n    }\n\n    ret = x86DecodeCPUData(cpu, cpuData, models);\n    cpu->microcodeVersion = virHostCPUGetMicrocodeVersion();\n\n    /* Probing for TSC frequency makes sense only if the CPU supports\n     * invariant TSC (Linux calls this constant_tsc in /proc/cpuinfo). */\n    if (virCPUx86DataCheckFeature(cpuData, \"invtsc\") == 1) {\n        VIR_DEBUG(\"Checking invariant TSC frequency\");\n        cpu->tsc = virHostCPUGetTscInfo();\n    } else {\n        VIR_DEBUG(\"Host CPU does not support invariant TSC\");\n    }\n\n cleanup:\n    virCPUx86DataFree(cpuData);\n    return ret;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const virArch archs[] = { VIR_ARCH_I686, VIR_ARCH_X86_64 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataFree",
          "args": [
            "cpuData"
          ],
          "line": 2779
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "473-481",
          "snippet": "static void\nvirCPUx86DataFree(virCPUDataPtr data)\n{\n    if (!data)\n        return;\n\n    virCPUx86DataClear(&data->data.x86);\n    VIR_FREE(data);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataFree(virCPUDataPtr data)\n{\n    if (!data)\n        return;\n\n    virCPUx86DataClear(&data->data.x86);\n    VIR_FREE(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Host CPU does not support invariant TSC\""
          ],
          "line": 2775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostCPUGetTscInfo",
          "args": [],
          "line": 2773
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetTscInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "1408-1414",
          "snippet": "virHostCPUTscInfoPtr\nvirHostCPUGetTscInfo(void)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Probing TSC is not supported on this platform\"));\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirHostCPUTscInfoPtr\nvirHostCPUGetTscInfo(void)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Probing TSC is not supported on this platform\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Checking invariant TSC frequency\""
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUx86DataCheckFeature",
          "args": [
            "cpuData",
            "\"invtsc\""
          ],
          "line": 2771
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataCheckFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2385-2395",
          "snippet": "static int\nvirCPUx86DataCheckFeature(const virCPUData *data,\n                          const char *name)\n{\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    return x86FeatureInData(name, &data->data.x86, map);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataCheckFeature(const virCPUData *data,\n                          const char *name)\n{\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    return x86FeatureInData(name, &data->data.x86, map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetMicrocodeVersion",
          "args": [],
          "line": 2767
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetMicrocodeVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "1259-1263",
          "snippet": "unsigned int\nvirHostCPUGetMicrocodeVersion(void)\n{\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nunsigned int\nvirHostCPUGetMicrocodeVersion(void)\n{\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DecodeCPUData",
          "args": [
            "cpu",
            "cpuData",
            "models"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "x86DecodeCPUData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2228-2234",
          "snippet": "static int\nx86DecodeCPUData(virCPUDefPtr cpu,\n                 const virCPUData *data,\n                 virDomainCapsCPUModelsPtr models)\n{\n    return x86Decode(cpu, &data->data.x86, models, NULL, false);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DecodeCPUData(virCPUDefPtr cpu,\n                 const virCPUData *data,\n                 virDomainCapsCPUModelsPtr models)\n{\n    return x86Decode(cpu, &data->data.x86, models, NULL, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataAdd",
          "args": [
            "cpuData",
            "&item"
          ],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetMSR",
          "args": [
            "index",
            "&msr"
          ],
          "line": 2751
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetMSR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "1399-1406",
          "snippet": "int\nvirHostCPUGetMSR(unsigned long index G_GNUC_UNUSED,\n                 uint64_t *msr G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Reading MSRs is not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUGetMSR(unsigned long index G_GNUC_UNUSED,\n                 uint64_t *msr G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Reading MSRs is not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidSet",
          "args": [
            "CPUX86_EXTENDED",
            "cpuData"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2678-2724",
          "snippet": "static int\ncpuidSet(uint32_t base, virCPUDataPtr data)\n{\n    int rc;\n    uint32_t max;\n    uint32_t leaf;\n    virCPUx86DataItem item = CPUID(.eax_in = base);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n\n    cpuidCall(cpuid);\n    max = cpuid->eax;\n\n    for (leaf = base; leaf <= max; leaf++) {\n        cpuid->eax_in = leaf;\n        cpuid->ecx_in = 0;\n        cpuidCall(cpuid);\n\n        /* Handle CPUID leaves that depend on previously queried bits or\n         * which provide additional sub leaves for ecx_in > 0\n         */\n        if (leaf == 0x4)\n            rc = cpuidSetLeaf4(data, &item);\n        else if (leaf == 0x7)\n            rc = cpuidSetLeaf7(data, &item);\n        else if (leaf == 0xb)\n            rc = cpuidSetLeafB(data, &item);\n        else if (leaf == 0xd)\n            rc = cpuidSetLeafD(data, &item);\n        else if (leaf == 0xf)\n            rc = cpuidSetLeafResID(data, &item, cpuid->edx);\n        else if (leaf == 0x10)\n            rc = cpuidSetLeafResID(data, &item, cpuid->ebx);\n        else if (leaf == 0x12)\n            rc = cpuidSetLeaf12(data, &item);\n        else if (leaf == 0x14)\n            rc = cpuidSetLeaf14(data, &item);\n        else if (leaf == 0x17)\n            rc = cpuidSetLeaf17(data, &item);\n        else\n            rc = virCPUx86DataAdd(data, &item);\n\n        if (rc < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSet(uint32_t base, virCPUDataPtr data)\n{\n    int rc;\n    uint32_t max;\n    uint32_t leaf;\n    virCPUx86DataItem item = CPUID(.eax_in = base);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n\n    cpuidCall(cpuid);\n    max = cpuid->eax;\n\n    for (leaf = base; leaf <= max; leaf++) {\n        cpuid->eax_in = leaf;\n        cpuid->ecx_in = 0;\n        cpuidCall(cpuid);\n\n        /* Handle CPUID leaves that depend on previously queried bits or\n         * which provide additional sub leaves for ecx_in > 0\n         */\n        if (leaf == 0x4)\n            rc = cpuidSetLeaf4(data, &item);\n        else if (leaf == 0x7)\n            rc = cpuidSetLeaf7(data, &item);\n        else if (leaf == 0xb)\n            rc = cpuidSetLeafB(data, &item);\n        else if (leaf == 0xd)\n            rc = cpuidSetLeafD(data, &item);\n        else if (leaf == 0xf)\n            rc = cpuidSetLeafResID(data, &item, cpuid->edx);\n        else if (leaf == 0x10)\n            rc = cpuidSetLeafResID(data, &item, cpuid->ebx);\n        else if (leaf == 0x12)\n            rc = cpuidSetLeaf12(data, &item);\n        else if (leaf == 0x14)\n            rc = cpuidSetLeaf14(data, &item);\n        else if (leaf == 0x17)\n            rc = cpuidSetLeaf17(data, &item);\n        else\n            rc = virCPUx86DataAdd(data, &item);\n\n        if (rc < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDataNew",
          "args": [
            "archs[0]"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDataNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "290-301",
          "snippet": "virCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DriverInitialize",
          "args": [],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic const virArch archs[] = { VIR_ARCH_I686, VIR_ARCH_X86_64 };\n\nstatic int\nvirCPUx86GetHost(virCPUDefPtr cpu,\n                 virDomainCapsCPUModelsPtr models)\n{\n    virCPUDataPtr cpuData = NULL;\n    int ret = -1;\n\n    if (virCPUx86DriverInitialize() < 0)\n        goto cleanup;\n\n    if (!(cpuData = virCPUDataNew(archs[0])))\n        goto cleanup;\n\n    if (cpuidSet(CPUX86_BASIC, cpuData) < 0 ||\n        cpuidSet(CPUX86_EXTENDED, cpuData) < 0)\n        goto cleanup;\n\n    /* Read the IA32_ARCH_CAPABILITIES MSR (0x10a) if supported.\n     * This is best effort since there might be no way to read the MSR\n     * when we are not running as root. */\n    if (virCPUx86DataCheckFeature(cpuData, \"arch-capabilities\") == 1) {\n        uint64_t msr;\n        unsigned long index = 0x10a;\n\n        if (virHostCPUGetMSR(index, &msr) == 0) {\n            virCPUx86DataItem item = {\n                .type = VIR_CPU_X86_DATA_MSR,\n                .data.msr = {\n                    .index = index,\n                    .eax = msr & 0xffffffff,\n                    .edx = msr >> 32,\n                },\n            };\n\n            if (virCPUx86DataAdd(cpuData, &item) < 0)\n                goto cleanup;\n        }\n    }\n\n    ret = x86DecodeCPUData(cpu, cpuData, models);\n    cpu->microcodeVersion = virHostCPUGetMicrocodeVersion();\n\n    /* Probing for TSC frequency makes sense only if the CPU supports\n     * invariant TSC (Linux calls this constant_tsc in /proc/cpuinfo). */\n    if (virCPUx86DataCheckFeature(cpuData, \"invtsc\") == 1) {\n        VIR_DEBUG(\"Checking invariant TSC frequency\");\n        cpu->tsc = virHostCPUGetTscInfo();\n    } else {\n        VIR_DEBUG(\"Host CPU does not support invariant TSC\");\n    }\n\n cleanup:\n    virCPUx86DataFree(cpuData);\n    return ret;\n}"
  },
  {
    "function_name": "cpuidSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2678-2724",
    "snippet": "static int\ncpuidSet(uint32_t base, virCPUDataPtr data)\n{\n    int rc;\n    uint32_t max;\n    uint32_t leaf;\n    virCPUx86DataItem item = CPUID(.eax_in = base);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n\n    cpuidCall(cpuid);\n    max = cpuid->eax;\n\n    for (leaf = base; leaf <= max; leaf++) {\n        cpuid->eax_in = leaf;\n        cpuid->ecx_in = 0;\n        cpuidCall(cpuid);\n\n        /* Handle CPUID leaves that depend on previously queried bits or\n         * which provide additional sub leaves for ecx_in > 0\n         */\n        if (leaf == 0x4)\n            rc = cpuidSetLeaf4(data, &item);\n        else if (leaf == 0x7)\n            rc = cpuidSetLeaf7(data, &item);\n        else if (leaf == 0xb)\n            rc = cpuidSetLeafB(data, &item);\n        else if (leaf == 0xd)\n            rc = cpuidSetLeafD(data, &item);\n        else if (leaf == 0xf)\n            rc = cpuidSetLeafResID(data, &item, cpuid->edx);\n        else if (leaf == 0x10)\n            rc = cpuidSetLeafResID(data, &item, cpuid->ebx);\n        else if (leaf == 0x12)\n            rc = cpuidSetLeaf12(data, &item);\n        else if (leaf == 0x14)\n            rc = cpuidSetLeaf14(data, &item);\n        else if (leaf == 0x17)\n            rc = cpuidSetLeaf17(data, &item);\n        else\n            rc = virCPUx86DataAdd(data, &item);\n\n        if (rc < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataAdd",
          "args": [
            "data",
            "&item"
          ],
          "line": 2717
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidSetLeaf17",
          "args": [
            "data",
            "&item"
          ],
          "line": 2715
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidSetLeaf17",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2654-2675",
          "snippet": "static int\ncpuidSetLeaf17(virCPUDataPtr data,\n               virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0x17);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    uint32_t sub;\n\n    if (subLeaf0->data.cpuid.eax < 3)\n        return 0;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    for (sub = 1; sub <= subLeaf0->data.cpuid.eax; sub++) {\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSetLeaf17(virCPUDataPtr data,\n               virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0x17);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    uint32_t sub;\n\n    if (subLeaf0->data.cpuid.eax < 3)\n        return 0;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    for (sub = 1; sub <= subLeaf0->data.cpuid.eax; sub++) {\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidSetLeaf14",
          "args": [
            "data",
            "&item"
          ],
          "line": 2713
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidSetLeaf14",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2628-2646",
          "snippet": "static int\ncpuidSetLeaf14(virCPUDataPtr data,\n               virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0x14);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    uint32_t sub;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    for (sub = 1; sub <= subLeaf0->data.cpuid.eax; sub++) {\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSetLeaf14(virCPUDataPtr data,\n               virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0x14);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    uint32_t sub;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    for (sub = 1; sub <= subLeaf0->data.cpuid.eax; sub++) {\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidSetLeaf12",
          "args": [
            "data",
            "&item"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidSetLeaf12",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2591-2621",
          "snippet": "static int\ncpuidSetLeaf12(virCPUDataPtr data,\n               virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0x7);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    virCPUx86DataItemPtr leaf7;\n\n    if (!(leaf7 = virCPUx86DataGet(&data->data.x86, &item)) ||\n        !(leaf7->data.cpuid.ebx & (1 << 2)))\n        return 0;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    cpuid->eax_in = 0x12;\n    cpuid->ecx_in = 1;\n    cpuidCall(cpuid);\n    if (virCPUx86DataAdd(data, &item) < 0)\n        return -1;\n\n    cpuid->ecx_in = 2;\n    cpuidCall(cpuid);\n    while (cpuid->eax & 0xf) {\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n        cpuid->ecx_in++;\n        cpuidCall(cpuid);\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSetLeaf12(virCPUDataPtr data,\n               virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0x7);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    virCPUx86DataItemPtr leaf7;\n\n    if (!(leaf7 = virCPUx86DataGet(&data->data.x86, &item)) ||\n        !(leaf7->data.cpuid.ebx & (1 << 2)))\n        return 0;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    cpuid->eax_in = 0x12;\n    cpuid->ecx_in = 1;\n    cpuidCall(cpuid);\n    if (virCPUx86DataAdd(data, &item) < 0)\n        return -1;\n\n    cpuid->ecx_in = 2;\n    cpuidCall(cpuid);\n    while (cpuid->eax & 0xf) {\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n        cpuid->ecx_in++;\n        cpuidCall(cpuid);\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidSetLeafResID",
          "args": [
            "data",
            "&item",
            "cpuid->ebx"
          ],
          "line": 2709
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidSetLeafResID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2562-2583",
          "snippet": "static int\ncpuidSetLeafResID(virCPUDataPtr data,\n                  virCPUx86DataItemPtr subLeaf0,\n                  uint32_t res)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = subLeaf0->data.cpuid.eax_in);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    uint32_t sub;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    for (sub = 1; sub < 32; sub++) {\n        if (!(res & (1 << sub)))\n            continue;\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSetLeafResID(virCPUDataPtr data,\n                  virCPUx86DataItemPtr subLeaf0,\n                  uint32_t res)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = subLeaf0->data.cpuid.eax_in);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    uint32_t sub;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    for (sub = 1; sub < 32; sub++) {\n        if (!(res & (1 << sub)))\n            continue;\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidSetLeafD",
          "args": [
            "data",
            "&item"
          ],
          "line": 2705
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidSetLeafD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2514-2550",
          "snippet": "static int\ncpuidSetLeafD(virCPUDataPtr data,\n              virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0xd);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    virCPUx86CPUID sub0;\n    virCPUx86CPUID sub1;\n    uint32_t sub;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    cpuid->ecx_in = 1;\n    cpuidCall(cpuid);\n    if (virCPUx86DataAdd(data, &item) < 0)\n        return -1;\n\n    sub0 = subLeaf0->data.cpuid;\n    sub1 = *cpuid;\n    for (sub = 2; sub < 64; sub++) {\n        if (sub < 32 &&\n            !(sub0.eax & (1 << sub)) &&\n            !(sub1.ecx & (1 << sub)))\n            continue;\n        if (sub >= 32 &&\n            !(sub0.edx & (1 << (sub - 32))) &&\n            !(sub1.edx & (1 << (sub - 32))))\n            continue;\n\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSetLeafD(virCPUDataPtr data,\n              virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0xd);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    virCPUx86CPUID sub0;\n    virCPUx86CPUID sub1;\n    uint32_t sub;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    cpuid->ecx_in = 1;\n    cpuidCall(cpuid);\n    if (virCPUx86DataAdd(data, &item) < 0)\n        return -1;\n\n    sub0 = subLeaf0->data.cpuid;\n    sub1 = *cpuid;\n    for (sub = 2; sub < 64; sub++) {\n        if (sub < 32 &&\n            !(sub0.eax & (1 << sub)) &&\n            !(sub1.ecx & (1 << sub)))\n            continue;\n        if (sub >= 32 &&\n            !(sub0.edx & (1 << (sub - 32))) &&\n            !(sub1.edx & (1 << (sub - 32))))\n            continue;\n\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidSetLeafB",
          "args": [
            "data",
            "&item"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidSetLeafB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2489-2503",
          "snippet": "static int\ncpuidSetLeafB(virCPUDataPtr data,\n              virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = *subLeaf0;\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n\n    while (cpuid->ecx & 0xff00) {\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n        cpuid->ecx_in++;\n        cpuidCall(cpuid);\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSetLeafB(virCPUDataPtr data,\n              virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = *subLeaf0;\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n\n    while (cpuid->ecx & 0xff00) {\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n        cpuid->ecx_in++;\n        cpuidCall(cpuid);\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidSetLeaf7",
          "args": [
            "data",
            "&item"
          ],
          "line": 2701
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidSetLeaf7",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2461-2479",
          "snippet": "static int\ncpuidSetLeaf7(virCPUDataPtr data,\n              virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0x7);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    uint32_t sub;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    for (sub = 1; sub <= subLeaf0->data.cpuid.eax; sub++) {\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSetLeaf7(virCPUDataPtr data,\n              virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0x7);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    uint32_t sub;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    for (sub = 1; sub <= subLeaf0->data.cpuid.eax; sub++) {\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidSetLeaf4",
          "args": [
            "data",
            "&item"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidSetLeaf4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2437-2454",
          "snippet": "static int\ncpuidSetLeaf4(virCPUDataPtr data,\n              virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = *subLeaf0;\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    while (cpuid->eax & 0x1f) {\n        cpuid->ecx_in++;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSetLeaf4(virCPUDataPtr data,\n              virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = *subLeaf0;\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    while (cpuid->eax & 0x1f) {\n        cpuid->ecx_in++;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidCall",
          "args": [
            "cpuid"
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2399-2430",
          "snippet": "static inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUID",
          "args": [
            ".eax_in = base"
          ],
          "line": 2684
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetMaxCPUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1057-1072",
          "snippet": "unsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSet(uint32_t base, virCPUDataPtr data)\n{\n    int rc;\n    uint32_t max;\n    uint32_t leaf;\n    virCPUx86DataItem item = CPUID(.eax_in = base);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n\n    cpuidCall(cpuid);\n    max = cpuid->eax;\n\n    for (leaf = base; leaf <= max; leaf++) {\n        cpuid->eax_in = leaf;\n        cpuid->ecx_in = 0;\n        cpuidCall(cpuid);\n\n        /* Handle CPUID leaves that depend on previously queried bits or\n         * which provide additional sub leaves for ecx_in > 0\n         */\n        if (leaf == 0x4)\n            rc = cpuidSetLeaf4(data, &item);\n        else if (leaf == 0x7)\n            rc = cpuidSetLeaf7(data, &item);\n        else if (leaf == 0xb)\n            rc = cpuidSetLeafB(data, &item);\n        else if (leaf == 0xd)\n            rc = cpuidSetLeafD(data, &item);\n        else if (leaf == 0xf)\n            rc = cpuidSetLeafResID(data, &item, cpuid->edx);\n        else if (leaf == 0x10)\n            rc = cpuidSetLeafResID(data, &item, cpuid->ebx);\n        else if (leaf == 0x12)\n            rc = cpuidSetLeaf12(data, &item);\n        else if (leaf == 0x14)\n            rc = cpuidSetLeaf14(data, &item);\n        else if (leaf == 0x17)\n            rc = cpuidSetLeaf17(data, &item);\n        else\n            rc = virCPUx86DataAdd(data, &item);\n\n        if (rc < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "cpuidSetLeaf17",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2654-2675",
    "snippet": "static int\ncpuidSetLeaf17(virCPUDataPtr data,\n               virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0x17);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    uint32_t sub;\n\n    if (subLeaf0->data.cpuid.eax < 3)\n        return 0;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    for (sub = 1; sub <= subLeaf0->data.cpuid.eax; sub++) {\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataAdd",
          "args": [
            "data",
            "&item"
          ],
          "line": 2671
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidCall",
          "args": [
            "cpuid"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2399-2430",
          "snippet": "static inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUID",
          "args": [
            ".eax_in = 0x17"
          ],
          "line": 2658
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetMaxCPUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1057-1072",
          "snippet": "unsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSetLeaf17(virCPUDataPtr data,\n               virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0x17);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    uint32_t sub;\n\n    if (subLeaf0->data.cpuid.eax < 3)\n        return 0;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    for (sub = 1; sub <= subLeaf0->data.cpuid.eax; sub++) {\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "cpuidSetLeaf14",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2628-2646",
    "snippet": "static int\ncpuidSetLeaf14(virCPUDataPtr data,\n               virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0x14);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    uint32_t sub;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    for (sub = 1; sub <= subLeaf0->data.cpuid.eax; sub++) {\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataAdd",
          "args": [
            "data",
            "&item"
          ],
          "line": 2642
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidCall",
          "args": [
            "cpuid"
          ],
          "line": 2641
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2399-2430",
          "snippet": "static inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUID",
          "args": [
            ".eax_in = 0x14"
          ],
          "line": 2632
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetMaxCPUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1057-1072",
          "snippet": "unsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSetLeaf14(virCPUDataPtr data,\n               virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0x14);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    uint32_t sub;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    for (sub = 1; sub <= subLeaf0->data.cpuid.eax; sub++) {\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "cpuidSetLeaf12",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2591-2621",
    "snippet": "static int\ncpuidSetLeaf12(virCPUDataPtr data,\n               virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0x7);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    virCPUx86DataItemPtr leaf7;\n\n    if (!(leaf7 = virCPUx86DataGet(&data->data.x86, &item)) ||\n        !(leaf7->data.cpuid.ebx & (1 << 2)))\n        return 0;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    cpuid->eax_in = 0x12;\n    cpuid->ecx_in = 1;\n    cpuidCall(cpuid);\n    if (virCPUx86DataAdd(data, &item) < 0)\n        return -1;\n\n    cpuid->ecx_in = 2;\n    cpuidCall(cpuid);\n    while (cpuid->eax & 0xf) {\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n        cpuid->ecx_in++;\n        cpuidCall(cpuid);\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuidCall",
          "args": [
            "cpuid"
          ],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2399-2430",
          "snippet": "static inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataAdd",
          "args": [
            "data",
            "&item"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataGet",
          "args": [
            "&data->data.x86",
            "&item"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "448-461",
          "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUID",
          "args": [
            ".eax_in = 0x7"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetMaxCPUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1057-1072",
          "snippet": "unsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSetLeaf12(virCPUDataPtr data,\n               virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0x7);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    virCPUx86DataItemPtr leaf7;\n\n    if (!(leaf7 = virCPUx86DataGet(&data->data.x86, &item)) ||\n        !(leaf7->data.cpuid.ebx & (1 << 2)))\n        return 0;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    cpuid->eax_in = 0x12;\n    cpuid->ecx_in = 1;\n    cpuidCall(cpuid);\n    if (virCPUx86DataAdd(data, &item) < 0)\n        return -1;\n\n    cpuid->ecx_in = 2;\n    cpuidCall(cpuid);\n    while (cpuid->eax & 0xf) {\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n        cpuid->ecx_in++;\n        cpuidCall(cpuid);\n    }\n    return 0;\n}"
  },
  {
    "function_name": "cpuidSetLeafResID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2562-2583",
    "snippet": "static int\ncpuidSetLeafResID(virCPUDataPtr data,\n                  virCPUx86DataItemPtr subLeaf0,\n                  uint32_t res)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = subLeaf0->data.cpuid.eax_in);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    uint32_t sub;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    for (sub = 1; sub < 32; sub++) {\n        if (!(res & (1 << sub)))\n            continue;\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataAdd",
          "args": [
            "data",
            "&item"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidCall",
          "args": [
            "cpuid"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2399-2430",
          "snippet": "static inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUID",
          "args": [
            ".eax_in = subLeaf0->data.cpuid.eax_in"
          ],
          "line": 2567
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetMaxCPUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1057-1072",
          "snippet": "unsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSetLeafResID(virCPUDataPtr data,\n                  virCPUx86DataItemPtr subLeaf0,\n                  uint32_t res)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = subLeaf0->data.cpuid.eax_in);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    uint32_t sub;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    for (sub = 1; sub < 32; sub++) {\n        if (!(res & (1 << sub)))\n            continue;\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "cpuidSetLeafD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2514-2550",
    "snippet": "static int\ncpuidSetLeafD(virCPUDataPtr data,\n              virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0xd);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    virCPUx86CPUID sub0;\n    virCPUx86CPUID sub1;\n    uint32_t sub;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    cpuid->ecx_in = 1;\n    cpuidCall(cpuid);\n    if (virCPUx86DataAdd(data, &item) < 0)\n        return -1;\n\n    sub0 = subLeaf0->data.cpuid;\n    sub1 = *cpuid;\n    for (sub = 2; sub < 64; sub++) {\n        if (sub < 32 &&\n            !(sub0.eax & (1 << sub)) &&\n            !(sub1.ecx & (1 << sub)))\n            continue;\n        if (sub >= 32 &&\n            !(sub0.edx & (1 << (sub - 32))) &&\n            !(sub1.edx & (1 << (sub - 32))))\n            continue;\n\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataAdd",
          "args": [
            "data",
            "&item"
          ],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidCall",
          "args": [
            "cpuid"
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2399-2430",
          "snippet": "static inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUID",
          "args": [
            ".eax_in = 0xd"
          ],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetMaxCPUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1057-1072",
          "snippet": "unsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSetLeafD(virCPUDataPtr data,\n              virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0xd);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    virCPUx86CPUID sub0;\n    virCPUx86CPUID sub1;\n    uint32_t sub;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    cpuid->ecx_in = 1;\n    cpuidCall(cpuid);\n    if (virCPUx86DataAdd(data, &item) < 0)\n        return -1;\n\n    sub0 = subLeaf0->data.cpuid;\n    sub1 = *cpuid;\n    for (sub = 2; sub < 64; sub++) {\n        if (sub < 32 &&\n            !(sub0.eax & (1 << sub)) &&\n            !(sub1.ecx & (1 << sub)))\n            continue;\n        if (sub >= 32 &&\n            !(sub0.edx & (1 << (sub - 32))) &&\n            !(sub1.edx & (1 << (sub - 32))))\n            continue;\n\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "cpuidSetLeafB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2489-2503",
    "snippet": "static int\ncpuidSetLeafB(virCPUDataPtr data,\n              virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = *subLeaf0;\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n\n    while (cpuid->ecx & 0xff00) {\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n        cpuid->ecx_in++;\n        cpuidCall(cpuid);\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuidCall",
          "args": [
            "cpuid"
          ],
          "line": 2500
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2399-2430",
          "snippet": "static inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataAdd",
          "args": [
            "data",
            "&item"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSetLeafB(virCPUDataPtr data,\n              virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = *subLeaf0;\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n\n    while (cpuid->ecx & 0xff00) {\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n        cpuid->ecx_in++;\n        cpuidCall(cpuid);\n    }\n    return 0;\n}"
  },
  {
    "function_name": "cpuidSetLeaf7",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2461-2479",
    "snippet": "static int\ncpuidSetLeaf7(virCPUDataPtr data,\n              virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0x7);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    uint32_t sub;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    for (sub = 1; sub <= subLeaf0->data.cpuid.eax; sub++) {\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataAdd",
          "args": [
            "data",
            "&item"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidCall",
          "args": [
            "cpuid"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2399-2430",
          "snippet": "static inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUID",
          "args": [
            ".eax_in = 0x7"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetMaxCPUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1057-1072",
          "snippet": "unsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSetLeaf7(virCPUDataPtr data,\n              virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = CPUID(.eax_in = 0x7);\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n    uint32_t sub;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    for (sub = 1; sub <= subLeaf0->data.cpuid.eax; sub++) {\n        cpuid->ecx_in = sub;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "cpuidSetLeaf4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2437-2454",
    "snippet": "static int\ncpuidSetLeaf4(virCPUDataPtr data,\n              virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = *subLeaf0;\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    while (cpuid->eax & 0x1f) {\n        cpuid->ecx_in++;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataAdd",
          "args": [
            "data",
            "&item"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidCall",
          "args": [
            "cpuid"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2399-2430",
          "snippet": "static inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\ncpuidSetLeaf4(virCPUDataPtr data,\n              virCPUx86DataItemPtr subLeaf0)\n{\n    virCPUx86DataItem item = *subLeaf0;\n    virCPUx86CPUIDPtr cpuid = &item.data.cpuid;\n\n    if (virCPUx86DataAdd(data, subLeaf0) < 0)\n        return -1;\n\n    while (cpuid->eax & 0x1f) {\n        cpuid->ecx_in++;\n        cpuidCall(cpuid);\n        if (virCPUx86DataAdd(data, &item) < 0)\n            return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "cpuidCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2399-2430",
    "snippet": "static inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic inline void\ncpuidCall(virCPUx86CPUID *cpuid)\n{\n# if __x86_64__\n    asm(\"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        : \"=a\" (cpuid->eax),\n          \"=b\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in));\n# else\n    /* we need to avoid direct use of ebx for CPUID output as it is used\n     * for global offset table on i386 with -fPIC\n     */\n    asm(\"push %%ebx;\"\n        \"xor %%ebx, %%ebx;\" /* clear the other registers as some cpuid */\n        \"xor %%edx, %%edx;\" /* functions may use them as additional arguments */\n        \"cpuid;\"\n        \"mov %%ebx, %1;\"\n        \"pop %%ebx;\"\n        : \"=a\" (cpuid->eax),\n          \"=r\" (cpuid->ebx),\n          \"=c\" (cpuid->ecx),\n          \"=d\" (cpuid->edx)\n        : \"a\" (cpuid->eax_in),\n          \"c\" (cpuid->ecx_in)\n        : \"cc\");\n# endif\n}"
  },
  {
    "function_name": "virCPUx86DataCheckFeature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2385-2395",
    "snippet": "static int\nvirCPUx86DataCheckFeature(const virCPUData *data,\n                          const char *name)\n{\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    return x86FeatureInData(name, &data->data.x86, map);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86FeatureInData",
          "args": [
            "name",
            "&data->data.x86",
            "map"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureInData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "921-939",
          "snippet": "static int\nx86FeatureInData(const char *name,\n                 const virCPUx86Data *data,\n                 virCPUx86MapPtr map)\n{\n    virCPUx86FeaturePtr feature;\n\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown CPU feature %s\"), name);\n        return -1;\n    }\n\n    if (x86DataIsSubset(data, &feature->data))\n        return 1;\n    else\n        return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86FeatureInData(const char *name,\n                 const virCPUx86Data *data,\n                 virCPUx86MapPtr map)\n{\n    virCPUx86FeaturePtr feature;\n\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown CPU feature %s\"), name);\n        return -1;\n    }\n\n    if (x86DataIsSubset(data, &feature->data))\n        return 1;\n    else\n        return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86GetMap",
          "args": [],
          "line": 2391
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86GetMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1605-1612",
          "snippet": "static virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86MapPtr cpuMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\n\nstatic virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataCheckFeature(const virCPUData *data,\n                          const char *name)\n{\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    return x86FeatureInData(name, &data->data.x86, map);\n}"
  },
  {
    "function_name": "virCPUx86CheckFeature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2363-2382",
    "snippet": "static int\nvirCPUx86CheckFeature(const virCPUDef *cpu,\n                      const char *name)\n{\n    int ret = -1;\n    virCPUx86MapPtr map;\n    virCPUx86ModelPtr model = NULL;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    if (!(model = x86ModelFromCPU(cpu, map, -1)))\n        goto cleanup;\n\n    ret = x86FeatureInData(name, &model->data, map);\n\n cleanup:\n    x86ModelFree(model);\n    return ret;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86ModelFree",
          "args": [
            "model"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1141-1151",
          "snippet": "static void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86FeatureInData",
          "args": [
            "name",
            "&model->data",
            "map"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureInData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "921-939",
          "snippet": "static int\nx86FeatureInData(const char *name,\n                 const virCPUx86Data *data,\n                 virCPUx86MapPtr map)\n{\n    virCPUx86FeaturePtr feature;\n\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown CPU feature %s\"), name);\n        return -1;\n    }\n\n    if (x86DataIsSubset(data, &feature->data))\n        return 1;\n    else\n        return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86FeatureInData(const char *name,\n                 const virCPUx86Data *data,\n                 virCPUx86MapPtr map)\n{\n    virCPUx86FeaturePtr feature;\n\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown CPU feature %s\"), name);\n        return -1;\n    }\n\n    if (x86DataIsSubset(data, &feature->data))\n        return 1;\n    else\n        return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelFromCPU",
          "args": [
            "cpu",
            "map",
            "-1"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFromCPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1220-1299",
          "snippet": "static virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86GetMap",
          "args": [],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86GetMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1605-1612",
          "snippet": "static virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86MapPtr cpuMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\n\nstatic virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86CheckFeature(const virCPUDef *cpu,\n                      const char *name)\n{\n    int ret = -1;\n    virCPUx86MapPtr map;\n    virCPUx86ModelPtr model = NULL;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    if (!(model = x86ModelFromCPU(cpu, map, -1)))\n        goto cleanup;\n\n    ret = x86FeatureInData(name, &model->data, map);\n\n cleanup:\n    x86ModelFree(model);\n    return ret;\n}"
  },
  {
    "function_name": "x86Encode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2257-2360",
    "snippet": "static int\nx86Encode(virArch arch,\n          const virCPUDef *cpu,\n          virCPUDataPtr *forced,\n          virCPUDataPtr *required,\n          virCPUDataPtr *optional,\n          virCPUDataPtr *disabled,\n          virCPUDataPtr *forbidden,\n          virCPUDataPtr *vendor)\n{\n    virCPUx86MapPtr map = NULL;\n    virCPUDataPtr data_forced = NULL;\n    virCPUDataPtr data_required = NULL;\n    virCPUDataPtr data_optional = NULL;\n    virCPUDataPtr data_disabled = NULL;\n    virCPUDataPtr data_forbidden = NULL;\n    virCPUDataPtr data_vendor = NULL;\n\n    if (forced)\n        *forced = NULL;\n    if (required)\n        *required = NULL;\n    if (optional)\n        *optional = NULL;\n    if (disabled)\n        *disabled = NULL;\n    if (forbidden)\n        *forbidden = NULL;\n    if (vendor)\n        *vendor = NULL;\n\n    if (!(map = virCPUx86GetMap()))\n        goto error;\n\n    if (forced &&\n        (!(data_forced = virCPUDataNew(arch)) ||\n         x86EncodePolicy(&data_forced->data.x86, cpu, map,\n                         VIR_CPU_FEATURE_FORCE) < 0))\n        goto error;\n\n    if (required &&\n        (!(data_required = virCPUDataNew(arch)) ||\n         x86EncodePolicy(&data_required->data.x86, cpu, map,\n                         VIR_CPU_FEATURE_REQUIRE) < 0))\n        goto error;\n\n    if (optional &&\n        (!(data_optional = virCPUDataNew(arch)) ||\n         x86EncodePolicy(&data_optional->data.x86, cpu, map,\n                         VIR_CPU_FEATURE_OPTIONAL) < 0))\n        goto error;\n\n    if (disabled &&\n        (!(data_disabled = virCPUDataNew(arch)) ||\n         x86EncodePolicy(&data_disabled->data.x86, cpu, map,\n                         VIR_CPU_FEATURE_DISABLE) < 0))\n        goto error;\n\n    if (forbidden &&\n        (!(data_forbidden = virCPUDataNew(arch)) ||\n         x86EncodePolicy(&data_forbidden->data.x86, cpu, map,\n                         VIR_CPU_FEATURE_FORBID) < 0))\n        goto error;\n\n    if (vendor) {\n        virCPUx86VendorPtr v = NULL;\n\n        if (cpu->vendor && !(v = x86VendorFind(map, cpu->vendor))) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"CPU vendor %s not found\"), cpu->vendor);\n            goto error;\n        }\n\n        if (!(data_vendor = virCPUDataNew(arch)))\n            goto error;\n\n        if (v && virCPUx86DataAdd(data_vendor, &v->data) < 0)\n            goto error;\n    }\n\n    if (forced)\n        *forced = data_forced;\n    if (required)\n        *required = data_required;\n    if (optional)\n        *optional = data_optional;\n    if (disabled)\n        *disabled = data_disabled;\n    if (forbidden)\n        *forbidden = data_forbidden;\n    if (vendor)\n        *vendor = data_vendor;\n\n    return 0;\n\n error:\n    virCPUx86DataFree(data_forced);\n    virCPUx86DataFree(data_required);\n    virCPUx86DataFree(data_optional);\n    virCPUx86DataFree(data_disabled);\n    virCPUx86DataFree(data_forbidden);\n    virCPUx86DataFree(data_vendor);\n    return -1;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataFree",
          "args": [
            "data_vendor"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "473-481",
          "snippet": "static void\nvirCPUx86DataFree(virCPUDataPtr data)\n{\n    if (!data)\n        return;\n\n    virCPUx86DataClear(&data->data.x86);\n    VIR_FREE(data);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataFree(virCPUDataPtr data)\n{\n    if (!data)\n        return;\n\n    virCPUx86DataClear(&data->data.x86);\n    VIR_FREE(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataAdd",
          "args": [
            "data_vendor",
            "&v->data"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDataNew",
          "args": [
            "arch"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDataNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "290-301",
          "snippet": "virCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"CPU vendor %s not found\")",
            "cpu->vendor"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"CPU vendor %s not found\""
          ],
          "line": 2326
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86VendorFind",
          "args": [
            "map",
            "cpu->vendor"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "x86VendorFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "838-850",
          "snippet": "static virCPUx86VendorPtr\nx86VendorFind(virCPUx86MapPtr map,\n              const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86VendorPtr\nx86VendorFind(virCPUx86MapPtr map,\n              const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86EncodePolicy",
          "args": [
            "&data_forbidden->data.x86",
            "cpu",
            "map",
            "VIR_CPU_FEATURE_FORBID"
          ],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "x86EncodePolicy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2237-2254",
          "snippet": "static int\nx86EncodePolicy(virCPUx86Data *data,\n                const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                virCPUFeaturePolicy policy)\n{\n    virCPUx86ModelPtr model;\n\n    if (!(model = x86ModelFromCPU(cpu, map, policy)))\n        return -1;\n\n    *data = model->data;\n    model->data.len = 0;\n    model->data.items = NULL;\n    x86ModelFree(model);\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86EncodePolicy(virCPUx86Data *data,\n                const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                virCPUFeaturePolicy policy)\n{\n    virCPUx86ModelPtr model;\n\n    if (!(model = x86ModelFromCPU(cpu, map, policy)))\n        return -1;\n\n    *data = model->data;\n    model->data.len = 0;\n    model->data.items = NULL;\n    x86ModelFree(model);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86GetMap",
          "args": [],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86GetMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1605-1612",
          "snippet": "static virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86MapPtr cpuMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\n\nstatic virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86Encode(virArch arch,\n          const virCPUDef *cpu,\n          virCPUDataPtr *forced,\n          virCPUDataPtr *required,\n          virCPUDataPtr *optional,\n          virCPUDataPtr *disabled,\n          virCPUDataPtr *forbidden,\n          virCPUDataPtr *vendor)\n{\n    virCPUx86MapPtr map = NULL;\n    virCPUDataPtr data_forced = NULL;\n    virCPUDataPtr data_required = NULL;\n    virCPUDataPtr data_optional = NULL;\n    virCPUDataPtr data_disabled = NULL;\n    virCPUDataPtr data_forbidden = NULL;\n    virCPUDataPtr data_vendor = NULL;\n\n    if (forced)\n        *forced = NULL;\n    if (required)\n        *required = NULL;\n    if (optional)\n        *optional = NULL;\n    if (disabled)\n        *disabled = NULL;\n    if (forbidden)\n        *forbidden = NULL;\n    if (vendor)\n        *vendor = NULL;\n\n    if (!(map = virCPUx86GetMap()))\n        goto error;\n\n    if (forced &&\n        (!(data_forced = virCPUDataNew(arch)) ||\n         x86EncodePolicy(&data_forced->data.x86, cpu, map,\n                         VIR_CPU_FEATURE_FORCE) < 0))\n        goto error;\n\n    if (required &&\n        (!(data_required = virCPUDataNew(arch)) ||\n         x86EncodePolicy(&data_required->data.x86, cpu, map,\n                         VIR_CPU_FEATURE_REQUIRE) < 0))\n        goto error;\n\n    if (optional &&\n        (!(data_optional = virCPUDataNew(arch)) ||\n         x86EncodePolicy(&data_optional->data.x86, cpu, map,\n                         VIR_CPU_FEATURE_OPTIONAL) < 0))\n        goto error;\n\n    if (disabled &&\n        (!(data_disabled = virCPUDataNew(arch)) ||\n         x86EncodePolicy(&data_disabled->data.x86, cpu, map,\n                         VIR_CPU_FEATURE_DISABLE) < 0))\n        goto error;\n\n    if (forbidden &&\n        (!(data_forbidden = virCPUDataNew(arch)) ||\n         x86EncodePolicy(&data_forbidden->data.x86, cpu, map,\n                         VIR_CPU_FEATURE_FORBID) < 0))\n        goto error;\n\n    if (vendor) {\n        virCPUx86VendorPtr v = NULL;\n\n        if (cpu->vendor && !(v = x86VendorFind(map, cpu->vendor))) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"CPU vendor %s not found\"), cpu->vendor);\n            goto error;\n        }\n\n        if (!(data_vendor = virCPUDataNew(arch)))\n            goto error;\n\n        if (v && virCPUx86DataAdd(data_vendor, &v->data) < 0)\n            goto error;\n    }\n\n    if (forced)\n        *forced = data_forced;\n    if (required)\n        *required = data_required;\n    if (optional)\n        *optional = data_optional;\n    if (disabled)\n        *disabled = data_disabled;\n    if (forbidden)\n        *forbidden = data_forbidden;\n    if (vendor)\n        *vendor = data_vendor;\n\n    return 0;\n\n error:\n    virCPUx86DataFree(data_forced);\n    virCPUx86DataFree(data_required);\n    virCPUx86DataFree(data_optional);\n    virCPUx86DataFree(data_disabled);\n    virCPUx86DataFree(data_forbidden);\n    virCPUx86DataFree(data_vendor);\n    return -1;\n}"
  },
  {
    "function_name": "x86EncodePolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2237-2254",
    "snippet": "static int\nx86EncodePolicy(virCPUx86Data *data,\n                const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                virCPUFeaturePolicy policy)\n{\n    virCPUx86ModelPtr model;\n\n    if (!(model = x86ModelFromCPU(cpu, map, policy)))\n        return -1;\n\n    *data = model->data;\n    model->data.len = 0;\n    model->data.items = NULL;\n    x86ModelFree(model);\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86ModelFree",
          "args": [
            "model"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1141-1151",
          "snippet": "static void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelFromCPU",
          "args": [
            "cpu",
            "map",
            "policy"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFromCPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1220-1299",
          "snippet": "static virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86EncodePolicy(virCPUx86Data *data,\n                const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                virCPUFeaturePolicy policy)\n{\n    virCPUx86ModelPtr model;\n\n    if (!(model = x86ModelFromCPU(cpu, map, policy)))\n        return -1;\n\n    *data = model->data;\n    model->data.len = 0;\n    model->data.items = NULL;\n    x86ModelFree(model);\n\n    return 0;\n}"
  },
  {
    "function_name": "x86DecodeCPUData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2228-2234",
    "snippet": "static int\nx86DecodeCPUData(virCPUDefPtr cpu,\n                 const virCPUData *data,\n                 virDomainCapsCPUModelsPtr models)\n{\n    return x86Decode(cpu, &data->data.x86, models, NULL, false);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86Decode",
          "args": [
            "cpu",
            "&data->data.x86",
            "models",
            "NULL",
            "false"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "x86Decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2095-2226",
          "snippet": "static int\nx86Decode(virCPUDefPtr cpu,\n          const virCPUx86Data *cpuData,\n          virDomainCapsCPUModelsPtr models,\n          const char *preferred,\n          bool migratable)\n{\n    int ret = -1;\n    virCPUx86MapPtr map;\n    virCPUx86ModelPtr candidate;\n    virCPUDefPtr cpuCandidate;\n    virCPUx86ModelPtr model = NULL;\n    virCPUDefPtr cpuModel = NULL;\n    virCPUx86Data data = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data copy = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data features = VIR_CPU_X86_DATA_INIT;\n    virCPUx86VendorPtr vendor;\n    virDomainCapsCPUModelPtr hvModel = NULL;\n    g_autofree char *sigs = NULL;\n    uint32_t signature;\n    ssize_t i;\n    int rc;\n\n    if (!cpuData || x86DataCopy(&data, cpuData) < 0)\n        return -1;\n\n    if (!(map = virCPUx86GetMap()))\n        goto cleanup;\n\n    vendor = x86DataToVendor(&data, map);\n    signature = x86DataToSignature(&data);\n\n    x86DataFilterTSX(&data, vendor, map);\n\n    /* Walk through the CPU models in reverse order to check newest\n     * models first.\n     */\n    for (i = map->nmodels - 1; i >= 0; i--) {\n        candidate = map->models[i];\n        if (models &&\n            !(hvModel = virDomainCapsCPUModelsGet(models, candidate->name))) {\n            if (preferred && STREQ(candidate->name, preferred)) {\n                if (cpu->fallback != VIR_CPU_FALLBACK_ALLOW) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"CPU model %s is not supported by hypervisor\"),\n                                   preferred);\n                    goto cleanup;\n                } else {\n                    VIR_WARN(\"Preferred CPU model %s not allowed by\"\n                             \" hypervisor; closest supported model will be\"\n                             \" used\", preferred);\n                }\n            } else {\n                VIR_DEBUG(\"CPU model %s not allowed by hypervisor; ignoring\",\n                          candidate->name);\n            }\n            continue;\n        }\n\n        /* Both vendor and candidate->vendor are pointers to a single list of\n         * known vendors stored in the map.\n         */\n        if (vendor && candidate->vendor && vendor != candidate->vendor) {\n            VIR_DEBUG(\"CPU vendor %s of model %s differs from %s; ignoring\",\n                      candidate->vendor->name, candidate->name, vendor->name);\n            continue;\n        }\n\n        if (!(cpuCandidate = x86DataToCPU(&data, candidate, map, hvModel)))\n            goto cleanup;\n        cpuCandidate->type = cpu->type;\n\n        if ((rc = x86DecodeUseCandidate(model, cpuModel,\n                                        candidate, cpuCandidate,\n                                        signature, preferred,\n                                        cpu->type == VIR_CPU_TYPE_HOST))) {\n            virCPUDefFree(cpuModel);\n            cpuModel = cpuCandidate;\n            model = candidate;\n            if (rc == 2)\n                break;\n        } else {\n            virCPUDefFree(cpuCandidate);\n        }\n    }\n\n    if (!cpuModel) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Cannot find suitable CPU model for given data\"));\n        goto cleanup;\n    }\n\n    /* Remove non-migratable features if requested\n     * Note: this only works as long as no CPU model contains non-migratable\n     * features directly */\n    if (migratable) {\n        i = 0;\n        while (i < cpuModel->nfeatures) {\n            if (x86FeatureIsMigratable(cpuModel->features[i].name, map)) {\n                i++;\n            } else {\n                VIR_FREE(cpuModel->features[i].name);\n                VIR_DELETE_ELEMENT_INPLACE(cpuModel->features, i,\n                                           cpuModel->nfeatures);\n            }\n        }\n    }\n\n    if (vendor)\n        cpu->vendor = g_strdup(vendor->name);\n\n    sigs = x86FormatSignatures(model);\n\n    VIR_DEBUG(\"Using CPU model %s (signatures %s) for CPU with signature %06lx\",\n              model->name, NULLSTR(sigs), (unsigned long)signature);\n\n    cpu->model = g_steal_pointer(&cpuModel->model);\n    cpu->features = g_steal_pointer(&cpuModel->features);\n    cpu->nfeatures = cpuModel->nfeatures;\n    cpuModel->nfeatures = 0;\n    cpu->nfeatures_max = cpuModel->nfeatures_max;\n    cpuModel->nfeatures_max = 0;\n\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(cpuModel);\n    virCPUx86DataClear(&data);\n    virCPUx86DataClear(&copy);\n    virCPUx86DataClear(&features);\n    return ret;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86Decode(virCPUDefPtr cpu,\n          const virCPUx86Data *cpuData,\n          virDomainCapsCPUModelsPtr models,\n          const char *preferred,\n          bool migratable)\n{\n    int ret = -1;\n    virCPUx86MapPtr map;\n    virCPUx86ModelPtr candidate;\n    virCPUDefPtr cpuCandidate;\n    virCPUx86ModelPtr model = NULL;\n    virCPUDefPtr cpuModel = NULL;\n    virCPUx86Data data = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data copy = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data features = VIR_CPU_X86_DATA_INIT;\n    virCPUx86VendorPtr vendor;\n    virDomainCapsCPUModelPtr hvModel = NULL;\n    g_autofree char *sigs = NULL;\n    uint32_t signature;\n    ssize_t i;\n    int rc;\n\n    if (!cpuData || x86DataCopy(&data, cpuData) < 0)\n        return -1;\n\n    if (!(map = virCPUx86GetMap()))\n        goto cleanup;\n\n    vendor = x86DataToVendor(&data, map);\n    signature = x86DataToSignature(&data);\n\n    x86DataFilterTSX(&data, vendor, map);\n\n    /* Walk through the CPU models in reverse order to check newest\n     * models first.\n     */\n    for (i = map->nmodels - 1; i >= 0; i--) {\n        candidate = map->models[i];\n        if (models &&\n            !(hvModel = virDomainCapsCPUModelsGet(models, candidate->name))) {\n            if (preferred && STREQ(candidate->name, preferred)) {\n                if (cpu->fallback != VIR_CPU_FALLBACK_ALLOW) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"CPU model %s is not supported by hypervisor\"),\n                                   preferred);\n                    goto cleanup;\n                } else {\n                    VIR_WARN(\"Preferred CPU model %s not allowed by\"\n                             \" hypervisor; closest supported model will be\"\n                             \" used\", preferred);\n                }\n            } else {\n                VIR_DEBUG(\"CPU model %s not allowed by hypervisor; ignoring\",\n                          candidate->name);\n            }\n            continue;\n        }\n\n        /* Both vendor and candidate->vendor are pointers to a single list of\n         * known vendors stored in the map.\n         */\n        if (vendor && candidate->vendor && vendor != candidate->vendor) {\n            VIR_DEBUG(\"CPU vendor %s of model %s differs from %s; ignoring\",\n                      candidate->vendor->name, candidate->name, vendor->name);\n            continue;\n        }\n\n        if (!(cpuCandidate = x86DataToCPU(&data, candidate, map, hvModel)))\n            goto cleanup;\n        cpuCandidate->type = cpu->type;\n\n        if ((rc = x86DecodeUseCandidate(model, cpuModel,\n                                        candidate, cpuCandidate,\n                                        signature, preferred,\n                                        cpu->type == VIR_CPU_TYPE_HOST))) {\n            virCPUDefFree(cpuModel);\n            cpuModel = cpuCandidate;\n            model = candidate;\n            if (rc == 2)\n                break;\n        } else {\n            virCPUDefFree(cpuCandidate);\n        }\n    }\n\n    if (!cpuModel) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Cannot find suitable CPU model for given data\"));\n        goto cleanup;\n    }\n\n    /* Remove non-migratable features if requested\n     * Note: this only works as long as no CPU model contains non-migratable\n     * features directly */\n    if (migratable) {\n        i = 0;\n        while (i < cpuModel->nfeatures) {\n            if (x86FeatureIsMigratable(cpuModel->features[i].name, map)) {\n                i++;\n            } else {\n                VIR_FREE(cpuModel->features[i].name);\n                VIR_DELETE_ELEMENT_INPLACE(cpuModel->features, i,\n                                           cpuModel->nfeatures);\n            }\n        }\n    }\n\n    if (vendor)\n        cpu->vendor = g_strdup(vendor->name);\n\n    sigs = x86FormatSignatures(model);\n\n    VIR_DEBUG(\"Using CPU model %s (signatures %s) for CPU with signature %06lx\",\n              model->name, NULLSTR(sigs), (unsigned long)signature);\n\n    cpu->model = g_steal_pointer(&cpuModel->model);\n    cpu->features = g_steal_pointer(&cpuModel->features);\n    cpu->nfeatures = cpuModel->nfeatures;\n    cpuModel->nfeatures = 0;\n    cpu->nfeatures_max = cpuModel->nfeatures_max;\n    cpuModel->nfeatures_max = 0;\n\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(cpuModel);\n    virCPUx86DataClear(&data);\n    virCPUx86DataClear(&copy);\n    virCPUx86DataClear(&features);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DecodeCPUData(virCPUDefPtr cpu,\n                 const virCPUData *data,\n                 virDomainCapsCPUModelsPtr models)\n{\n    return x86Decode(cpu, &data->data.x86, models, NULL, false);\n}"
  },
  {
    "function_name": "x86Decode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2095-2226",
    "snippet": "static int\nx86Decode(virCPUDefPtr cpu,\n          const virCPUx86Data *cpuData,\n          virDomainCapsCPUModelsPtr models,\n          const char *preferred,\n          bool migratable)\n{\n    int ret = -1;\n    virCPUx86MapPtr map;\n    virCPUx86ModelPtr candidate;\n    virCPUDefPtr cpuCandidate;\n    virCPUx86ModelPtr model = NULL;\n    virCPUDefPtr cpuModel = NULL;\n    virCPUx86Data data = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data copy = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data features = VIR_CPU_X86_DATA_INIT;\n    virCPUx86VendorPtr vendor;\n    virDomainCapsCPUModelPtr hvModel = NULL;\n    g_autofree char *sigs = NULL;\n    uint32_t signature;\n    ssize_t i;\n    int rc;\n\n    if (!cpuData || x86DataCopy(&data, cpuData) < 0)\n        return -1;\n\n    if (!(map = virCPUx86GetMap()))\n        goto cleanup;\n\n    vendor = x86DataToVendor(&data, map);\n    signature = x86DataToSignature(&data);\n\n    x86DataFilterTSX(&data, vendor, map);\n\n    /* Walk through the CPU models in reverse order to check newest\n     * models first.\n     */\n    for (i = map->nmodels - 1; i >= 0; i--) {\n        candidate = map->models[i];\n        if (models &&\n            !(hvModel = virDomainCapsCPUModelsGet(models, candidate->name))) {\n            if (preferred && STREQ(candidate->name, preferred)) {\n                if (cpu->fallback != VIR_CPU_FALLBACK_ALLOW) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"CPU model %s is not supported by hypervisor\"),\n                                   preferred);\n                    goto cleanup;\n                } else {\n                    VIR_WARN(\"Preferred CPU model %s not allowed by\"\n                             \" hypervisor; closest supported model will be\"\n                             \" used\", preferred);\n                }\n            } else {\n                VIR_DEBUG(\"CPU model %s not allowed by hypervisor; ignoring\",\n                          candidate->name);\n            }\n            continue;\n        }\n\n        /* Both vendor and candidate->vendor are pointers to a single list of\n         * known vendors stored in the map.\n         */\n        if (vendor && candidate->vendor && vendor != candidate->vendor) {\n            VIR_DEBUG(\"CPU vendor %s of model %s differs from %s; ignoring\",\n                      candidate->vendor->name, candidate->name, vendor->name);\n            continue;\n        }\n\n        if (!(cpuCandidate = x86DataToCPU(&data, candidate, map, hvModel)))\n            goto cleanup;\n        cpuCandidate->type = cpu->type;\n\n        if ((rc = x86DecodeUseCandidate(model, cpuModel,\n                                        candidate, cpuCandidate,\n                                        signature, preferred,\n                                        cpu->type == VIR_CPU_TYPE_HOST))) {\n            virCPUDefFree(cpuModel);\n            cpuModel = cpuCandidate;\n            model = candidate;\n            if (rc == 2)\n                break;\n        } else {\n            virCPUDefFree(cpuCandidate);\n        }\n    }\n\n    if (!cpuModel) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Cannot find suitable CPU model for given data\"));\n        goto cleanup;\n    }\n\n    /* Remove non-migratable features if requested\n     * Note: this only works as long as no CPU model contains non-migratable\n     * features directly */\n    if (migratable) {\n        i = 0;\n        while (i < cpuModel->nfeatures) {\n            if (x86FeatureIsMigratable(cpuModel->features[i].name, map)) {\n                i++;\n            } else {\n                VIR_FREE(cpuModel->features[i].name);\n                VIR_DELETE_ELEMENT_INPLACE(cpuModel->features, i,\n                                           cpuModel->nfeatures);\n            }\n        }\n    }\n\n    if (vendor)\n        cpu->vendor = g_strdup(vendor->name);\n\n    sigs = x86FormatSignatures(model);\n\n    VIR_DEBUG(\"Using CPU model %s (signatures %s) for CPU with signature %06lx\",\n              model->name, NULLSTR(sigs), (unsigned long)signature);\n\n    cpu->model = g_steal_pointer(&cpuModel->model);\n    cpu->features = g_steal_pointer(&cpuModel->features);\n    cpu->nfeatures = cpuModel->nfeatures;\n    cpuModel->nfeatures = 0;\n    cpu->nfeatures_max = cpuModel->nfeatures_max;\n    cpuModel->nfeatures_max = 0;\n\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(cpuModel);\n    virCPUx86DataClear(&data);\n    virCPUx86DataClear(&copy);\n    virCPUx86DataClear(&features);\n    return ret;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataClear",
          "args": [
            "&features"
          ],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "463-470",
          "snippet": "static void\nvirCPUx86DataClear(virCPUx86Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->items);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataClear(virCPUx86Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->items);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "cpuModel"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&cpuModel->features"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&cpuModel->model"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Using CPU model %s (signatures %s) for CPU with signature %06lx\"",
            "model->name",
            "NULLSTR(sigs)",
            "(unsigned long)signature"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "sigs"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86FormatSignatures",
          "args": [
            "model"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "x86FormatSignatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1973-1987",
          "snippet": "static char *\nx86FormatSignatures(virCPUx86ModelPtr model)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n\n    for (i = 0; i < model->nsignatures; i++) {\n        virBufferAsprintf(&buf, \"%06lx,\",\n                          (unsigned long)model->signatures[i]);\n    }\n\n    virBufferTrim(&buf, \",\");\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic char *\nx86FormatSignatures(virCPUx86ModelPtr model)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n\n    for (i = 0; i < model->nsignatures; i++) {\n        virBufferAsprintf(&buf, \"%06lx,\",\n                          (unsigned long)model->signatures[i]);\n    }\n\n    virBufferTrim(&buf, \",\");\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "vendor->name"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT_INPLACE",
          "args": [
            "cpuModel->features",
            "i",
            "cpuModel->nfeatures"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpuModel->features[i].name"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86FeatureIsMigratable",
          "args": [
            "cpuModel->features[i].name",
            "map"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureIsMigratable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "942-955",
          "snippet": "static bool\nx86FeatureIsMigratable(const char *name,\n                       void *cpu_map)\n{\n    virCPUx86MapPtr map = cpu_map;\n    size_t i;\n\n    for (i = 0; i < map->nblockers; i++) {\n        if (STREQ(name, map->migrate_blockers[i]->name))\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nx86FeatureIsMigratable(const char *name,\n                       void *cpu_map)\n{\n    virCPUx86MapPtr map = cpu_map;\n    size_t i;\n\n    for (i = 0; i < map->nblockers; i++) {\n        if (STREQ(name, map->migrate_blockers[i]->name))\n            return false;\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot find suitable CPU model for given data\")"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86DecodeUseCandidate",
          "args": [
            "model",
            "cpuModel",
            "candidate",
            "cpuCandidate",
            "signature",
            "preferred",
            "cpu->type == VIR_CPU_TYPE_HOST"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "x86DecodeUseCandidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1998-2057",
          "snippet": "static int\nx86DecodeUseCandidate(virCPUx86ModelPtr current,\n                      virCPUDefPtr cpuCurrent,\n                      virCPUx86ModelPtr candidate,\n                      virCPUDefPtr cpuCandidate,\n                      uint32_t signature,\n                      const char *preferred,\n                      bool checkPolicy)\n{\n    if (checkPolicy) {\n        size_t i;\n        for (i = 0; i < cpuCandidate->nfeatures; i++) {\n            if (cpuCandidate->features[i].policy == VIR_CPU_FEATURE_DISABLE)\n                return 0;\n            cpuCandidate->features[i].policy = -1;\n        }\n    }\n\n    if (preferred && STREQ(cpuCandidate->model, preferred)) {\n        VIR_DEBUG(\"%s is the preferred model\", cpuCandidate->model);\n        return 2;\n    }\n\n    if (!cpuCurrent) {\n        VIR_DEBUG(\"%s is better than nothing\", cpuCandidate->model);\n        return 1;\n    }\n\n    /* Ideally we want to select a model with family/model equal to\n     * family/model of the real CPU. Once we found such model, we only\n     * consider candidates with matching family/model.\n     */\n    if (signature &&\n        x86ModelHasSignature(current, signature) &&\n        !x86ModelHasSignature(candidate, signature)) {\n        VIR_DEBUG(\"%s differs in signature from matching %s\",\n                  cpuCandidate->model, cpuCurrent->model);\n        return 0;\n    }\n\n    if (cpuCurrent->nfeatures > cpuCandidate->nfeatures) {\n        VIR_DEBUG(\"%s results in shorter feature list than %s\",\n                  cpuCandidate->model, cpuCurrent->model);\n        return 1;\n    }\n\n    /* Prefer a candidate with matching signature even though it would\n     * result in longer list of features.\n     */\n    if (signature &&\n        x86ModelHasSignature(candidate, signature) &&\n        !x86ModelHasSignature(current, signature)) {\n        VIR_DEBUG(\"%s provides matching signature\", cpuCandidate->model);\n        return 1;\n    }\n\n    VIR_DEBUG(\"%s does not result in shorter feature list than %s\",\n              cpuCandidate->model, cpuCurrent->model);\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DecodeUseCandidate(virCPUx86ModelPtr current,\n                      virCPUDefPtr cpuCurrent,\n                      virCPUx86ModelPtr candidate,\n                      virCPUDefPtr cpuCandidate,\n                      uint32_t signature,\n                      const char *preferred,\n                      bool checkPolicy)\n{\n    if (checkPolicy) {\n        size_t i;\n        for (i = 0; i < cpuCandidate->nfeatures; i++) {\n            if (cpuCandidate->features[i].policy == VIR_CPU_FEATURE_DISABLE)\n                return 0;\n            cpuCandidate->features[i].policy = -1;\n        }\n    }\n\n    if (preferred && STREQ(cpuCandidate->model, preferred)) {\n        VIR_DEBUG(\"%s is the preferred model\", cpuCandidate->model);\n        return 2;\n    }\n\n    if (!cpuCurrent) {\n        VIR_DEBUG(\"%s is better than nothing\", cpuCandidate->model);\n        return 1;\n    }\n\n    /* Ideally we want to select a model with family/model equal to\n     * family/model of the real CPU. Once we found such model, we only\n     * consider candidates with matching family/model.\n     */\n    if (signature &&\n        x86ModelHasSignature(current, signature) &&\n        !x86ModelHasSignature(candidate, signature)) {\n        VIR_DEBUG(\"%s differs in signature from matching %s\",\n                  cpuCandidate->model, cpuCurrent->model);\n        return 0;\n    }\n\n    if (cpuCurrent->nfeatures > cpuCandidate->nfeatures) {\n        VIR_DEBUG(\"%s results in shorter feature list than %s\",\n                  cpuCandidate->model, cpuCurrent->model);\n        return 1;\n    }\n\n    /* Prefer a candidate with matching signature even though it would\n     * result in longer list of features.\n     */\n    if (signature &&\n        x86ModelHasSignature(candidate, signature) &&\n        !x86ModelHasSignature(current, signature)) {\n        VIR_DEBUG(\"%s provides matching signature\", cpuCandidate->model);\n        return 1;\n    }\n\n    VIR_DEBUG(\"%s does not result in shorter feature list than %s\",\n              cpuCandidate->model, cpuCurrent->model);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataToCPU",
          "args": [
            "&data",
            "candidate",
            "map",
            "hvModel"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataToCPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "767-824",
          "snippet": "static virCPUDefPtr\nx86DataToCPU(const virCPUx86Data *data,\n             virCPUx86ModelPtr model,\n             virCPUx86MapPtr map,\n             virDomainCapsCPUModelPtr hvModel)\n{\n    virCPUDefPtr cpu;\n    virCPUx86Data copy = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data modelData = VIR_CPU_X86_DATA_INIT;\n    virCPUx86VendorPtr vendor;\n\n    cpu = virCPUDefNew();\n\n    cpu->model = g_strdup(model->name);\n\n    if (x86DataCopy(&copy, data) < 0 ||\n        x86DataCopy(&modelData, &model->data) < 0)\n        goto error;\n\n    if ((vendor = x86DataToVendor(&copy, map)))\n        cpu->vendor = g_strdup(vendor->name);\n\n    x86DataSubtract(&copy, &modelData);\n    x86DataSubtract(&modelData, data);\n\n    /* The hypervisor's version of the CPU model (hvModel) may contain\n     * additional features which may be currently unavailable. Such features\n     * block usage of the CPU model and we need to explicitly disable them.\n     */\n    if (hvModel && hvModel->blockers) {\n        char **blocker;\n        virCPUx86FeaturePtr feature;\n\n        for (blocker = hvModel->blockers; *blocker; blocker++) {\n            if ((feature = x86FeatureFind(map, *blocker)) &&\n                !x86DataIsSubset(&copy, &feature->data))\n                if (x86DataAdd(&modelData, &feature->data) < 0)\n                    goto error;\n        }\n    }\n\n    /* because feature policy is ignored for host CPU */\n    cpu->type = VIR_CPU_TYPE_GUEST;\n\n    if (x86DataToCPUFeatures(cpu, VIR_CPU_FEATURE_REQUIRE, &copy, map) ||\n        x86DataToCPUFeatures(cpu, VIR_CPU_FEATURE_DISABLE, &modelData, map))\n        goto error;\n\n cleanup:\n    virCPUx86DataClear(&modelData);\n    virCPUx86DataClear(&copy);\n    return cpu;\n\n error:\n    virCPUDefFree(cpu);\n    cpu = NULL;\n    goto cleanup;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUDefPtr\nx86DataToCPU(const virCPUx86Data *data,\n             virCPUx86ModelPtr model,\n             virCPUx86MapPtr map,\n             virDomainCapsCPUModelPtr hvModel)\n{\n    virCPUDefPtr cpu;\n    virCPUx86Data copy = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data modelData = VIR_CPU_X86_DATA_INIT;\n    virCPUx86VendorPtr vendor;\n\n    cpu = virCPUDefNew();\n\n    cpu->model = g_strdup(model->name);\n\n    if (x86DataCopy(&copy, data) < 0 ||\n        x86DataCopy(&modelData, &model->data) < 0)\n        goto error;\n\n    if ((vendor = x86DataToVendor(&copy, map)))\n        cpu->vendor = g_strdup(vendor->name);\n\n    x86DataSubtract(&copy, &modelData);\n    x86DataSubtract(&modelData, data);\n\n    /* The hypervisor's version of the CPU model (hvModel) may contain\n     * additional features which may be currently unavailable. Such features\n     * block usage of the CPU model and we need to explicitly disable them.\n     */\n    if (hvModel && hvModel->blockers) {\n        char **blocker;\n        virCPUx86FeaturePtr feature;\n\n        for (blocker = hvModel->blockers; *blocker; blocker++) {\n            if ((feature = x86FeatureFind(map, *blocker)) &&\n                !x86DataIsSubset(&copy, &feature->data))\n                if (x86DataAdd(&modelData, &feature->data) < 0)\n                    goto error;\n        }\n    }\n\n    /* because feature policy is ignored for host CPU */\n    cpu->type = VIR_CPU_TYPE_GUEST;\n\n    if (x86DataToCPUFeatures(cpu, VIR_CPU_FEATURE_REQUIRE, &copy, map) ||\n        x86DataToCPUFeatures(cpu, VIR_CPU_FEATURE_DISABLE, &modelData, map))\n        goto error;\n\n cleanup:\n    virCPUx86DataClear(&modelData);\n    virCPUx86DataClear(&copy);\n    return cpu;\n\n error:\n    virCPUDefFree(cpu);\n    cpu = NULL;\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"CPU vendor %s of model %s differs from %s; ignoring\"",
            "candidate->vendor->name",
            "candidate->name",
            "vendor->name"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"CPU model %s not allowed by hypervisor; ignoring\"",
            "candidate->name"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Preferred CPU model %s not allowed by\"\n                             \" hypervisor; closest supported model will be\"\n                             \" used\"",
            "preferred"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"CPU model %s is not supported by hypervisor\")",
            "preferred"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "candidate->name",
            "preferred"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainCapsCPUModelsGet",
          "args": [
            "models",
            "candidate->name"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCapsCPUModelsGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_capabilities.c",
          "lines": "225-240",
          "snippet": "virDomainCapsCPUModelPtr\nvirDomainCapsCPUModelsGet(virDomainCapsCPUModelsPtr cpuModels,\n                          const char *name)\n{\n    size_t i;\n\n    if (!cpuModels)\n        return NULL;\n\n    for (i = 0; i < cpuModels->nmodels; i++) {\n        if (STREQ(cpuModels->models[i].name, name))\n            return cpuModels->models + i;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"device_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"domain_capabilities.h\"\n#include \"device_conf.h\"\n#include <config.h>\n\nvirDomainCapsCPUModelPtr\nvirDomainCapsCPUModelsGet(virDomainCapsCPUModelsPtr cpuModels,\n                          const char *name)\n{\n    size_t i;\n\n    if (!cpuModels)\n        return NULL;\n\n    for (i = 0; i < cpuModels->nmodels; i++) {\n        if (STREQ(cpuModels->models[i].name, name))\n            return cpuModels->models + i;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataFilterTSX",
          "args": [
            "&data",
            "vendor",
            "map"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataFilterTSX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "2063-2092",
          "snippet": "static void\nx86DataFilterTSX(virCPUx86Data *data,\n                 virCPUx86VendorPtr vendor,\n                 virCPUx86MapPtr map)\n{\n    unsigned int family;\n    unsigned int model;\n    unsigned int stepping;\n\n    if (!vendor || STRNEQ(vendor->name, \"Intel\"))\n        return;\n\n    x86DataToSignatureFull(data, &family, &model, &stepping);\n\n    if (family == 6 &&\n        ((model == 63 && stepping < 4) ||\n         model == 60 ||\n         model == 69 ||\n         model == 70)) {\n        virCPUx86FeaturePtr feature;\n\n        VIR_DEBUG(\"Dropping broken TSX\");\n\n        if ((feature = x86FeatureFind(map, \"hle\")))\n            x86DataSubtract(data, &feature->data);\n\n        if ((feature = x86FeatureFind(map, \"rtm\")))\n            x86DataSubtract(data, &feature->data);\n    }\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86DataFilterTSX(virCPUx86Data *data,\n                 virCPUx86VendorPtr vendor,\n                 virCPUx86MapPtr map)\n{\n    unsigned int family;\n    unsigned int model;\n    unsigned int stepping;\n\n    if (!vendor || STRNEQ(vendor->name, \"Intel\"))\n        return;\n\n    x86DataToSignatureFull(data, &family, &model, &stepping);\n\n    if (family == 6 &&\n        ((model == 63 && stepping < 4) ||\n         model == 60 ||\n         model == 69 ||\n         model == 70)) {\n        virCPUx86FeaturePtr feature;\n\n        VIR_DEBUG(\"Dropping broken TSX\");\n\n        if ((feature = x86FeatureFind(map, \"hle\")))\n            x86DataSubtract(data, &feature->data);\n\n        if ((feature = x86FeatureFind(map, \"rtm\")))\n            x86DataSubtract(data, &feature->data);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataToSignature",
          "args": [
            "&data"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataToSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "744-754",
          "snippet": "static uint32_t\nx86DataToSignature(const virCPUx86Data *data)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1);\n    virCPUx86DataItemPtr item;\n\n    if (!(item = virCPUx86DataGet(data, &leaf1)))\n        return 0;\n\n    return item->data.cpuid.eax & SIGNATURE_MASK;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SIGNATURE_MASK  0x0fff3ff0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\n#define SIGNATURE_MASK  0x0fff3ff0\n\nstatic uint32_t\nx86DataToSignature(const virCPUx86Data *data)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1);\n    virCPUx86DataItemPtr item;\n\n    if (!(item = virCPUx86DataGet(data, &leaf1)))\n        return 0;\n\n    return item->data.cpuid.eax & SIGNATURE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataToVendor",
          "args": [
            "&data",
            "map"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataToVendor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "625-642",
          "snippet": "static virCPUx86VendorPtr\nx86DataToVendor(const virCPUx86Data *data,\n                virCPUx86MapPtr map)\n{\n    virCPUx86DataItemPtr item;\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        virCPUx86VendorPtr vendor = map->vendors[i];\n        if ((item = virCPUx86DataGet(data, &vendor->data)) &&\n            virCPUx86DataItemMatchMasked(item, &vendor->data)) {\n            virCPUx86DataItemClearBits(item, &vendor->data);\n            return vendor;\n        }\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86VendorPtr\nx86DataToVendor(const virCPUx86Data *data,\n                virCPUx86MapPtr map)\n{\n    virCPUx86DataItemPtr item;\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        virCPUx86VendorPtr vendor = map->vendors[i];\n        if ((item = virCPUx86DataGet(data, &vendor->data)) &&\n            virCPUx86DataItemMatchMasked(item, &vendor->data)) {\n            virCPUx86DataItemClearBits(item, &vendor->data);\n            return vendor;\n        }\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86GetMap",
          "args": [],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86GetMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1605-1612",
          "snippet": "static virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86MapPtr cpuMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\n\nstatic virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataCopy",
          "args": [
            "&data",
            "cpuData"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "484-497",
          "snippet": "static int\nx86DataCopy(virCPUx86Data *dst, const virCPUx86Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->items, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n    for (i = 0; i < src->len; i++)\n        dst->items[i] = src->items[i];\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DataCopy(virCPUx86Data *dst, const virCPUx86Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->items, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n    for (i = 0; i < src->len; i++)\n        dst->items[i] = src->items[i];\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86Decode(virCPUDefPtr cpu,\n          const virCPUx86Data *cpuData,\n          virDomainCapsCPUModelsPtr models,\n          const char *preferred,\n          bool migratable)\n{\n    int ret = -1;\n    virCPUx86MapPtr map;\n    virCPUx86ModelPtr candidate;\n    virCPUDefPtr cpuCandidate;\n    virCPUx86ModelPtr model = NULL;\n    virCPUDefPtr cpuModel = NULL;\n    virCPUx86Data data = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data copy = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data features = VIR_CPU_X86_DATA_INIT;\n    virCPUx86VendorPtr vendor;\n    virDomainCapsCPUModelPtr hvModel = NULL;\n    g_autofree char *sigs = NULL;\n    uint32_t signature;\n    ssize_t i;\n    int rc;\n\n    if (!cpuData || x86DataCopy(&data, cpuData) < 0)\n        return -1;\n\n    if (!(map = virCPUx86GetMap()))\n        goto cleanup;\n\n    vendor = x86DataToVendor(&data, map);\n    signature = x86DataToSignature(&data);\n\n    x86DataFilterTSX(&data, vendor, map);\n\n    /* Walk through the CPU models in reverse order to check newest\n     * models first.\n     */\n    for (i = map->nmodels - 1; i >= 0; i--) {\n        candidate = map->models[i];\n        if (models &&\n            !(hvModel = virDomainCapsCPUModelsGet(models, candidate->name))) {\n            if (preferred && STREQ(candidate->name, preferred)) {\n                if (cpu->fallback != VIR_CPU_FALLBACK_ALLOW) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"CPU model %s is not supported by hypervisor\"),\n                                   preferred);\n                    goto cleanup;\n                } else {\n                    VIR_WARN(\"Preferred CPU model %s not allowed by\"\n                             \" hypervisor; closest supported model will be\"\n                             \" used\", preferred);\n                }\n            } else {\n                VIR_DEBUG(\"CPU model %s not allowed by hypervisor; ignoring\",\n                          candidate->name);\n            }\n            continue;\n        }\n\n        /* Both vendor and candidate->vendor are pointers to a single list of\n         * known vendors stored in the map.\n         */\n        if (vendor && candidate->vendor && vendor != candidate->vendor) {\n            VIR_DEBUG(\"CPU vendor %s of model %s differs from %s; ignoring\",\n                      candidate->vendor->name, candidate->name, vendor->name);\n            continue;\n        }\n\n        if (!(cpuCandidate = x86DataToCPU(&data, candidate, map, hvModel)))\n            goto cleanup;\n        cpuCandidate->type = cpu->type;\n\n        if ((rc = x86DecodeUseCandidate(model, cpuModel,\n                                        candidate, cpuCandidate,\n                                        signature, preferred,\n                                        cpu->type == VIR_CPU_TYPE_HOST))) {\n            virCPUDefFree(cpuModel);\n            cpuModel = cpuCandidate;\n            model = candidate;\n            if (rc == 2)\n                break;\n        } else {\n            virCPUDefFree(cpuCandidate);\n        }\n    }\n\n    if (!cpuModel) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Cannot find suitable CPU model for given data\"));\n        goto cleanup;\n    }\n\n    /* Remove non-migratable features if requested\n     * Note: this only works as long as no CPU model contains non-migratable\n     * features directly */\n    if (migratable) {\n        i = 0;\n        while (i < cpuModel->nfeatures) {\n            if (x86FeatureIsMigratable(cpuModel->features[i].name, map)) {\n                i++;\n            } else {\n                VIR_FREE(cpuModel->features[i].name);\n                VIR_DELETE_ELEMENT_INPLACE(cpuModel->features, i,\n                                           cpuModel->nfeatures);\n            }\n        }\n    }\n\n    if (vendor)\n        cpu->vendor = g_strdup(vendor->name);\n\n    sigs = x86FormatSignatures(model);\n\n    VIR_DEBUG(\"Using CPU model %s (signatures %s) for CPU with signature %06lx\",\n              model->name, NULLSTR(sigs), (unsigned long)signature);\n\n    cpu->model = g_steal_pointer(&cpuModel->model);\n    cpu->features = g_steal_pointer(&cpuModel->features);\n    cpu->nfeatures = cpuModel->nfeatures;\n    cpuModel->nfeatures = 0;\n    cpu->nfeatures_max = cpuModel->nfeatures_max;\n    cpuModel->nfeatures_max = 0;\n\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(cpuModel);\n    virCPUx86DataClear(&data);\n    virCPUx86DataClear(&copy);\n    virCPUx86DataClear(&features);\n    return ret;\n}"
  },
  {
    "function_name": "x86DataFilterTSX",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "2063-2092",
    "snippet": "static void\nx86DataFilterTSX(virCPUx86Data *data,\n                 virCPUx86VendorPtr vendor,\n                 virCPUx86MapPtr map)\n{\n    unsigned int family;\n    unsigned int model;\n    unsigned int stepping;\n\n    if (!vendor || STRNEQ(vendor->name, \"Intel\"))\n        return;\n\n    x86DataToSignatureFull(data, &family, &model, &stepping);\n\n    if (family == 6 &&\n        ((model == 63 && stepping < 4) ||\n         model == 60 ||\n         model == 69 ||\n         model == 70)) {\n        virCPUx86FeaturePtr feature;\n\n        VIR_DEBUG(\"Dropping broken TSX\");\n\n        if ((feature = x86FeatureFind(map, \"hle\")))\n            x86DataSubtract(data, &feature->data);\n\n        if ((feature = x86FeatureFind(map, \"rtm\")))\n            x86DataSubtract(data, &feature->data);\n    }\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86DataSubtract",
          "args": [
            "data",
            "&feature->data"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "538-551",
          "snippet": "static void\nx86DataSubtract(virCPUx86Data *data1,\n                const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        virCPUx86DataItemClearBits(item1, item2);\n    }\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86DataSubtract(virCPUx86Data *data1,\n                const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        virCPUx86DataItemClearBits(item1, item2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86FeatureFind",
          "args": [
            "map",
            "\"rtm\""
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "348-360",
          "snippet": "static virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Dropping broken TSX\""
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86DataToSignatureFull",
          "args": [
            "data",
            "&family",
            "&model",
            "&stepping"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataToSignatureFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "719-738",
          "snippet": "static void\nx86DataToSignatureFull(const virCPUx86Data *data,\n                       unsigned int *family,\n                       unsigned int *model,\n                       unsigned int *stepping)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1);\n    virCPUx86DataItemPtr item;\n    virCPUx86CPUIDPtr cpuid;\n\n    *family = *model = *stepping = 0;\n\n    if (!(item = virCPUx86DataGet(data, &leaf1)))\n        return;\n\n    cpuid = &item->data.cpuid;\n    *family = ((cpuid->eax >> 20) & 0xff) + ((cpuid->eax >> 8) & 0xf);\n    *model = ((cpuid->eax >> 12) & 0xf0) + ((cpuid->eax >> 4) & 0xf);\n    *stepping = cpuid->eax & 0xf;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86DataToSignatureFull(const virCPUx86Data *data,\n                       unsigned int *family,\n                       unsigned int *model,\n                       unsigned int *stepping)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1);\n    virCPUx86DataItemPtr item;\n    virCPUx86CPUIDPtr cpuid;\n\n    *family = *model = *stepping = 0;\n\n    if (!(item = virCPUx86DataGet(data, &leaf1)))\n        return;\n\n    cpuid = &item->data.cpuid;\n    *family = ((cpuid->eax >> 20) & 0xff) + ((cpuid->eax >> 8) & 0xf);\n    *model = ((cpuid->eax >> 12) & 0xf0) + ((cpuid->eax >> 4) & 0xf);\n    *stepping = cpuid->eax & 0xf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "vendor->name",
            "\"Intel\""
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86DataFilterTSX(virCPUx86Data *data,\n                 virCPUx86VendorPtr vendor,\n                 virCPUx86MapPtr map)\n{\n    unsigned int family;\n    unsigned int model;\n    unsigned int stepping;\n\n    if (!vendor || STRNEQ(vendor->name, \"Intel\"))\n        return;\n\n    x86DataToSignatureFull(data, &family, &model, &stepping);\n\n    if (family == 6 &&\n        ((model == 63 && stepping < 4) ||\n         model == 60 ||\n         model == 69 ||\n         model == 70)) {\n        virCPUx86FeaturePtr feature;\n\n        VIR_DEBUG(\"Dropping broken TSX\");\n\n        if ((feature = x86FeatureFind(map, \"hle\")))\n            x86DataSubtract(data, &feature->data);\n\n        if ((feature = x86FeatureFind(map, \"rtm\")))\n            x86DataSubtract(data, &feature->data);\n    }\n}"
  },
  {
    "function_name": "x86DecodeUseCandidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1998-2057",
    "snippet": "static int\nx86DecodeUseCandidate(virCPUx86ModelPtr current,\n                      virCPUDefPtr cpuCurrent,\n                      virCPUx86ModelPtr candidate,\n                      virCPUDefPtr cpuCandidate,\n                      uint32_t signature,\n                      const char *preferred,\n                      bool checkPolicy)\n{\n    if (checkPolicy) {\n        size_t i;\n        for (i = 0; i < cpuCandidate->nfeatures; i++) {\n            if (cpuCandidate->features[i].policy == VIR_CPU_FEATURE_DISABLE)\n                return 0;\n            cpuCandidate->features[i].policy = -1;\n        }\n    }\n\n    if (preferred && STREQ(cpuCandidate->model, preferred)) {\n        VIR_DEBUG(\"%s is the preferred model\", cpuCandidate->model);\n        return 2;\n    }\n\n    if (!cpuCurrent) {\n        VIR_DEBUG(\"%s is better than nothing\", cpuCandidate->model);\n        return 1;\n    }\n\n    /* Ideally we want to select a model with family/model equal to\n     * family/model of the real CPU. Once we found such model, we only\n     * consider candidates with matching family/model.\n     */\n    if (signature &&\n        x86ModelHasSignature(current, signature) &&\n        !x86ModelHasSignature(candidate, signature)) {\n        VIR_DEBUG(\"%s differs in signature from matching %s\",\n                  cpuCandidate->model, cpuCurrent->model);\n        return 0;\n    }\n\n    if (cpuCurrent->nfeatures > cpuCandidate->nfeatures) {\n        VIR_DEBUG(\"%s results in shorter feature list than %s\",\n                  cpuCandidate->model, cpuCurrent->model);\n        return 1;\n    }\n\n    /* Prefer a candidate with matching signature even though it would\n     * result in longer list of features.\n     */\n    if (signature &&\n        x86ModelHasSignature(candidate, signature) &&\n        !x86ModelHasSignature(current, signature)) {\n        VIR_DEBUG(\"%s provides matching signature\", cpuCandidate->model);\n        return 1;\n    }\n\n    VIR_DEBUG(\"%s does not result in shorter feature list than %s\",\n              cpuCandidate->model, cpuCurrent->model);\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s does not result in shorter feature list than %s\"",
            "cpuCandidate->model",
            "cpuCurrent->model"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s provides matching signature\"",
            "cpuCandidate->model"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86ModelHasSignature",
          "args": [
            "current",
            "signature"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelHasSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1958-1970",
          "snippet": "static bool\nx86ModelHasSignature(virCPUx86ModelPtr model,\n                     uint32_t signature)\n{\n    size_t i;\n\n    for (i = 0; i < model->nsignatures; i++) {\n        if (model->signatures[i] == signature)\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nx86ModelHasSignature(virCPUx86ModelPtr model,\n                     uint32_t signature)\n{\n    size_t i;\n\n    for (i = 0; i < model->nsignatures; i++) {\n        if (model->signatures[i] == signature)\n            return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s results in shorter feature list than %s\"",
            "cpuCandidate->model",
            "cpuCurrent->model"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s differs in signature from matching %s\"",
            "cpuCandidate->model",
            "cpuCurrent->model"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s is better than nothing\"",
            "cpuCandidate->model"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s is the preferred model\"",
            "cpuCandidate->model"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "cpuCandidate->model",
            "preferred"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DecodeUseCandidate(virCPUx86ModelPtr current,\n                      virCPUDefPtr cpuCurrent,\n                      virCPUx86ModelPtr candidate,\n                      virCPUDefPtr cpuCandidate,\n                      uint32_t signature,\n                      const char *preferred,\n                      bool checkPolicy)\n{\n    if (checkPolicy) {\n        size_t i;\n        for (i = 0; i < cpuCandidate->nfeatures; i++) {\n            if (cpuCandidate->features[i].policy == VIR_CPU_FEATURE_DISABLE)\n                return 0;\n            cpuCandidate->features[i].policy = -1;\n        }\n    }\n\n    if (preferred && STREQ(cpuCandidate->model, preferred)) {\n        VIR_DEBUG(\"%s is the preferred model\", cpuCandidate->model);\n        return 2;\n    }\n\n    if (!cpuCurrent) {\n        VIR_DEBUG(\"%s is better than nothing\", cpuCandidate->model);\n        return 1;\n    }\n\n    /* Ideally we want to select a model with family/model equal to\n     * family/model of the real CPU. Once we found such model, we only\n     * consider candidates with matching family/model.\n     */\n    if (signature &&\n        x86ModelHasSignature(current, signature) &&\n        !x86ModelHasSignature(candidate, signature)) {\n        VIR_DEBUG(\"%s differs in signature from matching %s\",\n                  cpuCandidate->model, cpuCurrent->model);\n        return 0;\n    }\n\n    if (cpuCurrent->nfeatures > cpuCandidate->nfeatures) {\n        VIR_DEBUG(\"%s results in shorter feature list than %s\",\n                  cpuCandidate->model, cpuCurrent->model);\n        return 1;\n    }\n\n    /* Prefer a candidate with matching signature even though it would\n     * result in longer list of features.\n     */\n    if (signature &&\n        x86ModelHasSignature(candidate, signature) &&\n        !x86ModelHasSignature(current, signature)) {\n        VIR_DEBUG(\"%s provides matching signature\", cpuCandidate->model);\n        return 1;\n    }\n\n    VIR_DEBUG(\"%s does not result in shorter feature list than %s\",\n              cpuCandidate->model, cpuCurrent->model);\n    return 0;\n}"
  },
  {
    "function_name": "x86FormatSignatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1973-1987",
    "snippet": "static char *\nx86FormatSignatures(virCPUx86ModelPtr model)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n\n    for (i = 0; i < model->nsignatures; i++) {\n        virBufferAsprintf(&buf, \"%06lx,\",\n                          (unsigned long)model->signatures[i]);\n    }\n\n    virBufferTrim(&buf, \",\");\n\n    return virBufferContentAndReset(&buf);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferTrim",
          "args": [
            "&buf",
            "\",\""
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferTrimLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "698-708",
          "snippet": "void\nvirBufferTrimLen(virBufferPtr buf, int len)\n{\n    if (!buf || !buf->str)\n        return;\n\n    if (len > buf->str->len)\n        return;\n\n    g_string_truncate(buf->str, buf->str->len - len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferTrimLen(virBufferPtr buf, int len)\n{\n    if (!buf || !buf->str)\n        return;\n\n    if (len > buf->str->len)\n        return;\n\n    g_string_truncate(buf->str, buf->str->len - len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"%06lx,\"",
            "(unsigned long)model->signatures[i]"
          ],
          "line": 1980
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic char *\nx86FormatSignatures(virCPUx86ModelPtr model)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n\n    for (i = 0; i < model->nsignatures; i++) {\n        virBufferAsprintf(&buf, \"%06lx,\",\n                          (unsigned long)model->signatures[i]);\n    }\n\n    virBufferTrim(&buf, \",\");\n\n    return virBufferContentAndReset(&buf);\n}"
  },
  {
    "function_name": "x86ModelHasSignature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1958-1970",
    "snippet": "static bool\nx86ModelHasSignature(virCPUx86ModelPtr model,\n                     uint32_t signature)\n{\n    size_t i;\n\n    for (i = 0; i < model->nsignatures; i++) {\n        if (model->signatures[i] == signature)\n            return true;\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nx86ModelHasSignature(virCPUx86ModelPtr model,\n                     uint32_t signature)\n{\n    size_t i;\n\n    for (i = 0; i < model->nsignatures; i++) {\n        if (model->signatures[i] == signature)\n            return true;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virCPUx86Compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1891-1955",
    "snippet": "static virCPUCompareResult\nvirCPUx86Compare(virCPUDefPtr host,\n                 virCPUDefPtr cpu,\n                 bool failIncompatible)\n{\n    virCPUCompareResult ret = VIR_CPU_COMPARE_ERROR;\n    virCPUx86MapPtr map;\n    virCPUx86ModelPtr model = NULL;\n    char *message = NULL;\n\n    if (!host || !host->model) {\n        if (failIncompatible) {\n            virReportError(VIR_ERR_CPU_INCOMPATIBLE, \"%s\",\n                           _(\"unknown host CPU\"));\n        } else {\n            VIR_WARN(\"unknown host CPU\");\n            ret = VIR_CPU_COMPARE_INCOMPATIBLE;\n        }\n        goto cleanup;\n    }\n\n    ret = x86Compute(host, cpu, NULL, &message);\n\n    if (ret == VIR_CPU_COMPARE_INCOMPATIBLE) {\n        bool noTSX = false;\n\n        if (STREQ_NULLABLE(cpu->model, \"Haswell\") ||\n            STREQ_NULLABLE(cpu->model, \"Broadwell\")) {\n            if (!(map = virCPUx86GetMap()))\n                goto cleanup;\n\n            if (!(model = x86ModelFromCPU(cpu, map, -1)))\n                goto cleanup;\n\n            noTSX = !x86FeatureInData(\"hle\", &model->data, map) ||\n                    !x86FeatureInData(\"rtm\", &model->data, map);\n        }\n\n        if (failIncompatible) {\n            ret = VIR_CPU_COMPARE_ERROR;\n            if (message) {\n                if (noTSX) {\n                    virReportError(VIR_ERR_CPU_INCOMPATIBLE,\n                                   _(\"%s; try using '%s-noTSX' CPU model\"),\n                                   message, cpu->model);\n                } else {\n                    virReportError(VIR_ERR_CPU_INCOMPATIBLE, \"%s\", message);\n                }\n            } else {\n                if (noTSX) {\n                    virReportError(VIR_ERR_CPU_INCOMPATIBLE,\n                                   _(\"try using '%s-noTSX' CPU model\"),\n                                   cpu->model);\n                } else {\n                    virReportError(VIR_ERR_CPU_INCOMPATIBLE, NULL);\n                }\n            }\n        }\n    }\n\n cleanup:\n    VIR_FREE(message);\n    x86ModelFree(model);\n    return ret;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86ModelFree",
          "args": [
            "model"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1141-1151",
          "snippet": "static void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "message"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CPU_INCOMPATIBLE",
            "NULL"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CPU_INCOMPATIBLE",
            "_(\"try using '%s-noTSX' CPU model\")",
            "cpu->model"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"try using '%s-noTSX' CPU model\""
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CPU_INCOMPATIBLE",
            "\"%s\"",
            "message"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CPU_INCOMPATIBLE",
            "_(\"%s; try using '%s-noTSX' CPU model\")",
            "message",
            "cpu->model"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86FeatureInData",
          "args": [
            "\"rtm\"",
            "&model->data",
            "map"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureInData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "921-939",
          "snippet": "static int\nx86FeatureInData(const char *name,\n                 const virCPUx86Data *data,\n                 virCPUx86MapPtr map)\n{\n    virCPUx86FeaturePtr feature;\n\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown CPU feature %s\"), name);\n        return -1;\n    }\n\n    if (x86DataIsSubset(data, &feature->data))\n        return 1;\n    else\n        return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86FeatureInData(const char *name,\n                 const virCPUx86Data *data,\n                 virCPUx86MapPtr map)\n{\n    virCPUx86FeaturePtr feature;\n\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown CPU feature %s\"), name);\n        return -1;\n    }\n\n    if (x86DataIsSubset(data, &feature->data))\n        return 1;\n    else\n        return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelFromCPU",
          "args": [
            "cpu",
            "map",
            "-1"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFromCPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1220-1299",
          "snippet": "static virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86GetMap",
          "args": [],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86GetMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1605-1612",
          "snippet": "static virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86MapPtr cpuMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\n\nstatic virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "cpu->model",
            "\"Broadwell\""
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "cpu->model",
            "\"Haswell\""
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86Compute",
          "args": [
            "host",
            "cpu",
            "NULL",
            "&message"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "x86Compute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1731-1887",
          "snippet": "static virCPUCompareResult\nx86Compute(virCPUDefPtr host,\n           virCPUDefPtr cpu,\n           virCPUDataPtr *guest,\n           char **message)\n{\n    virCPUx86MapPtr map = NULL;\n    virCPUx86ModelPtr host_model = NULL;\n    virCPUx86ModelPtr cpu_force = NULL;\n    virCPUx86ModelPtr cpu_require = NULL;\n    virCPUx86ModelPtr cpu_optional = NULL;\n    virCPUx86ModelPtr cpu_disable = NULL;\n    virCPUx86ModelPtr cpu_forbid = NULL;\n    virCPUx86ModelPtr diff = NULL;\n    virCPUx86ModelPtr guest_model = NULL;\n    virCPUDataPtr guestData = NULL;\n    virCPUCompareResult ret;\n    virCPUx86CompareResult result;\n    virArch arch;\n    size_t i;\n\n    if (cpu->arch != VIR_ARCH_NONE) {\n        bool found = false;\n\n        for (i = 0; i < G_N_ELEMENTS(archs); i++) {\n            if (archs[i] == cpu->arch) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            VIR_DEBUG(\"CPU arch %s does not match host arch\",\n                      virArchToString(cpu->arch));\n            if (message) {\n                *message = g_strdup_printf(_(\"CPU arch %s does not match host arch\"),\n                                           virArchToString(cpu->arch));\n            }\n            return VIR_CPU_COMPARE_INCOMPATIBLE;\n        }\n        arch = cpu->arch;\n    } else {\n        arch = host->arch;\n    }\n\n    if (cpu->vendor &&\n        (!host->vendor || STRNEQ(cpu->vendor, host->vendor))) {\n        VIR_DEBUG(\"host CPU vendor does not match required CPU vendor %s\",\n                  cpu->vendor);\n        if (message) {\n            *message = g_strdup_printf(_(\"host CPU vendor does not match required \"\n                                         \"CPU vendor %s\"),\n                                       cpu->vendor);\n        }\n\n        return VIR_CPU_COMPARE_INCOMPATIBLE;\n    }\n\n    if (!(map = virCPUx86GetMap()) ||\n        !(host_model = x86ModelFromCPU(host, map, -1)) ||\n        !(cpu_force = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_FORCE)) ||\n        !(cpu_require = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_REQUIRE)) ||\n        !(cpu_optional = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_OPTIONAL)) ||\n        !(cpu_disable = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_DISABLE)) ||\n        !(cpu_forbid = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_FORBID)))\n        goto error;\n\n    x86DataIntersect(&cpu_forbid->data, &host_model->data);\n    if (!x86DataIsEmpty(&cpu_forbid->data)) {\n        virX86CpuIncompatible(N_(\"Host CPU provides forbidden features\"),\n                              &cpu_forbid->data);\n        goto cleanup;\n    }\n\n    /* first remove features that were inherited from the CPU model and were\n     * explicitly forced, disabled, or made optional\n     */\n    x86DataSubtract(&cpu_require->data, &cpu_force->data);\n    x86DataSubtract(&cpu_require->data, &cpu_optional->data);\n    x86DataSubtract(&cpu_require->data, &cpu_disable->data);\n    result = x86ModelCompare(host_model, cpu_require);\n    if (result == SUBSET || result == UNRELATED) {\n        x86DataSubtract(&cpu_require->data, &host_model->data);\n        virX86CpuIncompatible(N_(\"Host CPU does not provide required \"\n                                 \"features\"),\n                              &cpu_require->data);\n        goto cleanup;\n    }\n\n    ret = VIR_CPU_COMPARE_IDENTICAL;\n\n    if (!(diff = x86ModelCopy(host_model)))\n        goto error;\n\n    x86DataSubtract(&diff->data, &cpu_optional->data);\n    x86DataSubtract(&diff->data, &cpu_require->data);\n    x86DataSubtract(&diff->data, &cpu_disable->data);\n    x86DataSubtract(&diff->data, &cpu_force->data);\n\n    if (!x86DataIsEmpty(&diff->data))\n        ret = VIR_CPU_COMPARE_SUPERSET;\n\n    if (ret == VIR_CPU_COMPARE_SUPERSET\n        && cpu->type == VIR_CPU_TYPE_GUEST\n        && cpu->match == VIR_CPU_MATCH_STRICT) {\n        virX86CpuIncompatible(N_(\"Host CPU does not strictly match guest CPU: \"\n                                 \"Extra features\"),\n                              &diff->data);\n        goto cleanup;\n    }\n\n    if (guest) {\n        if (!(guest_model = x86ModelCopy(host_model)))\n            goto error;\n\n        if (cpu->vendor && host_model->vendor &&\n            virCPUx86DataAddItem(&guest_model->data,\n                                 &host_model->vendor->data) < 0)\n            goto error;\n\n        if (host_model->signatures &&\n            x86DataAddSignature(&guest_model->data, *host_model->signatures) < 0)\n            goto error;\n\n        if (cpu->type == VIR_CPU_TYPE_GUEST\n            && cpu->match == VIR_CPU_MATCH_EXACT)\n            x86DataSubtract(&guest_model->data, &diff->data);\n\n        if (x86DataAdd(&guest_model->data, &cpu_force->data))\n            goto error;\n\n        x86DataSubtract(&guest_model->data, &cpu_disable->data);\n\n        if (!(guestData = virCPUDataNew(arch)) ||\n            x86DataCopy(&guestData->data.x86, &guest_model->data) < 0)\n            goto error;\n\n        *guest = guestData;\n    }\n\n cleanup:\n    x86ModelFree(host_model);\n    x86ModelFree(diff);\n    x86ModelFree(cpu_force);\n    x86ModelFree(cpu_require);\n    x86ModelFree(cpu_optional);\n    x86ModelFree(cpu_disable);\n    x86ModelFree(cpu_forbid);\n    x86ModelFree(guest_model);\n\n    return ret;\n\n error:\n    virCPUx86DataFree(guestData);\n    ret = VIR_CPU_COMPARE_ERROR;\n    goto cleanup;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const virArch archs[] = { VIR_ARCH_I686, VIR_ARCH_X86_64 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic const virArch archs[] = { VIR_ARCH_I686, VIR_ARCH_X86_64 };\n\nstatic virCPUCompareResult\nx86Compute(virCPUDefPtr host,\n           virCPUDefPtr cpu,\n           virCPUDataPtr *guest,\n           char **message)\n{\n    virCPUx86MapPtr map = NULL;\n    virCPUx86ModelPtr host_model = NULL;\n    virCPUx86ModelPtr cpu_force = NULL;\n    virCPUx86ModelPtr cpu_require = NULL;\n    virCPUx86ModelPtr cpu_optional = NULL;\n    virCPUx86ModelPtr cpu_disable = NULL;\n    virCPUx86ModelPtr cpu_forbid = NULL;\n    virCPUx86ModelPtr diff = NULL;\n    virCPUx86ModelPtr guest_model = NULL;\n    virCPUDataPtr guestData = NULL;\n    virCPUCompareResult ret;\n    virCPUx86CompareResult result;\n    virArch arch;\n    size_t i;\n\n    if (cpu->arch != VIR_ARCH_NONE) {\n        bool found = false;\n\n        for (i = 0; i < G_N_ELEMENTS(archs); i++) {\n            if (archs[i] == cpu->arch) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            VIR_DEBUG(\"CPU arch %s does not match host arch\",\n                      virArchToString(cpu->arch));\n            if (message) {\n                *message = g_strdup_printf(_(\"CPU arch %s does not match host arch\"),\n                                           virArchToString(cpu->arch));\n            }\n            return VIR_CPU_COMPARE_INCOMPATIBLE;\n        }\n        arch = cpu->arch;\n    } else {\n        arch = host->arch;\n    }\n\n    if (cpu->vendor &&\n        (!host->vendor || STRNEQ(cpu->vendor, host->vendor))) {\n        VIR_DEBUG(\"host CPU vendor does not match required CPU vendor %s\",\n                  cpu->vendor);\n        if (message) {\n            *message = g_strdup_printf(_(\"host CPU vendor does not match required \"\n                                         \"CPU vendor %s\"),\n                                       cpu->vendor);\n        }\n\n        return VIR_CPU_COMPARE_INCOMPATIBLE;\n    }\n\n    if (!(map = virCPUx86GetMap()) ||\n        !(host_model = x86ModelFromCPU(host, map, -1)) ||\n        !(cpu_force = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_FORCE)) ||\n        !(cpu_require = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_REQUIRE)) ||\n        !(cpu_optional = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_OPTIONAL)) ||\n        !(cpu_disable = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_DISABLE)) ||\n        !(cpu_forbid = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_FORBID)))\n        goto error;\n\n    x86DataIntersect(&cpu_forbid->data, &host_model->data);\n    if (!x86DataIsEmpty(&cpu_forbid->data)) {\n        virX86CpuIncompatible(N_(\"Host CPU provides forbidden features\"),\n                              &cpu_forbid->data);\n        goto cleanup;\n    }\n\n    /* first remove features that were inherited from the CPU model and were\n     * explicitly forced, disabled, or made optional\n     */\n    x86DataSubtract(&cpu_require->data, &cpu_force->data);\n    x86DataSubtract(&cpu_require->data, &cpu_optional->data);\n    x86DataSubtract(&cpu_require->data, &cpu_disable->data);\n    result = x86ModelCompare(host_model, cpu_require);\n    if (result == SUBSET || result == UNRELATED) {\n        x86DataSubtract(&cpu_require->data, &host_model->data);\n        virX86CpuIncompatible(N_(\"Host CPU does not provide required \"\n                                 \"features\"),\n                              &cpu_require->data);\n        goto cleanup;\n    }\n\n    ret = VIR_CPU_COMPARE_IDENTICAL;\n\n    if (!(diff = x86ModelCopy(host_model)))\n        goto error;\n\n    x86DataSubtract(&diff->data, &cpu_optional->data);\n    x86DataSubtract(&diff->data, &cpu_require->data);\n    x86DataSubtract(&diff->data, &cpu_disable->data);\n    x86DataSubtract(&diff->data, &cpu_force->data);\n\n    if (!x86DataIsEmpty(&diff->data))\n        ret = VIR_CPU_COMPARE_SUPERSET;\n\n    if (ret == VIR_CPU_COMPARE_SUPERSET\n        && cpu->type == VIR_CPU_TYPE_GUEST\n        && cpu->match == VIR_CPU_MATCH_STRICT) {\n        virX86CpuIncompatible(N_(\"Host CPU does not strictly match guest CPU: \"\n                                 \"Extra features\"),\n                              &diff->data);\n        goto cleanup;\n    }\n\n    if (guest) {\n        if (!(guest_model = x86ModelCopy(host_model)))\n            goto error;\n\n        if (cpu->vendor && host_model->vendor &&\n            virCPUx86DataAddItem(&guest_model->data,\n                                 &host_model->vendor->data) < 0)\n            goto error;\n\n        if (host_model->signatures &&\n            x86DataAddSignature(&guest_model->data, *host_model->signatures) < 0)\n            goto error;\n\n        if (cpu->type == VIR_CPU_TYPE_GUEST\n            && cpu->match == VIR_CPU_MATCH_EXACT)\n            x86DataSubtract(&guest_model->data, &diff->data);\n\n        if (x86DataAdd(&guest_model->data, &cpu_force->data))\n            goto error;\n\n        x86DataSubtract(&guest_model->data, &cpu_disable->data);\n\n        if (!(guestData = virCPUDataNew(arch)) ||\n            x86DataCopy(&guestData->data.x86, &guest_model->data) < 0)\n            goto error;\n\n        *guest = guestData;\n    }\n\n cleanup:\n    x86ModelFree(host_model);\n    x86ModelFree(diff);\n    x86ModelFree(cpu_force);\n    x86ModelFree(cpu_require);\n    x86ModelFree(cpu_optional);\n    x86ModelFree(cpu_disable);\n    x86ModelFree(cpu_forbid);\n    x86ModelFree(guest_model);\n\n    return ret;\n\n error:\n    virCPUx86DataFree(guestData);\n    ret = VIR_CPU_COMPARE_ERROR;\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"unknown host CPU\""
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CPU_INCOMPATIBLE",
            "\"%s\"",
            "_(\"unknown host CPU\")"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUCompareResult\nvirCPUx86Compare(virCPUDefPtr host,\n                 virCPUDefPtr cpu,\n                 bool failIncompatible)\n{\n    virCPUCompareResult ret = VIR_CPU_COMPARE_ERROR;\n    virCPUx86MapPtr map;\n    virCPUx86ModelPtr model = NULL;\n    char *message = NULL;\n\n    if (!host || !host->model) {\n        if (failIncompatible) {\n            virReportError(VIR_ERR_CPU_INCOMPATIBLE, \"%s\",\n                           _(\"unknown host CPU\"));\n        } else {\n            VIR_WARN(\"unknown host CPU\");\n            ret = VIR_CPU_COMPARE_INCOMPATIBLE;\n        }\n        goto cleanup;\n    }\n\n    ret = x86Compute(host, cpu, NULL, &message);\n\n    if (ret == VIR_CPU_COMPARE_INCOMPATIBLE) {\n        bool noTSX = false;\n\n        if (STREQ_NULLABLE(cpu->model, \"Haswell\") ||\n            STREQ_NULLABLE(cpu->model, \"Broadwell\")) {\n            if (!(map = virCPUx86GetMap()))\n                goto cleanup;\n\n            if (!(model = x86ModelFromCPU(cpu, map, -1)))\n                goto cleanup;\n\n            noTSX = !x86FeatureInData(\"hle\", &model->data, map) ||\n                    !x86FeatureInData(\"rtm\", &model->data, map);\n        }\n\n        if (failIncompatible) {\n            ret = VIR_CPU_COMPARE_ERROR;\n            if (message) {\n                if (noTSX) {\n                    virReportError(VIR_ERR_CPU_INCOMPATIBLE,\n                                   _(\"%s; try using '%s-noTSX' CPU model\"),\n                                   message, cpu->model);\n                } else {\n                    virReportError(VIR_ERR_CPU_INCOMPATIBLE, \"%s\", message);\n                }\n            } else {\n                if (noTSX) {\n                    virReportError(VIR_ERR_CPU_INCOMPATIBLE,\n                                   _(\"try using '%s-noTSX' CPU model\"),\n                                   cpu->model);\n                } else {\n                    virReportError(VIR_ERR_CPU_INCOMPATIBLE, NULL);\n                }\n            }\n        }\n    }\n\n cleanup:\n    VIR_FREE(message);\n    x86ModelFree(model);\n    return ret;\n}"
  },
  {
    "function_name": "x86Compute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1731-1887",
    "snippet": "static virCPUCompareResult\nx86Compute(virCPUDefPtr host,\n           virCPUDefPtr cpu,\n           virCPUDataPtr *guest,\n           char **message)\n{\n    virCPUx86MapPtr map = NULL;\n    virCPUx86ModelPtr host_model = NULL;\n    virCPUx86ModelPtr cpu_force = NULL;\n    virCPUx86ModelPtr cpu_require = NULL;\n    virCPUx86ModelPtr cpu_optional = NULL;\n    virCPUx86ModelPtr cpu_disable = NULL;\n    virCPUx86ModelPtr cpu_forbid = NULL;\n    virCPUx86ModelPtr diff = NULL;\n    virCPUx86ModelPtr guest_model = NULL;\n    virCPUDataPtr guestData = NULL;\n    virCPUCompareResult ret;\n    virCPUx86CompareResult result;\n    virArch arch;\n    size_t i;\n\n    if (cpu->arch != VIR_ARCH_NONE) {\n        bool found = false;\n\n        for (i = 0; i < G_N_ELEMENTS(archs); i++) {\n            if (archs[i] == cpu->arch) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            VIR_DEBUG(\"CPU arch %s does not match host arch\",\n                      virArchToString(cpu->arch));\n            if (message) {\n                *message = g_strdup_printf(_(\"CPU arch %s does not match host arch\"),\n                                           virArchToString(cpu->arch));\n            }\n            return VIR_CPU_COMPARE_INCOMPATIBLE;\n        }\n        arch = cpu->arch;\n    } else {\n        arch = host->arch;\n    }\n\n    if (cpu->vendor &&\n        (!host->vendor || STRNEQ(cpu->vendor, host->vendor))) {\n        VIR_DEBUG(\"host CPU vendor does not match required CPU vendor %s\",\n                  cpu->vendor);\n        if (message) {\n            *message = g_strdup_printf(_(\"host CPU vendor does not match required \"\n                                         \"CPU vendor %s\"),\n                                       cpu->vendor);\n        }\n\n        return VIR_CPU_COMPARE_INCOMPATIBLE;\n    }\n\n    if (!(map = virCPUx86GetMap()) ||\n        !(host_model = x86ModelFromCPU(host, map, -1)) ||\n        !(cpu_force = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_FORCE)) ||\n        !(cpu_require = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_REQUIRE)) ||\n        !(cpu_optional = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_OPTIONAL)) ||\n        !(cpu_disable = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_DISABLE)) ||\n        !(cpu_forbid = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_FORBID)))\n        goto error;\n\n    x86DataIntersect(&cpu_forbid->data, &host_model->data);\n    if (!x86DataIsEmpty(&cpu_forbid->data)) {\n        virX86CpuIncompatible(N_(\"Host CPU provides forbidden features\"),\n                              &cpu_forbid->data);\n        goto cleanup;\n    }\n\n    /* first remove features that were inherited from the CPU model and were\n     * explicitly forced, disabled, or made optional\n     */\n    x86DataSubtract(&cpu_require->data, &cpu_force->data);\n    x86DataSubtract(&cpu_require->data, &cpu_optional->data);\n    x86DataSubtract(&cpu_require->data, &cpu_disable->data);\n    result = x86ModelCompare(host_model, cpu_require);\n    if (result == SUBSET || result == UNRELATED) {\n        x86DataSubtract(&cpu_require->data, &host_model->data);\n        virX86CpuIncompatible(N_(\"Host CPU does not provide required \"\n                                 \"features\"),\n                              &cpu_require->data);\n        goto cleanup;\n    }\n\n    ret = VIR_CPU_COMPARE_IDENTICAL;\n\n    if (!(diff = x86ModelCopy(host_model)))\n        goto error;\n\n    x86DataSubtract(&diff->data, &cpu_optional->data);\n    x86DataSubtract(&diff->data, &cpu_require->data);\n    x86DataSubtract(&diff->data, &cpu_disable->data);\n    x86DataSubtract(&diff->data, &cpu_force->data);\n\n    if (!x86DataIsEmpty(&diff->data))\n        ret = VIR_CPU_COMPARE_SUPERSET;\n\n    if (ret == VIR_CPU_COMPARE_SUPERSET\n        && cpu->type == VIR_CPU_TYPE_GUEST\n        && cpu->match == VIR_CPU_MATCH_STRICT) {\n        virX86CpuIncompatible(N_(\"Host CPU does not strictly match guest CPU: \"\n                                 \"Extra features\"),\n                              &diff->data);\n        goto cleanup;\n    }\n\n    if (guest) {\n        if (!(guest_model = x86ModelCopy(host_model)))\n            goto error;\n\n        if (cpu->vendor && host_model->vendor &&\n            virCPUx86DataAddItem(&guest_model->data,\n                                 &host_model->vendor->data) < 0)\n            goto error;\n\n        if (host_model->signatures &&\n            x86DataAddSignature(&guest_model->data, *host_model->signatures) < 0)\n            goto error;\n\n        if (cpu->type == VIR_CPU_TYPE_GUEST\n            && cpu->match == VIR_CPU_MATCH_EXACT)\n            x86DataSubtract(&guest_model->data, &diff->data);\n\n        if (x86DataAdd(&guest_model->data, &cpu_force->data))\n            goto error;\n\n        x86DataSubtract(&guest_model->data, &cpu_disable->data);\n\n        if (!(guestData = virCPUDataNew(arch)) ||\n            x86DataCopy(&guestData->data.x86, &guest_model->data) < 0)\n            goto error;\n\n        *guest = guestData;\n    }\n\n cleanup:\n    x86ModelFree(host_model);\n    x86ModelFree(diff);\n    x86ModelFree(cpu_force);\n    x86ModelFree(cpu_require);\n    x86ModelFree(cpu_optional);\n    x86ModelFree(cpu_disable);\n    x86ModelFree(cpu_forbid);\n    x86ModelFree(guest_model);\n\n    return ret;\n\n error:\n    virCPUx86DataFree(guestData);\n    ret = VIR_CPU_COMPARE_ERROR;\n    goto cleanup;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const virArch archs[] = { VIR_ARCH_I686, VIR_ARCH_X86_64 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataFree",
          "args": [
            "guestData"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "473-481",
          "snippet": "static void\nvirCPUx86DataFree(virCPUDataPtr data)\n{\n    if (!data)\n        return;\n\n    virCPUx86DataClear(&data->data.x86);\n    VIR_FREE(data);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataFree(virCPUDataPtr data)\n{\n    if (!data)\n        return;\n\n    virCPUx86DataClear(&data->data.x86);\n    VIR_FREE(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelFree",
          "args": [
            "guest_model"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1141-1151",
          "snippet": "static void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataCopy",
          "args": [
            "&guestData->data.x86",
            "&guest_model->data"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "484-497",
          "snippet": "static int\nx86DataCopy(virCPUx86Data *dst, const virCPUx86Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->items, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n    for (i = 0; i < src->len; i++)\n        dst->items[i] = src->items[i];\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DataCopy(virCPUx86Data *dst, const virCPUx86Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->items, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n    for (i = 0; i < src->len; i++)\n        dst->items[i] = src->items[i];\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDataNew",
          "args": [
            "arch"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDataNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "290-301",
          "snippet": "virCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataSubtract",
          "args": [
            "&guest_model->data",
            "&cpu_disable->data"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "538-551",
          "snippet": "static void\nx86DataSubtract(virCPUx86Data *data1,\n                const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        virCPUx86DataItemClearBits(item1, item2);\n    }\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86DataSubtract(virCPUx86Data *data1,\n                const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        virCPUx86DataItemClearBits(item1, item2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataAdd",
          "args": [
            "&guest_model->data",
            "&cpu_force->data"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataAddSignature",
          "args": [
            "&guest_model->data",
            "*host_model->signatures"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataAddSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "757-764",
          "snippet": "static int\nx86DataAddSignature(virCPUx86Data *data,\n                    uint32_t signature)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1, .eax = signature);\n\n    return virCPUx86DataAddItem(data, &leaf1);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DataAddSignature(virCPUx86Data *data,\n                    uint32_t signature)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1, .eax = signature);\n\n    return virCPUx86DataAddItem(data, &leaf1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataAddItem",
          "args": [
            "&guest_model->data",
            "&host_model->vendor->data"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddItem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "500-518",
          "snippet": "static int\nvirCPUx86DataAddItem(virCPUx86Data *data,\n                     const virCPUx86DataItem *item)\n{\n    virCPUx86DataItemPtr existing;\n\n    if ((existing = virCPUx86DataGet(data, item))) {\n        virCPUx86DataItemSetBits(existing, item);\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(data->items, data->len,\n                                    *((virCPUx86DataItemPtr)item)) < 0)\n            return -1;\n\n        qsort(data->items, data->len,\n              sizeof(virCPUx86DataItem), virCPUx86DataSorter);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddItem(virCPUx86Data *data,\n                     const virCPUx86DataItem *item)\n{\n    virCPUx86DataItemPtr existing;\n\n    if ((existing = virCPUx86DataGet(data, item))) {\n        virCPUx86DataItemSetBits(existing, item);\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(data->items, data->len,\n                                    *((virCPUx86DataItemPtr)item)) < 0)\n            return -1;\n\n        qsort(data->items, data->len,\n              sizeof(virCPUx86DataItem), virCPUx86DataSorter);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelCopy",
          "args": [
            "host_model"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1174-1193",
          "snippet": "static virCPUx86ModelPtr\nx86ModelCopy(virCPUx86ModelPtr model)\n{\n    virCPUx86ModelPtr copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        return NULL;\n\n    copy->name = g_strdup(model->name);\n\n    if (x86ModelCopySignatures(copy, model) < 0 ||\n        x86DataCopy(&copy->data, &model->data) < 0) {\n        x86ModelFree(copy);\n        return NULL;\n    }\n\n    copy->vendor = model->vendor;\n\n    return copy;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelCopy(virCPUx86ModelPtr model)\n{\n    virCPUx86ModelPtr copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        return NULL;\n\n    copy->name = g_strdup(model->name);\n\n    if (x86ModelCopySignatures(copy, model) < 0 ||\n        x86DataCopy(&copy->data, &model->data) < 0) {\n        x86ModelFree(copy);\n        return NULL;\n    }\n\n    copy->vendor = model->vendor;\n\n    return copy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virX86CpuIncompatible",
          "args": [
            "N_(\"Host CPU does not strictly match guest CPU: \"\n                                 \"Extra features\")",
            "&diff->data"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_",
          "args": [
            "\"Host CPU does not strictly match guest CPU: \"\n                                 \"Extra features\""
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "ESX_VI__TEMPLATE__ENUMERATION__DESERIALIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "886-906",
          "snippet": "ESX_VI__TEMPLATE__ENUMERATION__SERIALIZE(Boolean)\n\n/* esxVI_Boolean_Deserialize */\nESX_VI__TEMPLATE__ENUMERATION__DESERIALIZE(Boolean)\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * XSD: AnyType\n */\n\n/* esxVI_AnyType_Alloc */\nESX_VI__TEMPLATE__ALLOC(AnyType)\n\n/* esxVI_AnyType_Free */\nESX_VI__TEMPLATE__FREE(AnyType,\n{\n    xmlFreeNode(item->node);\n    VIR_FREE(item->other);\n    VIR_FREE(item->value);\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__ENUMERATION__SERIALIZE(Boolean)\n\n/* esxVI_Boolean_Deserialize */\nESX_VI__TEMPLATE__ENUMERATION__DESERIALIZE(Boolean)\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * XSD: AnyType\n */\n\n/* esxVI_AnyType_Alloc */\nESX_VI__TEMPLATE__ALLOC(AnyType)\n\n/* esxVI_AnyType_Free */\nESX_VI__TEMPLATE__FREE(AnyType,\n{\n    xmlFreeNode(item->node);\n    VIR_FREE(item->other);\n    VIR_FREE(item->value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataIsEmpty",
          "args": [
            "&diff->data"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "573-580",
          "snippet": "static bool\nx86DataIsEmpty(virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter;\n\n    virCPUx86DataIteratorInit(&iter, data);\n    return !virCPUx86DataNext(&iter);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nx86DataIsEmpty(virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter;\n\n    virCPUx86DataIteratorInit(&iter, data);\n    return !virCPUx86DataNext(&iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virX86CpuIncompatible",
          "args": [
            "N_(\"Host CPU does not provide required \"\n                                 \"features\")",
            "&cpu_require->data"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86ModelCompare",
          "args": [
            "host_model",
            "cpu_require"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelCompare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1302-1347",
          "snippet": "static virCPUx86CompareResult\nx86ModelCompare(virCPUx86ModelPtr model1,\n                virCPUx86ModelPtr model2)\n{\n    virCPUx86CompareResult result = EQUAL;\n    virCPUx86DataIterator iter1;\n    virCPUx86DataIterator iter2;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter1, &model1->data);\n    virCPUx86DataIteratorInit(&iter2, &model2->data);\n    while ((item1 = virCPUx86DataNext(&iter1))) {\n        virCPUx86CompareResult match = SUPERSET;\n\n        if ((item2 = virCPUx86DataGet(&model2->data, item1))) {\n            if (virCPUx86DataItemMatch(item1, item2))\n                continue;\n            else if (!virCPUx86DataItemMatchMasked(item1, item2))\n                match = SUBSET;\n        }\n\n        if (result == EQUAL)\n            result = match;\n        else if (result != match)\n            return UNRELATED;\n    }\n\n    while ((item2 = virCPUx86DataNext(&iter2))) {\n        virCPUx86CompareResult match = SUBSET;\n\n        if ((item1 = virCPUx86DataGet(&model1->data, item2))) {\n            if (virCPUx86DataItemMatch(item2, item1))\n                continue;\n            else if (!virCPUx86DataItemMatchMasked(item2, item1))\n                match = SUPERSET;\n        }\n\n        if (result == EQUAL)\n            result = match;\n        else if (result != match)\n            return UNRELATED;\n    }\n\n    return result;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86CompareResult\nx86ModelCompare(virCPUx86ModelPtr model1,\n                virCPUx86ModelPtr model2)\n{\n    virCPUx86CompareResult result = EQUAL;\n    virCPUx86DataIterator iter1;\n    virCPUx86DataIterator iter2;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter1, &model1->data);\n    virCPUx86DataIteratorInit(&iter2, &model2->data);\n    while ((item1 = virCPUx86DataNext(&iter1))) {\n        virCPUx86CompareResult match = SUPERSET;\n\n        if ((item2 = virCPUx86DataGet(&model2->data, item1))) {\n            if (virCPUx86DataItemMatch(item1, item2))\n                continue;\n            else if (!virCPUx86DataItemMatchMasked(item1, item2))\n                match = SUBSET;\n        }\n\n        if (result == EQUAL)\n            result = match;\n        else if (result != match)\n            return UNRELATED;\n    }\n\n    while ((item2 = virCPUx86DataNext(&iter2))) {\n        virCPUx86CompareResult match = SUBSET;\n\n        if ((item1 = virCPUx86DataGet(&model1->data, item2))) {\n            if (virCPUx86DataItemMatch(item2, item1))\n                continue;\n            else if (!virCPUx86DataItemMatchMasked(item2, item1))\n                match = SUPERSET;\n        }\n\n        if (result == EQUAL)\n            result = match;\n        else if (result != match)\n            return UNRELATED;\n    }\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virX86CpuIncompatible",
          "args": [
            "N_(\"Host CPU provides forbidden features\")",
            "&cpu_forbid->data"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86DataIntersect",
          "args": [
            "&cpu_forbid->data",
            "&host_model->data"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataIntersect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "554-570",
          "snippet": "static void\nx86DataIntersect(virCPUx86Data *data1,\n                 const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        if (item2)\n            virCPUx86DataItemAndBits(item1, item2);\n        else\n            virCPUx86DataItemClearBits(item1, item1);\n    }\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86DataIntersect(virCPUx86Data *data1,\n                 const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        if (item2)\n            virCPUx86DataItemAndBits(item1, item2);\n        else\n            virCPUx86DataItemClearBits(item1, item1);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelFromCPU",
          "args": [
            "cpu",
            "map",
            "VIR_CPU_FEATURE_FORBID"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFromCPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1220-1299",
          "snippet": "static virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86GetMap",
          "args": [],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86GetMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1605-1612",
          "snippet": "static virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86MapPtr cpuMap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\n\nstatic virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "_(\"host CPU vendor does not match required \"\n                                         \"CPU vendor %s\")",
            "cpu->vendor"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"host CPU vendor does not match required CPU vendor %s\"",
            "cpu->vendor"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "cpu->vendor",
            "host->vendor"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "cpu->arch"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"CPU arch %s does not match host arch\"",
            "virArchToString(cpu->arch)"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "archs"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic const virArch archs[] = { VIR_ARCH_I686, VIR_ARCH_X86_64 };\n\nstatic virCPUCompareResult\nx86Compute(virCPUDefPtr host,\n           virCPUDefPtr cpu,\n           virCPUDataPtr *guest,\n           char **message)\n{\n    virCPUx86MapPtr map = NULL;\n    virCPUx86ModelPtr host_model = NULL;\n    virCPUx86ModelPtr cpu_force = NULL;\n    virCPUx86ModelPtr cpu_require = NULL;\n    virCPUx86ModelPtr cpu_optional = NULL;\n    virCPUx86ModelPtr cpu_disable = NULL;\n    virCPUx86ModelPtr cpu_forbid = NULL;\n    virCPUx86ModelPtr diff = NULL;\n    virCPUx86ModelPtr guest_model = NULL;\n    virCPUDataPtr guestData = NULL;\n    virCPUCompareResult ret;\n    virCPUx86CompareResult result;\n    virArch arch;\n    size_t i;\n\n    if (cpu->arch != VIR_ARCH_NONE) {\n        bool found = false;\n\n        for (i = 0; i < G_N_ELEMENTS(archs); i++) {\n            if (archs[i] == cpu->arch) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            VIR_DEBUG(\"CPU arch %s does not match host arch\",\n                      virArchToString(cpu->arch));\n            if (message) {\n                *message = g_strdup_printf(_(\"CPU arch %s does not match host arch\"),\n                                           virArchToString(cpu->arch));\n            }\n            return VIR_CPU_COMPARE_INCOMPATIBLE;\n        }\n        arch = cpu->arch;\n    } else {\n        arch = host->arch;\n    }\n\n    if (cpu->vendor &&\n        (!host->vendor || STRNEQ(cpu->vendor, host->vendor))) {\n        VIR_DEBUG(\"host CPU vendor does not match required CPU vendor %s\",\n                  cpu->vendor);\n        if (message) {\n            *message = g_strdup_printf(_(\"host CPU vendor does not match required \"\n                                         \"CPU vendor %s\"),\n                                       cpu->vendor);\n        }\n\n        return VIR_CPU_COMPARE_INCOMPATIBLE;\n    }\n\n    if (!(map = virCPUx86GetMap()) ||\n        !(host_model = x86ModelFromCPU(host, map, -1)) ||\n        !(cpu_force = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_FORCE)) ||\n        !(cpu_require = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_REQUIRE)) ||\n        !(cpu_optional = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_OPTIONAL)) ||\n        !(cpu_disable = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_DISABLE)) ||\n        !(cpu_forbid = x86ModelFromCPU(cpu, map, VIR_CPU_FEATURE_FORBID)))\n        goto error;\n\n    x86DataIntersect(&cpu_forbid->data, &host_model->data);\n    if (!x86DataIsEmpty(&cpu_forbid->data)) {\n        virX86CpuIncompatible(N_(\"Host CPU provides forbidden features\"),\n                              &cpu_forbid->data);\n        goto cleanup;\n    }\n\n    /* first remove features that were inherited from the CPU model and were\n     * explicitly forced, disabled, or made optional\n     */\n    x86DataSubtract(&cpu_require->data, &cpu_force->data);\n    x86DataSubtract(&cpu_require->data, &cpu_optional->data);\n    x86DataSubtract(&cpu_require->data, &cpu_disable->data);\n    result = x86ModelCompare(host_model, cpu_require);\n    if (result == SUBSET || result == UNRELATED) {\n        x86DataSubtract(&cpu_require->data, &host_model->data);\n        virX86CpuIncompatible(N_(\"Host CPU does not provide required \"\n                                 \"features\"),\n                              &cpu_require->data);\n        goto cleanup;\n    }\n\n    ret = VIR_CPU_COMPARE_IDENTICAL;\n\n    if (!(diff = x86ModelCopy(host_model)))\n        goto error;\n\n    x86DataSubtract(&diff->data, &cpu_optional->data);\n    x86DataSubtract(&diff->data, &cpu_require->data);\n    x86DataSubtract(&diff->data, &cpu_disable->data);\n    x86DataSubtract(&diff->data, &cpu_force->data);\n\n    if (!x86DataIsEmpty(&diff->data))\n        ret = VIR_CPU_COMPARE_SUPERSET;\n\n    if (ret == VIR_CPU_COMPARE_SUPERSET\n        && cpu->type == VIR_CPU_TYPE_GUEST\n        && cpu->match == VIR_CPU_MATCH_STRICT) {\n        virX86CpuIncompatible(N_(\"Host CPU does not strictly match guest CPU: \"\n                                 \"Extra features\"),\n                              &diff->data);\n        goto cleanup;\n    }\n\n    if (guest) {\n        if (!(guest_model = x86ModelCopy(host_model)))\n            goto error;\n\n        if (cpu->vendor && host_model->vendor &&\n            virCPUx86DataAddItem(&guest_model->data,\n                                 &host_model->vendor->data) < 0)\n            goto error;\n\n        if (host_model->signatures &&\n            x86DataAddSignature(&guest_model->data, *host_model->signatures) < 0)\n            goto error;\n\n        if (cpu->type == VIR_CPU_TYPE_GUEST\n            && cpu->match == VIR_CPU_MATCH_EXACT)\n            x86DataSubtract(&guest_model->data, &diff->data);\n\n        if (x86DataAdd(&guest_model->data, &cpu_force->data))\n            goto error;\n\n        x86DataSubtract(&guest_model->data, &cpu_disable->data);\n\n        if (!(guestData = virCPUDataNew(arch)) ||\n            x86DataCopy(&guestData->data.x86, &guest_model->data) < 0)\n            goto error;\n\n        *guest = guestData;\n    }\n\n cleanup:\n    x86ModelFree(host_model);\n    x86ModelFree(diff);\n    x86ModelFree(cpu_force);\n    x86ModelFree(cpu_require);\n    x86ModelFree(cpu_optional);\n    x86ModelFree(cpu_disable);\n    x86ModelFree(cpu_forbid);\n    x86ModelFree(guest_model);\n\n    return ret;\n\n error:\n    virCPUx86DataFree(guestData);\n    ret = VIR_CPU_COMPARE_ERROR;\n    goto cleanup;\n}"
  },
  {
    "function_name": "virCPUx86DataParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1658-1705",
    "snippet": "static virCPUDataPtr\nvirCPUx86DataParse(xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr *nodes = NULL;\n    virCPUDataPtr cpuData = NULL;\n    virCPUx86DataItem item;\n    size_t i;\n    int n;\n\n    n = virXPathNodeSet(\"/cpudata/cpuid|/cpudata/msr\", ctxt, &nodes);\n    if (n <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no x86 CPU data found\"));\n        goto error;\n    }\n\n    if (!(cpuData = virCPUDataNew(VIR_ARCH_X86_64)))\n        goto error;\n\n    for (i = 0; i < n; i++) {\n        ctxt->node = nodes[i];\n        if (virXMLNodeNameEqual(nodes[i], \"cpuid\")) {\n            if (x86ParseCPUID(ctxt, &item) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"failed to parse cpuid[%zu]\"), i);\n                goto error;\n            }\n        } else {\n            if (x86ParseMSR(ctxt, &item) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"failed to parse msr[%zu]\"), i);\n                goto error;\n            }\n        }\n\n        if (virCPUx86DataAdd(cpuData, &item) < 0)\n            goto error;\n    }\n\n cleanup:\n    VIR_FREE(nodes);\n    return cpuData;\n\n error:\n    virCPUx86DataFree(cpuData);\n    cpuData = NULL;\n    goto cleanup;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataFree",
          "args": [
            "cpuData"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "473-481",
          "snippet": "static void\nvirCPUx86DataFree(virCPUDataPtr data)\n{\n    if (!data)\n        return;\n\n    virCPUx86DataClear(&data->data.x86);\n    VIR_FREE(data);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataFree(virCPUDataPtr data)\n{\n    if (!data)\n        return;\n\n    virCPUx86DataClear(&data->data.x86);\n    VIR_FREE(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUx86DataAdd",
          "args": [
            "cpuData",
            "&item"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to parse msr[%zu]\")",
            "i"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to parse msr[%zu]\""
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ParseMSR",
          "args": [
            "ctxt",
            "&item"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "x86ParseMSR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1021-1043",
          "snippet": "static int\nx86ParseMSR(xmlXPathContextPtr ctxt,\n            virCPUx86DataItemPtr item)\n{\n    virCPUx86MSRPtr msr;\n    unsigned long index;\n    unsigned long eax;\n    unsigned long edx;\n\n    memset(item, 0, sizeof(*item));\n\n    if (virXPathULongHex(\"string(@index)\", ctxt, &index) < 0 ||\n        virXPathULongHex(\"string(@eax)\", ctxt, &eax) < 0 ||\n        virXPathULongHex(\"string(@edx)\", ctxt, &edx) < 0)\n        return -1;\n\n    item->type = VIR_CPU_X86_DATA_MSR;\n    msr = &item->data.msr;\n    msr->index = index;\n    msr->eax = eax;\n    msr->edx = edx;\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ParseMSR(xmlXPathContextPtr ctxt,\n            virCPUx86DataItemPtr item)\n{\n    virCPUx86MSRPtr msr;\n    unsigned long index;\n    unsigned long eax;\n    unsigned long edx;\n\n    memset(item, 0, sizeof(*item));\n\n    if (virXPathULongHex(\"string(@index)\", ctxt, &index) < 0 ||\n        virXPathULongHex(\"string(@eax)\", ctxt, &eax) < 0 ||\n        virXPathULongHex(\"string(@edx)\", ctxt, &edx) < 0)\n        return -1;\n\n    item->type = VIR_CPU_X86_DATA_MSR;\n    msr = &item->data.msr;\n    msr->index = index;\n    msr->eax = eax;\n    msr->edx = edx;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to parse cpuid[%zu]\")",
            "i"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86ParseCPUID",
          "args": [
            "ctxt",
            "&item"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "x86ParseCPUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "985-1018",
          "snippet": "static int\nx86ParseCPUID(xmlXPathContextPtr ctxt,\n              virCPUx86DataItemPtr item)\n{\n    virCPUx86CPUIDPtr cpuid;\n    unsigned long eax_in, ecx_in;\n    unsigned long eax, ebx, ecx, edx;\n    int ret_eax_in, ret_ecx_in, ret_eax, ret_ebx, ret_ecx, ret_edx;\n\n    memset(item, 0, sizeof(*item));\n\n    eax_in = ecx_in = 0;\n    eax = ebx = ecx = edx = 0;\n    ret_eax_in = virXPathULongHex(\"string(@eax_in)\", ctxt, &eax_in);\n    ret_ecx_in = virXPathULongHex(\"string(@ecx_in)\", ctxt, &ecx_in);\n    ret_eax = virXPathULongHex(\"string(@eax)\", ctxt, &eax);\n    ret_ebx = virXPathULongHex(\"string(@ebx)\", ctxt, &ebx);\n    ret_ecx = virXPathULongHex(\"string(@ecx)\", ctxt, &ecx);\n    ret_edx = virXPathULongHex(\"string(@edx)\", ctxt, &edx);\n\n    if (ret_eax_in < 0 || ret_ecx_in == -2 ||\n        ret_eax == -2 || ret_ebx == -2 || ret_ecx == -2 || ret_edx == -2)\n        return -1;\n\n    item->type = VIR_CPU_X86_DATA_CPUID;\n    cpuid = &item->data.cpuid;\n    cpuid->eax_in = eax_in;\n    cpuid->ecx_in = ecx_in;\n    cpuid->eax = eax;\n    cpuid->ebx = ebx;\n    cpuid->ecx = ecx;\n    cpuid->edx = edx;\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ParseCPUID(xmlXPathContextPtr ctxt,\n              virCPUx86DataItemPtr item)\n{\n    virCPUx86CPUIDPtr cpuid;\n    unsigned long eax_in, ecx_in;\n    unsigned long eax, ebx, ecx, edx;\n    int ret_eax_in, ret_ecx_in, ret_eax, ret_ebx, ret_ecx, ret_edx;\n\n    memset(item, 0, sizeof(*item));\n\n    eax_in = ecx_in = 0;\n    eax = ebx = ecx = edx = 0;\n    ret_eax_in = virXPathULongHex(\"string(@eax_in)\", ctxt, &eax_in);\n    ret_ecx_in = virXPathULongHex(\"string(@ecx_in)\", ctxt, &ecx_in);\n    ret_eax = virXPathULongHex(\"string(@eax)\", ctxt, &eax);\n    ret_ebx = virXPathULongHex(\"string(@ebx)\", ctxt, &ebx);\n    ret_ecx = virXPathULongHex(\"string(@ecx)\", ctxt, &ecx);\n    ret_edx = virXPathULongHex(\"string(@edx)\", ctxt, &edx);\n\n    if (ret_eax_in < 0 || ret_ecx_in == -2 ||\n        ret_eax == -2 || ret_ebx == -2 || ret_ecx == -2 || ret_edx == -2)\n        return -1;\n\n    item->type = VIR_CPU_X86_DATA_CPUID;\n    cpuid = &item->data.cpuid;\n    cpuid->eax_in = eax_in;\n    cpuid->ecx_in = ecx_in;\n    cpuid->eax = eax;\n    cpuid->ebx = ebx;\n    cpuid->ecx = ecx;\n    cpuid->edx = edx;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLNodeNameEqual",
          "args": [
            "nodes[i]",
            "\"cpuid\""
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeNameEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1013-1018",
          "snippet": "bool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDataNew",
          "args": [
            "VIR_ARCH_X86_64"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDataNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "290-301",
          "snippet": "virCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no x86 CPU data found\")"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"/cpudata/cpuid|/cpudata/msr\"",
            "ctxt",
            "&nodes"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUDataPtr\nvirCPUx86DataParse(xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr *nodes = NULL;\n    virCPUDataPtr cpuData = NULL;\n    virCPUx86DataItem item;\n    size_t i;\n    int n;\n\n    n = virXPathNodeSet(\"/cpudata/cpuid|/cpudata/msr\", ctxt, &nodes);\n    if (n <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no x86 CPU data found\"));\n        goto error;\n    }\n\n    if (!(cpuData = virCPUDataNew(VIR_ARCH_X86_64)))\n        goto error;\n\n    for (i = 0; i < n; i++) {\n        ctxt->node = nodes[i];\n        if (virXMLNodeNameEqual(nodes[i], \"cpuid\")) {\n            if (x86ParseCPUID(ctxt, &item) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"failed to parse cpuid[%zu]\"), i);\n                goto error;\n            }\n        } else {\n            if (x86ParseMSR(ctxt, &item) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"failed to parse msr[%zu]\"), i);\n                goto error;\n            }\n        }\n\n        if (virCPUx86DataAdd(cpuData, &item) < 0)\n            goto error;\n    }\n\n cleanup:\n    VIR_FREE(nodes);\n    return cpuData;\n\n error:\n    virCPUx86DataFree(cpuData);\n    cpuData = NULL;\n    goto cleanup;\n}"
  },
  {
    "function_name": "virCPUx86DataFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1615-1655",
    "snippet": "static char *\nvirCPUx86DataFormat(const virCPUData *data)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCPUx86DataIteratorInit(&iter, &data->data.x86);\n\n    virBufferAddLit(&buf, \"<cpudata arch='x86'>\\n\");\n    while ((item = virCPUx86DataNext(&iter))) {\n        virCPUx86CPUIDPtr cpuid;\n        virCPUx86MSRPtr msr;\n\n        switch (item->type) {\n        case VIR_CPU_X86_DATA_CPUID:\n            cpuid = &item->data.cpuid;\n            virBufferAsprintf(&buf,\n                              \"  <cpuid eax_in='0x%08x' ecx_in='0x%08x'\"\n                              \" eax='0x%08x' ebx='0x%08x'\"\n                              \" ecx='0x%08x' edx='0x%08x'/>\\n\",\n                              cpuid->eax_in, cpuid->ecx_in,\n                              cpuid->eax, cpuid->ebx, cpuid->ecx, cpuid->edx);\n            break;\n\n        case VIR_CPU_X86_DATA_MSR:\n            msr = &item->data.msr;\n            virBufferAsprintf(&buf,\n                              \"  <msr index='0x%x' eax='0x%08x' edx='0x%08x'/>\\n\",\n                              msr->index, msr->eax, msr->edx);\n            break;\n\n        case VIR_CPU_X86_DATA_NONE:\n        default:\n            break;\n        }\n    }\n    virBufferAddLit(&buf, \"</cpudata>\\n\");\n\n    return virBufferContentAndReset(&buf);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"</cpudata>\\n\""
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"  <msr index='0x%x' eax='0x%08x' edx='0x%08x'/>\\n\"",
            "msr->index",
            "msr->eax",
            "msr->edx"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataNext",
          "args": [
            "&iter"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "428-445",
          "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"<cpudata arch='x86'>\\n\""
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUx86DataIteratorInit",
          "args": [
            "&iter",
            "&data->data.x86"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "169-175",
          "snippet": "static void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic char *\nvirCPUx86DataFormat(const virCPUData *data)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCPUx86DataIteratorInit(&iter, &data->data.x86);\n\n    virBufferAddLit(&buf, \"<cpudata arch='x86'>\\n\");\n    while ((item = virCPUx86DataNext(&iter))) {\n        virCPUx86CPUIDPtr cpuid;\n        virCPUx86MSRPtr msr;\n\n        switch (item->type) {\n        case VIR_CPU_X86_DATA_CPUID:\n            cpuid = &item->data.cpuid;\n            virBufferAsprintf(&buf,\n                              \"  <cpuid eax_in='0x%08x' ecx_in='0x%08x'\"\n                              \" eax='0x%08x' ebx='0x%08x'\"\n                              \" ecx='0x%08x' edx='0x%08x'/>\\n\",\n                              cpuid->eax_in, cpuid->ecx_in,\n                              cpuid->eax, cpuid->ebx, cpuid->ecx, cpuid->edx);\n            break;\n\n        case VIR_CPU_X86_DATA_MSR:\n            msr = &item->data.msr;\n            virBufferAsprintf(&buf,\n                              \"  <msr index='0x%x' eax='0x%08x' edx='0x%08x'/>\\n\",\n                              msr->index, msr->eax, msr->edx);\n            break;\n\n        case VIR_CPU_X86_DATA_NONE:\n        default:\n            break;\n        }\n    }\n    virBufferAddLit(&buf, \"</cpudata>\\n\");\n\n    return virBufferContentAndReset(&buf);\n}"
  },
  {
    "function_name": "virCPUx86GetMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1605-1612",
    "snippet": "static virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virCPUx86MapPtr cpuMap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DriverInitialize",
          "args": [],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\n\nstatic virCPUx86MapPtr\nvirCPUx86GetMap(void)\n{\n    if (virCPUx86DriverInitialize() < 0)\n        return NULL;\n\n    return cpuMap;\n}"
  },
  {
    "function_name": "virCPUx86DriverOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1595-1602",
    "snippet": "int\nvirCPUx86DriverOnceInit(void)\n{\n    if (!(cpuMap = virCPUx86LoadMap()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virCPUx86MapPtr cpuMap;",
      "int virCPUx86DriverOnceInit(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86LoadMap",
          "args": [],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86LoadMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1576-1592",
          "snippet": "static virCPUx86MapPtr\nvirCPUx86LoadMap(void)\n{\n    virCPUx86MapPtr map;\n\n    if (VIR_ALLOC(map) < 0)\n        return NULL;\n\n    if (cpuMapLoad(\"x86\", x86VendorParse, x86FeatureParse, x86ModelParse, map) < 0)\n        goto error;\n\n    return map;\n\n error:\n    x86MapFree(map);\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr\nvirCPUx86LoadMap(void)\n{\n    virCPUx86MapPtr map;\n\n    if (VIR_ALLOC(map) < 0)\n        return NULL;\n\n    if (cpuMapLoad(\"x86\", x86VendorParse, x86FeatureParse, x86ModelParse, map) < 0)\n        goto error;\n\n    return map;\n\n error:\n    x86MapFree(map);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr cpuMap;\nint virCPUx86DriverOnceInit(void);\n\nint\nvirCPUx86DriverOnceInit(void)\n{\n    if (!(cpuMap = virCPUx86LoadMap()))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virCPUx86LoadMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1576-1592",
    "snippet": "static virCPUx86MapPtr\nvirCPUx86LoadMap(void)\n{\n    virCPUx86MapPtr map;\n\n    if (VIR_ALLOC(map) < 0)\n        return NULL;\n\n    if (cpuMapLoad(\"x86\", x86VendorParse, x86FeatureParse, x86ModelParse, map) < 0)\n        goto error;\n\n    return map;\n\n error:\n    x86MapFree(map);\n    return NULL;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86MapFree",
          "args": [
            "map"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "x86MapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1547-1573",
          "snippet": "static void\nx86MapFree(virCPUx86MapPtr map)\n{\n    size_t i;\n\n    if (!map)\n        return;\n\n    for (i = 0; i < map->nfeatures; i++)\n        x86FeatureFree(map->features[i]);\n    VIR_FREE(map->features);\n\n    for (i = 0; i < map->nmodels; i++)\n        x86ModelFree(map->models[i]);\n    VIR_FREE(map->models);\n\n    for (i = 0; i < map->nvendors; i++)\n        x86VendorFree(map->vendors[i]);\n    VIR_FREE(map->vendors);\n\n    /* migrate_blockers only points to the features from map->features list,\n     * which were already freed above\n     */\n    VIR_FREE(map->migrate_blockers);\n\n    VIR_FREE(map);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86MapFree(virCPUx86MapPtr map)\n{\n    size_t i;\n\n    if (!map)\n        return;\n\n    for (i = 0; i < map->nfeatures; i++)\n        x86FeatureFree(map->features[i]);\n    VIR_FREE(map->features);\n\n    for (i = 0; i < map->nmodels; i++)\n        x86ModelFree(map->models[i]);\n    VIR_FREE(map->models);\n\n    for (i = 0; i < map->nvendors; i++)\n        x86VendorFree(map->vendors[i]);\n    VIR_FREE(map->vendors);\n\n    /* migrate_blockers only points to the features from map->features list,\n     * which were already freed above\n     */\n    VIR_FREE(map->migrate_blockers);\n\n    VIR_FREE(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuMapLoad",
          "args": [
            "\"x86\"",
            "x86VendorParse",
            "x86FeatureParse",
            "x86ModelParse",
            "map"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "cpuMapLoad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_map.c",
          "lines": "174-236",
          "snippet": "int cpuMapLoad(const char *arch,\n               cpuMapLoadCallback vendorCB,\n               cpuMapLoadCallback featureCB,\n               cpuMapLoadCallback modelCB,\n               void *data)\n{\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xpath = NULL;\n    int ret = -1;\n    char *mapfile;\n\n    if (!(mapfile = virFileFindResource(\"index.xml\",\n                                        abs_top_srcdir \"/src/cpu_map\",\n                                        PKGDATADIR \"/cpu_map\")))\n        return -1;\n\n    VIR_DEBUG(\"Loading '%s' CPU map from %s\", NULLSTR(arch), mapfile);\n\n    if (arch == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"undefined hardware architecture\"));\n        goto cleanup;\n    }\n\n    if (!(xml = virXMLParseFileCtxt(mapfile, &ctxt)))\n        goto cleanup;\n\n    virBufferAsprintf(&buf, \"./arch[@name='%s']\", arch);\n\n    xpath = virBufferContentAndReset(&buf);\n\n    ctxt->node = xmlDocGetRootElement(xml);\n\n    if ((ctxt->node = virXPathNode(xpath, ctxt)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot find CPU map for %s architecture\"), arch);\n        goto cleanup;\n    }\n\n    if (loadData(mapfile, ctxt, \"vendor\", vendorCB, data) < 0)\n        goto cleanup;\n\n    if (loadData(mapfile, ctxt, \"feature\", featureCB, data) < 0)\n        goto cleanup;\n\n    if (loadData(mapfile, ctxt, \"model\", modelCB, data) < 0)\n        goto cleanup;\n\n    if (loadIncludes(ctxt, vendorCB, featureCB, modelCB, data) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(xml);\n    VIR_FREE(xpath);\n    VIR_FREE(mapfile);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint cpuMapLoad(const char *arch,\n               cpuMapLoadCallback vendorCB,\n               cpuMapLoadCallback featureCB,\n               cpuMapLoadCallback modelCB,\n               void *data)\n{\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xpath = NULL;\n    int ret = -1;\n    char *mapfile;\n\n    if (!(mapfile = virFileFindResource(\"index.xml\",\n                                        abs_top_srcdir \"/src/cpu_map\",\n                                        PKGDATADIR \"/cpu_map\")))\n        return -1;\n\n    VIR_DEBUG(\"Loading '%s' CPU map from %s\", NULLSTR(arch), mapfile);\n\n    if (arch == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"undefined hardware architecture\"));\n        goto cleanup;\n    }\n\n    if (!(xml = virXMLParseFileCtxt(mapfile, &ctxt)))\n        goto cleanup;\n\n    virBufferAsprintf(&buf, \"./arch[@name='%s']\", arch);\n\n    xpath = virBufferContentAndReset(&buf);\n\n    ctxt->node = xmlDocGetRootElement(xml);\n\n    if ((ctxt->node = virXPathNode(xpath, ctxt)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot find CPU map for %s architecture\"), arch);\n        goto cleanup;\n    }\n\n    if (loadData(mapfile, ctxt, \"vendor\", vendorCB, data) < 0)\n        goto cleanup;\n\n    if (loadData(mapfile, ctxt, \"feature\", featureCB, data) < 0)\n        goto cleanup;\n\n    if (loadData(mapfile, ctxt, \"model\", modelCB, data) < 0)\n        goto cleanup;\n\n    if (loadIncludes(ctxt, vendorCB, featureCB, modelCB, data) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(xml);\n    VIR_FREE(xpath);\n    VIR_FREE(mapfile);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "map"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86MapPtr\nvirCPUx86LoadMap(void)\n{\n    virCPUx86MapPtr map;\n\n    if (VIR_ALLOC(map) < 0)\n        return NULL;\n\n    if (cpuMapLoad(\"x86\", x86VendorParse, x86FeatureParse, x86ModelParse, map) < 0)\n        goto error;\n\n    return map;\n\n error:\n    x86MapFree(map);\n    return NULL;\n}"
  },
  {
    "function_name": "x86MapFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1547-1573",
    "snippet": "static void\nx86MapFree(virCPUx86MapPtr map)\n{\n    size_t i;\n\n    if (!map)\n        return;\n\n    for (i = 0; i < map->nfeatures; i++)\n        x86FeatureFree(map->features[i]);\n    VIR_FREE(map->features);\n\n    for (i = 0; i < map->nmodels; i++)\n        x86ModelFree(map->models[i]);\n    VIR_FREE(map->models);\n\n    for (i = 0; i < map->nvendors; i++)\n        x86VendorFree(map->vendors[i]);\n    VIR_FREE(map->vendors);\n\n    /* migrate_blockers only points to the features from map->features list,\n     * which were already freed above\n     */\n    VIR_FREE(map->migrate_blockers);\n\n    VIR_FREE(map);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "map"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "map->migrate_blockers"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "map->vendors"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86VendorFree",
          "args": [
            "map->vendors[i]"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "x86VendorFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "827-835",
          "snippet": "static void\nx86VendorFree(virCPUx86VendorPtr vendor)\n{\n    if (!vendor)\n        return;\n\n    VIR_FREE(vendor->name);\n    VIR_FREE(vendor);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86VendorFree(virCPUx86VendorPtr vendor)\n{\n    if (!vendor)\n        return;\n\n    VIR_FREE(vendor->name);\n    VIR_FREE(vendor);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "map->models"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86ModelFree",
          "args": [
            "map->models[i]"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1141-1151",
          "snippet": "static void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "map->features"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86FeatureFree",
          "args": [
            "map->features[i]"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "909-918",
          "snippet": "static void\nx86FeatureFree(virCPUx86FeaturePtr feature)\n{\n    if (!feature)\n        return;\n\n    VIR_FREE(feature->name);\n    virCPUx86DataClear(&feature->data);\n    VIR_FREE(feature);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86FeatureFree(virCPUx86FeaturePtr feature)\n{\n    if (!feature)\n        return;\n\n    VIR_FREE(feature->name);\n    virCPUx86DataClear(&feature->data);\n    VIR_FREE(feature);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86MapFree(virCPUx86MapPtr map)\n{\n    size_t i;\n\n    if (!map)\n        return;\n\n    for (i = 0; i < map->nfeatures; i++)\n        x86FeatureFree(map->features[i]);\n    VIR_FREE(map->features);\n\n    for (i = 0; i < map->nmodels; i++)\n        x86ModelFree(map->models[i]);\n    VIR_FREE(map->models);\n\n    for (i = 0; i < map->nvendors; i++)\n        x86VendorFree(map->vendors[i]);\n    VIR_FREE(map->vendors);\n\n    /* migrate_blockers only points to the features from map->features list,\n     * which were already freed above\n     */\n    VIR_FREE(map->migrate_blockers);\n\n    VIR_FREE(map);\n}"
  },
  {
    "function_name": "x86ModelParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1504-1544",
    "snippet": "static int\nx86ModelParse(xmlXPathContextPtr ctxt,\n              const char *name,\n              void *data)\n{\n    virCPUx86MapPtr map = data;\n    virCPUx86ModelPtr model = NULL;\n    int ret = -1;\n\n    if (x86ModelFind(map, name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Multiple definitions of CPU model '%s'\"), name);\n        goto cleanup;\n    }\n\n    if (!(model = x86ModelNew()))\n        goto cleanup;\n\n    model->name = g_strdup(name);\n\n    if (x86ModelParseAncestor(model, ctxt, map) < 0)\n        goto cleanup;\n\n    if (x86ModelParseSignatures(model, ctxt) < 0)\n        goto cleanup;\n\n    if (x86ModelParseVendor(model, ctxt, map) < 0)\n        goto cleanup;\n\n    if (x86ModelParseFeatures(model, ctxt, map) < 0)\n        goto cleanup;\n\n    if (VIR_APPEND_ELEMENT(map->models, map->nmodels, model) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    x86ModelFree(model);\n    return ret;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86ModelFree",
          "args": [
            "model"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1141-1151",
          "snippet": "static void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "map->models",
            "map->nmodels",
            "model"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86ModelParseFeatures",
          "args": [
            "model",
            "ctxt",
            "map"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelParseFeatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1466-1501",
          "snippet": "static int\nx86ModelParseFeatures(virCPUx86ModelPtr model,\n                      xmlXPathContextPtr ctxt,\n                      virCPUx86MapPtr map)\n{\n    g_autofree xmlNodePtr *nodes = NULL;\n    size_t i;\n    int n;\n\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) <= 0)\n        return n;\n\n    for (i = 0; i < n; i++) {\n        g_autofree char *ftname = NULL;\n        virCPUx86FeaturePtr feature;\n\n        if (!(ftname = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Missing feature name for CPU model %s\"),\n                           model->name);\n            return -1;\n        }\n\n        if (!(feature = x86FeatureFind(map, ftname))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Feature %s required by CPU model %s not found\"),\n                           ftname, model->name);\n            return -1;\n        }\n\n        if (x86DataAdd(&model->data, &feature->data))\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ModelParseFeatures(virCPUx86ModelPtr model,\n                      xmlXPathContextPtr ctxt,\n                      virCPUx86MapPtr map)\n{\n    g_autofree xmlNodePtr *nodes = NULL;\n    size_t i;\n    int n;\n\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) <= 0)\n        return n;\n\n    for (i = 0; i < n; i++) {\n        g_autofree char *ftname = NULL;\n        virCPUx86FeaturePtr feature;\n\n        if (!(ftname = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Missing feature name for CPU model %s\"),\n                           model->name);\n            return -1;\n        }\n\n        if (!(feature = x86FeatureFind(map, ftname))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Feature %s required by CPU model %s not found\"),\n                           ftname, model->name);\n            return -1;\n        }\n\n        if (x86DataAdd(&model->data, &feature->data))\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelParseVendor",
          "args": [
            "model",
            "ctxt",
            "map"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelParseVendor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1436-1463",
          "snippet": "static int\nx86ModelParseVendor(virCPUx86ModelPtr model,\n                    xmlXPathContextPtr ctxt,\n                    virCPUx86MapPtr map)\n{\n    g_autofree char *vendor = NULL;\n    int rc;\n\n    if ((rc = virXPathBoolean(\"boolean(./vendor)\", ctxt)) <= 0)\n        return rc;\n\n    vendor = virXPathString(\"string(./vendor/@name)\", ctxt);\n    if (!vendor) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid vendor element in CPU model %s\"),\n                       model->name);\n        return -1;\n    }\n\n    if (!(model->vendor = x86VendorFind(map, vendor))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown vendor %s referenced by CPU model %s\"),\n                       vendor, model->name);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ModelParseVendor(virCPUx86ModelPtr model,\n                    xmlXPathContextPtr ctxt,\n                    virCPUx86MapPtr map)\n{\n    g_autofree char *vendor = NULL;\n    int rc;\n\n    if ((rc = virXPathBoolean(\"boolean(./vendor)\", ctxt)) <= 0)\n        return rc;\n\n    vendor = virXPathString(\"string(./vendor/@name)\", ctxt);\n    if (!vendor) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid vendor element in CPU model %s\"),\n                       model->name);\n        return -1;\n    }\n\n    if (!(model->vendor = x86VendorFind(map, vendor))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown vendor %s referenced by CPU model %s\"),\n                       vendor, model->name);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelParseSignatures",
          "args": [
            "model",
            "ctxt"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelParseSignatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1386-1433",
          "snippet": "static int\nx86ModelParseSignatures(virCPUx86ModelPtr model,\n                        xmlXPathContextPtr ctxt)\n{\n    g_autofree xmlNodePtr *nodes = NULL;\n    xmlNodePtr root = ctxt->node;\n    size_t i;\n    int n;\n\n    if ((n = virXPathNodeSet(\"./signature\", ctxt, &nodes)) <= 0)\n        return n;\n\n    /* Remove inherited signatures. */\n    VIR_FREE(model->signatures);\n\n    model->nsignatures = n;\n    if (VIR_ALLOC_N(model->signatures, n) < 0)\n       return -1;\n\n    for (i = 0; i < n; i++) {\n        unsigned int sigFamily = 0;\n        unsigned int sigModel = 0;\n        int rc;\n\n        ctxt->node = nodes[i];\n\n        rc = virXPathUInt(\"string(@family)\", ctxt, &sigFamily);\n        if (rc < 0 || sigFamily == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid CPU signature family in model %s\"),\n                           model->name);\n            return -1;\n        }\n\n        rc = virXPathUInt(\"string(@model)\", ctxt, &sigModel);\n        if (rc < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid CPU signature model in model %s\"),\n                           model->name);\n            return -1;\n        }\n\n        model->signatures[i] = x86MakeSignature(sigFamily, sigModel, 0);\n    }\n\n    ctxt->node = root;\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ModelParseSignatures(virCPUx86ModelPtr model,\n                        xmlXPathContextPtr ctxt)\n{\n    g_autofree xmlNodePtr *nodes = NULL;\n    xmlNodePtr root = ctxt->node;\n    size_t i;\n    int n;\n\n    if ((n = virXPathNodeSet(\"./signature\", ctxt, &nodes)) <= 0)\n        return n;\n\n    /* Remove inherited signatures. */\n    VIR_FREE(model->signatures);\n\n    model->nsignatures = n;\n    if (VIR_ALLOC_N(model->signatures, n) < 0)\n       return -1;\n\n    for (i = 0; i < n; i++) {\n        unsigned int sigFamily = 0;\n        unsigned int sigModel = 0;\n        int rc;\n\n        ctxt->node = nodes[i];\n\n        rc = virXPathUInt(\"string(@family)\", ctxt, &sigFamily);\n        if (rc < 0 || sigFamily == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid CPU signature family in model %s\"),\n                           model->name);\n            return -1;\n        }\n\n        rc = virXPathUInt(\"string(@model)\", ctxt, &sigModel);\n        if (rc < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid CPU signature model in model %s\"),\n                           model->name);\n            return -1;\n        }\n\n        model->signatures[i] = x86MakeSignature(sigFamily, sigModel, 0);\n    }\n\n    ctxt->node = root;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelParseAncestor",
          "args": [
            "model",
            "ctxt",
            "map"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelParseAncestor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1350-1383",
          "snippet": "static int\nx86ModelParseAncestor(virCPUx86ModelPtr model,\n                      xmlXPathContextPtr ctxt,\n                      virCPUx86MapPtr map)\n{\n    g_autofree char *name = NULL;\n    virCPUx86ModelPtr ancestor;\n    int rc;\n\n    if ((rc = virXPathBoolean(\"boolean(./model)\", ctxt)) <= 0)\n        return rc;\n\n    name = virXPathString(\"string(./model/@name)\", ctxt);\n    if (!name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing ancestor's name in CPU model %s\"),\n                       model->name);\n        return -1;\n    }\n\n    if (!(ancestor = x86ModelFind(map, name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Ancestor model %s not found for CPU model %s\"),\n                       name, model->name);\n        return -1;\n    }\n\n    model->vendor = ancestor->vendor;\n    if (x86ModelCopySignatures(model, ancestor) < 0 ||\n        x86DataCopy(&model->data, &ancestor->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ModelParseAncestor(virCPUx86ModelPtr model,\n                      xmlXPathContextPtr ctxt,\n                      virCPUx86MapPtr map)\n{\n    g_autofree char *name = NULL;\n    virCPUx86ModelPtr ancestor;\n    int rc;\n\n    if ((rc = virXPathBoolean(\"boolean(./model)\", ctxt)) <= 0)\n        return rc;\n\n    name = virXPathString(\"string(./model/@name)\", ctxt);\n    if (!name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing ancestor's name in CPU model %s\"),\n                       model->name);\n        return -1;\n    }\n\n    if (!(ancestor = x86ModelFind(map, name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Ancestor model %s not found for CPU model %s\"),\n                       name, model->name);\n        return -1;\n    }\n\n    model->vendor = ancestor->vendor;\n    if (x86ModelCopySignatures(model, ancestor) < 0 ||\n        x86DataCopy(&model->data, &ancestor->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "name"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelNew",
          "args": [],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1129-1138",
          "snippet": "static virCPUx86ModelPtr\nx86ModelNew(void)\n{\n    virCPUx86ModelPtr model;\n\n    if (VIR_ALLOC(model) < 0)\n        return NULL;\n\n    return model;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelNew(void)\n{\n    virCPUx86ModelPtr model;\n\n    if (VIR_ALLOC(model) < 0)\n        return NULL;\n\n    return model;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Multiple definitions of CPU model '%s'\")",
            "name"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86ModelFind",
          "args": [
            "map",
            "name"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1196-1208",
          "snippet": "static virCPUx86ModelPtr\nx86ModelFind(virCPUx86MapPtr map,\n             const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nmodels; i++) {\n        if (STREQ(map->models[i]->name, name))\n            return map->models[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelFind(virCPUx86MapPtr map,\n             const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nmodels; i++) {\n        if (STREQ(map->models[i]->name, name))\n            return map->models[i];\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ModelParse(xmlXPathContextPtr ctxt,\n              const char *name,\n              void *data)\n{\n    virCPUx86MapPtr map = data;\n    virCPUx86ModelPtr model = NULL;\n    int ret = -1;\n\n    if (x86ModelFind(map, name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Multiple definitions of CPU model '%s'\"), name);\n        goto cleanup;\n    }\n\n    if (!(model = x86ModelNew()))\n        goto cleanup;\n\n    model->name = g_strdup(name);\n\n    if (x86ModelParseAncestor(model, ctxt, map) < 0)\n        goto cleanup;\n\n    if (x86ModelParseSignatures(model, ctxt) < 0)\n        goto cleanup;\n\n    if (x86ModelParseVendor(model, ctxt, map) < 0)\n        goto cleanup;\n\n    if (x86ModelParseFeatures(model, ctxt, map) < 0)\n        goto cleanup;\n\n    if (VIR_APPEND_ELEMENT(map->models, map->nmodels, model) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    x86ModelFree(model);\n    return ret;\n}"
  },
  {
    "function_name": "x86ModelParseFeatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1466-1501",
    "snippet": "static int\nx86ModelParseFeatures(virCPUx86ModelPtr model,\n                      xmlXPathContextPtr ctxt,\n                      virCPUx86MapPtr map)\n{\n    g_autofree xmlNodePtr *nodes = NULL;\n    size_t i;\n    int n;\n\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) <= 0)\n        return n;\n\n    for (i = 0; i < n; i++) {\n        g_autofree char *ftname = NULL;\n        virCPUx86FeaturePtr feature;\n\n        if (!(ftname = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Missing feature name for CPU model %s\"),\n                           model->name);\n            return -1;\n        }\n\n        if (!(feature = x86FeatureFind(map, ftname))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Feature %s required by CPU model %s not found\"),\n                           ftname, model->name);\n            return -1;\n        }\n\n        if (x86DataAdd(&model->data, &feature->data))\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86DataAdd",
          "args": [
            "&model->data",
            "&feature->data"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Feature %s required by CPU model %s not found\")",
            "ftname",
            "model->name"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Feature %s required by CPU model %s not found\""
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86FeatureFind",
          "args": [
            "map",
            "ftname"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "348-360",
          "snippet": "static virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing feature name for CPU model %s\")",
            "model->name"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "nodes[i]",
            "\"name\""
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./feature\"",
            "ctxt",
            "&nodes"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ModelParseFeatures(virCPUx86ModelPtr model,\n                      xmlXPathContextPtr ctxt,\n                      virCPUx86MapPtr map)\n{\n    g_autofree xmlNodePtr *nodes = NULL;\n    size_t i;\n    int n;\n\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) <= 0)\n        return n;\n\n    for (i = 0; i < n; i++) {\n        g_autofree char *ftname = NULL;\n        virCPUx86FeaturePtr feature;\n\n        if (!(ftname = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Missing feature name for CPU model %s\"),\n                           model->name);\n            return -1;\n        }\n\n        if (!(feature = x86FeatureFind(map, ftname))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Feature %s required by CPU model %s not found\"),\n                           ftname, model->name);\n            return -1;\n        }\n\n        if (x86DataAdd(&model->data, &feature->data))\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "x86ModelParseVendor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1436-1463",
    "snippet": "static int\nx86ModelParseVendor(virCPUx86ModelPtr model,\n                    xmlXPathContextPtr ctxt,\n                    virCPUx86MapPtr map)\n{\n    g_autofree char *vendor = NULL;\n    int rc;\n\n    if ((rc = virXPathBoolean(\"boolean(./vendor)\", ctxt)) <= 0)\n        return rc;\n\n    vendor = virXPathString(\"string(./vendor/@name)\", ctxt);\n    if (!vendor) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid vendor element in CPU model %s\"),\n                       model->name);\n        return -1;\n    }\n\n    if (!(model->vendor = x86VendorFind(map, vendor))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown vendor %s referenced by CPU model %s\"),\n                       vendor, model->name);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown vendor %s referenced by CPU model %s\")",
            "vendor",
            "model->name"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown vendor %s referenced by CPU model %s\""
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86VendorFind",
          "args": [
            "map",
            "vendor"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "x86VendorFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "838-850",
          "snippet": "static virCPUx86VendorPtr\nx86VendorFind(virCPUx86MapPtr map,\n              const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86VendorPtr\nx86VendorFind(virCPUx86MapPtr map,\n              const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid vendor element in CPU model %s\")",
            "model->name"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./vendor/@name)\"",
            "ctxt"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathBoolean",
          "args": [
            "\"boolean(./vendor)\"",
            "ctxt"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "571-596",
          "snippet": "int\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ModelParseVendor(virCPUx86ModelPtr model,\n                    xmlXPathContextPtr ctxt,\n                    virCPUx86MapPtr map)\n{\n    g_autofree char *vendor = NULL;\n    int rc;\n\n    if ((rc = virXPathBoolean(\"boolean(./vendor)\", ctxt)) <= 0)\n        return rc;\n\n    vendor = virXPathString(\"string(./vendor/@name)\", ctxt);\n    if (!vendor) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid vendor element in CPU model %s\"),\n                       model->name);\n        return -1;\n    }\n\n    if (!(model->vendor = x86VendorFind(map, vendor))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown vendor %s referenced by CPU model %s\"),\n                       vendor, model->name);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "x86ModelParseSignatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1386-1433",
    "snippet": "static int\nx86ModelParseSignatures(virCPUx86ModelPtr model,\n                        xmlXPathContextPtr ctxt)\n{\n    g_autofree xmlNodePtr *nodes = NULL;\n    xmlNodePtr root = ctxt->node;\n    size_t i;\n    int n;\n\n    if ((n = virXPathNodeSet(\"./signature\", ctxt, &nodes)) <= 0)\n        return n;\n\n    /* Remove inherited signatures. */\n    VIR_FREE(model->signatures);\n\n    model->nsignatures = n;\n    if (VIR_ALLOC_N(model->signatures, n) < 0)\n       return -1;\n\n    for (i = 0; i < n; i++) {\n        unsigned int sigFamily = 0;\n        unsigned int sigModel = 0;\n        int rc;\n\n        ctxt->node = nodes[i];\n\n        rc = virXPathUInt(\"string(@family)\", ctxt, &sigFamily);\n        if (rc < 0 || sigFamily == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid CPU signature family in model %s\"),\n                           model->name);\n            return -1;\n        }\n\n        rc = virXPathUInt(\"string(@model)\", ctxt, &sigModel);\n        if (rc < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid CPU signature model in model %s\"),\n                           model->name);\n            return -1;\n        }\n\n        model->signatures[i] = x86MakeSignature(sigFamily, sigModel, 0);\n    }\n\n    ctxt->node = root;\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86MakeSignature",
          "args": [
            "sigFamily",
            "sigModel",
            "0"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "x86MakeSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "669-716",
          "snippet": "static uint32_t\nx86MakeSignature(unsigned int family,\n                 unsigned int model,\n                 unsigned int stepping)\n{\n    uint32_t sig = 0;\n\n    /*\n     * CPU signature (eax from 0x1 CPUID leaf):\n     *\n     * |31 .. 28|27 .. 20|19 .. 16|15 .. 14|13 .. 12|11 .. 8|7 .. 4|3 .. 0|\n     * |   R    | extFam | extMod |   R    | PType  |  Fam  | Mod  | Step |\n     *\n     * R        reserved\n     * extFam   extended family (valid only if Fam == 0xf)\n     * extMod   extended model\n     * PType    processor type\n     * Fam      family\n     * Mod      model\n     * Step     stepping\n     *\n     * family = eax[27:20] + eax[11:8]\n     * model = eax[19:16] << 4 + eax[7:4]\n     * stepping = eax[3:0]\n     */\n\n    /* extFam */\n    if (family > 0xf) {\n        sig |= (family - 0xf) << 20;\n        family = 0xf;\n    }\n\n    /* extMod */\n    sig |= (model >> 4) << 16;\n\n    /* PType is always 0 */\n\n    /* Fam */\n    sig |= family << 8;\n\n    /* Mod */\n    sig |= (model & 0xf) << 4;\n\n    /* Step */\n    sig |= stepping & 0xf;\n\n    return sig;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic uint32_t\nx86MakeSignature(unsigned int family,\n                 unsigned int model,\n                 unsigned int stepping)\n{\n    uint32_t sig = 0;\n\n    /*\n     * CPU signature (eax from 0x1 CPUID leaf):\n     *\n     * |31 .. 28|27 .. 20|19 .. 16|15 .. 14|13 .. 12|11 .. 8|7 .. 4|3 .. 0|\n     * |   R    | extFam | extMod |   R    | PType  |  Fam  | Mod  | Step |\n     *\n     * R        reserved\n     * extFam   extended family (valid only if Fam == 0xf)\n     * extMod   extended model\n     * PType    processor type\n     * Fam      family\n     * Mod      model\n     * Step     stepping\n     *\n     * family = eax[27:20] + eax[11:8]\n     * model = eax[19:16] << 4 + eax[7:4]\n     * stepping = eax[3:0]\n     */\n\n    /* extFam */\n    if (family > 0xf) {\n        sig |= (family - 0xf) << 20;\n        family = 0xf;\n    }\n\n    /* extMod */\n    sig |= (model >> 4) << 16;\n\n    /* PType is always 0 */\n\n    /* Fam */\n    sig |= family << 8;\n\n    /* Mod */\n    sig |= (model & 0xf) << 4;\n\n    /* Step */\n    sig |= stepping & 0xf;\n\n    return sig;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid CPU signature model in model %s\")",
            "model->name"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid CPU signature model in model %s\""
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathUInt",
          "args": [
            "\"string(@model)\"",
            "ctxt",
            "&sigModel"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathUInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "328-343",
          "snippet": "int\nvirXPathUInt(const char *xpath,\n             xmlXPathContextPtr ctxt,\n             unsigned int *value)\n{\n    unsigned long tmp;\n    int ret;\n\n    ret = virXPathULongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((unsigned int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathUInt(const char *xpath,\n             xmlXPathContextPtr ctxt,\n             unsigned int *value)\n{\n    unsigned long tmp;\n    int ret;\n\n    ret = virXPathULongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((unsigned int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid CPU signature family in model %s\")",
            "model->name"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "model->signatures",
            "n"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "model->signatures"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./signature\"",
            "ctxt",
            "&nodes"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ModelParseSignatures(virCPUx86ModelPtr model,\n                        xmlXPathContextPtr ctxt)\n{\n    g_autofree xmlNodePtr *nodes = NULL;\n    xmlNodePtr root = ctxt->node;\n    size_t i;\n    int n;\n\n    if ((n = virXPathNodeSet(\"./signature\", ctxt, &nodes)) <= 0)\n        return n;\n\n    /* Remove inherited signatures. */\n    VIR_FREE(model->signatures);\n\n    model->nsignatures = n;\n    if (VIR_ALLOC_N(model->signatures, n) < 0)\n       return -1;\n\n    for (i = 0; i < n; i++) {\n        unsigned int sigFamily = 0;\n        unsigned int sigModel = 0;\n        int rc;\n\n        ctxt->node = nodes[i];\n\n        rc = virXPathUInt(\"string(@family)\", ctxt, &sigFamily);\n        if (rc < 0 || sigFamily == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid CPU signature family in model %s\"),\n                           model->name);\n            return -1;\n        }\n\n        rc = virXPathUInt(\"string(@model)\", ctxt, &sigModel);\n        if (rc < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid CPU signature model in model %s\"),\n                           model->name);\n            return -1;\n        }\n\n        model->signatures[i] = x86MakeSignature(sigFamily, sigModel, 0);\n    }\n\n    ctxt->node = root;\n    return 0;\n}"
  },
  {
    "function_name": "x86ModelParseAncestor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1350-1383",
    "snippet": "static int\nx86ModelParseAncestor(virCPUx86ModelPtr model,\n                      xmlXPathContextPtr ctxt,\n                      virCPUx86MapPtr map)\n{\n    g_autofree char *name = NULL;\n    virCPUx86ModelPtr ancestor;\n    int rc;\n\n    if ((rc = virXPathBoolean(\"boolean(./model)\", ctxt)) <= 0)\n        return rc;\n\n    name = virXPathString(\"string(./model/@name)\", ctxt);\n    if (!name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing ancestor's name in CPU model %s\"),\n                       model->name);\n        return -1;\n    }\n\n    if (!(ancestor = x86ModelFind(map, name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Ancestor model %s not found for CPU model %s\"),\n                       name, model->name);\n        return -1;\n    }\n\n    model->vendor = ancestor->vendor;\n    if (x86ModelCopySignatures(model, ancestor) < 0 ||\n        x86DataCopy(&model->data, &ancestor->data) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86DataCopy",
          "args": [
            "&model->data",
            "&ancestor->data"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "484-497",
          "snippet": "static int\nx86DataCopy(virCPUx86Data *dst, const virCPUx86Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->items, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n    for (i = 0; i < src->len; i++)\n        dst->items[i] = src->items[i];\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DataCopy(virCPUx86Data *dst, const virCPUx86Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->items, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n    for (i = 0; i < src->len; i++)\n        dst->items[i] = src->items[i];\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelCopySignatures",
          "args": [
            "model",
            "ancestor"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelCopySignatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1154-1171",
          "snippet": "static int\nx86ModelCopySignatures(virCPUx86ModelPtr dst,\n                       virCPUx86ModelPtr src)\n{\n    size_t i;\n\n    if (src->nsignatures == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(dst->signatures, src->nsignatures) < 0)\n        return -1;\n\n    dst->nsignatures = src->nsignatures;\n    for (i = 0; i < src->nsignatures; i++)\n        dst->signatures[i] = src->signatures[i];\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ModelCopySignatures(virCPUx86ModelPtr dst,\n                       virCPUx86ModelPtr src)\n{\n    size_t i;\n\n    if (src->nsignatures == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(dst->signatures, src->nsignatures) < 0)\n        return -1;\n\n    dst->nsignatures = src->nsignatures;\n    for (i = 0; i < src->nsignatures; i++)\n        dst->signatures[i] = src->signatures[i];\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Ancestor model %s not found for CPU model %s\")",
            "name",
            "model->name"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Ancestor model %s not found for CPU model %s\""
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelFind",
          "args": [
            "map",
            "name"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1196-1208",
          "snippet": "static virCPUx86ModelPtr\nx86ModelFind(virCPUx86MapPtr map,\n             const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nmodels; i++) {\n        if (STREQ(map->models[i]->name, name))\n            return map->models[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelFind(virCPUx86MapPtr map,\n             const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nmodels; i++) {\n        if (STREQ(map->models[i]->name, name))\n            return map->models[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing ancestor's name in CPU model %s\")",
            "model->name"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./model/@name)\"",
            "ctxt"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathBoolean",
          "args": [
            "\"boolean(./model)\"",
            "ctxt"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "571-596",
          "snippet": "int\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ModelParseAncestor(virCPUx86ModelPtr model,\n                      xmlXPathContextPtr ctxt,\n                      virCPUx86MapPtr map)\n{\n    g_autofree char *name = NULL;\n    virCPUx86ModelPtr ancestor;\n    int rc;\n\n    if ((rc = virXPathBoolean(\"boolean(./model)\", ctxt)) <= 0)\n        return rc;\n\n    name = virXPathString(\"string(./model/@name)\", ctxt);\n    if (!name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing ancestor's name in CPU model %s\"),\n                       model->name);\n        return -1;\n    }\n\n    if (!(ancestor = x86ModelFind(map, name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Ancestor model %s not found for CPU model %s\"),\n                       name, model->name);\n        return -1;\n    }\n\n    model->vendor = ancestor->vendor;\n    if (x86ModelCopySignatures(model, ancestor) < 0 ||\n        x86DataCopy(&model->data, &ancestor->data) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "x86ModelCompare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1302-1347",
    "snippet": "static virCPUx86CompareResult\nx86ModelCompare(virCPUx86ModelPtr model1,\n                virCPUx86ModelPtr model2)\n{\n    virCPUx86CompareResult result = EQUAL;\n    virCPUx86DataIterator iter1;\n    virCPUx86DataIterator iter2;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter1, &model1->data);\n    virCPUx86DataIteratorInit(&iter2, &model2->data);\n    while ((item1 = virCPUx86DataNext(&iter1))) {\n        virCPUx86CompareResult match = SUPERSET;\n\n        if ((item2 = virCPUx86DataGet(&model2->data, item1))) {\n            if (virCPUx86DataItemMatch(item1, item2))\n                continue;\n            else if (!virCPUx86DataItemMatchMasked(item1, item2))\n                match = SUBSET;\n        }\n\n        if (result == EQUAL)\n            result = match;\n        else if (result != match)\n            return UNRELATED;\n    }\n\n    while ((item2 = virCPUx86DataNext(&iter2))) {\n        virCPUx86CompareResult match = SUBSET;\n\n        if ((item1 = virCPUx86DataGet(&model1->data, item2))) {\n            if (virCPUx86DataItemMatch(item2, item1))\n                continue;\n            else if (!virCPUx86DataItemMatchMasked(item2, item1))\n                match = SUPERSET;\n        }\n\n        if (result == EQUAL)\n            result = match;\n        else if (result != match)\n            return UNRELATED;\n    }\n\n    return result;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataItemMatchMasked",
          "args": [
            "item2",
            "item1"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataItemMatchMasked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "209-237",
          "snippet": "static bool\nvirCPUx86DataItemMatchMasked(const virCPUx86DataItem *item,\n                             const virCPUx86DataItem *mask)\n{\n    const virCPUx86CPUID *cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    const virCPUx86MSR *msr;\n    const virCPUx86MSR *msrMask;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        return ((cpuid->eax & cpuidMask->eax) == cpuidMask->eax &&\n                (cpuid->ebx & cpuidMask->ebx) == cpuidMask->ebx &&\n                (cpuid->ecx & cpuidMask->ecx) == cpuidMask->ecx &&\n                (cpuid->edx & cpuidMask->edx) == cpuidMask->edx);\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        return ((msr->eax & msrMask->eax) == msrMask->eax &&\n                (msr->edx & msrMask->edx) == msrMask->edx);\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        return false;\n    }\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nvirCPUx86DataItemMatchMasked(const virCPUx86DataItem *item,\n                             const virCPUx86DataItem *mask)\n{\n    const virCPUx86CPUID *cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    const virCPUx86MSR *msr;\n    const virCPUx86MSR *msrMask;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        return ((cpuid->eax & cpuidMask->eax) == cpuidMask->eax &&\n                (cpuid->ebx & cpuidMask->ebx) == cpuidMask->ebx &&\n                (cpuid->ecx & cpuidMask->ecx) == cpuidMask->ecx &&\n                (cpuid->edx & cpuidMask->edx) == cpuidMask->edx);\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        return ((msr->eax & msrMask->eax) == msrMask->eax &&\n                (msr->edx & msrMask->edx) == msrMask->edx);\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        return false;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataGet",
          "args": [
            "&model1->data",
            "item2"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "448-461",
          "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataNext",
          "args": [
            "&iter2"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "428-445",
          "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataIteratorInit",
          "args": [
            "&iter2",
            "&model2->data"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "169-175",
          "snippet": "static void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86CompareResult\nx86ModelCompare(virCPUx86ModelPtr model1,\n                virCPUx86ModelPtr model2)\n{\n    virCPUx86CompareResult result = EQUAL;\n    virCPUx86DataIterator iter1;\n    virCPUx86DataIterator iter2;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter1, &model1->data);\n    virCPUx86DataIteratorInit(&iter2, &model2->data);\n    while ((item1 = virCPUx86DataNext(&iter1))) {\n        virCPUx86CompareResult match = SUPERSET;\n\n        if ((item2 = virCPUx86DataGet(&model2->data, item1))) {\n            if (virCPUx86DataItemMatch(item1, item2))\n                continue;\n            else if (!virCPUx86DataItemMatchMasked(item1, item2))\n                match = SUBSET;\n        }\n\n        if (result == EQUAL)\n            result = match;\n        else if (result != match)\n            return UNRELATED;\n    }\n\n    while ((item2 = virCPUx86DataNext(&iter2))) {\n        virCPUx86CompareResult match = SUBSET;\n\n        if ((item1 = virCPUx86DataGet(&model1->data, item2))) {\n            if (virCPUx86DataItemMatch(item2, item1))\n                continue;\n            else if (!virCPUx86DataItemMatchMasked(item2, item1))\n                match = SUPERSET;\n        }\n\n        if (result == EQUAL)\n            result = match;\n        else if (result != match)\n            return UNRELATED;\n    }\n\n    return result;\n}"
  },
  {
    "function_name": "x86ModelFromCPU",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1220-1299",
    "snippet": "static virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86ModelFree",
          "args": [
            "model"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1141-1151",
          "snippet": "static void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataAdd",
          "args": [
            "&model->data",
            "&feature->data"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataSubtract",
          "args": [
            "&model->data",
            "&feature->data"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "538-551",
          "snippet": "static void\nx86DataSubtract(virCPUx86Data *data1,\n                const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        virCPUx86DataItemClearBits(item1, item2);\n    }\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86DataSubtract(virCPUx86Data *data1,\n                const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        virCPUx86DataItemClearBits(item1, item2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown CPU feature %s\")",
            "cpu->features[i].name"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown CPU feature %s\""
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86FeatureFind",
          "args": [
            "map",
            "cpu->features[i].name"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "348-360",
          "snippet": "static virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelNew",
          "args": [],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1129-1138",
          "snippet": "static virCPUx86ModelPtr\nx86ModelNew(void)\n{\n    virCPUx86ModelPtr model;\n\n    if (VIR_ALLOC(model) < 0)\n        return NULL;\n\n    return model;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelNew(void)\n{\n    virCPUx86ModelPtr model;\n\n    if (VIR_ALLOC(model) < 0)\n        return NULL;\n\n    return model;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelCopy",
          "args": [
            "model"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1174-1193",
          "snippet": "static virCPUx86ModelPtr\nx86ModelCopy(virCPUx86ModelPtr model)\n{\n    virCPUx86ModelPtr copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        return NULL;\n\n    copy->name = g_strdup(model->name);\n\n    if (x86ModelCopySignatures(copy, model) < 0 ||\n        x86DataCopy(&copy->data, &model->data) < 0) {\n        x86ModelFree(copy);\n        return NULL;\n    }\n\n    copy->vendor = model->vendor;\n\n    return copy;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelCopy(virCPUx86ModelPtr model)\n{\n    virCPUx86ModelPtr copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        return NULL;\n\n    copy->name = g_strdup(model->name);\n\n    if (x86ModelCopySignatures(copy, model) < 0 ||\n        x86DataCopy(&copy->data, &model->data) < 0) {\n        x86ModelFree(copy);\n        return NULL;\n    }\n\n    copy->vendor = model->vendor;\n\n    return copy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown CPU model %s\")",
            "cpu->model"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86ModelFind",
          "args": [
            "map",
            "cpu->model"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1196-1208",
          "snippet": "static virCPUx86ModelPtr\nx86ModelFind(virCPUx86MapPtr map,\n             const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nmodels; i++) {\n        if (STREQ(map->models[i]->name, name))\n            return map->models[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelFind(virCPUx86MapPtr map,\n             const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nmodels; i++) {\n        if (STREQ(map->models[i]->name, name))\n            return map->models[i];\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelFromCPU(const virCPUDef *cpu,\n                virCPUx86MapPtr map,\n                int policy)\n{\n    virCPUx86ModelPtr model = NULL;\n    size_t i;\n\n    /* host CPU only contains required features; requesting other features\n     * just returns an empty model\n     */\n    if (cpu->type == VIR_CPU_TYPE_HOST &&\n        policy != VIR_CPU_FEATURE_REQUIRE &&\n        policy != -1)\n        return x86ModelNew();\n\n    if (cpu->model &&\n        (policy == VIR_CPU_FEATURE_REQUIRE || policy == -1)) {\n        if (!(model = x86ModelFind(map, cpu->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU model %s\"), cpu->model);\n            return NULL;\n        }\n\n        model = x86ModelCopy(model);\n    } else {\n        model = x86ModelNew();\n    }\n\n    if (!model)\n        return NULL;\n\n    for (i = 0; i < cpu->nfeatures; i++) {\n        virCPUx86FeaturePtr feature;\n        virCPUFeaturePolicy fpol;\n\n        if (cpu->features[i].policy == -1)\n            fpol = VIR_CPU_FEATURE_REQUIRE;\n        else\n            fpol = cpu->features[i].policy;\n\n        if ((policy == -1 && fpol == VIR_CPU_FEATURE_OPTIONAL) ||\n            (policy != -1 && fpol != policy))\n            continue;\n\n        if (!(feature = x86FeatureFind(map, cpu->features[i].name))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown CPU feature %s\"), cpu->features[i].name);\n            goto error;\n        }\n\n        if (policy == -1) {\n            switch (fpol) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                if (x86DataAdd(&model->data, &feature->data) < 0)\n                    goto error;\n                break;\n\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                x86DataSubtract(&model->data, &feature->data);\n                break;\n\n            /* coverity[dead_error_condition] */\n            case VIR_CPU_FEATURE_OPTIONAL:\n            case VIR_CPU_FEATURE_LAST:\n                break;\n            }\n        } else if (x86DataAdd(&model->data, &feature->data) < 0) {\n            goto error;\n        }\n    }\n\n    return model;\n\n error:\n    x86ModelFree(model);\n    return NULL;\n}"
  },
  {
    "function_name": "x86ModelFind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1196-1208",
    "snippet": "static virCPUx86ModelPtr\nx86ModelFind(virCPUx86MapPtr map,\n             const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nmodels; i++) {\n        if (STREQ(map->models[i]->name, name))\n            return map->models[i];\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "map->models[i]->name",
            "name"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelFind(virCPUx86MapPtr map,\n             const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nmodels; i++) {\n        if (STREQ(map->models[i]->name, name))\n            return map->models[i];\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "x86ModelCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1174-1193",
    "snippet": "static virCPUx86ModelPtr\nx86ModelCopy(virCPUx86ModelPtr model)\n{\n    virCPUx86ModelPtr copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        return NULL;\n\n    copy->name = g_strdup(model->name);\n\n    if (x86ModelCopySignatures(copy, model) < 0 ||\n        x86DataCopy(&copy->data, &model->data) < 0) {\n        x86ModelFree(copy);\n        return NULL;\n    }\n\n    copy->vendor = model->vendor;\n\n    return copy;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86ModelFree",
          "args": [
            "copy"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1141-1151",
          "snippet": "static void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataCopy",
          "args": [
            "&copy->data",
            "&model->data"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "484-497",
          "snippet": "static int\nx86DataCopy(virCPUx86Data *dst, const virCPUx86Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->items, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n    for (i = 0; i < src->len; i++)\n        dst->items[i] = src->items[i];\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DataCopy(virCPUx86Data *dst, const virCPUx86Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->items, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n    for (i = 0; i < src->len; i++)\n        dst->items[i] = src->items[i];\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ModelCopySignatures",
          "args": [
            "copy",
            "model"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "x86ModelCopySignatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1154-1171",
          "snippet": "static int\nx86ModelCopySignatures(virCPUx86ModelPtr dst,\n                       virCPUx86ModelPtr src)\n{\n    size_t i;\n\n    if (src->nsignatures == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(dst->signatures, src->nsignatures) < 0)\n        return -1;\n\n    dst->nsignatures = src->nsignatures;\n    for (i = 0; i < src->nsignatures; i++)\n        dst->signatures[i] = src->signatures[i];\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ModelCopySignatures(virCPUx86ModelPtr dst,\n                       virCPUx86ModelPtr src)\n{\n    size_t i;\n\n    if (src->nsignatures == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(dst->signatures, src->nsignatures) < 0)\n        return -1;\n\n    dst->nsignatures = src->nsignatures;\n    for (i = 0; i < src->nsignatures; i++)\n        dst->signatures[i] = src->signatures[i];\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "model->name"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "copy"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelCopy(virCPUx86ModelPtr model)\n{\n    virCPUx86ModelPtr copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        return NULL;\n\n    copy->name = g_strdup(model->name);\n\n    if (x86ModelCopySignatures(copy, model) < 0 ||\n        x86DataCopy(&copy->data, &model->data) < 0) {\n        x86ModelFree(copy);\n        return NULL;\n    }\n\n    copy->vendor = model->vendor;\n\n    return copy;\n}"
  },
  {
    "function_name": "x86ModelCopySignatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1154-1171",
    "snippet": "static int\nx86ModelCopySignatures(virCPUx86ModelPtr dst,\n                       virCPUx86ModelPtr src)\n{\n    size_t i;\n\n    if (src->nsignatures == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(dst->signatures, src->nsignatures) < 0)\n        return -1;\n\n    dst->nsignatures = src->nsignatures;\n    for (i = 0; i < src->nsignatures; i++)\n        dst->signatures[i] = src->signatures[i];\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "dst->signatures",
            "src->nsignatures"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ModelCopySignatures(virCPUx86ModelPtr dst,\n                       virCPUx86ModelPtr src)\n{\n    size_t i;\n\n    if (src->nsignatures == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(dst->signatures, src->nsignatures) < 0)\n        return -1;\n\n    dst->nsignatures = src->nsignatures;\n    for (i = 0; i < src->nsignatures; i++)\n        dst->signatures[i] = src->signatures[i];\n\n    return 0;\n}"
  },
  {
    "function_name": "x86ModelFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1141-1151",
    "snippet": "static void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "model"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUx86DataClear",
          "args": [
            "&model->data"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "463-470",
          "snippet": "static void\nvirCPUx86DataClear(virCPUx86Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->items);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataClear(virCPUx86Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->items);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "model->signatures"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "model->name"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86ModelFree(virCPUx86ModelPtr model)\n{\n    if (!model)\n        return;\n\n    VIR_FREE(model->name);\n    VIR_FREE(model->signatures);\n    virCPUx86DataClear(&model->data);\n    VIR_FREE(model);\n}"
  },
  {
    "function_name": "x86ModelNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1129-1138",
    "snippet": "static virCPUx86ModelPtr\nx86ModelNew(void)\n{\n    virCPUx86ModelPtr model;\n\n    if (VIR_ALLOC(model) < 0)\n        return NULL;\n\n    return model;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "model"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86ModelPtr\nx86ModelNew(void)\n{\n    virCPUx86ModelPtr model;\n\n    if (VIR_ALLOC(model) < 0)\n        return NULL;\n\n    return model;\n}"
  },
  {
    "function_name": "x86FeatureParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1046-1126",
    "snippet": "static int\nx86FeatureParse(xmlXPathContextPtr ctxt,\n                const char *name,\n                void *data)\n{\n    virCPUx86MapPtr map = data;\n    xmlNodePtr *nodes = NULL;\n    virCPUx86FeaturePtr feature;\n    virCPUx86DataItem item;\n    size_t i;\n    int n;\n    char *str = NULL;\n    int ret = -1;\n\n    if (!(feature = x86FeatureNew()))\n        goto cleanup;\n\n    feature->migratable = true;\n\n    feature->name = g_strdup(name);\n\n    if (x86FeatureFind(map, feature->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"CPU feature %s already defined\"), feature->name);\n        goto cleanup;\n    }\n\n    str = virXPathString(\"string(@migratable)\", ctxt);\n    if (STREQ_NULLABLE(str, \"no\"))\n        feature->migratable = false;\n\n    n = virXPathNodeSet(\"./cpuid|./msr\", ctxt, &nodes);\n    if (n < 0)\n        goto cleanup;\n\n    if (n == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing cpuid or msr element in feature %s\"),\n                       feature->name);\n        goto cleanup;\n    }\n\n    for (i = 0; i < n; i++) {\n        ctxt->node = nodes[i];\n        if (virXMLNodeNameEqual(nodes[i], \"cpuid\")) {\n            if (x86ParseCPUID(ctxt, &item) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid cpuid[%zu] in %s feature\"),\n                               i, feature->name);\n                goto cleanup;\n            }\n        } else {\n            if (x86ParseMSR(ctxt, &item) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid msr[%zu] in %s feature\"),\n                               i, feature->name);\n                goto cleanup;\n            }\n        }\n\n        if (virCPUx86DataAddItem(&feature->data, &item))\n            goto cleanup;\n    }\n\n    if (!feature->migratable &&\n        VIR_APPEND_ELEMENT_COPY(map->migrate_blockers,\n                                map->nblockers,\n                                feature) < 0)\n        goto cleanup;\n\n    if (VIR_APPEND_ELEMENT(map->features, map->nfeatures, feature) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    x86FeatureFree(feature);\n    VIR_FREE(nodes);\n    VIR_FREE(str);\n    return ret;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86FeatureFree",
          "args": [
            "feature"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "909-918",
          "snippet": "static void\nx86FeatureFree(virCPUx86FeaturePtr feature)\n{\n    if (!feature)\n        return;\n\n    VIR_FREE(feature->name);\n    virCPUx86DataClear(&feature->data);\n    VIR_FREE(feature);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86FeatureFree(virCPUx86FeaturePtr feature)\n{\n    if (!feature)\n        return;\n\n    VIR_FREE(feature->name);\n    virCPUx86DataClear(&feature->data);\n    VIR_FREE(feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "map->features",
            "map->nfeatures",
            "feature"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT_COPY",
          "args": [
            "map->migrate_blockers",
            "map->nblockers",
            "feature"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUx86DataAddItem",
          "args": [
            "&feature->data",
            "&item"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddItem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "500-518",
          "snippet": "static int\nvirCPUx86DataAddItem(virCPUx86Data *data,\n                     const virCPUx86DataItem *item)\n{\n    virCPUx86DataItemPtr existing;\n\n    if ((existing = virCPUx86DataGet(data, item))) {\n        virCPUx86DataItemSetBits(existing, item);\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(data->items, data->len,\n                                    *((virCPUx86DataItemPtr)item)) < 0)\n            return -1;\n\n        qsort(data->items, data->len,\n              sizeof(virCPUx86DataItem), virCPUx86DataSorter);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddItem(virCPUx86Data *data,\n                     const virCPUx86DataItem *item)\n{\n    virCPUx86DataItemPtr existing;\n\n    if ((existing = virCPUx86DataGet(data, item))) {\n        virCPUx86DataItemSetBits(existing, item);\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(data->items, data->len,\n                                    *((virCPUx86DataItemPtr)item)) < 0)\n            return -1;\n\n        qsort(data->items, data->len,\n              sizeof(virCPUx86DataItem), virCPUx86DataSorter);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid msr[%zu] in %s feature\")",
            "i",
            "feature->name"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid msr[%zu] in %s feature\""
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86ParseMSR",
          "args": [
            "ctxt",
            "&item"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "x86ParseMSR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "1021-1043",
          "snippet": "static int\nx86ParseMSR(xmlXPathContextPtr ctxt,\n            virCPUx86DataItemPtr item)\n{\n    virCPUx86MSRPtr msr;\n    unsigned long index;\n    unsigned long eax;\n    unsigned long edx;\n\n    memset(item, 0, sizeof(*item));\n\n    if (virXPathULongHex(\"string(@index)\", ctxt, &index) < 0 ||\n        virXPathULongHex(\"string(@eax)\", ctxt, &eax) < 0 ||\n        virXPathULongHex(\"string(@edx)\", ctxt, &edx) < 0)\n        return -1;\n\n    item->type = VIR_CPU_X86_DATA_MSR;\n    msr = &item->data.msr;\n    msr->index = index;\n    msr->eax = eax;\n    msr->edx = edx;\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ParseMSR(xmlXPathContextPtr ctxt,\n            virCPUx86DataItemPtr item)\n{\n    virCPUx86MSRPtr msr;\n    unsigned long index;\n    unsigned long eax;\n    unsigned long edx;\n\n    memset(item, 0, sizeof(*item));\n\n    if (virXPathULongHex(\"string(@index)\", ctxt, &index) < 0 ||\n        virXPathULongHex(\"string(@eax)\", ctxt, &eax) < 0 ||\n        virXPathULongHex(\"string(@edx)\", ctxt, &edx) < 0)\n        return -1;\n\n    item->type = VIR_CPU_X86_DATA_MSR;\n    msr = &item->data.msr;\n    msr->index = index;\n    msr->eax = eax;\n    msr->edx = edx;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid cpuid[%zu] in %s feature\")",
            "i",
            "feature->name"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86ParseCPUID",
          "args": [
            "ctxt",
            "&item"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "x86ParseCPUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "985-1018",
          "snippet": "static int\nx86ParseCPUID(xmlXPathContextPtr ctxt,\n              virCPUx86DataItemPtr item)\n{\n    virCPUx86CPUIDPtr cpuid;\n    unsigned long eax_in, ecx_in;\n    unsigned long eax, ebx, ecx, edx;\n    int ret_eax_in, ret_ecx_in, ret_eax, ret_ebx, ret_ecx, ret_edx;\n\n    memset(item, 0, sizeof(*item));\n\n    eax_in = ecx_in = 0;\n    eax = ebx = ecx = edx = 0;\n    ret_eax_in = virXPathULongHex(\"string(@eax_in)\", ctxt, &eax_in);\n    ret_ecx_in = virXPathULongHex(\"string(@ecx_in)\", ctxt, &ecx_in);\n    ret_eax = virXPathULongHex(\"string(@eax)\", ctxt, &eax);\n    ret_ebx = virXPathULongHex(\"string(@ebx)\", ctxt, &ebx);\n    ret_ecx = virXPathULongHex(\"string(@ecx)\", ctxt, &ecx);\n    ret_edx = virXPathULongHex(\"string(@edx)\", ctxt, &edx);\n\n    if (ret_eax_in < 0 || ret_ecx_in == -2 ||\n        ret_eax == -2 || ret_ebx == -2 || ret_ecx == -2 || ret_edx == -2)\n        return -1;\n\n    item->type = VIR_CPU_X86_DATA_CPUID;\n    cpuid = &item->data.cpuid;\n    cpuid->eax_in = eax_in;\n    cpuid->ecx_in = ecx_in;\n    cpuid->eax = eax;\n    cpuid->ebx = ebx;\n    cpuid->ecx = ecx;\n    cpuid->edx = edx;\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ParseCPUID(xmlXPathContextPtr ctxt,\n              virCPUx86DataItemPtr item)\n{\n    virCPUx86CPUIDPtr cpuid;\n    unsigned long eax_in, ecx_in;\n    unsigned long eax, ebx, ecx, edx;\n    int ret_eax_in, ret_ecx_in, ret_eax, ret_ebx, ret_ecx, ret_edx;\n\n    memset(item, 0, sizeof(*item));\n\n    eax_in = ecx_in = 0;\n    eax = ebx = ecx = edx = 0;\n    ret_eax_in = virXPathULongHex(\"string(@eax_in)\", ctxt, &eax_in);\n    ret_ecx_in = virXPathULongHex(\"string(@ecx_in)\", ctxt, &ecx_in);\n    ret_eax = virXPathULongHex(\"string(@eax)\", ctxt, &eax);\n    ret_ebx = virXPathULongHex(\"string(@ebx)\", ctxt, &ebx);\n    ret_ecx = virXPathULongHex(\"string(@ecx)\", ctxt, &ecx);\n    ret_edx = virXPathULongHex(\"string(@edx)\", ctxt, &edx);\n\n    if (ret_eax_in < 0 || ret_ecx_in == -2 ||\n        ret_eax == -2 || ret_ebx == -2 || ret_ecx == -2 || ret_edx == -2)\n        return -1;\n\n    item->type = VIR_CPU_X86_DATA_CPUID;\n    cpuid = &item->data.cpuid;\n    cpuid->eax_in = eax_in;\n    cpuid->ecx_in = ecx_in;\n    cpuid->eax = eax;\n    cpuid->ebx = ebx;\n    cpuid->ecx = ecx;\n    cpuid->edx = edx;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLNodeNameEqual",
          "args": [
            "nodes[i]",
            "\"cpuid\""
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeNameEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1013-1018",
          "snippet": "bool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing cpuid or msr element in feature %s\")",
            "feature->name"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./cpuid|./msr\"",
            "ctxt",
            "&nodes"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "str",
            "\"no\""
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(@migratable)\"",
            "ctxt"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"CPU feature %s already defined\")",
            "feature->name"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86FeatureFind",
          "args": [
            "map",
            "feature->name"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "348-360",
          "snippet": "static virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86FeatureNew",
          "args": [],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "897-906",
          "snippet": "static virCPUx86FeaturePtr\nx86FeatureNew(void)\n{\n    virCPUx86FeaturePtr feature;\n\n    if (VIR_ALLOC(feature) < 0)\n        return NULL;\n\n    return feature;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86FeaturePtr\nx86FeatureNew(void)\n{\n    virCPUx86FeaturePtr feature;\n\n    if (VIR_ALLOC(feature) < 0)\n        return NULL;\n\n    return feature;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86FeatureParse(xmlXPathContextPtr ctxt,\n                const char *name,\n                void *data)\n{\n    virCPUx86MapPtr map = data;\n    xmlNodePtr *nodes = NULL;\n    virCPUx86FeaturePtr feature;\n    virCPUx86DataItem item;\n    size_t i;\n    int n;\n    char *str = NULL;\n    int ret = -1;\n\n    if (!(feature = x86FeatureNew()))\n        goto cleanup;\n\n    feature->migratable = true;\n\n    feature->name = g_strdup(name);\n\n    if (x86FeatureFind(map, feature->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"CPU feature %s already defined\"), feature->name);\n        goto cleanup;\n    }\n\n    str = virXPathString(\"string(@migratable)\", ctxt);\n    if (STREQ_NULLABLE(str, \"no\"))\n        feature->migratable = false;\n\n    n = virXPathNodeSet(\"./cpuid|./msr\", ctxt, &nodes);\n    if (n < 0)\n        goto cleanup;\n\n    if (n == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing cpuid or msr element in feature %s\"),\n                       feature->name);\n        goto cleanup;\n    }\n\n    for (i = 0; i < n; i++) {\n        ctxt->node = nodes[i];\n        if (virXMLNodeNameEqual(nodes[i], \"cpuid\")) {\n            if (x86ParseCPUID(ctxt, &item) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid cpuid[%zu] in %s feature\"),\n                               i, feature->name);\n                goto cleanup;\n            }\n        } else {\n            if (x86ParseMSR(ctxt, &item) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid msr[%zu] in %s feature\"),\n                               i, feature->name);\n                goto cleanup;\n            }\n        }\n\n        if (virCPUx86DataAddItem(&feature->data, &item))\n            goto cleanup;\n    }\n\n    if (!feature->migratable &&\n        VIR_APPEND_ELEMENT_COPY(map->migrate_blockers,\n                                map->nblockers,\n                                feature) < 0)\n        goto cleanup;\n\n    if (VIR_APPEND_ELEMENT(map->features, map->nfeatures, feature) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    x86FeatureFree(feature);\n    VIR_FREE(nodes);\n    VIR_FREE(str);\n    return ret;\n}"
  },
  {
    "function_name": "x86ParseMSR",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "1021-1043",
    "snippet": "static int\nx86ParseMSR(xmlXPathContextPtr ctxt,\n            virCPUx86DataItemPtr item)\n{\n    virCPUx86MSRPtr msr;\n    unsigned long index;\n    unsigned long eax;\n    unsigned long edx;\n\n    memset(item, 0, sizeof(*item));\n\n    if (virXPathULongHex(\"string(@index)\", ctxt, &index) < 0 ||\n        virXPathULongHex(\"string(@eax)\", ctxt, &eax) < 0 ||\n        virXPathULongHex(\"string(@edx)\", ctxt, &edx) < 0)\n        return -1;\n\n    item->type = VIR_CPU_X86_DATA_MSR;\n    msr = &item->data.msr;\n    msr->index = index;\n    msr->eax = eax;\n    msr->edx = edx;\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virXPathULongHex",
          "args": [
            "\"string(@edx)\"",
            "ctxt",
            "&edx"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathULongHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "378-384",
          "snippet": "int\nvirXPathULongHex(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 unsigned long *value)\n{\n    return virXPathULongBase(xpath, ctxt, 16, value);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathULongHex(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 unsigned long *value)\n{\n    return virXPathULongBase(xpath, ctxt, 16, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "item",
            "0",
            "sizeof(*item)"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ParseMSR(xmlXPathContextPtr ctxt,\n            virCPUx86DataItemPtr item)\n{\n    virCPUx86MSRPtr msr;\n    unsigned long index;\n    unsigned long eax;\n    unsigned long edx;\n\n    memset(item, 0, sizeof(*item));\n\n    if (virXPathULongHex(\"string(@index)\", ctxt, &index) < 0 ||\n        virXPathULongHex(\"string(@eax)\", ctxt, &eax) < 0 ||\n        virXPathULongHex(\"string(@edx)\", ctxt, &edx) < 0)\n        return -1;\n\n    item->type = VIR_CPU_X86_DATA_MSR;\n    msr = &item->data.msr;\n    msr->index = index;\n    msr->eax = eax;\n    msr->edx = edx;\n    return 0;\n}"
  },
  {
    "function_name": "x86ParseCPUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "985-1018",
    "snippet": "static int\nx86ParseCPUID(xmlXPathContextPtr ctxt,\n              virCPUx86DataItemPtr item)\n{\n    virCPUx86CPUIDPtr cpuid;\n    unsigned long eax_in, ecx_in;\n    unsigned long eax, ebx, ecx, edx;\n    int ret_eax_in, ret_ecx_in, ret_eax, ret_ebx, ret_ecx, ret_edx;\n\n    memset(item, 0, sizeof(*item));\n\n    eax_in = ecx_in = 0;\n    eax = ebx = ecx = edx = 0;\n    ret_eax_in = virXPathULongHex(\"string(@eax_in)\", ctxt, &eax_in);\n    ret_ecx_in = virXPathULongHex(\"string(@ecx_in)\", ctxt, &ecx_in);\n    ret_eax = virXPathULongHex(\"string(@eax)\", ctxt, &eax);\n    ret_ebx = virXPathULongHex(\"string(@ebx)\", ctxt, &ebx);\n    ret_ecx = virXPathULongHex(\"string(@ecx)\", ctxt, &ecx);\n    ret_edx = virXPathULongHex(\"string(@edx)\", ctxt, &edx);\n\n    if (ret_eax_in < 0 || ret_ecx_in == -2 ||\n        ret_eax == -2 || ret_ebx == -2 || ret_ecx == -2 || ret_edx == -2)\n        return -1;\n\n    item->type = VIR_CPU_X86_DATA_CPUID;\n    cpuid = &item->data.cpuid;\n    cpuid->eax_in = eax_in;\n    cpuid->ecx_in = ecx_in;\n    cpuid->eax = eax;\n    cpuid->ebx = ebx;\n    cpuid->ecx = ecx;\n    cpuid->edx = edx;\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virXPathULongHex",
          "args": [
            "\"string(@edx)\"",
            "ctxt",
            "&edx"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathULongHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "378-384",
          "snippet": "int\nvirXPathULongHex(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 unsigned long *value)\n{\n    return virXPathULongBase(xpath, ctxt, 16, value);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathULongHex(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 unsigned long *value)\n{\n    return virXPathULongBase(xpath, ctxt, 16, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "item",
            "0",
            "sizeof(*item)"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86ParseCPUID(xmlXPathContextPtr ctxt,\n              virCPUx86DataItemPtr item)\n{\n    virCPUx86CPUIDPtr cpuid;\n    unsigned long eax_in, ecx_in;\n    unsigned long eax, ebx, ecx, edx;\n    int ret_eax_in, ret_ecx_in, ret_eax, ret_ebx, ret_ecx, ret_edx;\n\n    memset(item, 0, sizeof(*item));\n\n    eax_in = ecx_in = 0;\n    eax = ebx = ecx = edx = 0;\n    ret_eax_in = virXPathULongHex(\"string(@eax_in)\", ctxt, &eax_in);\n    ret_ecx_in = virXPathULongHex(\"string(@ecx_in)\", ctxt, &ecx_in);\n    ret_eax = virXPathULongHex(\"string(@eax)\", ctxt, &eax);\n    ret_ebx = virXPathULongHex(\"string(@ebx)\", ctxt, &ebx);\n    ret_ecx = virXPathULongHex(\"string(@ecx)\", ctxt, &ecx);\n    ret_edx = virXPathULongHex(\"string(@edx)\", ctxt, &edx);\n\n    if (ret_eax_in < 0 || ret_ecx_in == -2 ||\n        ret_eax == -2 || ret_ebx == -2 || ret_ecx == -2 || ret_edx == -2)\n        return -1;\n\n    item->type = VIR_CPU_X86_DATA_CPUID;\n    cpuid = &item->data.cpuid;\n    cpuid->eax_in = eax_in;\n    cpuid->ecx_in = ecx_in;\n    cpuid->eax = eax;\n    cpuid->ebx = ebx;\n    cpuid->ecx = ecx;\n    cpuid->edx = edx;\n    return 0;\n}"
  },
  {
    "function_name": "x86FeatureNames",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "958-982",
    "snippet": "static char *\nx86FeatureNames(virCPUx86MapPtr map,\n                const char *separator,\n                virCPUx86Data *data)\n{\n    virBuffer ret = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    size_t i;\n\n    virBufferAdd(&ret, \"\", 0);\n\n    for (i = 0; i < map->nfeatures; i++) {\n        virCPUx86FeaturePtr feature = map->features[i];\n        if (x86DataIsSubset(data, &feature->data)) {\n            if (!first)\n                virBufferAdd(&ret, separator, -1);\n            else\n                first = false;\n\n            virBufferAdd(&ret, feature->name, -1);\n        }\n    }\n\n    return virBufferContentAndReset(&ret);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&ret"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "&ret",
            "feature->name",
            "-1"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataIsSubset",
          "args": [
            "data",
            "&feature->data"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataIsSubset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "583-599",
          "snippet": "static bool\nx86DataIsSubset(const virCPUx86Data *data,\n                const virCPUx86Data *subset)\n{\n    virCPUx86DataIterator iter;\n    const virCPUx86DataItem *item;\n    const virCPUx86DataItem *itemSubset;\n\n    virCPUx86DataIteratorInit(&iter, subset);\n    while ((itemSubset = virCPUx86DataNext(&iter))) {\n        if (!(item = virCPUx86DataGet(data, itemSubset)) ||\n            !virCPUx86DataItemMatchMasked(item, itemSubset))\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nx86DataIsSubset(const virCPUx86Data *data,\n                const virCPUx86Data *subset)\n{\n    virCPUx86DataIterator iter;\n    const virCPUx86DataItem *item;\n    const virCPUx86DataItem *itemSubset;\n\n    virCPUx86DataIteratorInit(&iter, subset);\n    while ((itemSubset = virCPUx86DataNext(&iter))) {\n        if (!(item = virCPUx86DataGet(data, itemSubset)) ||\n            !virCPUx86DataItemMatchMasked(item, itemSubset))\n            return false;\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic char *\nx86FeatureNames(virCPUx86MapPtr map,\n                const char *separator,\n                virCPUx86Data *data)\n{\n    virBuffer ret = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    size_t i;\n\n    virBufferAdd(&ret, \"\", 0);\n\n    for (i = 0; i < map->nfeatures; i++) {\n        virCPUx86FeaturePtr feature = map->features[i];\n        if (x86DataIsSubset(data, &feature->data)) {\n            if (!first)\n                virBufferAdd(&ret, separator, -1);\n            else\n                first = false;\n\n            virBufferAdd(&ret, feature->name, -1);\n        }\n    }\n\n    return virBufferContentAndReset(&ret);\n}"
  },
  {
    "function_name": "x86FeatureIsMigratable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "942-955",
    "snippet": "static bool\nx86FeatureIsMigratable(const char *name,\n                       void *cpu_map)\n{\n    virCPUx86MapPtr map = cpu_map;\n    size_t i;\n\n    for (i = 0; i < map->nblockers; i++) {\n        if (STREQ(name, map->migrate_blockers[i]->name))\n            return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "map->migrate_blockers[i]->name"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nx86FeatureIsMigratable(const char *name,\n                       void *cpu_map)\n{\n    virCPUx86MapPtr map = cpu_map;\n    size_t i;\n\n    for (i = 0; i < map->nblockers; i++) {\n        if (STREQ(name, map->migrate_blockers[i]->name))\n            return false;\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "x86FeatureInData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "921-939",
    "snippet": "static int\nx86FeatureInData(const char *name,\n                 const virCPUx86Data *data,\n                 virCPUx86MapPtr map)\n{\n    virCPUx86FeaturePtr feature;\n\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown CPU feature %s\"), name);\n        return -1;\n    }\n\n    if (x86DataIsSubset(data, &feature->data))\n        return 1;\n    else\n        return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86DataIsSubset",
          "args": [
            "data",
            "&feature->data"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataIsSubset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "583-599",
          "snippet": "static bool\nx86DataIsSubset(const virCPUx86Data *data,\n                const virCPUx86Data *subset)\n{\n    virCPUx86DataIterator iter;\n    const virCPUx86DataItem *item;\n    const virCPUx86DataItem *itemSubset;\n\n    virCPUx86DataIteratorInit(&iter, subset);\n    while ((itemSubset = virCPUx86DataNext(&iter))) {\n        if (!(item = virCPUx86DataGet(data, itemSubset)) ||\n            !virCPUx86DataItemMatchMasked(item, itemSubset))\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nx86DataIsSubset(const virCPUx86Data *data,\n                const virCPUx86Data *subset)\n{\n    virCPUx86DataIterator iter;\n    const virCPUx86DataItem *item;\n    const virCPUx86DataItem *itemSubset;\n\n    virCPUx86DataIteratorInit(&iter, subset);\n    while ((itemSubset = virCPUx86DataNext(&iter))) {\n        if (!(item = virCPUx86DataGet(data, itemSubset)) ||\n            !virCPUx86DataItemMatchMasked(item, itemSubset))\n            return false;\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown CPU feature %s\")",
            "name"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown CPU feature %s\""
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86FeatureFindInternal",
          "args": [
            "name"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureFindInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "363-375",
          "snippet": "static virCPUx86FeaturePtr\nx86FeatureFindInternal(const char *name)\n{\n    size_t i;\n    size_t count = G_N_ELEMENTS(x86_kvm_features);\n\n    for (i = 0; i < count; i++) {\n        if (STREQ(x86_kvm_features[i].name, name))\n            return x86_kvm_features + i;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virCPUx86Feature x86_kvm_features[] =\n{\n    KVM_FEATURE(VIR_CPU_x86_KVM_PV_UNHALT),\n    KVM_FEATURE(VIR_CPU_x86_HV_RUNTIME),\n    KVM_FEATURE(VIR_CPU_x86_HV_SYNIC),\n    KVM_FEATURE(VIR_CPU_x86_HV_STIMER),\n    KVM_FEATURE(VIR_CPU_x86_HV_RELAXED),\n    KVM_FEATURE(VIR_CPU_x86_HV_VAPIC),\n    KVM_FEATURE(VIR_CPU_x86_HV_VPINDEX),\n    KVM_FEATURE(VIR_CPU_x86_HV_RESET),\n    KVM_FEATURE(VIR_CPU_x86_HV_FREQUENCIES),\n    KVM_FEATURE(VIR_CPU_x86_HV_REENLIGHTENMENT),\n    KVM_FEATURE(VIR_CPU_x86_HV_TLBFLUSH),\n    KVM_FEATURE(VIR_CPU_x86_HV_IPI),\n    KVM_FEATURE(VIR_CPU_x86_HV_EVMCS),\n    KVM_FEATURE(VIR_CPU_x86_HV_STIMER_DIRECT),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86Feature x86_kvm_features[] =\n{\n    KVM_FEATURE(VIR_CPU_x86_KVM_PV_UNHALT),\n    KVM_FEATURE(VIR_CPU_x86_HV_RUNTIME),\n    KVM_FEATURE(VIR_CPU_x86_HV_SYNIC),\n    KVM_FEATURE(VIR_CPU_x86_HV_STIMER),\n    KVM_FEATURE(VIR_CPU_x86_HV_RELAXED),\n    KVM_FEATURE(VIR_CPU_x86_HV_VAPIC),\n    KVM_FEATURE(VIR_CPU_x86_HV_VPINDEX),\n    KVM_FEATURE(VIR_CPU_x86_HV_RESET),\n    KVM_FEATURE(VIR_CPU_x86_HV_FREQUENCIES),\n    KVM_FEATURE(VIR_CPU_x86_HV_REENLIGHTENMENT),\n    KVM_FEATURE(VIR_CPU_x86_HV_TLBFLUSH),\n    KVM_FEATURE(VIR_CPU_x86_HV_IPI),\n    KVM_FEATURE(VIR_CPU_x86_HV_EVMCS),\n    KVM_FEATURE(VIR_CPU_x86_HV_STIMER_DIRECT),\n};\n\nstatic virCPUx86FeaturePtr\nx86FeatureFindInternal(const char *name)\n{\n    size_t i;\n    size_t count = G_N_ELEMENTS(x86_kvm_features);\n\n    for (i = 0; i < count; i++) {\n        if (STREQ(x86_kvm_features[i].name, name))\n            return x86_kvm_features + i;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86FeatureFind",
          "args": [
            "map",
            "name"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "348-360",
          "snippet": "static virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86FeatureInData(const char *name,\n                 const virCPUx86Data *data,\n                 virCPUx86MapPtr map)\n{\n    virCPUx86FeaturePtr feature;\n\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown CPU feature %s\"), name);\n        return -1;\n    }\n\n    if (x86DataIsSubset(data, &feature->data))\n        return 1;\n    else\n        return 0;\n}"
  },
  {
    "function_name": "x86FeatureFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "909-918",
    "snippet": "static void\nx86FeatureFree(virCPUx86FeaturePtr feature)\n{\n    if (!feature)\n        return;\n\n    VIR_FREE(feature->name);\n    virCPUx86DataClear(&feature->data);\n    VIR_FREE(feature);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "feature"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUx86DataClear",
          "args": [
            "&feature->data"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "463-470",
          "snippet": "static void\nvirCPUx86DataClear(virCPUx86Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->items);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataClear(virCPUx86Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->items);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "feature->name"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86FeatureFree(virCPUx86FeaturePtr feature)\n{\n    if (!feature)\n        return;\n\n    VIR_FREE(feature->name);\n    virCPUx86DataClear(&feature->data);\n    VIR_FREE(feature);\n}"
  },
  {
    "function_name": "x86FeatureNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "897-906",
    "snippet": "static virCPUx86FeaturePtr\nx86FeatureNew(void)\n{\n    virCPUx86FeaturePtr feature;\n\n    if (VIR_ALLOC(feature) < 0)\n        return NULL;\n\n    return feature;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "feature"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86FeaturePtr\nx86FeatureNew(void)\n{\n    virCPUx86FeaturePtr feature;\n\n    if (VIR_ALLOC(feature) < 0)\n        return NULL;\n\n    return feature;\n}"
  },
  {
    "function_name": "x86VendorParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "853-894",
    "snippet": "static int\nx86VendorParse(xmlXPathContextPtr ctxt,\n               const char *name,\n               void *data)\n{\n    virCPUx86MapPtr map = data;\n    virCPUx86VendorPtr vendor = NULL;\n    char *string = NULL;\n    int ret = -1;\n\n    if (VIR_ALLOC(vendor) < 0)\n        goto cleanup;\n\n    vendor->name = g_strdup(name);\n\n    if (x86VendorFind(map, vendor->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"CPU vendor %s already defined\"), vendor->name);\n        goto cleanup;\n    }\n\n    string = virXPathString(\"string(@string)\", ctxt);\n    if (!string) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing vendor string for CPU vendor %s\"),\n                       vendor->name);\n        goto cleanup;\n    }\n\n    if (virCPUx86VendorToData(string, &vendor->data) < 0)\n        goto cleanup;\n\n    if (VIR_APPEND_ELEMENT(map->vendors, map->nvendors, vendor) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    x86VendorFree(vendor);\n    VIR_FREE(string);\n    return ret;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "string"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86VendorFree",
          "args": [
            "vendor"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "x86VendorFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "827-835",
          "snippet": "static void\nx86VendorFree(virCPUx86VendorPtr vendor)\n{\n    if (!vendor)\n        return;\n\n    VIR_FREE(vendor->name);\n    VIR_FREE(vendor);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86VendorFree(virCPUx86VendorPtr vendor)\n{\n    if (!vendor)\n        return;\n\n    VIR_FREE(vendor->name);\n    VIR_FREE(vendor);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "map->vendors",
            "map->nvendors",
            "vendor"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUx86VendorToData",
          "args": [
            "string",
            "&vendor->data"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86VendorToData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "645-666",
          "snippet": "static int\nvirCPUx86VendorToData(const char *vendor,\n                      virCPUx86DataItemPtr item)\n{\n    virCPUx86CPUIDPtr cpuid;\n\n    if (strlen(vendor) != VENDOR_STRING_LENGTH) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid CPU vendor string '%s'\"), vendor);\n        return -1;\n    }\n\n    item->type = VIR_CPU_X86_DATA_CPUID;\n    cpuid = &item->data.cpuid;\n    cpuid->eax_in = 0;\n    cpuid->ecx_in = 0;\n    cpuid->ebx = virReadBufInt32LE(vendor);\n    cpuid->edx = virReadBufInt32LE(vendor + 4);\n    cpuid->ecx = virReadBufInt32LE(vendor + 8);\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VENDOR_STRING_LENGTH    12"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\n#define VENDOR_STRING_LENGTH    12\n\nstatic int\nvirCPUx86VendorToData(const char *vendor,\n                      virCPUx86DataItemPtr item)\n{\n    virCPUx86CPUIDPtr cpuid;\n\n    if (strlen(vendor) != VENDOR_STRING_LENGTH) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid CPU vendor string '%s'\"), vendor);\n        return -1;\n    }\n\n    item->type = VIR_CPU_X86_DATA_CPUID;\n    cpuid = &item->data.cpuid;\n    cpuid->eax_in = 0;\n    cpuid->ecx_in = 0;\n    cpuid->ebx = virReadBufInt32LE(vendor);\n    cpuid->edx = virReadBufInt32LE(vendor + 4);\n    cpuid->ecx = virReadBufInt32LE(vendor + 8);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing vendor string for CPU vendor %s\")",
            "vendor->name"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing vendor string for CPU vendor %s\""
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(@string)\"",
            "ctxt"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"CPU vendor %s already defined\")",
            "vendor->name"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86VendorFind",
          "args": [
            "map",
            "vendor->name"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "x86VendorFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "838-850",
          "snippet": "static virCPUx86VendorPtr\nx86VendorFind(virCPUx86MapPtr map,\n              const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86VendorPtr\nx86VendorFind(virCPUx86MapPtr map,\n              const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "vendor"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86VendorParse(xmlXPathContextPtr ctxt,\n               const char *name,\n               void *data)\n{\n    virCPUx86MapPtr map = data;\n    virCPUx86VendorPtr vendor = NULL;\n    char *string = NULL;\n    int ret = -1;\n\n    if (VIR_ALLOC(vendor) < 0)\n        goto cleanup;\n\n    vendor->name = g_strdup(name);\n\n    if (x86VendorFind(map, vendor->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"CPU vendor %s already defined\"), vendor->name);\n        goto cleanup;\n    }\n\n    string = virXPathString(\"string(@string)\", ctxt);\n    if (!string) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing vendor string for CPU vendor %s\"),\n                       vendor->name);\n        goto cleanup;\n    }\n\n    if (virCPUx86VendorToData(string, &vendor->data) < 0)\n        goto cleanup;\n\n    if (VIR_APPEND_ELEMENT(map->vendors, map->nvendors, vendor) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    x86VendorFree(vendor);\n    VIR_FREE(string);\n    return ret;\n}"
  },
  {
    "function_name": "x86VendorFind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "838-850",
    "snippet": "static virCPUx86VendorPtr\nx86VendorFind(virCPUx86MapPtr map,\n              const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "map->vendors[i]->name",
            "name"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86VendorPtr\nx86VendorFind(virCPUx86MapPtr map,\n              const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "x86VendorFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "827-835",
    "snippet": "static void\nx86VendorFree(virCPUx86VendorPtr vendor)\n{\n    if (!vendor)\n        return;\n\n    VIR_FREE(vendor->name);\n    VIR_FREE(vendor);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vendor"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vendor->name"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86VendorFree(virCPUx86VendorPtr vendor)\n{\n    if (!vendor)\n        return;\n\n    VIR_FREE(vendor->name);\n    VIR_FREE(vendor);\n}"
  },
  {
    "function_name": "x86DataToCPU",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "767-824",
    "snippet": "static virCPUDefPtr\nx86DataToCPU(const virCPUx86Data *data,\n             virCPUx86ModelPtr model,\n             virCPUx86MapPtr map,\n             virDomainCapsCPUModelPtr hvModel)\n{\n    virCPUDefPtr cpu;\n    virCPUx86Data copy = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data modelData = VIR_CPU_X86_DATA_INIT;\n    virCPUx86VendorPtr vendor;\n\n    cpu = virCPUDefNew();\n\n    cpu->model = g_strdup(model->name);\n\n    if (x86DataCopy(&copy, data) < 0 ||\n        x86DataCopy(&modelData, &model->data) < 0)\n        goto error;\n\n    if ((vendor = x86DataToVendor(&copy, map)))\n        cpu->vendor = g_strdup(vendor->name);\n\n    x86DataSubtract(&copy, &modelData);\n    x86DataSubtract(&modelData, data);\n\n    /* The hypervisor's version of the CPU model (hvModel) may contain\n     * additional features which may be currently unavailable. Such features\n     * block usage of the CPU model and we need to explicitly disable them.\n     */\n    if (hvModel && hvModel->blockers) {\n        char **blocker;\n        virCPUx86FeaturePtr feature;\n\n        for (blocker = hvModel->blockers; *blocker; blocker++) {\n            if ((feature = x86FeatureFind(map, *blocker)) &&\n                !x86DataIsSubset(&copy, &feature->data))\n                if (x86DataAdd(&modelData, &feature->data) < 0)\n                    goto error;\n        }\n    }\n\n    /* because feature policy is ignored for host CPU */\n    cpu->type = VIR_CPU_TYPE_GUEST;\n\n    if (x86DataToCPUFeatures(cpu, VIR_CPU_FEATURE_REQUIRE, &copy, map) ||\n        x86DataToCPUFeatures(cpu, VIR_CPU_FEATURE_DISABLE, &modelData, map))\n        goto error;\n\n cleanup:\n    virCPUx86DataClear(&modelData);\n    virCPUx86DataClear(&copy);\n    return cpu;\n\n error:\n    virCPUDefFree(cpu);\n    cpu = NULL;\n    goto cleanup;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "cpu"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataClear",
          "args": [
            "&copy"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "463-470",
          "snippet": "static void\nvirCPUx86DataClear(virCPUx86Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->items);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataClear(virCPUx86Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->items);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataToCPUFeatures",
          "args": [
            "cpu",
            "VIR_CPU_FEATURE_DISABLE",
            "&modelData",
            "map"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataToCPUFeatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "603-621",
          "snippet": "static int\nx86DataToCPUFeatures(virCPUDefPtr cpu,\n                     int policy,\n                     virCPUx86Data *data,\n                     virCPUx86MapPtr map)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        virCPUx86FeaturePtr feature = map->features[i];\n        if (x86DataIsSubset(data, &feature->data)) {\n            x86DataSubtract(data, &feature->data);\n            if (virCPUDefAddFeature(cpu, feature->name, policy) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DataToCPUFeatures(virCPUDefPtr cpu,\n                     int policy,\n                     virCPUx86Data *data,\n                     virCPUx86MapPtr map)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        virCPUx86FeaturePtr feature = map->features[i];\n        if (x86DataIsSubset(data, &feature->data)) {\n            x86DataSubtract(data, &feature->data);\n            if (virCPUDefAddFeature(cpu, feature->name, policy) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataAdd",
          "args": [
            "&modelData",
            "&feature->data"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataIsSubset",
          "args": [
            "&copy",
            "&feature->data"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataIsSubset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "583-599",
          "snippet": "static bool\nx86DataIsSubset(const virCPUx86Data *data,\n                const virCPUx86Data *subset)\n{\n    virCPUx86DataIterator iter;\n    const virCPUx86DataItem *item;\n    const virCPUx86DataItem *itemSubset;\n\n    virCPUx86DataIteratorInit(&iter, subset);\n    while ((itemSubset = virCPUx86DataNext(&iter))) {\n        if (!(item = virCPUx86DataGet(data, itemSubset)) ||\n            !virCPUx86DataItemMatchMasked(item, itemSubset))\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nx86DataIsSubset(const virCPUx86Data *data,\n                const virCPUx86Data *subset)\n{\n    virCPUx86DataIterator iter;\n    const virCPUx86DataItem *item;\n    const virCPUx86DataItem *itemSubset;\n\n    virCPUx86DataIteratorInit(&iter, subset);\n    while ((itemSubset = virCPUx86DataNext(&iter))) {\n        if (!(item = virCPUx86DataGet(data, itemSubset)) ||\n            !virCPUx86DataItemMatchMasked(item, itemSubset))\n            return false;\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86FeatureFind",
          "args": [
            "map",
            "*blocker"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "x86FeatureFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "348-360",
          "snippet": "static virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataSubtract",
          "args": [
            "&modelData",
            "data"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "538-551",
          "snippet": "static void\nx86DataSubtract(virCPUx86Data *data1,\n                const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        virCPUx86DataItemClearBits(item1, item2);\n    }\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86DataSubtract(virCPUx86Data *data1,\n                const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        virCPUx86DataItemClearBits(item1, item2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "vendor->name"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataToVendor",
          "args": [
            "&copy",
            "map"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataToVendor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "625-642",
          "snippet": "static virCPUx86VendorPtr\nx86DataToVendor(const virCPUx86Data *data,\n                virCPUx86MapPtr map)\n{\n    virCPUx86DataItemPtr item;\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        virCPUx86VendorPtr vendor = map->vendors[i];\n        if ((item = virCPUx86DataGet(data, &vendor->data)) &&\n            virCPUx86DataItemMatchMasked(item, &vendor->data)) {\n            virCPUx86DataItemClearBits(item, &vendor->data);\n            return vendor;\n        }\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86VendorPtr\nx86DataToVendor(const virCPUx86Data *data,\n                virCPUx86MapPtr map)\n{\n    virCPUx86DataItemPtr item;\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        virCPUx86VendorPtr vendor = map->vendors[i];\n        if ((item = virCPUx86DataGet(data, &vendor->data)) &&\n            virCPUx86DataItemMatchMasked(item, &vendor->data)) {\n            virCPUx86DataItemClearBits(item, &vendor->data);\n            return vendor;\n        }\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataCopy",
          "args": [
            "&modelData",
            "&model->data"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "484-497",
          "snippet": "static int\nx86DataCopy(virCPUx86Data *dst, const virCPUx86Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->items, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n    for (i = 0; i < src->len; i++)\n        dst->items[i] = src->items[i];\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DataCopy(virCPUx86Data *dst, const virCPUx86Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->items, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n    for (i = 0; i < src->len; i++)\n        dst->items[i] = src->items[i];\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefNew",
          "args": [],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "85-90",
          "snippet": "virCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUDefPtr\nx86DataToCPU(const virCPUx86Data *data,\n             virCPUx86ModelPtr model,\n             virCPUx86MapPtr map,\n             virDomainCapsCPUModelPtr hvModel)\n{\n    virCPUDefPtr cpu;\n    virCPUx86Data copy = VIR_CPU_X86_DATA_INIT;\n    virCPUx86Data modelData = VIR_CPU_X86_DATA_INIT;\n    virCPUx86VendorPtr vendor;\n\n    cpu = virCPUDefNew();\n\n    cpu->model = g_strdup(model->name);\n\n    if (x86DataCopy(&copy, data) < 0 ||\n        x86DataCopy(&modelData, &model->data) < 0)\n        goto error;\n\n    if ((vendor = x86DataToVendor(&copy, map)))\n        cpu->vendor = g_strdup(vendor->name);\n\n    x86DataSubtract(&copy, &modelData);\n    x86DataSubtract(&modelData, data);\n\n    /* The hypervisor's version of the CPU model (hvModel) may contain\n     * additional features which may be currently unavailable. Such features\n     * block usage of the CPU model and we need to explicitly disable them.\n     */\n    if (hvModel && hvModel->blockers) {\n        char **blocker;\n        virCPUx86FeaturePtr feature;\n\n        for (blocker = hvModel->blockers; *blocker; blocker++) {\n            if ((feature = x86FeatureFind(map, *blocker)) &&\n                !x86DataIsSubset(&copy, &feature->data))\n                if (x86DataAdd(&modelData, &feature->data) < 0)\n                    goto error;\n        }\n    }\n\n    /* because feature policy is ignored for host CPU */\n    cpu->type = VIR_CPU_TYPE_GUEST;\n\n    if (x86DataToCPUFeatures(cpu, VIR_CPU_FEATURE_REQUIRE, &copy, map) ||\n        x86DataToCPUFeatures(cpu, VIR_CPU_FEATURE_DISABLE, &modelData, map))\n        goto error;\n\n cleanup:\n    virCPUx86DataClear(&modelData);\n    virCPUx86DataClear(&copy);\n    return cpu;\n\n error:\n    virCPUDefFree(cpu);\n    cpu = NULL;\n    goto cleanup;\n}"
  },
  {
    "function_name": "x86DataAddSignature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "757-764",
    "snippet": "static int\nx86DataAddSignature(virCPUx86Data *data,\n                    uint32_t signature)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1, .eax = signature);\n\n    return virCPUx86DataAddItem(data, &leaf1);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataAddItem",
          "args": [
            "data",
            "&leaf1"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddItem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "500-518",
          "snippet": "static int\nvirCPUx86DataAddItem(virCPUx86Data *data,\n                     const virCPUx86DataItem *item)\n{\n    virCPUx86DataItemPtr existing;\n\n    if ((existing = virCPUx86DataGet(data, item))) {\n        virCPUx86DataItemSetBits(existing, item);\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(data->items, data->len,\n                                    *((virCPUx86DataItemPtr)item)) < 0)\n            return -1;\n\n        qsort(data->items, data->len,\n              sizeof(virCPUx86DataItem), virCPUx86DataSorter);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddItem(virCPUx86Data *data,\n                     const virCPUx86DataItem *item)\n{\n    virCPUx86DataItemPtr existing;\n\n    if ((existing = virCPUx86DataGet(data, item))) {\n        virCPUx86DataItemSetBits(existing, item);\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(data->items, data->len,\n                                    *((virCPUx86DataItemPtr)item)) < 0)\n            return -1;\n\n        qsort(data->items, data->len,\n              sizeof(virCPUx86DataItem), virCPUx86DataSorter);\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DataAddSignature(virCPUx86Data *data,\n                    uint32_t signature)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1, .eax = signature);\n\n    return virCPUx86DataAddItem(data, &leaf1);\n}"
  },
  {
    "function_name": "x86DataToSignature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "744-754",
    "snippet": "static uint32_t\nx86DataToSignature(const virCPUx86Data *data)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1);\n    virCPUx86DataItemPtr item;\n\n    if (!(item = virCPUx86DataGet(data, &leaf1)))\n        return 0;\n\n    return item->data.cpuid.eax & SIGNATURE_MASK;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SIGNATURE_MASK  0x0fff3ff0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataGet",
          "args": [
            "data",
            "&leaf1"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "448-461",
          "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUID",
          "args": [
            ".eax_in = 0x1"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetMaxCPUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1057-1072",
          "snippet": "unsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\n#define SIGNATURE_MASK  0x0fff3ff0\n\nstatic uint32_t\nx86DataToSignature(const virCPUx86Data *data)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1);\n    virCPUx86DataItemPtr item;\n\n    if (!(item = virCPUx86DataGet(data, &leaf1)))\n        return 0;\n\n    return item->data.cpuid.eax & SIGNATURE_MASK;\n}"
  },
  {
    "function_name": "x86DataToSignatureFull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "719-738",
    "snippet": "static void\nx86DataToSignatureFull(const virCPUx86Data *data,\n                       unsigned int *family,\n                       unsigned int *model,\n                       unsigned int *stepping)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1);\n    virCPUx86DataItemPtr item;\n    virCPUx86CPUIDPtr cpuid;\n\n    *family = *model = *stepping = 0;\n\n    if (!(item = virCPUx86DataGet(data, &leaf1)))\n        return;\n\n    cpuid = &item->data.cpuid;\n    *family = ((cpuid->eax >> 20) & 0xff) + ((cpuid->eax >> 8) & 0xf);\n    *model = ((cpuid->eax >> 12) & 0xf0) + ((cpuid->eax >> 4) & 0xf);\n    *stepping = cpuid->eax & 0xf;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataGet",
          "args": [
            "data",
            "&leaf1"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "448-461",
          "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUID",
          "args": [
            ".eax_in = 0x1"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetMaxCPUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1057-1072",
          "snippet": "unsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86DataToSignatureFull(const virCPUx86Data *data,\n                       unsigned int *family,\n                       unsigned int *model,\n                       unsigned int *stepping)\n{\n    virCPUx86DataItem leaf1 = CPUID(.eax_in = 0x1);\n    virCPUx86DataItemPtr item;\n    virCPUx86CPUIDPtr cpuid;\n\n    *family = *model = *stepping = 0;\n\n    if (!(item = virCPUx86DataGet(data, &leaf1)))\n        return;\n\n    cpuid = &item->data.cpuid;\n    *family = ((cpuid->eax >> 20) & 0xff) + ((cpuid->eax >> 8) & 0xf);\n    *model = ((cpuid->eax >> 12) & 0xf0) + ((cpuid->eax >> 4) & 0xf);\n    *stepping = cpuid->eax & 0xf;\n}"
  },
  {
    "function_name": "x86MakeSignature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "669-716",
    "snippet": "static uint32_t\nx86MakeSignature(unsigned int family,\n                 unsigned int model,\n                 unsigned int stepping)\n{\n    uint32_t sig = 0;\n\n    /*\n     * CPU signature (eax from 0x1 CPUID leaf):\n     *\n     * |31 .. 28|27 .. 20|19 .. 16|15 .. 14|13 .. 12|11 .. 8|7 .. 4|3 .. 0|\n     * |   R    | extFam | extMod |   R    | PType  |  Fam  | Mod  | Step |\n     *\n     * R        reserved\n     * extFam   extended family (valid only if Fam == 0xf)\n     * extMod   extended model\n     * PType    processor type\n     * Fam      family\n     * Mod      model\n     * Step     stepping\n     *\n     * family = eax[27:20] + eax[11:8]\n     * model = eax[19:16] << 4 + eax[7:4]\n     * stepping = eax[3:0]\n     */\n\n    /* extFam */\n    if (family > 0xf) {\n        sig |= (family - 0xf) << 20;\n        family = 0xf;\n    }\n\n    /* extMod */\n    sig |= (model >> 4) << 16;\n\n    /* PType is always 0 */\n\n    /* Fam */\n    sig |= family << 8;\n\n    /* Mod */\n    sig |= (model & 0xf) << 4;\n\n    /* Step */\n    sig |= stepping & 0xf;\n\n    return sig;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic uint32_t\nx86MakeSignature(unsigned int family,\n                 unsigned int model,\n                 unsigned int stepping)\n{\n    uint32_t sig = 0;\n\n    /*\n     * CPU signature (eax from 0x1 CPUID leaf):\n     *\n     * |31 .. 28|27 .. 20|19 .. 16|15 .. 14|13 .. 12|11 .. 8|7 .. 4|3 .. 0|\n     * |   R    | extFam | extMod |   R    | PType  |  Fam  | Mod  | Step |\n     *\n     * R        reserved\n     * extFam   extended family (valid only if Fam == 0xf)\n     * extMod   extended model\n     * PType    processor type\n     * Fam      family\n     * Mod      model\n     * Step     stepping\n     *\n     * family = eax[27:20] + eax[11:8]\n     * model = eax[19:16] << 4 + eax[7:4]\n     * stepping = eax[3:0]\n     */\n\n    /* extFam */\n    if (family > 0xf) {\n        sig |= (family - 0xf) << 20;\n        family = 0xf;\n    }\n\n    /* extMod */\n    sig |= (model >> 4) << 16;\n\n    /* PType is always 0 */\n\n    /* Fam */\n    sig |= family << 8;\n\n    /* Mod */\n    sig |= (model & 0xf) << 4;\n\n    /* Step */\n    sig |= stepping & 0xf;\n\n    return sig;\n}"
  },
  {
    "function_name": "virCPUx86VendorToData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "645-666",
    "snippet": "static int\nvirCPUx86VendorToData(const char *vendor,\n                      virCPUx86DataItemPtr item)\n{\n    virCPUx86CPUIDPtr cpuid;\n\n    if (strlen(vendor) != VENDOR_STRING_LENGTH) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid CPU vendor string '%s'\"), vendor);\n        return -1;\n    }\n\n    item->type = VIR_CPU_X86_DATA_CPUID;\n    cpuid = &item->data.cpuid;\n    cpuid->eax_in = 0;\n    cpuid->ecx_in = 0;\n    cpuid->ebx = virReadBufInt32LE(vendor);\n    cpuid->edx = virReadBufInt32LE(vendor + 4);\n    cpuid->ecx = virReadBufInt32LE(vendor + 8);\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VENDOR_STRING_LENGTH    12"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReadBufInt32LE",
          "args": [
            "vendor + 8"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt32LE",
          "args": [
            "vendor + 4"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReadBufInt32LE",
          "args": [
            "vendor"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid CPU vendor string '%s'\")",
            "vendor"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid CPU vendor string '%s'\""
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "vendor"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\n#define VENDOR_STRING_LENGTH    12\n\nstatic int\nvirCPUx86VendorToData(const char *vendor,\n                      virCPUx86DataItemPtr item)\n{\n    virCPUx86CPUIDPtr cpuid;\n\n    if (strlen(vendor) != VENDOR_STRING_LENGTH) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid CPU vendor string '%s'\"), vendor);\n        return -1;\n    }\n\n    item->type = VIR_CPU_X86_DATA_CPUID;\n    cpuid = &item->data.cpuid;\n    cpuid->eax_in = 0;\n    cpuid->ecx_in = 0;\n    cpuid->ebx = virReadBufInt32LE(vendor);\n    cpuid->edx = virReadBufInt32LE(vendor + 4);\n    cpuid->ecx = virReadBufInt32LE(vendor + 8);\n\n    return 0;\n}"
  },
  {
    "function_name": "x86DataToVendor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "625-642",
    "snippet": "static virCPUx86VendorPtr\nx86DataToVendor(const virCPUx86Data *data,\n                virCPUx86MapPtr map)\n{\n    virCPUx86DataItemPtr item;\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        virCPUx86VendorPtr vendor = map->vendors[i];\n        if ((item = virCPUx86DataGet(data, &vendor->data)) &&\n            virCPUx86DataItemMatchMasked(item, &vendor->data)) {\n            virCPUx86DataItemClearBits(item, &vendor->data);\n            return vendor;\n        }\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataItemClearBits",
          "args": [
            "item",
            "&vendor->data"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataItemClearBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "276-309",
          "snippet": "static void\nvirCPUx86DataItemClearBits(virCPUx86DataItemPtr item,\n                           const virCPUx86DataItem *mask)\n{\n    virCPUx86CPUIDPtr cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    virCPUx86MSRPtr msr;\n    const virCPUx86MSR *msrMask;\n\n    if (!mask)\n        return;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        cpuid->eax &= ~cpuidMask->eax;\n        cpuid->ebx &= ~cpuidMask->ebx;\n        cpuid->ecx &= ~cpuidMask->ecx;\n        cpuid->edx &= ~cpuidMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        msr->eax &= ~msrMask->eax;\n        msr->edx &= ~msrMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataItemClearBits(virCPUx86DataItemPtr item,\n                           const virCPUx86DataItem *mask)\n{\n    virCPUx86CPUIDPtr cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    virCPUx86MSRPtr msr;\n    const virCPUx86MSR *msrMask;\n\n    if (!mask)\n        return;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        cpuid->eax &= ~cpuidMask->eax;\n        cpuid->ebx &= ~cpuidMask->ebx;\n        cpuid->ecx &= ~cpuidMask->ecx;\n        cpuid->edx &= ~cpuidMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        msr->eax &= ~msrMask->eax;\n        msr->edx &= ~msrMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataItemMatchMasked",
          "args": [
            "item",
            "&vendor->data"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataItemMatchMasked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "209-237",
          "snippet": "static bool\nvirCPUx86DataItemMatchMasked(const virCPUx86DataItem *item,\n                             const virCPUx86DataItem *mask)\n{\n    const virCPUx86CPUID *cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    const virCPUx86MSR *msr;\n    const virCPUx86MSR *msrMask;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        return ((cpuid->eax & cpuidMask->eax) == cpuidMask->eax &&\n                (cpuid->ebx & cpuidMask->ebx) == cpuidMask->ebx &&\n                (cpuid->ecx & cpuidMask->ecx) == cpuidMask->ecx &&\n                (cpuid->edx & cpuidMask->edx) == cpuidMask->edx);\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        return ((msr->eax & msrMask->eax) == msrMask->eax &&\n                (msr->edx & msrMask->edx) == msrMask->edx);\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        return false;\n    }\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nvirCPUx86DataItemMatchMasked(const virCPUx86DataItem *item,\n                             const virCPUx86DataItem *mask)\n{\n    const virCPUx86CPUID *cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    const virCPUx86MSR *msr;\n    const virCPUx86MSR *msrMask;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        return ((cpuid->eax & cpuidMask->eax) == cpuidMask->eax &&\n                (cpuid->ebx & cpuidMask->ebx) == cpuidMask->ebx &&\n                (cpuid->ecx & cpuidMask->ecx) == cpuidMask->ecx &&\n                (cpuid->edx & cpuidMask->edx) == cpuidMask->edx);\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        return ((msr->eax & msrMask->eax) == msrMask->eax &&\n                (msr->edx & msrMask->edx) == msrMask->edx);\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        return false;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataGet",
          "args": [
            "data",
            "&vendor->data"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "448-461",
          "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86VendorPtr\nx86DataToVendor(const virCPUx86Data *data,\n                virCPUx86MapPtr map)\n{\n    virCPUx86DataItemPtr item;\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        virCPUx86VendorPtr vendor = map->vendors[i];\n        if ((item = virCPUx86DataGet(data, &vendor->data)) &&\n            virCPUx86DataItemMatchMasked(item, &vendor->data)) {\n            virCPUx86DataItemClearBits(item, &vendor->data);\n            return vendor;\n        }\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "x86DataToCPUFeatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "603-621",
    "snippet": "static int\nx86DataToCPUFeatures(virCPUDefPtr cpu,\n                     int policy,\n                     virCPUx86Data *data,\n                     virCPUx86MapPtr map)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        virCPUx86FeaturePtr feature = map->features[i];\n        if (x86DataIsSubset(data, &feature->data)) {\n            x86DataSubtract(data, &feature->data);\n            if (virCPUDefAddFeature(cpu, feature->name, policy) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefAddFeature",
          "args": [
            "cpu",
            "feature->name",
            "policy"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "928-934",
          "snippet": "int\nvirCPUDefAddFeature(virCPUDefPtr def,\n                    const char *name,\n                    int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, false);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefAddFeature(virCPUDefPtr def,\n                    const char *name,\n                    int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataSubtract",
          "args": [
            "data",
            "&feature->data"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "538-551",
          "snippet": "static void\nx86DataSubtract(virCPUx86Data *data1,\n                const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        virCPUx86DataItemClearBits(item1, item2);\n    }\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86DataSubtract(virCPUx86Data *data1,\n                const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        virCPUx86DataItemClearBits(item1, item2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "x86DataIsSubset",
          "args": [
            "data",
            "&feature->data"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "x86DataIsSubset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "583-599",
          "snippet": "static bool\nx86DataIsSubset(const virCPUx86Data *data,\n                const virCPUx86Data *subset)\n{\n    virCPUx86DataIterator iter;\n    const virCPUx86DataItem *item;\n    const virCPUx86DataItem *itemSubset;\n\n    virCPUx86DataIteratorInit(&iter, subset);\n    while ((itemSubset = virCPUx86DataNext(&iter))) {\n        if (!(item = virCPUx86DataGet(data, itemSubset)) ||\n            !virCPUx86DataItemMatchMasked(item, itemSubset))\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nx86DataIsSubset(const virCPUx86Data *data,\n                const virCPUx86Data *subset)\n{\n    virCPUx86DataIterator iter;\n    const virCPUx86DataItem *item;\n    const virCPUx86DataItem *itemSubset;\n\n    virCPUx86DataIteratorInit(&iter, subset);\n    while ((itemSubset = virCPUx86DataNext(&iter))) {\n        if (!(item = virCPUx86DataGet(data, itemSubset)) ||\n            !virCPUx86DataItemMatchMasked(item, itemSubset))\n            return false;\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DataToCPUFeatures(virCPUDefPtr cpu,\n                     int policy,\n                     virCPUx86Data *data,\n                     virCPUx86MapPtr map)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        virCPUx86FeaturePtr feature = map->features[i];\n        if (x86DataIsSubset(data, &feature->data)) {\n            x86DataSubtract(data, &feature->data);\n            if (virCPUDefAddFeature(cpu, feature->name, policy) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "x86DataIsSubset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "583-599",
    "snippet": "static bool\nx86DataIsSubset(const virCPUx86Data *data,\n                const virCPUx86Data *subset)\n{\n    virCPUx86DataIterator iter;\n    const virCPUx86DataItem *item;\n    const virCPUx86DataItem *itemSubset;\n\n    virCPUx86DataIteratorInit(&iter, subset);\n    while ((itemSubset = virCPUx86DataNext(&iter))) {\n        if (!(item = virCPUx86DataGet(data, itemSubset)) ||\n            !virCPUx86DataItemMatchMasked(item, itemSubset))\n            return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataItemMatchMasked",
          "args": [
            "item",
            "itemSubset"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataItemMatchMasked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "209-237",
          "snippet": "static bool\nvirCPUx86DataItemMatchMasked(const virCPUx86DataItem *item,\n                             const virCPUx86DataItem *mask)\n{\n    const virCPUx86CPUID *cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    const virCPUx86MSR *msr;\n    const virCPUx86MSR *msrMask;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        return ((cpuid->eax & cpuidMask->eax) == cpuidMask->eax &&\n                (cpuid->ebx & cpuidMask->ebx) == cpuidMask->ebx &&\n                (cpuid->ecx & cpuidMask->ecx) == cpuidMask->ecx &&\n                (cpuid->edx & cpuidMask->edx) == cpuidMask->edx);\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        return ((msr->eax & msrMask->eax) == msrMask->eax &&\n                (msr->edx & msrMask->edx) == msrMask->edx);\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        return false;\n    }\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nvirCPUx86DataItemMatchMasked(const virCPUx86DataItem *item,\n                             const virCPUx86DataItem *mask)\n{\n    const virCPUx86CPUID *cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    const virCPUx86MSR *msr;\n    const virCPUx86MSR *msrMask;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        return ((cpuid->eax & cpuidMask->eax) == cpuidMask->eax &&\n                (cpuid->ebx & cpuidMask->ebx) == cpuidMask->ebx &&\n                (cpuid->ecx & cpuidMask->ecx) == cpuidMask->ecx &&\n                (cpuid->edx & cpuidMask->edx) == cpuidMask->edx);\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        return ((msr->eax & msrMask->eax) == msrMask->eax &&\n                (msr->edx & msrMask->edx) == msrMask->edx);\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        return false;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataGet",
          "args": [
            "data",
            "itemSubset"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "448-461",
          "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataNext",
          "args": [
            "&iter"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "428-445",
          "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataIteratorInit",
          "args": [
            "&iter",
            "subset"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "169-175",
          "snippet": "static void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nx86DataIsSubset(const virCPUx86Data *data,\n                const virCPUx86Data *subset)\n{\n    virCPUx86DataIterator iter;\n    const virCPUx86DataItem *item;\n    const virCPUx86DataItem *itemSubset;\n\n    virCPUx86DataIteratorInit(&iter, subset);\n    while ((itemSubset = virCPUx86DataNext(&iter))) {\n        if (!(item = virCPUx86DataGet(data, itemSubset)) ||\n            !virCPUx86DataItemMatchMasked(item, itemSubset))\n            return false;\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "x86DataIsEmpty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "573-580",
    "snippet": "static bool\nx86DataIsEmpty(virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter;\n\n    virCPUx86DataIteratorInit(&iter, data);\n    return !virCPUx86DataNext(&iter);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataNext",
          "args": [
            "&iter"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "428-445",
          "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataIteratorInit",
          "args": [
            "&iter",
            "data"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "169-175",
          "snippet": "static void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nx86DataIsEmpty(virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter;\n\n    virCPUx86DataIteratorInit(&iter, data);\n    return !virCPUx86DataNext(&iter);\n}"
  },
  {
    "function_name": "x86DataIntersect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "554-570",
    "snippet": "static void\nx86DataIntersect(virCPUx86Data *data1,\n                 const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        if (item2)\n            virCPUx86DataItemAndBits(item1, item2);\n        else\n            virCPUx86DataItemClearBits(item1, item1);\n    }\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataItemClearBits",
          "args": [
            "item1",
            "item1"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataItemClearBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "276-309",
          "snippet": "static void\nvirCPUx86DataItemClearBits(virCPUx86DataItemPtr item,\n                           const virCPUx86DataItem *mask)\n{\n    virCPUx86CPUIDPtr cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    virCPUx86MSRPtr msr;\n    const virCPUx86MSR *msrMask;\n\n    if (!mask)\n        return;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        cpuid->eax &= ~cpuidMask->eax;\n        cpuid->ebx &= ~cpuidMask->ebx;\n        cpuid->ecx &= ~cpuidMask->ecx;\n        cpuid->edx &= ~cpuidMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        msr->eax &= ~msrMask->eax;\n        msr->edx &= ~msrMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataItemClearBits(virCPUx86DataItemPtr item,\n                           const virCPUx86DataItem *mask)\n{\n    virCPUx86CPUIDPtr cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    virCPUx86MSRPtr msr;\n    const virCPUx86MSR *msrMask;\n\n    if (!mask)\n        return;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        cpuid->eax &= ~cpuidMask->eax;\n        cpuid->ebx &= ~cpuidMask->ebx;\n        cpuid->ecx &= ~cpuidMask->ecx;\n        cpuid->edx &= ~cpuidMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        msr->eax &= ~msrMask->eax;\n        msr->edx &= ~msrMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataItemAndBits",
          "args": [
            "item1",
            "item2"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataItemAndBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "312-345",
          "snippet": "static void\nvirCPUx86DataItemAndBits(virCPUx86DataItemPtr item,\n                         const virCPUx86DataItem *mask)\n{\n    virCPUx86CPUIDPtr cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    virCPUx86MSRPtr msr;\n    const virCPUx86MSR *msrMask;\n\n    if (!mask)\n        return;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        cpuid->eax &= cpuidMask->eax;\n        cpuid->ebx &= cpuidMask->ebx;\n        cpuid->ecx &= cpuidMask->ecx;\n        cpuid->edx &= cpuidMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        msr->eax &= msrMask->eax;\n        msr->edx &= msrMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataItemAndBits(virCPUx86DataItemPtr item,\n                         const virCPUx86DataItem *mask)\n{\n    virCPUx86CPUIDPtr cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    virCPUx86MSRPtr msr;\n    const virCPUx86MSR *msrMask;\n\n    if (!mask)\n        return;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        cpuid->eax &= cpuidMask->eax;\n        cpuid->ebx &= cpuidMask->ebx;\n        cpuid->ecx &= cpuidMask->ecx;\n        cpuid->edx &= cpuidMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        msr->eax &= msrMask->eax;\n        msr->edx &= msrMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataGet",
          "args": [
            "data2",
            "item1"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "448-461",
          "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataNext",
          "args": [
            "&iter"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "428-445",
          "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataIteratorInit",
          "args": [
            "&iter",
            "data1"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "169-175",
          "snippet": "static void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86DataIntersect(virCPUx86Data *data1,\n                 const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        if (item2)\n            virCPUx86DataItemAndBits(item1, item2);\n        else\n            virCPUx86DataItemClearBits(item1, item1);\n    }\n}"
  },
  {
    "function_name": "x86DataSubtract",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "538-551",
    "snippet": "static void\nx86DataSubtract(virCPUx86Data *data1,\n                const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        virCPUx86DataItemClearBits(item1, item2);\n    }\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataItemClearBits",
          "args": [
            "item1",
            "item2"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataItemClearBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "276-309",
          "snippet": "static void\nvirCPUx86DataItemClearBits(virCPUx86DataItemPtr item,\n                           const virCPUx86DataItem *mask)\n{\n    virCPUx86CPUIDPtr cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    virCPUx86MSRPtr msr;\n    const virCPUx86MSR *msrMask;\n\n    if (!mask)\n        return;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        cpuid->eax &= ~cpuidMask->eax;\n        cpuid->ebx &= ~cpuidMask->ebx;\n        cpuid->ecx &= ~cpuidMask->ecx;\n        cpuid->edx &= ~cpuidMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        msr->eax &= ~msrMask->eax;\n        msr->edx &= ~msrMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataItemClearBits(virCPUx86DataItemPtr item,\n                           const virCPUx86DataItem *mask)\n{\n    virCPUx86CPUIDPtr cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    virCPUx86MSRPtr msr;\n    const virCPUx86MSR *msrMask;\n\n    if (!mask)\n        return;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        cpuid->eax &= ~cpuidMask->eax;\n        cpuid->ebx &= ~cpuidMask->ebx;\n        cpuid->ecx &= ~cpuidMask->ecx;\n        cpuid->edx &= ~cpuidMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        msr->eax &= ~msrMask->eax;\n        msr->edx &= ~msrMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataGet",
          "args": [
            "data2",
            "item1"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "448-461",
          "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataNext",
          "args": [
            "&iter"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "428-445",
          "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataIteratorInit",
          "args": [
            "&iter",
            "data1"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "169-175",
          "snippet": "static void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nx86DataSubtract(virCPUx86Data *data1,\n                const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item1;\n    virCPUx86DataItemPtr item2;\n\n    virCPUx86DataIteratorInit(&iter, data1);\n    while ((item1 = virCPUx86DataNext(&iter))) {\n        item2 = virCPUx86DataGet(data2, item1);\n        virCPUx86DataItemClearBits(item1, item2);\n    }\n}"
  },
  {
    "function_name": "x86DataAdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "521-535",
    "snippet": "static int\nx86DataAdd(virCPUx86Data *data1,\n           const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item;\n\n    virCPUx86DataIteratorInit(&iter, data2);\n    while ((item = virCPUx86DataNext(&iter))) {\n        if (virCPUx86DataAddItem(data1, item) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataAddItem",
          "args": [
            "data1",
            "item"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddItem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "500-518",
          "snippet": "static int\nvirCPUx86DataAddItem(virCPUx86Data *data,\n                     const virCPUx86DataItem *item)\n{\n    virCPUx86DataItemPtr existing;\n\n    if ((existing = virCPUx86DataGet(data, item))) {\n        virCPUx86DataItemSetBits(existing, item);\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(data->items, data->len,\n                                    *((virCPUx86DataItemPtr)item)) < 0)\n            return -1;\n\n        qsort(data->items, data->len,\n              sizeof(virCPUx86DataItem), virCPUx86DataSorter);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddItem(virCPUx86Data *data,\n                     const virCPUx86DataItem *item)\n{\n    virCPUx86DataItemPtr existing;\n\n    if ((existing = virCPUx86DataGet(data, item))) {\n        virCPUx86DataItemSetBits(existing, item);\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(data->items, data->len,\n                                    *((virCPUx86DataItemPtr)item)) < 0)\n            return -1;\n\n        qsort(data->items, data->len,\n              sizeof(virCPUx86DataItem), virCPUx86DataSorter);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataNext",
          "args": [
            "&iter"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "428-445",
          "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataIteratorInit",
          "args": [
            "&iter",
            "data2"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "169-175",
          "snippet": "static void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DataAdd(virCPUx86Data *data1,\n           const virCPUx86Data *data2)\n{\n    virCPUx86DataIterator iter;\n    virCPUx86DataItemPtr item;\n\n    virCPUx86DataIteratorInit(&iter, data2);\n    while ((item = virCPUx86DataNext(&iter))) {\n        if (virCPUx86DataAddItem(data1, item) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virCPUx86DataAddItem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "500-518",
    "snippet": "static int\nvirCPUx86DataAddItem(virCPUx86Data *data,\n                     const virCPUx86DataItem *item)\n{\n    virCPUx86DataItemPtr existing;\n\n    if ((existing = virCPUx86DataGet(data, item))) {\n        virCPUx86DataItemSetBits(existing, item);\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(data->items, data->len,\n                                    *((virCPUx86DataItemPtr)item)) < 0)\n            return -1;\n\n        qsort(data->items, data->len,\n              sizeof(virCPUx86DataItem), virCPUx86DataSorter);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "data->items",
            "data->len",
            "sizeof(virCPUx86DataItem)",
            "virCPUx86DataSorter"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT_COPY",
          "args": [
            "data->items",
            "data->len",
            "*((virCPUx86DataItemPtr)item)"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUx86DataItemSetBits",
          "args": [
            "existing",
            "item"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataItemSetBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "240-273",
          "snippet": "static void\nvirCPUx86DataItemSetBits(virCPUx86DataItemPtr item,\n                         const virCPUx86DataItem *mask)\n{\n    virCPUx86CPUIDPtr cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    virCPUx86MSRPtr msr;\n    const virCPUx86MSR *msrMask;\n\n    if (!mask)\n        return;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        cpuid->eax |= cpuidMask->eax;\n        cpuid->ebx |= cpuidMask->ebx;\n        cpuid->ecx |= cpuidMask->ecx;\n        cpuid->edx |= cpuidMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        msr->eax |= msrMask->eax;\n        msr->edx |= msrMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataItemSetBits(virCPUx86DataItemPtr item,\n                         const virCPUx86DataItem *mask)\n{\n    virCPUx86CPUIDPtr cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    virCPUx86MSRPtr msr;\n    const virCPUx86MSR *msrMask;\n\n    if (!mask)\n        return;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        cpuid->eax |= cpuidMask->eax;\n        cpuid->ebx |= cpuidMask->ebx;\n        cpuid->ecx |= cpuidMask->ecx;\n        cpuid->edx |= cpuidMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        msr->eax |= msrMask->eax;\n        msr->edx |= msrMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUx86DataGet",
          "args": [
            "data",
            "item"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "448-461",
          "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddItem(virCPUx86Data *data,\n                     const virCPUx86DataItem *item)\n{\n    virCPUx86DataItemPtr existing;\n\n    if ((existing = virCPUx86DataGet(data, item))) {\n        virCPUx86DataItemSetBits(existing, item);\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(data->items, data->len,\n                                    *((virCPUx86DataItemPtr)item)) < 0)\n            return -1;\n\n        qsort(data->items, data->len,\n              sizeof(virCPUx86DataItem), virCPUx86DataSorter);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "x86DataCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "484-497",
    "snippet": "static int\nx86DataCopy(virCPUx86Data *dst, const virCPUx86Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->items, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n    for (i = 0; i < src->len; i++)\n        dst->items[i] = src->items[i];\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "dst->items",
            "src->len"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nx86DataCopy(virCPUx86Data *dst, const virCPUx86Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->items, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n    for (i = 0; i < src->len; i++)\n        dst->items[i] = src->items[i];\n\n    return 0;\n}"
  },
  {
    "function_name": "virCPUx86DataFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "473-481",
    "snippet": "static void\nvirCPUx86DataFree(virCPUDataPtr data)\n{\n    if (!data)\n        return;\n\n    virCPUx86DataClear(&data->data.x86);\n    VIR_FREE(data);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUx86DataClear",
          "args": [
            "&data->data.x86"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "463-470",
          "snippet": "static void\nvirCPUx86DataClear(virCPUx86Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->items);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataClear(virCPUx86Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->items);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataFree(virCPUDataPtr data)\n{\n    if (!data)\n        return;\n\n    virCPUx86DataClear(&data->data.x86);\n    VIR_FREE(data);\n}"
  },
  {
    "function_name": "virCPUx86DataClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "463-470",
    "snippet": "static void\nvirCPUx86DataClear(virCPUx86Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->items);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->items"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataClear(virCPUx86Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->items);\n}"
  },
  {
    "function_name": "virCPUx86DataGet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "448-461",
    "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataItemCmp",
          "args": [
            "di",
            "item"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataItemCmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "419-424",
          "snippet": "static int\nvirCPUx86DataItemCmp(const virCPUx86DataItem *item1,\n                     const virCPUx86DataItem *item2)\n{\n    return virCPUx86DataSorter(item1, item2);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataItemCmp(const virCPUx86DataItem *item1,\n                     const virCPUx86DataItem *item2)\n{\n    return virCPUx86DataSorter(item1, item2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataGet(const virCPUx86Data *data,\n                 const virCPUx86DataItem *item)\n{\n    size_t i;\n\n    for (i = 0; i < data->len; i++) {\n        virCPUx86DataItemPtr di = data->items + i;\n        if (virCPUx86DataItemCmp(di, item) == 0)\n            return di;\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "virCPUx86DataNext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "428-445",
    "snippet": "static virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataItemMatch",
          "args": [
            "item",
            "&zero"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataItemMatchMasked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "209-237",
          "snippet": "static bool\nvirCPUx86DataItemMatchMasked(const virCPUx86DataItem *item,\n                             const virCPUx86DataItem *mask)\n{\n    const virCPUx86CPUID *cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    const virCPUx86MSR *msr;\n    const virCPUx86MSR *msrMask;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        return ((cpuid->eax & cpuidMask->eax) == cpuidMask->eax &&\n                (cpuid->ebx & cpuidMask->ebx) == cpuidMask->ebx &&\n                (cpuid->ecx & cpuidMask->ecx) == cpuidMask->ecx &&\n                (cpuid->edx & cpuidMask->edx) == cpuidMask->edx);\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        return ((msr->eax & msrMask->eax) == msrMask->eax &&\n                (msr->edx & msrMask->edx) == msrMask->edx);\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        return false;\n    }\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nvirCPUx86DataItemMatchMasked(const virCPUx86DataItem *item,\n                             const virCPUx86DataItem *mask)\n{\n    const virCPUx86CPUID *cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    const virCPUx86MSR *msr;\n    const virCPUx86MSR *msrMask;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        return ((cpuid->eax & cpuidMask->eax) == cpuidMask->eax &&\n                (cpuid->ebx & cpuidMask->ebx) == cpuidMask->ebx &&\n                (cpuid->ecx & cpuidMask->ecx) == cpuidMask->ecx &&\n                (cpuid->edx & cpuidMask->edx) == cpuidMask->edx);\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        return ((msr->eax & msrMask->eax) == msrMask->eax &&\n                (msr->edx & msrMask->edx) == msrMask->edx);\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        return false;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86DataItemPtr\nvirCPUx86DataNext(virCPUx86DataIteratorPtr iterator)\n{\n    const virCPUx86Data *data = iterator->data;\n    virCPUx86DataItem zero = { 0 };\n\n    if (!data)\n        return NULL;\n\n    while (++iterator->pos < data->len) {\n        virCPUx86DataItemPtr item = data->items + iterator->pos;\n\n        if (!virCPUx86DataItemMatch(item, &zero))\n            return item;\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "virCPUx86DataItemCmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "419-424",
    "snippet": "static int\nvirCPUx86DataItemCmp(const virCPUx86DataItem *item1,\n                     const virCPUx86DataItem *item2)\n{\n    return virCPUx86DataSorter(item1, item2);\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUx86DataSorter",
          "args": [
            "item1",
            "item2"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataSorter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "378-417",
          "snippet": "static int\nvirCPUx86DataSorter(const void *a, const void *b)\n{\n    virCPUx86DataItemPtr da = (virCPUx86DataItemPtr) a;\n    virCPUx86DataItemPtr db = (virCPUx86DataItemPtr) b;\n\n    if (da->type > db->type)\n        return 1;\n    else if (da->type < db->type)\n        return -1;\n\n    switch (da->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        if (da->data.cpuid.eax_in > db->data.cpuid.eax_in)\n            return 1;\n        else if (da->data.cpuid.eax_in < db->data.cpuid.eax_in)\n            return -1;\n\n        if (da->data.cpuid.ecx_in > db->data.cpuid.ecx_in)\n            return 1;\n        else if (da->data.cpuid.ecx_in < db->data.cpuid.ecx_in)\n            return -1;\n\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        if (da->data.msr.index > db->data.msr.index)\n            return 1;\n        else if (da->data.msr.index < db->data.msr.index)\n            return -1;\n\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataSorter(const void *a, const void *b)\n{\n    virCPUx86DataItemPtr da = (virCPUx86DataItemPtr) a;\n    virCPUx86DataItemPtr db = (virCPUx86DataItemPtr) b;\n\n    if (da->type > db->type)\n        return 1;\n    else if (da->type < db->type)\n        return -1;\n\n    switch (da->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        if (da->data.cpuid.eax_in > db->data.cpuid.eax_in)\n            return 1;\n        else if (da->data.cpuid.eax_in < db->data.cpuid.eax_in)\n            return -1;\n\n        if (da->data.cpuid.ecx_in > db->data.cpuid.ecx_in)\n            return 1;\n        else if (da->data.cpuid.ecx_in < db->data.cpuid.ecx_in)\n            return -1;\n\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        if (da->data.msr.index > db->data.msr.index)\n            return 1;\n        else if (da->data.msr.index < db->data.msr.index)\n            return -1;\n\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataItemCmp(const virCPUx86DataItem *item1,\n                     const virCPUx86DataItem *item2)\n{\n    return virCPUx86DataSorter(item1, item2);\n}"
  },
  {
    "function_name": "virCPUx86DataSorter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "378-417",
    "snippet": "static int\nvirCPUx86DataSorter(const void *a, const void *b)\n{\n    virCPUx86DataItemPtr da = (virCPUx86DataItemPtr) a;\n    virCPUx86DataItemPtr db = (virCPUx86DataItemPtr) b;\n\n    if (da->type > db->type)\n        return 1;\n    else if (da->type < db->type)\n        return -1;\n\n    switch (da->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        if (da->data.cpuid.eax_in > db->data.cpuid.eax_in)\n            return 1;\n        else if (da->data.cpuid.eax_in < db->data.cpuid.eax_in)\n            return -1;\n\n        if (da->data.cpuid.ecx_in > db->data.cpuid.ecx_in)\n            return 1;\n        else if (da->data.cpuid.ecx_in < db->data.cpuid.ecx_in)\n            return -1;\n\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        if (da->data.msr.index > db->data.msr.index)\n            return 1;\n        else if (da->data.msr.index < db->data.msr.index)\n            return -1;\n\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataSorter(const void *a, const void *b)\n{\n    virCPUx86DataItemPtr da = (virCPUx86DataItemPtr) a;\n    virCPUx86DataItemPtr db = (virCPUx86DataItemPtr) b;\n\n    if (da->type > db->type)\n        return 1;\n    else if (da->type < db->type)\n        return -1;\n\n    switch (da->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        if (da->data.cpuid.eax_in > db->data.cpuid.eax_in)\n            return 1;\n        else if (da->data.cpuid.eax_in < db->data.cpuid.eax_in)\n            return -1;\n\n        if (da->data.cpuid.ecx_in > db->data.cpuid.ecx_in)\n            return 1;\n        else if (da->data.cpuid.ecx_in < db->data.cpuid.ecx_in)\n            return -1;\n\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        if (da->data.msr.index > db->data.msr.index)\n            return 1;\n        else if (da->data.msr.index < db->data.msr.index)\n            return -1;\n\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "x86FeatureFindInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "363-375",
    "snippet": "static virCPUx86FeaturePtr\nx86FeatureFindInternal(const char *name)\n{\n    size_t i;\n    size_t count = G_N_ELEMENTS(x86_kvm_features);\n\n    for (i = 0; i < count; i++) {\n        if (STREQ(x86_kvm_features[i].name, name))\n            return x86_kvm_features + i;\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virCPUx86Feature x86_kvm_features[] =\n{\n    KVM_FEATURE(VIR_CPU_x86_KVM_PV_UNHALT),\n    KVM_FEATURE(VIR_CPU_x86_HV_RUNTIME),\n    KVM_FEATURE(VIR_CPU_x86_HV_SYNIC),\n    KVM_FEATURE(VIR_CPU_x86_HV_STIMER),\n    KVM_FEATURE(VIR_CPU_x86_HV_RELAXED),\n    KVM_FEATURE(VIR_CPU_x86_HV_VAPIC),\n    KVM_FEATURE(VIR_CPU_x86_HV_VPINDEX),\n    KVM_FEATURE(VIR_CPU_x86_HV_RESET),\n    KVM_FEATURE(VIR_CPU_x86_HV_FREQUENCIES),\n    KVM_FEATURE(VIR_CPU_x86_HV_REENLIGHTENMENT),\n    KVM_FEATURE(VIR_CPU_x86_HV_TLBFLUSH),\n    KVM_FEATURE(VIR_CPU_x86_HV_IPI),\n    KVM_FEATURE(VIR_CPU_x86_HV_EVMCS),\n    KVM_FEATURE(VIR_CPU_x86_HV_STIMER_DIRECT),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "x86_kvm_features[i].name",
            "name"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "x86_kvm_features"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86Feature x86_kvm_features[] =\n{\n    KVM_FEATURE(VIR_CPU_x86_KVM_PV_UNHALT),\n    KVM_FEATURE(VIR_CPU_x86_HV_RUNTIME),\n    KVM_FEATURE(VIR_CPU_x86_HV_SYNIC),\n    KVM_FEATURE(VIR_CPU_x86_HV_STIMER),\n    KVM_FEATURE(VIR_CPU_x86_HV_RELAXED),\n    KVM_FEATURE(VIR_CPU_x86_HV_VAPIC),\n    KVM_FEATURE(VIR_CPU_x86_HV_VPINDEX),\n    KVM_FEATURE(VIR_CPU_x86_HV_RESET),\n    KVM_FEATURE(VIR_CPU_x86_HV_FREQUENCIES),\n    KVM_FEATURE(VIR_CPU_x86_HV_REENLIGHTENMENT),\n    KVM_FEATURE(VIR_CPU_x86_HV_TLBFLUSH),\n    KVM_FEATURE(VIR_CPU_x86_HV_IPI),\n    KVM_FEATURE(VIR_CPU_x86_HV_EVMCS),\n    KVM_FEATURE(VIR_CPU_x86_HV_STIMER_DIRECT),\n};\n\nstatic virCPUx86FeaturePtr\nx86FeatureFindInternal(const char *name)\n{\n    size_t i;\n    size_t count = G_N_ELEMENTS(x86_kvm_features);\n\n    for (i = 0; i < count; i++) {\n        if (STREQ(x86_kvm_features[i].name, name))\n            return x86_kvm_features + i;\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "x86FeatureFind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "348-360",
    "snippet": "static virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "map->features[i]->name",
            "name"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUx86FeaturePtr\nx86FeatureFind(virCPUx86MapPtr map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nfeatures; i++) {\n        if (STREQ(map->features[i]->name, name))\n            return map->features[i];\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "virCPUx86DataItemAndBits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "312-345",
    "snippet": "static void\nvirCPUx86DataItemAndBits(virCPUx86DataItemPtr item,\n                         const virCPUx86DataItem *mask)\n{\n    virCPUx86CPUIDPtr cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    virCPUx86MSRPtr msr;\n    const virCPUx86MSR *msrMask;\n\n    if (!mask)\n        return;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        cpuid->eax &= cpuidMask->eax;\n        cpuid->ebx &= cpuidMask->ebx;\n        cpuid->ecx &= cpuidMask->ecx;\n        cpuid->edx &= cpuidMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        msr->eax &= msrMask->eax;\n        msr->edx &= msrMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataItemAndBits(virCPUx86DataItemPtr item,\n                         const virCPUx86DataItem *mask)\n{\n    virCPUx86CPUIDPtr cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    virCPUx86MSRPtr msr;\n    const virCPUx86MSR *msrMask;\n\n    if (!mask)\n        return;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        cpuid->eax &= cpuidMask->eax;\n        cpuid->ebx &= cpuidMask->ebx;\n        cpuid->ecx &= cpuidMask->ecx;\n        cpuid->edx &= cpuidMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        msr->eax &= msrMask->eax;\n        msr->edx &= msrMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n}"
  },
  {
    "function_name": "virCPUx86DataItemClearBits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "276-309",
    "snippet": "static void\nvirCPUx86DataItemClearBits(virCPUx86DataItemPtr item,\n                           const virCPUx86DataItem *mask)\n{\n    virCPUx86CPUIDPtr cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    virCPUx86MSRPtr msr;\n    const virCPUx86MSR *msrMask;\n\n    if (!mask)\n        return;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        cpuid->eax &= ~cpuidMask->eax;\n        cpuid->ebx &= ~cpuidMask->ebx;\n        cpuid->ecx &= ~cpuidMask->ecx;\n        cpuid->edx &= ~cpuidMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        msr->eax &= ~msrMask->eax;\n        msr->edx &= ~msrMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataItemClearBits(virCPUx86DataItemPtr item,\n                           const virCPUx86DataItem *mask)\n{\n    virCPUx86CPUIDPtr cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    virCPUx86MSRPtr msr;\n    const virCPUx86MSR *msrMask;\n\n    if (!mask)\n        return;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        cpuid->eax &= ~cpuidMask->eax;\n        cpuid->ebx &= ~cpuidMask->ebx;\n        cpuid->ecx &= ~cpuidMask->ecx;\n        cpuid->edx &= ~cpuidMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        msr->eax &= ~msrMask->eax;\n        msr->edx &= ~msrMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n}"
  },
  {
    "function_name": "virCPUx86DataItemSetBits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "240-273",
    "snippet": "static void\nvirCPUx86DataItemSetBits(virCPUx86DataItemPtr item,\n                         const virCPUx86DataItem *mask)\n{\n    virCPUx86CPUIDPtr cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    virCPUx86MSRPtr msr;\n    const virCPUx86MSR *msrMask;\n\n    if (!mask)\n        return;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        cpuid->eax |= cpuidMask->eax;\n        cpuid->ebx |= cpuidMask->ebx;\n        cpuid->ecx |= cpuidMask->ecx;\n        cpuid->edx |= cpuidMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        msr->eax |= msrMask->eax;\n        msr->edx |= msrMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataItemSetBits(virCPUx86DataItemPtr item,\n                         const virCPUx86DataItem *mask)\n{\n    virCPUx86CPUIDPtr cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    virCPUx86MSRPtr msr;\n    const virCPUx86MSR *msrMask;\n\n    if (!mask)\n        return;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        cpuid->eax |= cpuidMask->eax;\n        cpuid->ebx |= cpuidMask->ebx;\n        cpuid->ecx |= cpuidMask->ecx;\n        cpuid->edx |= cpuidMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        msr->eax |= msrMask->eax;\n        msr->edx |= msrMask->edx;\n        break;\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        break;\n    }\n}"
  },
  {
    "function_name": "virCPUx86DataItemMatchMasked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "209-237",
    "snippet": "static bool\nvirCPUx86DataItemMatchMasked(const virCPUx86DataItem *item,\n                             const virCPUx86DataItem *mask)\n{\n    const virCPUx86CPUID *cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    const virCPUx86MSR *msr;\n    const virCPUx86MSR *msrMask;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        return ((cpuid->eax & cpuidMask->eax) == cpuidMask->eax &&\n                (cpuid->ebx & cpuidMask->ebx) == cpuidMask->ebx &&\n                (cpuid->ecx & cpuidMask->ecx) == cpuidMask->ecx &&\n                (cpuid->edx & cpuidMask->edx) == cpuidMask->edx);\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        return ((msr->eax & msrMask->eax) == msrMask->eax &&\n                (msr->edx & msrMask->edx) == msrMask->edx);\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        return false;\n    }\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nvirCPUx86DataItemMatchMasked(const virCPUx86DataItem *item,\n                             const virCPUx86DataItem *mask)\n{\n    const virCPUx86CPUID *cpuid;\n    const virCPUx86CPUID *cpuidMask;\n    const virCPUx86MSR *msr;\n    const virCPUx86MSR *msrMask;\n\n    switch (item->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid = &item->data.cpuid;\n        cpuidMask = &mask->data.cpuid;\n        return ((cpuid->eax & cpuidMask->eax) == cpuidMask->eax &&\n                (cpuid->ebx & cpuidMask->ebx) == cpuidMask->ebx &&\n                (cpuid->ecx & cpuidMask->ecx) == cpuidMask->ecx &&\n                (cpuid->edx & cpuidMask->edx) == cpuidMask->edx);\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr = &item->data.msr;\n        msrMask = &mask->data.msr;\n        return ((msr->eax & msrMask->eax) == msrMask->eax &&\n                (msr->edx & msrMask->edx) == msrMask->edx);\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        return false;\n    }\n}"
  },
  {
    "function_name": "virCPUx86DataItemMatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "178-206",
    "snippet": "static bool\nvirCPUx86DataItemMatch(const virCPUx86DataItem *item1,\n                       const virCPUx86DataItem *item2)\n{\n    const virCPUx86CPUID *cpuid1;\n    const virCPUx86CPUID *cpuid2;\n    const virCPUx86MSR *msr1;\n    const virCPUx86MSR *msr2;\n\n    switch (item1->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid1 = &item1->data.cpuid;\n        cpuid2 = &item2->data.cpuid;\n        return (cpuid1->eax == cpuid2->eax &&\n                cpuid1->ebx == cpuid2->ebx &&\n                cpuid1->ecx == cpuid2->ecx &&\n                cpuid1->edx == cpuid2->edx);\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr1 = &item1->data.msr;\n        msr2 = &item2->data.msr;\n        return (msr1->eax == msr2->eax &&\n                msr1->edx == msr2->edx);\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        return false;\n    }\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic bool\nvirCPUx86DataItemMatch(const virCPUx86DataItem *item1,\n                       const virCPUx86DataItem *item2)\n{\n    const virCPUx86CPUID *cpuid1;\n    const virCPUx86CPUID *cpuid2;\n    const virCPUx86MSR *msr1;\n    const virCPUx86MSR *msr2;\n\n    switch (item1->type) {\n    case VIR_CPU_X86_DATA_CPUID:\n        cpuid1 = &item1->data.cpuid;\n        cpuid2 = &item2->data.cpuid;\n        return (cpuid1->eax == cpuid2->eax &&\n                cpuid1->ebx == cpuid2->ebx &&\n                cpuid1->ecx == cpuid2->ecx &&\n                cpuid1->edx == cpuid2->edx);\n\n    case VIR_CPU_X86_DATA_MSR:\n        msr1 = &item1->data.msr;\n        msr2 = &item2->data.msr;\n        return (msr1->eax == msr2->eax &&\n                msr1->edx == msr2->edx);\n\n    case VIR_CPU_X86_DATA_NONE:\n    default:\n        return false;\n    }\n}"
  },
  {
    "function_name": "virCPUx86DataIteratorInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
    "lines": "169-175",
    "snippet": "static void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}",
    "includes": [
      "#include \"virhostcpu.h\"",
      "#include \"virstring.h\"",
      "#include \"virendian.h\"",
      "#include \"virbuffer.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUx86DataIteratorInit(virCPUx86DataIteratorPtr iterator,\n                          const virCPUx86Data *data)\n{\n    virCPUx86DataIterator iter = { data, -1 };\n    *iterator = iter;\n}"
  }
]