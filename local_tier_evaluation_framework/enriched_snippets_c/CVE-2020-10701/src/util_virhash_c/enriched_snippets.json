[
  {
    "function_name": "virHashEqual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "831-851",
    "snippet": "bool virHashEqual(const virHashTable *table1,\n                  const virHashTable *table2,\n                  virHashValueComparator compar)\n{\n    struct virHashEqualData data = {\n        .equal = true,\n        .table2 = table2,\n        .compar = compar,\n    };\n\n    if (table1 == table2)\n        return true;\n\n    if (!table1 || !table2 ||\n        virHashSize(table1) != virHashSize(table2))\n        return false;\n\n    virHashSearch(table1, virHashEqualSearcher, &data, NULL);\n\n    return data.equal;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashSearch",
          "args": [
            "table1",
            "virHashEqualSearcher",
            "&data",
            "NULL"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "virHashSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "736-761",
          "snippet": "void *virHashSearch(const virHashTable *ctable,\n                    virHashSearcher iter,\n                    const void *data,\n                    void **name)\n{\n    size_t i;\n\n    /* Cast away const for internal detection of misuse.  */\n    virHashTablePtr table = (virHashTablePtr)ctable;\n\n    if (table == NULL || iter == NULL)\n        return NULL;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr entry;\n        for (entry = table->table[i]; entry; entry = entry->next) {\n            if (iter(entry->payload, entry->name, data)) {\n                if (name)\n                    *name = table->keyCopy(entry->name);\n                return entry->payload;\n            }\n        }\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *virHashSearch(const virHashTable *ctable,\n                    virHashSearcher iter,\n                    const void *data,\n                    void **name)\n{\n    size_t i;\n\n    /* Cast away const for internal detection of misuse.  */\n    virHashTablePtr table = (virHashTablePtr)ctable;\n\n    if (table == NULL || iter == NULL)\n        return NULL;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr entry;\n        for (entry = table->table[i]; entry; entry = entry->next) {\n            if (iter(entry->payload, entry->name, data)) {\n                if (name)\n                    *name = table->keyCopy(entry->name);\n                return entry->payload;\n            }\n        }\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashSize",
          "args": [
            "table2"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "virHashSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "547-553",
          "snippet": "ssize_t\nvirHashSize(const virHashTable *table)\n{\n    if (table == NULL)\n        return -1;\n    return table->nbElems;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nssize_t\nvirHashSize(const virHashTable *table)\n{\n    if (table == NULL)\n        return -1;\n    return table->nbElems;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool virHashEqual(const virHashTable *table1,\n                  const virHashTable *table2,\n                  virHashValueComparator compar)\n{\n    struct virHashEqualData data = {\n        .equal = true,\n        .table2 = table2,\n        .compar = compar,\n    };\n\n    if (table1 == table2)\n        return true;\n\n    if (!table1 || !table2 ||\n        virHashSize(table1) != virHashSize(table2))\n        return false;\n\n    virHashSearch(table1, virHashEqualSearcher, &data, NULL);\n\n    return data.equal;\n}"
  },
  {
    "function_name": "virHashEqualSearcher",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "814-829",
    "snippet": "static int virHashEqualSearcher(const void *payload, const void *name,\n                                const void *data)\n{\n    struct virHashEqualData *vhed = (void *)data;\n    const void *value;\n\n    value = virHashLookup(vhed->table2, name);\n    if (!value ||\n        vhed->compar(value, payload) != 0) {\n        /* key is missing in 2nd table or values are different */\n        vhed->equal = false;\n        /* stop 'iteration' */\n        return 1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vhed->compar",
          "args": [
            "value",
            "payload"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "vhed->table2",
            "name"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int virHashEqualSearcher(const void *payload, const void *name,\n                                const void *data)\n{\n    struct virHashEqualData *vhed = (void *)data;\n    const void *value;\n\n    value = virHashLookup(vhed->table2, name);\n    if (!value ||\n        vhed->compar(value, payload) != 0) {\n        /* key is missing in 2nd table or values are different */\n        vhed->equal = false;\n        /* stop 'iteration' */\n        return 1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virHashGetItems",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "783-805",
    "snippet": "virHashKeyValuePairPtr virHashGetItems(virHashTablePtr table,\n                                       virHashKeyComparator compar)\n{\n    ssize_t numElems = virHashSize(table);\n    struct getKeysIter iter = {\n        .arrayIdx = 0,\n        .sortArray = NULL,\n    };\n\n    if (numElems < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(iter.sortArray, numElems + 1))\n        return NULL;\n\n    virHashForEach(table, virHashGetKeysIterator, &iter);\n\n    if (compar)\n        qsort(&iter.sortArray[0], numElems, sizeof(iter.sortArray[0]),\n              (qsort_comp)compar);\n\n    return iter.sortArray;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "&iter.sortArray[0]",
            "numElems",
            "sizeof(iter.sortArray[0])",
            "(qsort_comp)compar"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashForEach",
          "args": [
            "table",
            "virHashGetKeysIterator",
            "&iter"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "virHashForEach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "626-649",
          "snippet": "int\nvirHashForEach(virHashTablePtr table, virHashIterator iter, void *data)\n{\n    size_t i;\n    int ret = -1;\n\n    if (table == NULL || iter == NULL)\n        return -1;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr entry = table->table[i];\n        while (entry) {\n            virHashEntryPtr next = entry->next;\n            ret = iter(entry->payload, entry->name, data);\n\n            if (ret < 0)\n                return ret;\n\n            entry = next;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashForEach(virHashTablePtr table, virHashIterator iter, void *data)\n{\n    size_t i;\n    int ret = -1;\n\n    if (table == NULL || iter == NULL)\n        return -1;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr entry = table->table[i];\n        while (entry) {\n            virHashEntryPtr next = entry->next;\n            ret = iter(entry->payload, entry->name, data);\n\n            if (ret < 0)\n                return ret;\n\n            entry = next;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "iter.sortArray",
            "numElems + 1"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashSize",
          "args": [
            "table"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "virHashSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "547-553",
          "snippet": "ssize_t\nvirHashSize(const virHashTable *table)\n{\n    if (table == NULL)\n        return -1;\n    return table->nbElems;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nssize_t\nvirHashSize(const virHashTable *table)\n{\n    if (table == NULL)\n        return -1;\n    return table->nbElems;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashKeyValuePairPtr virHashGetItems(virHashTablePtr table,\n                                       virHashKeyComparator compar)\n{\n    ssize_t numElems = virHashSize(table);\n    struct getKeysIter iter = {\n        .arrayIdx = 0,\n        .sortArray = NULL,\n    };\n\n    if (numElems < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(iter.sortArray, numElems + 1))\n        return NULL;\n\n    virHashForEach(table, virHashGetKeysIterator, &iter);\n\n    if (compar)\n        qsort(&iter.sortArray[0], numElems, sizeof(iter.sortArray[0]),\n              (qsort_comp)compar);\n\n    return iter.sortArray;\n}"
  },
  {
    "function_name": "virHashGetKeysIterator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "769-779",
    "snippet": "static int virHashGetKeysIterator(void *payload,\n                                  const void *key, void *data)\n{\n    struct getKeysIter *iter = data;\n\n    iter->sortArray[iter->arrayIdx].key = key;\n    iter->sortArray[iter->arrayIdx].value = payload;\n\n    iter->arrayIdx++;\n    return 0;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int virHashGetKeysIterator(void *payload,\n                                  const void *key, void *data)\n{\n    struct getKeysIter *iter = data;\n\n    iter->sortArray[iter->arrayIdx].key = key;\n    iter->sortArray[iter->arrayIdx].value = payload;\n\n    iter->arrayIdx++;\n    return 0;\n}"
  },
  {
    "function_name": "virHashSearch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "736-761",
    "snippet": "void *virHashSearch(const virHashTable *ctable,\n                    virHashSearcher iter,\n                    const void *data,\n                    void **name)\n{\n    size_t i;\n\n    /* Cast away const for internal detection of misuse.  */\n    virHashTablePtr table = (virHashTablePtr)ctable;\n\n    if (table == NULL || iter == NULL)\n        return NULL;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr entry;\n        for (entry = table->table[i]; entry; entry = entry->next) {\n            if (iter(entry->payload, entry->name, data)) {\n                if (name)\n                    *name = table->keyCopy(entry->name);\n                return entry->payload;\n            }\n        }\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "table->keyCopy",
          "args": [
            "entry->name"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter",
          "args": [
            "entry->payload",
            "entry->name",
            "data"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "virRotatingFileWriterAppend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virrotatingfile.c",
          "lines": "427-495",
          "snippet": "ssize_t\nvirRotatingFileWriterAppend(virRotatingFileWriterPtr file,\n                            const char *buf,\n                            size_t len)\n{\n    ssize_t ret = 0;\n    size_t i;\n    while (len) {\n        size_t towrite = len;\n        bool forceRollover = false;\n\n        if (file->entry->pos > file->maxlen) {\n            /* If existing file is for some reason larger then max length we\n             * won't write to this file anymore, but we rollover this file.*/\n            forceRollover = true;\n            towrite = 0;\n        } else if ((file->entry->pos + towrite) > file->maxlen) {\n            towrite = file->maxlen - file->entry->pos;\n\n            /*\n             * If there's a newline in the last 80 chars\n             * we're about to write, then break at that\n             * point to avoid splitting lines across\n             * separate files\n             */\n            for (i = 0; i < towrite && i < 80; i++) {\n                if (buf[towrite - i - 1] == '\\n') {\n                    towrite -= i;\n                    forceRollover = true;\n                    break;\n                }\n            }\n        }\n\n        if (towrite) {\n            if (safewrite(file->entry->fd, buf, towrite) != towrite) {\n                virReportSystemError(errno,\n                                     _(\"Unable to write to file %s\"),\n                                     file->basepath);\n                return -1;\n            }\n\n            len -= towrite;\n            buf += towrite;\n            ret += towrite;\n            file->entry->pos += towrite;\n            file->entry->len += towrite;\n        }\n\n        if ((file->entry->pos == file->maxlen && len) ||\n            forceRollover) {\n            virRotatingFileWriterEntryPtr tmp;\n            VIR_DEBUG(\"Hit max size %zu on %s (force=%d)\",\n                      file->maxlen, file->basepath, forceRollover);\n\n            if (virRotatingFileWriterRollover(file) < 0)\n                return -1;\n\n            if (!(tmp = virRotatingFileWriterEntryNew(file->basepath,\n                                                      file->mode)))\n                return -1;\n\n            virRotatingFileWriterEntryFree(file->entry);\n            file->entry = tmp;\n        }\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virrotatingfile.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virrotatingfile.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nssize_t\nvirRotatingFileWriterAppend(virRotatingFileWriterPtr file,\n                            const char *buf,\n                            size_t len)\n{\n    ssize_t ret = 0;\n    size_t i;\n    while (len) {\n        size_t towrite = len;\n        bool forceRollover = false;\n\n        if (file->entry->pos > file->maxlen) {\n            /* If existing file is for some reason larger then max length we\n             * won't write to this file anymore, but we rollover this file.*/\n            forceRollover = true;\n            towrite = 0;\n        } else if ((file->entry->pos + towrite) > file->maxlen) {\n            towrite = file->maxlen - file->entry->pos;\n\n            /*\n             * If there's a newline in the last 80 chars\n             * we're about to write, then break at that\n             * point to avoid splitting lines across\n             * separate files\n             */\n            for (i = 0; i < towrite && i < 80; i++) {\n                if (buf[towrite - i - 1] == '\\n') {\n                    towrite -= i;\n                    forceRollover = true;\n                    break;\n                }\n            }\n        }\n\n        if (towrite) {\n            if (safewrite(file->entry->fd, buf, towrite) != towrite) {\n                virReportSystemError(errno,\n                                     _(\"Unable to write to file %s\"),\n                                     file->basepath);\n                return -1;\n            }\n\n            len -= towrite;\n            buf += towrite;\n            ret += towrite;\n            file->entry->pos += towrite;\n            file->entry->len += towrite;\n        }\n\n        if ((file->entry->pos == file->maxlen && len) ||\n            forceRollover) {\n            virRotatingFileWriterEntryPtr tmp;\n            VIR_DEBUG(\"Hit max size %zu on %s (force=%d)\",\n                      file->maxlen, file->basepath, forceRollover);\n\n            if (virRotatingFileWriterRollover(file) < 0)\n                return -1;\n\n            if (!(tmp = virRotatingFileWriterEntryNew(file->basepath,\n                                                      file->mode)))\n                return -1;\n\n            virRotatingFileWriterEntryFree(file->entry);\n            file->entry = tmp;\n        }\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *virHashSearch(const virHashTable *ctable,\n                    virHashSearcher iter,\n                    const void *data,\n                    void **name)\n{\n    size_t i;\n\n    /* Cast away const for internal detection of misuse.  */\n    virHashTablePtr table = (virHashTablePtr)ctable;\n\n    if (table == NULL || iter == NULL)\n        return NULL;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr entry;\n        for (entry = table->table[i]; entry; entry = entry->next) {\n            if (iter(entry->payload, entry->name, data)) {\n                if (name)\n                    *name = table->keyCopy(entry->name);\n                return entry->payload;\n            }\n        }\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "virHashRemoveAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "715-721",
    "snippet": "ssize_t\nvirHashRemoveAll(virHashTablePtr table)\n{\n    return virHashRemoveSet(table,\n                            _virHashRemoveAllIter,\n                            NULL);\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashRemoveSet",
          "args": [
            "table",
            "_virHashRemoveAllIter",
            "NULL"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "virHashRemoveSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "665-696",
          "snippet": "ssize_t\nvirHashRemoveSet(virHashTablePtr table,\n                 virHashSearcher iter,\n                 const void *data)\n{\n    size_t i, count = 0;\n\n    if (table == NULL || iter == NULL)\n        return -1;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr *nextptr = table->table + i;\n\n        while (*nextptr) {\n            virHashEntryPtr entry = *nextptr;\n            if (!iter(entry->payload, entry->name, data)) {\n                nextptr = &entry->next;\n            } else {\n                count++;\n                if (table->dataFree)\n                    table->dataFree(entry->payload);\n                if (table->keyFree)\n                    table->keyFree(entry->name);\n                *nextptr = entry->next;\n                VIR_FREE(entry);\n                table->nbElems--;\n            }\n        }\n    }\n\n    return count;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nssize_t\nvirHashRemoveSet(virHashTablePtr table,\n                 virHashSearcher iter,\n                 const void *data)\n{\n    size_t i, count = 0;\n\n    if (table == NULL || iter == NULL)\n        return -1;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr *nextptr = table->table + i;\n\n        while (*nextptr) {\n            virHashEntryPtr entry = *nextptr;\n            if (!iter(entry->payload, entry->name, data)) {\n                nextptr = &entry->next;\n            } else {\n                count++;\n                if (table->dataFree)\n                    table->dataFree(entry->payload);\n                if (table->keyFree)\n                    table->keyFree(entry->name);\n                *nextptr = entry->next;\n                VIR_FREE(entry);\n                table->nbElems--;\n            }\n        }\n    }\n\n    return count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nssize_t\nvirHashRemoveAll(virHashTablePtr table)\n{\n    return virHashRemoveSet(table,\n                            _virHashRemoveAllIter,\n                            NULL);\n}"
  },
  {
    "function_name": "_virHashRemoveAllIter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "698-704",
    "snippet": "static int\n_virHashRemoveAllIter(const void *payload G_GNUC_UNUSED,\n                      const void *name G_GNUC_UNUSED,\n                      const void *data G_GNUC_UNUSED)\n{\n    return 1;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\n_virHashRemoveAllIter(const void *payload G_GNUC_UNUSED,\n                      const void *name G_GNUC_UNUSED,\n                      const void *data G_GNUC_UNUSED)\n{\n    return 1;\n}"
  },
  {
    "function_name": "virHashRemoveSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "665-696",
    "snippet": "ssize_t\nvirHashRemoveSet(virHashTablePtr table,\n                 virHashSearcher iter,\n                 const void *data)\n{\n    size_t i, count = 0;\n\n    if (table == NULL || iter == NULL)\n        return -1;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr *nextptr = table->table + i;\n\n        while (*nextptr) {\n            virHashEntryPtr entry = *nextptr;\n            if (!iter(entry->payload, entry->name, data)) {\n                nextptr = &entry->next;\n            } else {\n                count++;\n                if (table->dataFree)\n                    table->dataFree(entry->payload);\n                if (table->keyFree)\n                    table->keyFree(entry->name);\n                *nextptr = entry->next;\n                VIR_FREE(entry);\n                table->nbElems--;\n            }\n        }\n    }\n\n    return count;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "entry"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table->keyFree",
          "args": [
            "entry->name"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table->dataFree",
          "args": [
            "entry->payload"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter",
          "args": [
            "entry->payload",
            "entry->name",
            "data"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "virRotatingFileWriterAppend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virrotatingfile.c",
          "lines": "427-495",
          "snippet": "ssize_t\nvirRotatingFileWriterAppend(virRotatingFileWriterPtr file,\n                            const char *buf,\n                            size_t len)\n{\n    ssize_t ret = 0;\n    size_t i;\n    while (len) {\n        size_t towrite = len;\n        bool forceRollover = false;\n\n        if (file->entry->pos > file->maxlen) {\n            /* If existing file is for some reason larger then max length we\n             * won't write to this file anymore, but we rollover this file.*/\n            forceRollover = true;\n            towrite = 0;\n        } else if ((file->entry->pos + towrite) > file->maxlen) {\n            towrite = file->maxlen - file->entry->pos;\n\n            /*\n             * If there's a newline in the last 80 chars\n             * we're about to write, then break at that\n             * point to avoid splitting lines across\n             * separate files\n             */\n            for (i = 0; i < towrite && i < 80; i++) {\n                if (buf[towrite - i - 1] == '\\n') {\n                    towrite -= i;\n                    forceRollover = true;\n                    break;\n                }\n            }\n        }\n\n        if (towrite) {\n            if (safewrite(file->entry->fd, buf, towrite) != towrite) {\n                virReportSystemError(errno,\n                                     _(\"Unable to write to file %s\"),\n                                     file->basepath);\n                return -1;\n            }\n\n            len -= towrite;\n            buf += towrite;\n            ret += towrite;\n            file->entry->pos += towrite;\n            file->entry->len += towrite;\n        }\n\n        if ((file->entry->pos == file->maxlen && len) ||\n            forceRollover) {\n            virRotatingFileWriterEntryPtr tmp;\n            VIR_DEBUG(\"Hit max size %zu on %s (force=%d)\",\n                      file->maxlen, file->basepath, forceRollover);\n\n            if (virRotatingFileWriterRollover(file) < 0)\n                return -1;\n\n            if (!(tmp = virRotatingFileWriterEntryNew(file->basepath,\n                                                      file->mode)))\n                return -1;\n\n            virRotatingFileWriterEntryFree(file->entry);\n            file->entry = tmp;\n        }\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virrotatingfile.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virrotatingfile.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nssize_t\nvirRotatingFileWriterAppend(virRotatingFileWriterPtr file,\n                            const char *buf,\n                            size_t len)\n{\n    ssize_t ret = 0;\n    size_t i;\n    while (len) {\n        size_t towrite = len;\n        bool forceRollover = false;\n\n        if (file->entry->pos > file->maxlen) {\n            /* If existing file is for some reason larger then max length we\n             * won't write to this file anymore, but we rollover this file.*/\n            forceRollover = true;\n            towrite = 0;\n        } else if ((file->entry->pos + towrite) > file->maxlen) {\n            towrite = file->maxlen - file->entry->pos;\n\n            /*\n             * If there's a newline in the last 80 chars\n             * we're about to write, then break at that\n             * point to avoid splitting lines across\n             * separate files\n             */\n            for (i = 0; i < towrite && i < 80; i++) {\n                if (buf[towrite - i - 1] == '\\n') {\n                    towrite -= i;\n                    forceRollover = true;\n                    break;\n                }\n            }\n        }\n\n        if (towrite) {\n            if (safewrite(file->entry->fd, buf, towrite) != towrite) {\n                virReportSystemError(errno,\n                                     _(\"Unable to write to file %s\"),\n                                     file->basepath);\n                return -1;\n            }\n\n            len -= towrite;\n            buf += towrite;\n            ret += towrite;\n            file->entry->pos += towrite;\n            file->entry->len += towrite;\n        }\n\n        if ((file->entry->pos == file->maxlen && len) ||\n            forceRollover) {\n            virRotatingFileWriterEntryPtr tmp;\n            VIR_DEBUG(\"Hit max size %zu on %s (force=%d)\",\n                      file->maxlen, file->basepath, forceRollover);\n\n            if (virRotatingFileWriterRollover(file) < 0)\n                return -1;\n\n            if (!(tmp = virRotatingFileWriterEntryNew(file->basepath,\n                                                      file->mode)))\n                return -1;\n\n            virRotatingFileWriterEntryFree(file->entry);\n            file->entry = tmp;\n        }\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nssize_t\nvirHashRemoveSet(virHashTablePtr table,\n                 virHashSearcher iter,\n                 const void *data)\n{\n    size_t i, count = 0;\n\n    if (table == NULL || iter == NULL)\n        return -1;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr *nextptr = table->table + i;\n\n        while (*nextptr) {\n            virHashEntryPtr entry = *nextptr;\n            if (!iter(entry->payload, entry->name, data)) {\n                nextptr = &entry->next;\n            } else {\n                count++;\n                if (table->dataFree)\n                    table->dataFree(entry->payload);\n                if (table->keyFree)\n                    table->keyFree(entry->name);\n                *nextptr = entry->next;\n                VIR_FREE(entry);\n                table->nbElems--;\n            }\n        }\n    }\n\n    return count;\n}"
  },
  {
    "function_name": "virHashForEach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "626-649",
    "snippet": "int\nvirHashForEach(virHashTablePtr table, virHashIterator iter, void *data)\n{\n    size_t i;\n    int ret = -1;\n\n    if (table == NULL || iter == NULL)\n        return -1;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr entry = table->table[i];\n        while (entry) {\n            virHashEntryPtr next = entry->next;\n            ret = iter(entry->payload, entry->name, data);\n\n            if (ret < 0)\n                return ret;\n\n            entry = next;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iter",
          "args": [
            "entry->payload",
            "entry->name",
            "data"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "virRotatingFileWriterAppend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virrotatingfile.c",
          "lines": "427-495",
          "snippet": "ssize_t\nvirRotatingFileWriterAppend(virRotatingFileWriterPtr file,\n                            const char *buf,\n                            size_t len)\n{\n    ssize_t ret = 0;\n    size_t i;\n    while (len) {\n        size_t towrite = len;\n        bool forceRollover = false;\n\n        if (file->entry->pos > file->maxlen) {\n            /* If existing file is for some reason larger then max length we\n             * won't write to this file anymore, but we rollover this file.*/\n            forceRollover = true;\n            towrite = 0;\n        } else if ((file->entry->pos + towrite) > file->maxlen) {\n            towrite = file->maxlen - file->entry->pos;\n\n            /*\n             * If there's a newline in the last 80 chars\n             * we're about to write, then break at that\n             * point to avoid splitting lines across\n             * separate files\n             */\n            for (i = 0; i < towrite && i < 80; i++) {\n                if (buf[towrite - i - 1] == '\\n') {\n                    towrite -= i;\n                    forceRollover = true;\n                    break;\n                }\n            }\n        }\n\n        if (towrite) {\n            if (safewrite(file->entry->fd, buf, towrite) != towrite) {\n                virReportSystemError(errno,\n                                     _(\"Unable to write to file %s\"),\n                                     file->basepath);\n                return -1;\n            }\n\n            len -= towrite;\n            buf += towrite;\n            ret += towrite;\n            file->entry->pos += towrite;\n            file->entry->len += towrite;\n        }\n\n        if ((file->entry->pos == file->maxlen && len) ||\n            forceRollover) {\n            virRotatingFileWriterEntryPtr tmp;\n            VIR_DEBUG(\"Hit max size %zu on %s (force=%d)\",\n                      file->maxlen, file->basepath, forceRollover);\n\n            if (virRotatingFileWriterRollover(file) < 0)\n                return -1;\n\n            if (!(tmp = virRotatingFileWriterEntryNew(file->basepath,\n                                                      file->mode)))\n                return -1;\n\n            virRotatingFileWriterEntryFree(file->entry);\n            file->entry = tmp;\n        }\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virrotatingfile.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virrotatingfile.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nssize_t\nvirRotatingFileWriterAppend(virRotatingFileWriterPtr file,\n                            const char *buf,\n                            size_t len)\n{\n    ssize_t ret = 0;\n    size_t i;\n    while (len) {\n        size_t towrite = len;\n        bool forceRollover = false;\n\n        if (file->entry->pos > file->maxlen) {\n            /* If existing file is for some reason larger then max length we\n             * won't write to this file anymore, but we rollover this file.*/\n            forceRollover = true;\n            towrite = 0;\n        } else if ((file->entry->pos + towrite) > file->maxlen) {\n            towrite = file->maxlen - file->entry->pos;\n\n            /*\n             * If there's a newline in the last 80 chars\n             * we're about to write, then break at that\n             * point to avoid splitting lines across\n             * separate files\n             */\n            for (i = 0; i < towrite && i < 80; i++) {\n                if (buf[towrite - i - 1] == '\\n') {\n                    towrite -= i;\n                    forceRollover = true;\n                    break;\n                }\n            }\n        }\n\n        if (towrite) {\n            if (safewrite(file->entry->fd, buf, towrite) != towrite) {\n                virReportSystemError(errno,\n                                     _(\"Unable to write to file %s\"),\n                                     file->basepath);\n                return -1;\n            }\n\n            len -= towrite;\n            buf += towrite;\n            ret += towrite;\n            file->entry->pos += towrite;\n            file->entry->len += towrite;\n        }\n\n        if ((file->entry->pos == file->maxlen && len) ||\n            forceRollover) {\n            virRotatingFileWriterEntryPtr tmp;\n            VIR_DEBUG(\"Hit max size %zu on %s (force=%d)\",\n                      file->maxlen, file->basepath, forceRollover);\n\n            if (virRotatingFileWriterRollover(file) < 0)\n                return -1;\n\n            if (!(tmp = virRotatingFileWriterEntryNew(file->basepath,\n                                                      file->mode)))\n                return -1;\n\n            virRotatingFileWriterEntryFree(file->entry);\n            file->entry = tmp;\n        }\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashForEach(virHashTablePtr table, virHashIterator iter, void *data)\n{\n    size_t i;\n    int ret = -1;\n\n    if (table == NULL || iter == NULL)\n        return -1;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr entry = table->table[i];\n        while (entry) {\n            virHashEntryPtr next = entry->next;\n            ret = iter(entry->payload, entry->name, data);\n\n            if (ret < 0)\n                return ret;\n\n            entry = next;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virHashRemoveEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "584-609",
    "snippet": "int\nvirHashRemoveEntry(virHashTablePtr table, const void *name)\n{\n    virHashEntryPtr entry;\n    virHashEntryPtr *nextptr;\n\n    if (table == NULL || name == NULL)\n        return -1;\n\n    nextptr = table->table + virHashComputeKey(table, name);\n    for (entry = *nextptr; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (table->dataFree)\n                table->dataFree(entry->payload);\n            if (table->keyFree)\n                table->keyFree(entry->name);\n            *nextptr = entry->next;\n            VIR_FREE(entry);\n            table->nbElems--;\n            return 0;\n        }\n        nextptr = &entry->next;\n    }\n\n    return -1;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "entry"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table->keyFree",
          "args": [
            "entry->name"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table->dataFree",
          "args": [
            "entry->payload"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table->keyEqual",
          "args": [
            "entry->name",
            "name"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashComputeKey",
          "args": [
            "table",
            "name"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "virHashComputeKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "121-126",
          "snippet": "static size_t\nvirHashComputeKey(const virHashTable *table, const void *name)\n{\n    uint32_t value = table->keyCode(name, table->seed);\n    return value % table->size;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic size_t\nvirHashComputeKey(const virHashTable *table, const void *name)\n{\n    uint32_t value = table->keyCode(name, table->seed);\n    return value % table->size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashRemoveEntry(virHashTablePtr table, const void *name)\n{\n    virHashEntryPtr entry;\n    virHashEntryPtr *nextptr;\n\n    if (table == NULL || name == NULL)\n        return -1;\n\n    nextptr = table->table + virHashComputeKey(table, name);\n    for (entry = *nextptr; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (table->dataFree)\n                table->dataFree(entry->payload);\n            if (table->keyFree)\n                table->keyFree(entry->name);\n            *nextptr = entry->next;\n            VIR_FREE(entry);\n            table->nbElems--;\n            return 0;\n        }\n        nextptr = &entry->next;\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "virHashTableSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "564-570",
    "snippet": "ssize_t\nvirHashTableSize(const virHashTable *table)\n{\n    if (table == NULL)\n        return -1;\n    return table->size;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nssize_t\nvirHashTableSize(const virHashTable *table)\n{\n    if (table == NULL)\n        return -1;\n    return table->size;\n}"
  },
  {
    "function_name": "virHashSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "547-553",
    "snippet": "ssize_t\nvirHashSize(const virHashTable *table)\n{\n    if (table == NULL)\n        return -1;\n    return table->nbElems;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nssize_t\nvirHashSize(const virHashTable *table)\n{\n    if (table == NULL)\n        return -1;\n    return table->nbElems;\n}"
  },
  {
    "function_name": "virHashAtomicSteal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "524-535",
    "snippet": "void *\nvirHashAtomicSteal(virHashAtomicPtr table,\n                   const void *name)\n{\n    void *data;\n\n    virObjectLock(table);\n    data = virHashSteal(table->hash, name);\n    virObjectUnlock(table);\n\n    return data;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "table"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashSteal",
          "args": [
            "table->hash",
            "name"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "virHashSteal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "512-522",
          "snippet": "void *virHashSteal(virHashTablePtr table, const void *name)\n{\n    void *data = virHashLookup(table, name);\n    if (data) {\n        virHashDataFree dataFree = table->dataFree;\n        table->dataFree = NULL;\n        virHashRemoveEntry(table, name);\n        table->dataFree = dataFree;\n    }\n    return data;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *virHashSteal(virHashTablePtr table, const void *name)\n{\n    void *data = virHashLookup(table, name);\n    if (data) {\n        virHashDataFree dataFree = table->dataFree;\n        table->dataFree = NULL;\n        virHashRemoveEntry(table, name);\n        table->dataFree = dataFree;\n    }\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "table"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashAtomicSteal(virHashAtomicPtr table,\n                   const void *name)\n{\n    void *data;\n\n    virObjectLock(table);\n    data = virHashSteal(table->hash, name);\n    virObjectUnlock(table);\n\n    return data;\n}"
  },
  {
    "function_name": "virHashSteal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "512-522",
    "snippet": "void *virHashSteal(virHashTablePtr table, const void *name)\n{\n    void *data = virHashLookup(table, name);\n    if (data) {\n        virHashDataFree dataFree = table->dataFree;\n        table->dataFree = NULL;\n        virHashRemoveEntry(table, name);\n        table->dataFree = dataFree;\n    }\n    return data;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashRemoveEntry",
          "args": [
            "table",
            "name"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "virHashRemoveEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "584-609",
          "snippet": "int\nvirHashRemoveEntry(virHashTablePtr table, const void *name)\n{\n    virHashEntryPtr entry;\n    virHashEntryPtr *nextptr;\n\n    if (table == NULL || name == NULL)\n        return -1;\n\n    nextptr = table->table + virHashComputeKey(table, name);\n    for (entry = *nextptr; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (table->dataFree)\n                table->dataFree(entry->payload);\n            if (table->keyFree)\n                table->keyFree(entry->name);\n            *nextptr = entry->next;\n            VIR_FREE(entry);\n            table->nbElems--;\n            return 0;\n        }\n        nextptr = &entry->next;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashRemoveEntry(virHashTablePtr table, const void *name)\n{\n    virHashEntryPtr entry;\n    virHashEntryPtr *nextptr;\n\n    if (table == NULL || name == NULL)\n        return -1;\n\n    nextptr = table->table + virHashComputeKey(table, name);\n    for (entry = *nextptr; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (table->dataFree)\n                table->dataFree(entry->payload);\n            if (table->keyFree)\n                table->keyFree(entry->name);\n            *nextptr = entry->next;\n            VIR_FREE(entry);\n            table->nbElems--;\n            return 0;\n        }\n        nextptr = &entry->next;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "table",
            "name"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *virHashSteal(virHashTablePtr table, const void *name)\n{\n    void *data = virHashLookup(table, name);\n    if (data) {\n        virHashDataFree dataFree = table->dataFree;\n        table->dataFree = NULL;\n        virHashRemoveEntry(table, name);\n        table->dataFree = dataFree;\n    }\n    return data;\n}"
  },
  {
    "function_name": "virHashHasEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "494-499",
    "snippet": "bool\nvirHashHasEntry(const virHashTable *table,\n                const void *name)\n{\n    return !!virHashGetEntry(table, name);\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashGetEntry",
          "args": [
            "table",
            "name"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "virHashGetEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "444-461",
          "snippet": "static virHashEntryPtr\nvirHashGetEntry(const virHashTable *table,\n                const void *name)\n{\n    size_t key;\n    virHashEntryPtr entry;\n\n    if (!table || !name)\n        return NULL;\n\n    key = virHashComputeKey(table, name);\n    for (entry = table->table[key]; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name))\n            return entry;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virHashEntryPtr\nvirHashGetEntry(const virHashTable *table,\n                const void *name)\n{\n    size_t key;\n    virHashEntryPtr entry;\n\n    if (!table || !name)\n        return NULL;\n\n    key = virHashComputeKey(table, name);\n    for (entry = table->table[key]; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name))\n            return entry;\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool\nvirHashHasEntry(const virHashTable *table,\n                const void *name)\n{\n    return !!virHashGetEntry(table, name);\n}"
  },
  {
    "function_name": "virHashLookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "473-482",
    "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashGetEntry",
          "args": [
            "table",
            "name"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "virHashGetEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "444-461",
          "snippet": "static virHashEntryPtr\nvirHashGetEntry(const virHashTable *table,\n                const void *name)\n{\n    size_t key;\n    virHashEntryPtr entry;\n\n    if (!table || !name)\n        return NULL;\n\n    key = virHashComputeKey(table, name);\n    for (entry = table->table[key]; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name))\n            return entry;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virHashEntryPtr\nvirHashGetEntry(const virHashTable *table,\n                const void *name)\n{\n    size_t key;\n    virHashEntryPtr entry;\n\n    if (!table || !name)\n        return NULL;\n\n    key = virHashComputeKey(table, name);\n    for (entry = table->table[key]; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name))\n            return entry;\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
  },
  {
    "function_name": "virHashGetEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "444-461",
    "snippet": "static virHashEntryPtr\nvirHashGetEntry(const virHashTable *table,\n                const void *name)\n{\n    size_t key;\n    virHashEntryPtr entry;\n\n    if (!table || !name)\n        return NULL;\n\n    key = virHashComputeKey(table, name);\n    for (entry = table->table[key]; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name))\n            return entry;\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "table->keyEqual",
          "args": [
            "entry->name",
            "name"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashComputeKey",
          "args": [
            "table",
            "name"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "virHashComputeKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "121-126",
          "snippet": "static size_t\nvirHashComputeKey(const virHashTable *table, const void *name)\n{\n    uint32_t value = table->keyCode(name, table->seed);\n    return value % table->size;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic size_t\nvirHashComputeKey(const virHashTable *table, const void *name)\n{\n    uint32_t value = table->keyCode(name, table->seed);\n    return value % table->size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virHashEntryPtr\nvirHashGetEntry(const virHashTable *table,\n                const void *name)\n{\n    size_t key;\n    virHashEntryPtr entry;\n\n    if (!table || !name)\n        return NULL;\n\n    key = virHashComputeKey(table, name);\n    for (entry = table->table[key]; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name))\n            return entry;\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "virHashAtomicUpdate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "429-441",
    "snippet": "int\nvirHashAtomicUpdate(virHashAtomicPtr table,\n                    const void *name,\n                    void *userdata)\n{\n    int ret;\n\n    virObjectLock(table);\n    ret = virHashAddOrUpdateEntry(table->hash, name, userdata, true);\n    virObjectUnlock(table);\n\n    return ret;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "table"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashAddOrUpdateEntry",
          "args": [
            "table->hash",
            "name",
            "userdata",
            "true"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddOrUpdateEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "339-391",
          "snippet": "static int\nvirHashAddOrUpdateEntry(virHashTablePtr table, const void *name,\n                        void *userdata,\n                        bool is_update)\n{\n    size_t key, len = 0;\n    virHashEntryPtr entry;\n    virHashEntryPtr last = NULL;\n\n    if ((table == NULL) || (name == NULL))\n        return -1;\n\n    key = virHashComputeKey(table, name);\n\n    /* Check for duplicate entry */\n    for (entry = table->table[key]; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (is_update) {\n                if (table->dataFree)\n                    table->dataFree(entry->payload);\n                entry->payload = userdata;\n                return 0;\n            } else {\n                g_autofree char *keystr = NULL;\n\n                if (table->keyPrint)\n                    keystr = table->keyPrint(name);\n\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Duplicate hash table key '%s'\"), NULLSTR(keystr));\n                return -1;\n            }\n        }\n        last = entry;\n        len++;\n    }\n\n    entry = g_new0(virHashEntry, 1);\n    entry->name = table->keyCopy(name);\n    entry->payload = userdata;\n\n    if (last)\n        last->next = entry;\n    else\n        table->table[key] = entry;\n\n    table->nbElems++;\n\n    if (len > MAX_HASH_LEN)\n        virHashGrow(table, MAX_HASH_LEN * table->size);\n\n    return 0;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_HASH_LEN 8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\n#define MAX_HASH_LEN 8\n\nstatic int\nvirHashAddOrUpdateEntry(virHashTablePtr table, const void *name,\n                        void *userdata,\n                        bool is_update)\n{\n    size_t key, len = 0;\n    virHashEntryPtr entry;\n    virHashEntryPtr last = NULL;\n\n    if ((table == NULL) || (name == NULL))\n        return -1;\n\n    key = virHashComputeKey(table, name);\n\n    /* Check for duplicate entry */\n    for (entry = table->table[key]; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (is_update) {\n                if (table->dataFree)\n                    table->dataFree(entry->payload);\n                entry->payload = userdata;\n                return 0;\n            } else {\n                g_autofree char *keystr = NULL;\n\n                if (table->keyPrint)\n                    keystr = table->keyPrint(name);\n\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Duplicate hash table key '%s'\"), NULLSTR(keystr));\n                return -1;\n            }\n        }\n        last = entry;\n        len++;\n    }\n\n    entry = g_new0(virHashEntry, 1);\n    entry->name = table->keyCopy(name);\n    entry->payload = userdata;\n\n    if (last)\n        last->next = entry;\n    else\n        table->table[key] = entry;\n\n    table->nbElems++;\n\n    if (len > MAX_HASH_LEN)\n        virHashGrow(table, MAX_HASH_LEN * table->size);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "table"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAtomicUpdate(virHashAtomicPtr table,\n                    const void *name,\n                    void *userdata)\n{\n    int ret;\n\n    virObjectLock(table);\n    ret = virHashAddOrUpdateEntry(table->hash, name, userdata, true);\n    virObjectUnlock(table);\n\n    return ret;\n}"
  },
  {
    "function_name": "virHashUpdateEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "422-427",
    "snippet": "int\nvirHashUpdateEntry(virHashTablePtr table, const void *name,\n                   void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, true);\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashAddOrUpdateEntry",
          "args": [
            "table",
            "name",
            "userdata",
            "true"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddOrUpdateEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "339-391",
          "snippet": "static int\nvirHashAddOrUpdateEntry(virHashTablePtr table, const void *name,\n                        void *userdata,\n                        bool is_update)\n{\n    size_t key, len = 0;\n    virHashEntryPtr entry;\n    virHashEntryPtr last = NULL;\n\n    if ((table == NULL) || (name == NULL))\n        return -1;\n\n    key = virHashComputeKey(table, name);\n\n    /* Check for duplicate entry */\n    for (entry = table->table[key]; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (is_update) {\n                if (table->dataFree)\n                    table->dataFree(entry->payload);\n                entry->payload = userdata;\n                return 0;\n            } else {\n                g_autofree char *keystr = NULL;\n\n                if (table->keyPrint)\n                    keystr = table->keyPrint(name);\n\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Duplicate hash table key '%s'\"), NULLSTR(keystr));\n                return -1;\n            }\n        }\n        last = entry;\n        len++;\n    }\n\n    entry = g_new0(virHashEntry, 1);\n    entry->name = table->keyCopy(name);\n    entry->payload = userdata;\n\n    if (last)\n        last->next = entry;\n    else\n        table->table[key] = entry;\n\n    table->nbElems++;\n\n    if (len > MAX_HASH_LEN)\n        virHashGrow(table, MAX_HASH_LEN * table->size);\n\n    return 0;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_HASH_LEN 8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\n#define MAX_HASH_LEN 8\n\nstatic int\nvirHashAddOrUpdateEntry(virHashTablePtr table, const void *name,\n                        void *userdata,\n                        bool is_update)\n{\n    size_t key, len = 0;\n    virHashEntryPtr entry;\n    virHashEntryPtr last = NULL;\n\n    if ((table == NULL) || (name == NULL))\n        return -1;\n\n    key = virHashComputeKey(table, name);\n\n    /* Check for duplicate entry */\n    for (entry = table->table[key]; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (is_update) {\n                if (table->dataFree)\n                    table->dataFree(entry->payload);\n                entry->payload = userdata;\n                return 0;\n            } else {\n                g_autofree char *keystr = NULL;\n\n                if (table->keyPrint)\n                    keystr = table->keyPrint(name);\n\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Duplicate hash table key '%s'\"), NULLSTR(keystr));\n                return -1;\n            }\n        }\n        last = entry;\n        len++;\n    }\n\n    entry = g_new0(virHashEntry, 1);\n    entry->name = table->keyCopy(name);\n    entry->payload = userdata;\n\n    if (last)\n        last->next = entry;\n    else\n        table->table[key] = entry;\n\n    table->nbElems++;\n\n    if (len > MAX_HASH_LEN)\n        virHashGrow(table, MAX_HASH_LEN * table->size);\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashUpdateEntry(virHashTablePtr table, const void *name,\n                   void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, true);\n}"
  },
  {
    "function_name": "virHashAddEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "404-408",
    "snippet": "int\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashAddOrUpdateEntry",
          "args": [
            "table",
            "name",
            "userdata",
            "false"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddOrUpdateEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "339-391",
          "snippet": "static int\nvirHashAddOrUpdateEntry(virHashTablePtr table, const void *name,\n                        void *userdata,\n                        bool is_update)\n{\n    size_t key, len = 0;\n    virHashEntryPtr entry;\n    virHashEntryPtr last = NULL;\n\n    if ((table == NULL) || (name == NULL))\n        return -1;\n\n    key = virHashComputeKey(table, name);\n\n    /* Check for duplicate entry */\n    for (entry = table->table[key]; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (is_update) {\n                if (table->dataFree)\n                    table->dataFree(entry->payload);\n                entry->payload = userdata;\n                return 0;\n            } else {\n                g_autofree char *keystr = NULL;\n\n                if (table->keyPrint)\n                    keystr = table->keyPrint(name);\n\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Duplicate hash table key '%s'\"), NULLSTR(keystr));\n                return -1;\n            }\n        }\n        last = entry;\n        len++;\n    }\n\n    entry = g_new0(virHashEntry, 1);\n    entry->name = table->keyCopy(name);\n    entry->payload = userdata;\n\n    if (last)\n        last->next = entry;\n    else\n        table->table[key] = entry;\n\n    table->nbElems++;\n\n    if (len > MAX_HASH_LEN)\n        virHashGrow(table, MAX_HASH_LEN * table->size);\n\n    return 0;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_HASH_LEN 8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\n#define MAX_HASH_LEN 8\n\nstatic int\nvirHashAddOrUpdateEntry(virHashTablePtr table, const void *name,\n                        void *userdata,\n                        bool is_update)\n{\n    size_t key, len = 0;\n    virHashEntryPtr entry;\n    virHashEntryPtr last = NULL;\n\n    if ((table == NULL) || (name == NULL))\n        return -1;\n\n    key = virHashComputeKey(table, name);\n\n    /* Check for duplicate entry */\n    for (entry = table->table[key]; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (is_update) {\n                if (table->dataFree)\n                    table->dataFree(entry->payload);\n                entry->payload = userdata;\n                return 0;\n            } else {\n                g_autofree char *keystr = NULL;\n\n                if (table->keyPrint)\n                    keystr = table->keyPrint(name);\n\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Duplicate hash table key '%s'\"), NULLSTR(keystr));\n                return -1;\n            }\n        }\n        last = entry;\n        len++;\n    }\n\n    entry = g_new0(virHashEntry, 1);\n    entry->name = table->keyCopy(name);\n    entry->payload = userdata;\n\n    if (last)\n        last->next = entry;\n    else\n        table->table[key] = entry;\n\n    table->nbElems++;\n\n    if (len > MAX_HASH_LEN)\n        virHashGrow(table, MAX_HASH_LEN * table->size);\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}"
  },
  {
    "function_name": "virHashAddOrUpdateEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "339-391",
    "snippet": "static int\nvirHashAddOrUpdateEntry(virHashTablePtr table, const void *name,\n                        void *userdata,\n                        bool is_update)\n{\n    size_t key, len = 0;\n    virHashEntryPtr entry;\n    virHashEntryPtr last = NULL;\n\n    if ((table == NULL) || (name == NULL))\n        return -1;\n\n    key = virHashComputeKey(table, name);\n\n    /* Check for duplicate entry */\n    for (entry = table->table[key]; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (is_update) {\n                if (table->dataFree)\n                    table->dataFree(entry->payload);\n                entry->payload = userdata;\n                return 0;\n            } else {\n                g_autofree char *keystr = NULL;\n\n                if (table->keyPrint)\n                    keystr = table->keyPrint(name);\n\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Duplicate hash table key '%s'\"), NULLSTR(keystr));\n                return -1;\n            }\n        }\n        last = entry;\n        len++;\n    }\n\n    entry = g_new0(virHashEntry, 1);\n    entry->name = table->keyCopy(name);\n    entry->payload = userdata;\n\n    if (last)\n        last->next = entry;\n    else\n        table->table[key] = entry;\n\n    table->nbElems++;\n\n    if (len > MAX_HASH_LEN)\n        virHashGrow(table, MAX_HASH_LEN * table->size);\n\n    return 0;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define MAX_HASH_LEN 8"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashGrow",
          "args": [
            "table",
            "MAX_HASH_LEN * table->size"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "virHashGrow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "252-304",
          "snippet": "static int\nvirHashGrow(virHashTablePtr table, size_t size)\n{\n    size_t oldsize, i;\n    virHashEntryPtr *oldtable;\n\n#ifdef DEBUG_GROW\n    size_t nbElem = 0;\n#endif\n\n    if (table == NULL)\n        return -1;\n    if (size < 8)\n        return -1;\n    if (size > 8 * 2048)\n        return -1;\n\n    oldsize = table->size;\n    oldtable = table->table;\n    if (oldtable == NULL)\n        return -1;\n\n    if (VIR_ALLOC_N(table->table, size) < 0) {\n        table->table = oldtable;\n        return -1;\n    }\n    table->size = size;\n\n    for (i = 0; i < oldsize; i++) {\n        virHashEntryPtr iter = oldtable[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n            size_t key = virHashComputeKey(table, iter->name);\n\n            iter->next = table->table[key];\n            table->table[key] = iter;\n\n#ifdef DEBUG_GROW\n            nbElem++;\n#endif\n            iter = next;\n        }\n    }\n\n    VIR_FREE(oldtable);\n\n#ifdef DEBUG_GROW\n    VIR_DEBUG(\"virHashGrow : from %d to %d, %ld elems\", oldsize,\n              size, nbElem);\n#endif\n\n    return 0;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirHashGrow(virHashTablePtr table, size_t size)\n{\n    size_t oldsize, i;\n    virHashEntryPtr *oldtable;\n\n#ifdef DEBUG_GROW\n    size_t nbElem = 0;\n#endif\n\n    if (table == NULL)\n        return -1;\n    if (size < 8)\n        return -1;\n    if (size > 8 * 2048)\n        return -1;\n\n    oldsize = table->size;\n    oldtable = table->table;\n    if (oldtable == NULL)\n        return -1;\n\n    if (VIR_ALLOC_N(table->table, size) < 0) {\n        table->table = oldtable;\n        return -1;\n    }\n    table->size = size;\n\n    for (i = 0; i < oldsize; i++) {\n        virHashEntryPtr iter = oldtable[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n            size_t key = virHashComputeKey(table, iter->name);\n\n            iter->next = table->table[key];\n            table->table[key] = iter;\n\n#ifdef DEBUG_GROW\n            nbElem++;\n#endif\n            iter = next;\n        }\n    }\n\n    VIR_FREE(oldtable);\n\n#ifdef DEBUG_GROW\n    VIR_DEBUG(\"virHashGrow : from %d to %d, %ld elems\", oldsize,\n              size, nbElem);\n#endif\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "table->keyCopy",
          "args": [
            "name"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virHashEntry",
            "1"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Duplicate hash table key '%s'\")",
            "NULLSTR(keystr)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "keystr"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Duplicate hash table key '%s'\""
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "table->keyPrint",
          "args": [
            "name"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table->dataFree",
          "args": [
            "entry->payload"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table->keyEqual",
          "args": [
            "entry->name",
            "name"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashComputeKey",
          "args": [
            "table",
            "name"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "virHashComputeKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "121-126",
          "snippet": "static size_t\nvirHashComputeKey(const virHashTable *table, const void *name)\n{\n    uint32_t value = table->keyCode(name, table->seed);\n    return value % table->size;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic size_t\nvirHashComputeKey(const virHashTable *table, const void *name)\n{\n    uint32_t value = table->keyCode(name, table->seed);\n    return value % table->size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\n#define MAX_HASH_LEN 8\n\nstatic int\nvirHashAddOrUpdateEntry(virHashTablePtr table, const void *name,\n                        void *userdata,\n                        bool is_update)\n{\n    size_t key, len = 0;\n    virHashEntryPtr entry;\n    virHashEntryPtr last = NULL;\n\n    if ((table == NULL) || (name == NULL))\n        return -1;\n\n    key = virHashComputeKey(table, name);\n\n    /* Check for duplicate entry */\n    for (entry = table->table[key]; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (is_update) {\n                if (table->dataFree)\n                    table->dataFree(entry->payload);\n                entry->payload = userdata;\n                return 0;\n            } else {\n                g_autofree char *keystr = NULL;\n\n                if (table->keyPrint)\n                    keystr = table->keyPrint(name);\n\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Duplicate hash table key '%s'\"), NULLSTR(keystr));\n                return -1;\n            }\n        }\n        last = entry;\n        len++;\n    }\n\n    entry = g_new0(virHashEntry, 1);\n    entry->name = table->keyCopy(name);\n    entry->payload = userdata;\n\n    if (last)\n        last->next = entry;\n    else\n        table->table[key] = entry;\n\n    table->nbElems++;\n\n    if (len > MAX_HASH_LEN)\n        virHashGrow(table, MAX_HASH_LEN * table->size);\n\n    return 0;\n}"
  },
  {
    "function_name": "virHashFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "313-337",
    "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "table"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "table->table"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "iter"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table->keyFree",
          "args": [
            "iter->name"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table->dataFree",
          "args": [
            "iter->payload"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
  },
  {
    "function_name": "virHashGrow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "252-304",
    "snippet": "static int\nvirHashGrow(virHashTablePtr table, size_t size)\n{\n    size_t oldsize, i;\n    virHashEntryPtr *oldtable;\n\n#ifdef DEBUG_GROW\n    size_t nbElem = 0;\n#endif\n\n    if (table == NULL)\n        return -1;\n    if (size < 8)\n        return -1;\n    if (size > 8 * 2048)\n        return -1;\n\n    oldsize = table->size;\n    oldtable = table->table;\n    if (oldtable == NULL)\n        return -1;\n\n    if (VIR_ALLOC_N(table->table, size) < 0) {\n        table->table = oldtable;\n        return -1;\n    }\n    table->size = size;\n\n    for (i = 0; i < oldsize; i++) {\n        virHashEntryPtr iter = oldtable[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n            size_t key = virHashComputeKey(table, iter->name);\n\n            iter->next = table->table[key];\n            table->table[key] = iter;\n\n#ifdef DEBUG_GROW\n            nbElem++;\n#endif\n            iter = next;\n        }\n    }\n\n    VIR_FREE(oldtable);\n\n#ifdef DEBUG_GROW\n    VIR_DEBUG(\"virHashGrow : from %d to %d, %ld elems\", oldsize,\n              size, nbElem);\n#endif\n\n    return 0;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"virHashGrow : from %d to %d, %ld elems\"",
            "oldsize",
            "size",
            "nbElem"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "oldtable"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashComputeKey",
          "args": [
            "table",
            "iter->name"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "virHashComputeKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "121-126",
          "snippet": "static size_t\nvirHashComputeKey(const virHashTable *table, const void *name)\n{\n    uint32_t value = table->keyCode(name, table->seed);\n    return value % table->size;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic size_t\nvirHashComputeKey(const virHashTable *table, const void *name)\n{\n    uint32_t value = table->keyCode(name, table->seed);\n    return value % table->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "table->table",
            "size"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirHashGrow(virHashTablePtr table, size_t size)\n{\n    size_t oldsize, i;\n    virHashEntryPtr *oldtable;\n\n#ifdef DEBUG_GROW\n    size_t nbElem = 0;\n#endif\n\n    if (table == NULL)\n        return -1;\n    if (size < 8)\n        return -1;\n    if (size > 8 * 2048)\n        return -1;\n\n    oldsize = table->size;\n    oldtable = table->table;\n    if (oldtable == NULL)\n        return -1;\n\n    if (VIR_ALLOC_N(table->table, size) < 0) {\n        table->table = oldtable;\n        return -1;\n    }\n    table->size = size;\n\n    for (i = 0; i < oldsize; i++) {\n        virHashEntryPtr iter = oldtable[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n            size_t key = virHashComputeKey(table, iter->name);\n\n            iter->next = table->table[key];\n            table->table[key] = iter;\n\n#ifdef DEBUG_GROW\n            nbElem++;\n#endif\n            iter = next;\n        }\n    }\n\n    VIR_FREE(oldtable);\n\n#ifdef DEBUG_GROW\n    VIR_DEBUG(\"virHashGrow : from %d to %d, %ld elems\", oldsize,\n              size, nbElem);\n#endif\n\n    return 0;\n}"
  },
  {
    "function_name": "virHashAtomicDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "234-240",
    "snippet": "static void\nvirHashAtomicDispose(void *obj)\n{\n    virHashAtomicPtr hash = obj;\n\n    virHashFree(hash->hash);\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virHashAtomicDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "hash->hash"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic void virHashAtomicDispose(void *obj);\n\nstatic void\nvirHashAtomicDispose(void *obj)\n{\n    virHashAtomicPtr hash = obj;\n\n    virHashFree(hash->hash);\n}"
  },
  {
    "function_name": "virHashAtomicNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "214-231",
    "snippet": "virHashAtomicPtr\nvirHashAtomicNew(ssize_t size,\n                 virHashDataFree dataFree)\n{\n    virHashAtomicPtr hash;\n\n    if (virHashAtomicInitialize() < 0)\n        return NULL;\n\n    if (!(hash = virObjectLockableNew(virHashAtomicClass)))\n        return NULL;\n\n    if (!(hash->hash = virHashCreate(size, dataFree))) {\n        virObjectUnref(hash);\n        return NULL;\n    }\n    return hash;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virHashAtomicClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "hash"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "size",
            "dataFree"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "virHashAtomicClass"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashAtomicInitialize",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virClassPtr virHashAtomicClass;\n\nvirHashAtomicPtr\nvirHashAtomicNew(ssize_t size,\n                 virHashDataFree dataFree)\n{\n    virHashAtomicPtr hash;\n\n    if (virHashAtomicInitialize() < 0)\n        return NULL;\n\n    if (!(hash = virObjectLockableNew(virHashAtomicClass)))\n        return NULL;\n\n    if (!(hash->hash = virHashCreate(size, dataFree))) {\n        virObjectUnref(hash);\n        return NULL;\n    }\n    return hash;\n}"
  },
  {
    "function_name": "virHashCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "202-211",
    "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashCreateFull",
          "args": [
            "size",
            "dataFree",
            "virHashStrCode",
            "virHashStrEqual",
            "virHashStrCopy",
            "virHashStrPrintHuman",
            "virHashStrFree"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreateFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "141-169",
          "snippet": "virHashTablePtr virHashCreateFull(ssize_t size,\n                                  virHashDataFree dataFree,\n                                  virHashKeyCode keyCode,\n                                  virHashKeyEqual keyEqual,\n                                  virHashKeyCopy keyCopy,\n                                  virHashKeyPrintHuman keyPrint,\n                                  virHashKeyFree keyFree)\n{\n    virHashTablePtr table = NULL;\n\n    if (size <= 0)\n        size = 256;\n\n    table = g_new0(virHashTable, 1);\n\n    table->seed = virRandomBits(32);\n    table->size = size;\n    table->nbElems = 0;\n    table->dataFree = dataFree;\n    table->keyCode = keyCode;\n    table->keyEqual = keyEqual;\n    table->keyCopy = keyCopy;\n    table->keyPrint = keyPrint;\n    table->keyFree = keyFree;\n\n    table->table = g_new0(virHashEntryPtr, table->size);\n\n    return table;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreateFull(ssize_t size,\n                                  virHashDataFree dataFree,\n                                  virHashKeyCode keyCode,\n                                  virHashKeyEqual keyEqual,\n                                  virHashKeyCopy keyCopy,\n                                  virHashKeyPrintHuman keyPrint,\n                                  virHashKeyFree keyFree)\n{\n    virHashTablePtr table = NULL;\n\n    if (size <= 0)\n        size = 256;\n\n    table = g_new0(virHashTable, 1);\n\n    table->seed = virRandomBits(32);\n    table->size = size;\n    table->nbElems = 0;\n    table->dataFree = dataFree;\n    table->keyCode = keyCode;\n    table->keyEqual = keyEqual;\n    table->keyCopy = keyCopy;\n    table->keyPrint = keyPrint;\n    table->keyFree = keyFree;\n\n    table->table = g_new0(virHashEntryPtr, table->size);\n\n    return table;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
  },
  {
    "function_name": "virHashNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "180-190",
    "snippet": "virHashTablePtr\nvirHashNew(virHashDataFree dataFree)\n{\n    return virHashCreateFull(32,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashCreateFull",
          "args": [
            "32",
            "dataFree",
            "virHashStrCode",
            "virHashStrEqual",
            "virHashStrCopy",
            "virHashStrPrintHuman",
            "virHashStrFree"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreateFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "141-169",
          "snippet": "virHashTablePtr virHashCreateFull(ssize_t size,\n                                  virHashDataFree dataFree,\n                                  virHashKeyCode keyCode,\n                                  virHashKeyEqual keyEqual,\n                                  virHashKeyCopy keyCopy,\n                                  virHashKeyPrintHuman keyPrint,\n                                  virHashKeyFree keyFree)\n{\n    virHashTablePtr table = NULL;\n\n    if (size <= 0)\n        size = 256;\n\n    table = g_new0(virHashTable, 1);\n\n    table->seed = virRandomBits(32);\n    table->size = size;\n    table->nbElems = 0;\n    table->dataFree = dataFree;\n    table->keyCode = keyCode;\n    table->keyEqual = keyEqual;\n    table->keyCopy = keyCopy;\n    table->keyPrint = keyPrint;\n    table->keyFree = keyFree;\n\n    table->table = g_new0(virHashEntryPtr, table->size);\n\n    return table;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreateFull(ssize_t size,\n                                  virHashDataFree dataFree,\n                                  virHashKeyCode keyCode,\n                                  virHashKeyEqual keyEqual,\n                                  virHashKeyCopy keyCopy,\n                                  virHashKeyPrintHuman keyPrint,\n                                  virHashKeyFree keyFree)\n{\n    virHashTablePtr table = NULL;\n\n    if (size <= 0)\n        size = 256;\n\n    table = g_new0(virHashTable, 1);\n\n    table->seed = virRandomBits(32);\n    table->size = size;\n    table->nbElems = 0;\n    table->dataFree = dataFree;\n    table->keyCode = keyCode;\n    table->keyEqual = keyEqual;\n    table->keyCopy = keyCopy;\n    table->keyPrint = keyPrint;\n    table->keyFree = keyFree;\n\n    table->table = g_new0(virHashEntryPtr, table->size);\n\n    return table;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr\nvirHashNew(virHashDataFree dataFree)\n{\n    return virHashCreateFull(32,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
  },
  {
    "function_name": "virHashCreateFull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "141-169",
    "snippet": "virHashTablePtr virHashCreateFull(ssize_t size,\n                                  virHashDataFree dataFree,\n                                  virHashKeyCode keyCode,\n                                  virHashKeyEqual keyEqual,\n                                  virHashKeyCopy keyCopy,\n                                  virHashKeyPrintHuman keyPrint,\n                                  virHashKeyFree keyFree)\n{\n    virHashTablePtr table = NULL;\n\n    if (size <= 0)\n        size = 256;\n\n    table = g_new0(virHashTable, 1);\n\n    table->seed = virRandomBits(32);\n    table->size = size;\n    table->nbElems = 0;\n    table->dataFree = dataFree;\n    table->keyCode = keyCode;\n    table->keyEqual = keyEqual;\n    table->keyCopy = keyCopy;\n    table->keyPrint = keyPrint;\n    table->keyFree = keyFree;\n\n    table->table = g_new0(virHashEntryPtr, table->size);\n\n    return table;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virHashEntryPtr",
            "table->size"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virRandomBits",
          "args": [
            "32"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "virRandomBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virrandom.c",
          "lines": "50-64",
          "snippet": "uint64_t virRandomBits(int nbits)\n{\n    uint64_t ret = 0;\n\n    if (virRandomBytes((unsigned char *) &ret, sizeof(ret)) < 0) {\n        /* You're already hosed, so this particular non-random value\n         * isn't any worse.  */\n        return 0;\n    }\n\n    if (nbits < 64)\n        ret &= (1ULL << nbits) - 1;\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virrandom.h\"",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <inttypes.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virrandom.h\"\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <time.h>\n#include <math.h>\n#include <inttypes.h>\n#include <config.h>\n\nuint64_t virRandomBits(int nbits)\n{\n    uint64_t ret = 0;\n\n    if (virRandomBytes((unsigned char *) &ret, sizeof(ret)) < 0) {\n        /* You're already hosed, so this particular non-random value\n         * isn't any worse.  */\n        return 0;\n    }\n\n    if (nbits < 64)\n        ret &= (1ULL << nbits) - 1;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virHashTable",
            "1"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreateFull(ssize_t size,\n                                  virHashDataFree dataFree,\n                                  virHashKeyCode keyCode,\n                                  virHashKeyEqual keyEqual,\n                                  virHashKeyCopy keyCopy,\n                                  virHashKeyPrintHuman keyPrint,\n                                  virHashKeyFree keyFree)\n{\n    virHashTablePtr table = NULL;\n\n    if (size <= 0)\n        size = 256;\n\n    table = g_new0(virHashTable, 1);\n\n    table->seed = virRandomBits(32);\n    table->size = size;\n    table->nbElems = 0;\n    table->dataFree = dataFree;\n    table->keyCode = keyCode;\n    table->keyEqual = keyEqual;\n    table->keyCopy = keyCopy;\n    table->keyPrint = keyPrint;\n    table->keyFree = keyFree;\n\n    table->table = g_new0(virHashEntryPtr, table->size);\n\n    return table;\n}"
  },
  {
    "function_name": "virHashComputeKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "121-126",
    "snippet": "static size_t\nvirHashComputeKey(const virHashTable *table, const void *name)\n{\n    uint32_t value = table->keyCode(name, table->seed);\n    return value % table->size;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "table->keyCode",
          "args": [
            "name",
            "table->seed"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic size_t\nvirHashComputeKey(const virHashTable *table, const void *name)\n{\n    uint32_t value = table->keyCode(name, table->seed);\n    return value % table->size;\n}"
  },
  {
    "function_name": "virHashValueFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "114-118",
    "snippet": "void\nvirHashValueFree(void *value)\n{\n    VIR_FREE(value);\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "value"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashValueFree(void *value)\n{\n    VIR_FREE(value);\n}"
  },
  {
    "function_name": "virHashStrFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "108-111",
    "snippet": "static void virHashStrFree(void *name)\n{\n    VIR_FREE(name);\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic void virHashStrFree(void *name)\n{\n    VIR_FREE(name);\n}"
  },
  {
    "function_name": "virHashStrPrintHuman",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "101-105",
    "snippet": "static char *\nvirHashStrPrintHuman(const void *name)\n{\n    return g_strdup(name);\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "name"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic char *\nvirHashStrPrintHuman(const void *name)\n{\n    return g_strdup(name);\n}"
  },
  {
    "function_name": "virHashStrCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "95-98",
    "snippet": "static void *virHashStrCopy(const void *name)\n{\n    return g_strdup(name);\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "name"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic void *virHashStrCopy(const void *name)\n{\n    return g_strdup(name);\n}"
  },
  {
    "function_name": "virHashStrEqual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "90-93",
    "snippet": "static bool virHashStrEqual(const void *namea, const void *nameb)\n{\n    return STREQ(namea, nameb);\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "namea",
            "nameb"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic bool virHashStrEqual(const void *namea, const void *nameb)\n{\n    return STREQ(namea, nameb);\n}"
  },
  {
    "function_name": "virHashStrCode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "85-88",
    "snippet": "static uint32_t virHashStrCode(const void *name, uint32_t seed)\n{\n    return virHashCodeGen(name, strlen(name), seed);\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashCodeGen",
          "args": [
            "name",
            "strlen(name)",
            "seed"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCodeGen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhashcode.c",
          "lines": "63-125",
          "snippet": "uint32_t virHashCodeGen(const void *key, size_t len, uint32_t seed)\n{\n    const uint8_t *blocks;\n    const uint8_t *tail;\n    size_t nblocks;\n    uint32_t h1;\n    uint32_t k1;\n    uint32_t c1;\n    uint32_t c2;\n    size_t i;\n\n    blocks = (const uint8_t *)key;\n    nblocks = len / 4;\n    h1 = seed;\n    c1 = 0xcc9e2d51;\n    c2 = 0x1b873593;\n\n    /* body */\n\n    for (i = 0; i < nblocks; i++) {\n\n        k1 = getblock(blocks, i);\n\n        k1 *= c1;\n        k1 = rotl32(k1, 15);\n        k1 *= c2;\n\n        h1 ^= k1;\n        h1 = rotl32(h1, 13);\n        h1 = h1 * 5 + 0xe6546b64;\n    }\n\n    /* tail */\n\n    tail = (const uint8_t *)key + nblocks * 4;\n\n    k1 = 0;\n\n    switch (len & 3) {\n    case 3:\n        k1 ^= tail[2] << 16;\n        G_GNUC_FALLTHROUGH;\n    case 2:\n        k1 ^= tail[1] << 8;\n        G_GNUC_FALLTHROUGH;\n    case 1:\n        k1 ^= tail[0];\n        k1 *= c1;\n        k1 = rotl32(k1, 15);\n        k1 *= c2;\n        h1 ^= k1;\n        G_GNUC_FALLTHROUGH;\n    default:\n        break;\n    }\n\n    /* finalization */\n\n    h1 ^= len;\n    h1 = fmix(h1);\n\n    return h1;\n}",
          "includes": [
            "#include \"virhashcode.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhashcode.h\"\n#include <config.h>\n\nuint32_t virHashCodeGen(const void *key, size_t len, uint32_t seed)\n{\n    const uint8_t *blocks;\n    const uint8_t *tail;\n    size_t nblocks;\n    uint32_t h1;\n    uint32_t k1;\n    uint32_t c1;\n    uint32_t c2;\n    size_t i;\n\n    blocks = (const uint8_t *)key;\n    nblocks = len / 4;\n    h1 = seed;\n    c1 = 0xcc9e2d51;\n    c2 = 0x1b873593;\n\n    /* body */\n\n    for (i = 0; i < nblocks; i++) {\n\n        k1 = getblock(blocks, i);\n\n        k1 *= c1;\n        k1 = rotl32(k1, 15);\n        k1 *= c2;\n\n        h1 ^= k1;\n        h1 = rotl32(h1, 13);\n        h1 = h1 * 5 + 0xe6546b64;\n    }\n\n    /* tail */\n\n    tail = (const uint8_t *)key + nblocks * 4;\n\n    k1 = 0;\n\n    switch (len & 3) {\n    case 3:\n        k1 ^= tail[2] << 16;\n        G_GNUC_FALLTHROUGH;\n    case 2:\n        k1 ^= tail[1] << 8;\n        G_GNUC_FALLTHROUGH;\n    case 1:\n        k1 ^= tail[0];\n        k1 *= c1;\n        k1 = rotl32(k1, 15);\n        k1 *= c2;\n        h1 ^= k1;\n        G_GNUC_FALLTHROUGH;\n    default:\n        break;\n    }\n\n    /* finalization */\n\n    h1 ^= len;\n    h1 = fmix(h1);\n\n    return h1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic uint32_t virHashStrCode(const void *name, uint32_t seed)\n{\n    return virHashCodeGen(name, strlen(name), seed);\n}"
  },
  {
    "function_name": "virHashAtomicOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
    "lines": "74-80",
    "snippet": "static int virHashAtomicOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virHashAtomic, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhashcode.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhash.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virHashAtomic",
            "virClassForObjectLockable()"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObjectLockable",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "116-123",
          "snippet": "virClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectLockableClass;\n\nvirClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int virHashAtomicOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virHashAtomic, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}"
  }
]