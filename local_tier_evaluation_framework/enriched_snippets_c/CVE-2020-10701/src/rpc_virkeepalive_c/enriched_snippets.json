[
  {
    "function_name": "virKeepAliveCheckMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
    "lines": "361-410",
    "snippet": "bool\nvirKeepAliveCheckMessage(virKeepAlivePtr ka,\n                         virNetMessagePtr msg,\n                         virNetMessagePtr *response)\n{\n    bool ret = false;\n\n    VIR_DEBUG(\"ka=%p, client=%p, msg=%p\",\n              ka, ka ? ka->client : \"(null)\", msg);\n\n    *response = NULL;\n    if (!ka)\n        return false;\n\n    virObjectLock(ka);\n\n    ka->countToDeath = ka->count;\n    ka->lastPacketReceived = ka->intervalStart = time(NULL);\n\n    if (msg->header.prog == KEEPALIVE_PROGRAM &&\n        msg->header.vers == KEEPALIVE_PROTOCOL_VERSION &&\n        msg->header.type == VIR_NET_MESSAGE) {\n        PROBE(RPC_KEEPALIVE_RECEIVED,\n              \"ka=%p client=%p prog=%d vers=%d proc=%d\",\n              ka, ka->client, msg->header.prog,\n              msg->header.vers, msg->header.proc);\n        ret = true;\n        switch (msg->header.proc) {\n        case KEEPALIVE_PROC_PING:\n            VIR_DEBUG(\"Got keepalive request from client %p\", ka->client);\n            *response = virKeepAliveMessage(ka, KEEPALIVE_PROC_PONG);\n            break;\n\n        case KEEPALIVE_PROC_PONG:\n            VIR_DEBUG(\"Got keepalive response from client %p\", ka->client);\n            break;\n\n        default:\n            VIR_DEBUG(\"Ignoring unknown keepalive message %d from client %p\",\n                      msg->header.proc, ka->client);\n        }\n    }\n\n    if (ka->timer >= 0)\n        virEventUpdateTimeout(ka->timer, ka->interval * 1000);\n\n    virObjectUnlock(ka);\n\n    return ret;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virkeepaliveprotocol.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "ka"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virEventUpdateTimeout",
          "args": [
            "ka->timer",
            "ka->interval * 1000"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "virEventUpdateTimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "170-175",
          "snippet": "void\nvirEventUpdateTimeout(int timer, int timeout)\n{\n    if (updateTimeoutImpl)\n        updateTimeoutImpl(timer, timeout);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventUpdateTimeoutFunc updateTimeoutImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventUpdateTimeoutFunc updateTimeoutImpl;\n\nvoid\nvirEventUpdateTimeout(int timer, int timeout)\n{\n    if (updateTimeoutImpl)\n        updateTimeoutImpl(timer, timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Ignoring unknown keepalive message %d from client %p\"",
            "msg->header.proc",
            "ka->client"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Got keepalive response from client %p\"",
            "ka->client"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virKeepAliveMessage",
          "args": [
            "ka",
            "KEEPALIVE_PROC_PONG"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "virKeepAliveMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
          "lines": "67-109",
          "snippet": "static virNetMessagePtr\nvirKeepAliveMessage(virKeepAlivePtr ka, int proc)\n{\n    virNetMessagePtr msg;\n    const char *procstr = NULL;\n\n    switch (proc) {\n    case KEEPALIVE_PROC_PING:\n        procstr = \"request\";\n        break;\n    case KEEPALIVE_PROC_PONG:\n        procstr = \"response\";\n        break;\n    default:\n        VIR_WARN(\"Refusing to send unknown keepalive message: %d\", proc);\n        return NULL;\n    }\n\n    if (!(msg = virNetMessageNew(false)))\n        goto error;\n\n    msg->header.prog = KEEPALIVE_PROGRAM;\n    msg->header.vers = KEEPALIVE_PROTOCOL_VERSION;\n    msg->header.type = VIR_NET_MESSAGE;\n    msg->header.proc = proc;\n\n    if (virNetMessageEncodeHeader(msg) < 0 ||\n        virNetMessageEncodePayloadEmpty(msg) < 0) {\n        virNetMessageFree(msg);\n        goto error;\n    }\n\n    VIR_DEBUG(\"Sending keepalive %s to client %p\", procstr, ka->client);\n    PROBE(RPC_KEEPALIVE_SEND,\n          \"ka=%p client=%p prog=%d vers=%d proc=%d\",\n          ka, ka->client, msg->header.prog, msg->header.vers, msg->header.proc);\n\n    return msg;\n\n error:\n    VIR_WARN(\"Failed to generate keepalive %s\", procstr);\n    return NULL;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virkeepaliveprotocol.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virNetMessagePtr\nvirKeepAliveMessage(virKeepAlivePtr ka, int proc)\n{\n    virNetMessagePtr msg;\n    const char *procstr = NULL;\n\n    switch (proc) {\n    case KEEPALIVE_PROC_PING:\n        procstr = \"request\";\n        break;\n    case KEEPALIVE_PROC_PONG:\n        procstr = \"response\";\n        break;\n    default:\n        VIR_WARN(\"Refusing to send unknown keepalive message: %d\", proc);\n        return NULL;\n    }\n\n    if (!(msg = virNetMessageNew(false)))\n        goto error;\n\n    msg->header.prog = KEEPALIVE_PROGRAM;\n    msg->header.vers = KEEPALIVE_PROTOCOL_VERSION;\n    msg->header.type = VIR_NET_MESSAGE;\n    msg->header.proc = proc;\n\n    if (virNetMessageEncodeHeader(msg) < 0 ||\n        virNetMessageEncodePayloadEmpty(msg) < 0) {\n        virNetMessageFree(msg);\n        goto error;\n    }\n\n    VIR_DEBUG(\"Sending keepalive %s to client %p\", procstr, ka->client);\n    PROBE(RPC_KEEPALIVE_SEND,\n          \"ka=%p client=%p prog=%d vers=%d proc=%d\",\n          ka, ka->client, msg->header.prog, msg->header.vers, msg->header.proc);\n\n    return msg;\n\n error:\n    VIR_WARN(\"Failed to generate keepalive %s\", procstr);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Got keepalive request from client %p\"",
            "ka->client"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_KEEPALIVE_RECEIVED",
            "\"ka=%p client=%p prog=%d vers=%d proc=%d\"",
            "ka",
            "ka->client",
            "msg->header.prog",
            "msg->header.vers",
            "msg->header.proc"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobCleanStorageSourceRuntime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "636-647",
          "snippet": "static void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "ka"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"ka=%p, client=%p, msg=%p\"",
            "ka",
            "ka ? ka->client : \"(null)\"",
            "msg"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirKeepAliveCheckMessage(virKeepAlivePtr ka,\n                         virNetMessagePtr msg,\n                         virNetMessagePtr *response)\n{\n    bool ret = false;\n\n    VIR_DEBUG(\"ka=%p, client=%p, msg=%p\",\n              ka, ka ? ka->client : \"(null)\", msg);\n\n    *response = NULL;\n    if (!ka)\n        return false;\n\n    virObjectLock(ka);\n\n    ka->countToDeath = ka->count;\n    ka->lastPacketReceived = ka->intervalStart = time(NULL);\n\n    if (msg->header.prog == KEEPALIVE_PROGRAM &&\n        msg->header.vers == KEEPALIVE_PROTOCOL_VERSION &&\n        msg->header.type == VIR_NET_MESSAGE) {\n        PROBE(RPC_KEEPALIVE_RECEIVED,\n              \"ka=%p client=%p prog=%d vers=%d proc=%d\",\n              ka, ka->client, msg->header.prog,\n              msg->header.vers, msg->header.proc);\n        ret = true;\n        switch (msg->header.proc) {\n        case KEEPALIVE_PROC_PING:\n            VIR_DEBUG(\"Got keepalive request from client %p\", ka->client);\n            *response = virKeepAliveMessage(ka, KEEPALIVE_PROC_PONG);\n            break;\n\n        case KEEPALIVE_PROC_PONG:\n            VIR_DEBUG(\"Got keepalive response from client %p\", ka->client);\n            break;\n\n        default:\n            VIR_DEBUG(\"Ignoring unknown keepalive message %d from client %p\",\n                      msg->header.proc, ka->client);\n        }\n    }\n\n    if (ka->timer >= 0)\n        virEventUpdateTimeout(ka->timer, ka->interval * 1000);\n\n    virObjectUnlock(ka);\n\n    return ret;\n}"
  },
  {
    "function_name": "virKeepAliveTrigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
    "lines": "343-358",
    "snippet": "bool\nvirKeepAliveTrigger(virKeepAlivePtr ka,\n                    virNetMessagePtr *msg)\n{\n    bool dead;\n\n    *msg = NULL;\n    if (!ka)\n        return false;\n\n    virObjectLock(ka);\n    dead = virKeepAliveTimerInternal(ka, msg);\n    virObjectUnlock(ka);\n\n    return dead;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virkeepaliveprotocol.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "ka"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virKeepAliveTimerInternal",
          "args": [
            "ka",
            "msg"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "virKeepAliveTimerInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
          "lines": "112-147",
          "snippet": "static bool\nvirKeepAliveTimerInternal(virKeepAlivePtr ka,\n                          virNetMessagePtr *msg)\n{\n    time_t now = time(NULL);\n    int timeval;\n\n    if (ka->interval <= 0 || ka->intervalStart == 0)\n        return false;\n\n    if (now - ka->intervalStart < ka->interval) {\n        timeval = ka->interval - (now - ka->intervalStart);\n        virEventUpdateTimeout(ka->timer, timeval * 1000);\n        return false;\n    }\n\n    timeval = now - ka->lastPacketReceived;\n    PROBE(RPC_KEEPALIVE_TIMEOUT,\n          \"ka=%p client=%p countToDeath=%d idle=%d\",\n          ka, ka->client, ka->countToDeath, timeval);\n\n    if (ka->countToDeath == 0) {\n        VIR_DEBUG(\"No response from client %p after %d keepalive messages \"\n                  \"in %d seconds\",\n                  ka->client, ka->count, timeval);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"connection closed due to keepalive timeout\"));\n        return true;\n    } else {\n        ka->countToDeath--;\n        ka->intervalStart = now;\n        *msg = virKeepAliveMessage(ka, KEEPALIVE_PROC_PING);\n        virEventUpdateTimeout(ka->timer, ka->interval * 1000);\n        return false;\n    }\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virkeepaliveprotocol.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic bool\nvirKeepAliveTimerInternal(virKeepAlivePtr ka,\n                          virNetMessagePtr *msg)\n{\n    time_t now = time(NULL);\n    int timeval;\n\n    if (ka->interval <= 0 || ka->intervalStart == 0)\n        return false;\n\n    if (now - ka->intervalStart < ka->interval) {\n        timeval = ka->interval - (now - ka->intervalStart);\n        virEventUpdateTimeout(ka->timer, timeval * 1000);\n        return false;\n    }\n\n    timeval = now - ka->lastPacketReceived;\n    PROBE(RPC_KEEPALIVE_TIMEOUT,\n          \"ka=%p client=%p countToDeath=%d idle=%d\",\n          ka, ka->client, ka->countToDeath, timeval);\n\n    if (ka->countToDeath == 0) {\n        VIR_DEBUG(\"No response from client %p after %d keepalive messages \"\n                  \"in %d seconds\",\n                  ka->client, ka->count, timeval);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"connection closed due to keepalive timeout\"));\n        return true;\n    } else {\n        ka->countToDeath--;\n        ka->intervalStart = now;\n        *msg = virKeepAliveMessage(ka, KEEPALIVE_PROC_PING);\n        virEventUpdateTimeout(ka->timer, ka->interval * 1000);\n        return false;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "ka"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirKeepAliveTrigger(virKeepAlivePtr ka,\n                    virNetMessagePtr *msg)\n{\n    bool dead;\n\n    *msg = NULL;\n    if (!ka)\n        return false;\n\n    virObjectLock(ka);\n    dead = virKeepAliveTimerInternal(ka, msg);\n    virObjectUnlock(ka);\n\n    return dead;\n}"
  },
  {
    "function_name": "virKeepAliveTimeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
    "lines": "313-340",
    "snippet": "int\nvirKeepAliveTimeout(virKeepAlivePtr ka)\n{\n    int timeout;\n\n    if (!ka)\n        return -1;\n\n    virObjectLock(ka);\n\n    if (ka->interval <= 0 || ka->intervalStart == 0) {\n        timeout = -1;\n    } else {\n        timeout = ka->interval - (time(NULL) - ka->intervalStart);\n        if (timeout < 0)\n            timeout = 0;\n        /* Guard against overflow */\n        if (timeout > INT_MAX / 1000)\n            timeout = INT_MAX / 1000;\n    }\n\n    virObjectUnlock(ka);\n\n    if (timeout < 0)\n        return -1;\n    else\n        return timeout * 1000;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virkeepaliveprotocol.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "ka"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobCleanStorageSourceRuntime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "636-647",
          "snippet": "static void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "ka"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirKeepAliveTimeout(virKeepAlivePtr ka)\n{\n    int timeout;\n\n    if (!ka)\n        return -1;\n\n    virObjectLock(ka);\n\n    if (ka->interval <= 0 || ka->intervalStart == 0) {\n        timeout = -1;\n    } else {\n        timeout = ka->interval - (time(NULL) - ka->intervalStart);\n        if (timeout < 0)\n            timeout = 0;\n        /* Guard against overflow */\n        if (timeout > INT_MAX / 1000)\n            timeout = INT_MAX / 1000;\n    }\n\n    virObjectUnlock(ka);\n\n    if (timeout < 0)\n        return -1;\n    else\n        return timeout * 1000;\n}"
  },
  {
    "function_name": "virKeepAliveStop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
    "lines": "295-310",
    "snippet": "void\nvirKeepAliveStop(virKeepAlivePtr ka)\n{\n    virObjectLock(ka);\n\n    PROBE(RPC_KEEPALIVE_STOP,\n          \"ka=%p client=%p\",\n          ka, ka->client);\n\n    if (ka->timer > 0) {\n        virEventRemoveTimeout(ka->timer);\n        ka->timer = -1;\n    }\n\n    virObjectUnlock(ka);\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virkeepaliveprotocol.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "ka"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virEventRemoveTimeout",
          "args": [
            "ka->timer"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "virEventRemoveTimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "188-195",
          "snippet": "int\nvirEventRemoveTimeout(int timer)\n{\n    if (!removeTimeoutImpl)\n        return -1;\n\n    return removeTimeoutImpl(timer);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventRemoveTimeoutFunc removeTimeoutImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventRemoveTimeoutFunc removeTimeoutImpl;\n\nint\nvirEventRemoveTimeout(int timer)\n{\n    if (!removeTimeoutImpl)\n        return -1;\n\n    return removeTimeoutImpl(timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_KEEPALIVE_STOP",
            "\"ka=%p client=%p\"",
            "ka",
            "ka->client"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "ka"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirKeepAliveStop(virKeepAlivePtr ka)\n{\n    virObjectLock(ka);\n\n    PROBE(RPC_KEEPALIVE_STOP,\n          \"ka=%p client=%p\",\n          ka, ka->client);\n\n    if (ka->timer > 0) {\n        virEventRemoveTimeout(ka->timer);\n        ka->timer = -1;\n    }\n\n    virObjectUnlock(ka);\n}"
  },
  {
    "function_name": "virKeepAliveStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
    "lines": "228-292",
    "snippet": "int\nvirKeepAliveStart(virKeepAlivePtr ka,\n                  int interval,\n                  unsigned int count)\n{\n    int ret = -1;\n    time_t delay;\n    int timeout;\n    time_t now;\n\n    virObjectLock(ka);\n\n    if (ka->timer >= 0) {\n        VIR_DEBUG(\"Keepalive messages already enabled\");\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (interval > 0) {\n        if (ka->interval > 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"keepalive interval already set\"));\n            goto cleanup;\n        }\n        /* Guard against overflow */\n        if (interval > INT_MAX / 1000) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"keepalive interval %d too large\"), interval);\n            goto cleanup;\n        }\n        ka->interval = interval;\n        ka->count = count;\n        ka->countToDeath = count;\n    }\n\n    if (ka->interval <= 0) {\n        VIR_DEBUG(\"Keepalive messages disabled by configuration\");\n        ret = 0;\n        goto cleanup;\n    }\n\n    PROBE(RPC_KEEPALIVE_START,\n          \"ka=%p client=%p interval=%d count=%u\",\n          ka, ka->client, interval, count);\n\n    now = time(NULL);\n    delay = now - ka->lastPacketReceived;\n    if (delay > ka->interval)\n        timeout = 0;\n    else\n        timeout = ka->interval - delay;\n    ka->intervalStart = now - (ka->interval - timeout);\n    ka->timer = virEventAddTimeout(timeout * 1000, virKeepAliveTimer,\n                                   ka, virObjectFreeCallback);\n    if (ka->timer < 0)\n        goto cleanup;\n\n    /* the timer now has another reference to this object */\n    virObjectRef(ka);\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(ka);\n    return ret;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virkeepaliveprotocol.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "ka"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "ka"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virEventAddTimeout",
          "args": [
            "timeout * 1000",
            "virKeepAliveTimer",
            "ka",
            "virObjectFreeCallback"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "virEventAddTimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "143-153",
          "snippet": "int\nvirEventAddTimeout(int timeout,\n                   virEventTimeoutCallback cb,\n                   void *opaque,\n                   virFreeCallback ff)\n{\n    if (!addTimeoutImpl)\n        return -1;\n\n    return addTimeoutImpl(timeout, cb, opaque, ff);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventAddTimeoutFunc addTimeoutImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventAddTimeoutFunc addTimeoutImpl;\n\nint\nvirEventAddTimeout(int timeout,\n                   virEventTimeoutCallback cb,\n                   void *opaque,\n                   virFreeCallback ff)\n{\n    if (!addTimeoutImpl)\n        return -1;\n\n    return addTimeoutImpl(timeout, cb, opaque, ff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobCleanStorageSourceRuntime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "636-647",
          "snippet": "static void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_KEEPALIVE_START",
            "\"ka=%p client=%p interval=%d count=%u\"",
            "ka",
            "ka->client",
            "interval",
            "count"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Keepalive messages disabled by configuration\""
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"keepalive interval %d too large\")",
            "interval"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"keepalive interval %d too large\""
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"keepalive interval already set\")"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Keepalive messages already enabled\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "ka"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirKeepAliveStart(virKeepAlivePtr ka,\n                  int interval,\n                  unsigned int count)\n{\n    int ret = -1;\n    time_t delay;\n    int timeout;\n    time_t now;\n\n    virObjectLock(ka);\n\n    if (ka->timer >= 0) {\n        VIR_DEBUG(\"Keepalive messages already enabled\");\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (interval > 0) {\n        if (ka->interval > 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"keepalive interval already set\"));\n            goto cleanup;\n        }\n        /* Guard against overflow */\n        if (interval > INT_MAX / 1000) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"keepalive interval %d too large\"), interval);\n            goto cleanup;\n        }\n        ka->interval = interval;\n        ka->count = count;\n        ka->countToDeath = count;\n    }\n\n    if (ka->interval <= 0) {\n        VIR_DEBUG(\"Keepalive messages disabled by configuration\");\n        ret = 0;\n        goto cleanup;\n    }\n\n    PROBE(RPC_KEEPALIVE_START,\n          \"ka=%p client=%p interval=%d count=%u\",\n          ka, ka->client, interval, count);\n\n    now = time(NULL);\n    delay = now - ka->lastPacketReceived;\n    if (delay > ka->interval)\n        timeout = 0;\n    else\n        timeout = ka->interval - delay;\n    ka->intervalStart = now - (ka->interval - timeout);\n    ka->timer = virEventAddTimeout(timeout * 1000, virKeepAliveTimer,\n                                   ka, virObjectFreeCallback);\n    if (ka->timer < 0)\n        goto cleanup;\n\n    /* the timer now has another reference to this object */\n    virObjectRef(ka);\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(ka);\n    return ret;\n}"
  },
  {
    "function_name": "virKeepAliveDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
    "lines": "216-225",
    "snippet": "void\nvirKeepAliveDispose(void *obj)\n{\n    virKeepAlivePtr ka = obj;\n\n    PROBE(RPC_KEEPALIVE_DISPOSE,\n          \"ka=%p\", ka);\n\n    ka->freeCB(ka->client);\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virkeepaliveprotocol.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virKeepAliveDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ka->freeCB",
          "args": [
            "ka->client"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_KEEPALIVE_DISPOSE",
            "\"ka=%p\"",
            "ka"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void virKeepAliveDispose(void *obj);\n\nvoid\nvirKeepAliveDispose(void *obj)\n{\n    virKeepAlivePtr ka = obj;\n\n    PROBE(RPC_KEEPALIVE_DISPOSE,\n          \"ka=%p\", ka);\n\n    ka->freeCB(ka->client);\n}"
  },
  {
    "function_name": "virKeepAliveNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
    "lines": "181-213",
    "snippet": "virKeepAlivePtr\nvirKeepAliveNew(int interval,\n                unsigned int count,\n                void *client,\n                virKeepAliveSendFunc sendCB,\n                virKeepAliveDeadFunc deadCB,\n                virKeepAliveFreeFunc freeCB)\n{\n    virKeepAlivePtr ka;\n\n    VIR_DEBUG(\"client=%p, interval=%d, count=%u\", client, interval, count);\n\n    if (virKeepAliveInitialize() < 0)\n        return NULL;\n\n    if (!(ka = virObjectLockableNew(virKeepAliveClass)))\n        return NULL;\n\n    ka->interval = interval;\n    ka->count = count;\n    ka->countToDeath = count;\n    ka->timer = -1;\n    ka->client = client;\n    ka->sendCB = sendCB;\n    ka->deadCB = deadCB;\n    ka->freeCB = freeCB;\n\n    PROBE(RPC_KEEPALIVE_NEW,\n          \"ka=%p client=%p\",\n          ka, ka->client);\n\n    return ka;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virkeepaliveprotocol.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virKeepAliveClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_KEEPALIVE_NEW",
            "\"ka=%p client=%p\"",
            "ka",
            "ka->client"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "virKeepAliveClass"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virKeepAliveInitialize",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p, interval=%d, count=%u\"",
            "client",
            "interval",
            "count"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virClassPtr virKeepAliveClass;\n\nvirKeepAlivePtr\nvirKeepAliveNew(int interval,\n                unsigned int count,\n                void *client,\n                virKeepAliveSendFunc sendCB,\n                virKeepAliveDeadFunc deadCB,\n                virKeepAliveFreeFunc freeCB)\n{\n    virKeepAlivePtr ka;\n\n    VIR_DEBUG(\"client=%p, interval=%d, count=%u\", client, interval, count);\n\n    if (virKeepAliveInitialize() < 0)\n        return NULL;\n\n    if (!(ka = virObjectLockableNew(virKeepAliveClass)))\n        return NULL;\n\n    ka->interval = interval;\n    ka->count = count;\n    ka->countToDeath = count;\n    ka->timer = -1;\n    ka->client = client;\n    ka->sendCB = sendCB;\n    ka->deadCB = deadCB;\n    ka->freeCB = freeCB;\n\n    PROBE(RPC_KEEPALIVE_NEW,\n          \"ka=%p client=%p\",\n          ka, ka->client);\n\n    return ka;\n}"
  },
  {
    "function_name": "virKeepAliveTimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
    "lines": "150-178",
    "snippet": "static void\nvirKeepAliveTimer(int timer G_GNUC_UNUSED, void *opaque)\n{\n    virKeepAlivePtr ka = opaque;\n    virNetMessagePtr msg = NULL;\n    bool dead;\n    void *client;\n\n    virObjectRef(ka);\n    virObjectLock(ka);\n\n    client = ka->client;\n    dead = virKeepAliveTimerInternal(ka, &msg);\n\n    virObjectUnlock(ka);\n\n    if (!dead && !msg)\n        goto cleanup;\n\n    if (dead) {\n        ka->deadCB(client);\n    } else if (ka->sendCB(client, msg) < 0) {\n        VIR_WARN(\"Failed to send keepalive request to client %p\", client);\n        virNetMessageFree(msg);\n    }\n\n cleanup:\n    virObjectUnref(ka);\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virkeepaliveprotocol.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "ka"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "msg"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to send keepalive request to client %p\"",
            "client"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ka->sendCB",
          "args": [
            "client",
            "msg"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ka->deadCB",
          "args": [
            "client"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "ka"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virKeepAliveTimerInternal",
          "args": [
            "ka",
            "&msg"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "virKeepAliveTimerInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
          "lines": "112-147",
          "snippet": "static bool\nvirKeepAliveTimerInternal(virKeepAlivePtr ka,\n                          virNetMessagePtr *msg)\n{\n    time_t now = time(NULL);\n    int timeval;\n\n    if (ka->interval <= 0 || ka->intervalStart == 0)\n        return false;\n\n    if (now - ka->intervalStart < ka->interval) {\n        timeval = ka->interval - (now - ka->intervalStart);\n        virEventUpdateTimeout(ka->timer, timeval * 1000);\n        return false;\n    }\n\n    timeval = now - ka->lastPacketReceived;\n    PROBE(RPC_KEEPALIVE_TIMEOUT,\n          \"ka=%p client=%p countToDeath=%d idle=%d\",\n          ka, ka->client, ka->countToDeath, timeval);\n\n    if (ka->countToDeath == 0) {\n        VIR_DEBUG(\"No response from client %p after %d keepalive messages \"\n                  \"in %d seconds\",\n                  ka->client, ka->count, timeval);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"connection closed due to keepalive timeout\"));\n        return true;\n    } else {\n        ka->countToDeath--;\n        ka->intervalStart = now;\n        *msg = virKeepAliveMessage(ka, KEEPALIVE_PROC_PING);\n        virEventUpdateTimeout(ka->timer, ka->interval * 1000);\n        return false;\n    }\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virkeepaliveprotocol.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic bool\nvirKeepAliveTimerInternal(virKeepAlivePtr ka,\n                          virNetMessagePtr *msg)\n{\n    time_t now = time(NULL);\n    int timeval;\n\n    if (ka->interval <= 0 || ka->intervalStart == 0)\n        return false;\n\n    if (now - ka->intervalStart < ka->interval) {\n        timeval = ka->interval - (now - ka->intervalStart);\n        virEventUpdateTimeout(ka->timer, timeval * 1000);\n        return false;\n    }\n\n    timeval = now - ka->lastPacketReceived;\n    PROBE(RPC_KEEPALIVE_TIMEOUT,\n          \"ka=%p client=%p countToDeath=%d idle=%d\",\n          ka, ka->client, ka->countToDeath, timeval);\n\n    if (ka->countToDeath == 0) {\n        VIR_DEBUG(\"No response from client %p after %d keepalive messages \"\n                  \"in %d seconds\",\n                  ka->client, ka->count, timeval);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"connection closed due to keepalive timeout\"));\n        return true;\n    } else {\n        ka->countToDeath--;\n        ka->intervalStart = now;\n        *msg = virKeepAliveMessage(ka, KEEPALIVE_PROC_PING);\n        virEventUpdateTimeout(ka->timer, ka->interval * 1000);\n        return false;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "ka"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "ka"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic void\nvirKeepAliveTimer(int timer G_GNUC_UNUSED, void *opaque)\n{\n    virKeepAlivePtr ka = opaque;\n    virNetMessagePtr msg = NULL;\n    bool dead;\n    void *client;\n\n    virObjectRef(ka);\n    virObjectLock(ka);\n\n    client = ka->client;\n    dead = virKeepAliveTimerInternal(ka, &msg);\n\n    virObjectUnlock(ka);\n\n    if (!dead && !msg)\n        goto cleanup;\n\n    if (dead) {\n        ka->deadCB(client);\n    } else if (ka->sendCB(client, msg) < 0) {\n        VIR_WARN(\"Failed to send keepalive request to client %p\", client);\n        virNetMessageFree(msg);\n    }\n\n cleanup:\n    virObjectUnref(ka);\n}"
  },
  {
    "function_name": "virKeepAliveTimerInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
    "lines": "112-147",
    "snippet": "static bool\nvirKeepAliveTimerInternal(virKeepAlivePtr ka,\n                          virNetMessagePtr *msg)\n{\n    time_t now = time(NULL);\n    int timeval;\n\n    if (ka->interval <= 0 || ka->intervalStart == 0)\n        return false;\n\n    if (now - ka->intervalStart < ka->interval) {\n        timeval = ka->interval - (now - ka->intervalStart);\n        virEventUpdateTimeout(ka->timer, timeval * 1000);\n        return false;\n    }\n\n    timeval = now - ka->lastPacketReceived;\n    PROBE(RPC_KEEPALIVE_TIMEOUT,\n          \"ka=%p client=%p countToDeath=%d idle=%d\",\n          ka, ka->client, ka->countToDeath, timeval);\n\n    if (ka->countToDeath == 0) {\n        VIR_DEBUG(\"No response from client %p after %d keepalive messages \"\n                  \"in %d seconds\",\n                  ka->client, ka->count, timeval);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"connection closed due to keepalive timeout\"));\n        return true;\n    } else {\n        ka->countToDeath--;\n        ka->intervalStart = now;\n        *msg = virKeepAliveMessage(ka, KEEPALIVE_PROC_PING);\n        virEventUpdateTimeout(ka->timer, ka->interval * 1000);\n        return false;\n    }\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virkeepaliveprotocol.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virEventUpdateTimeout",
          "args": [
            "ka->timer",
            "ka->interval * 1000"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "virEventUpdateTimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "170-175",
          "snippet": "void\nvirEventUpdateTimeout(int timer, int timeout)\n{\n    if (updateTimeoutImpl)\n        updateTimeoutImpl(timer, timeout);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventUpdateTimeoutFunc updateTimeoutImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventUpdateTimeoutFunc updateTimeoutImpl;\n\nvoid\nvirEventUpdateTimeout(int timer, int timeout)\n{\n    if (updateTimeoutImpl)\n        updateTimeoutImpl(timer, timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virKeepAliveMessage",
          "args": [
            "ka",
            "KEEPALIVE_PROC_PING"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "virKeepAliveMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
          "lines": "67-109",
          "snippet": "static virNetMessagePtr\nvirKeepAliveMessage(virKeepAlivePtr ka, int proc)\n{\n    virNetMessagePtr msg;\n    const char *procstr = NULL;\n\n    switch (proc) {\n    case KEEPALIVE_PROC_PING:\n        procstr = \"request\";\n        break;\n    case KEEPALIVE_PROC_PONG:\n        procstr = \"response\";\n        break;\n    default:\n        VIR_WARN(\"Refusing to send unknown keepalive message: %d\", proc);\n        return NULL;\n    }\n\n    if (!(msg = virNetMessageNew(false)))\n        goto error;\n\n    msg->header.prog = KEEPALIVE_PROGRAM;\n    msg->header.vers = KEEPALIVE_PROTOCOL_VERSION;\n    msg->header.type = VIR_NET_MESSAGE;\n    msg->header.proc = proc;\n\n    if (virNetMessageEncodeHeader(msg) < 0 ||\n        virNetMessageEncodePayloadEmpty(msg) < 0) {\n        virNetMessageFree(msg);\n        goto error;\n    }\n\n    VIR_DEBUG(\"Sending keepalive %s to client %p\", procstr, ka->client);\n    PROBE(RPC_KEEPALIVE_SEND,\n          \"ka=%p client=%p prog=%d vers=%d proc=%d\",\n          ka, ka->client, msg->header.prog, msg->header.vers, msg->header.proc);\n\n    return msg;\n\n error:\n    VIR_WARN(\"Failed to generate keepalive %s\", procstr);\n    return NULL;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virkeepaliveprotocol.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virNetMessagePtr\nvirKeepAliveMessage(virKeepAlivePtr ka, int proc)\n{\n    virNetMessagePtr msg;\n    const char *procstr = NULL;\n\n    switch (proc) {\n    case KEEPALIVE_PROC_PING:\n        procstr = \"request\";\n        break;\n    case KEEPALIVE_PROC_PONG:\n        procstr = \"response\";\n        break;\n    default:\n        VIR_WARN(\"Refusing to send unknown keepalive message: %d\", proc);\n        return NULL;\n    }\n\n    if (!(msg = virNetMessageNew(false)))\n        goto error;\n\n    msg->header.prog = KEEPALIVE_PROGRAM;\n    msg->header.vers = KEEPALIVE_PROTOCOL_VERSION;\n    msg->header.type = VIR_NET_MESSAGE;\n    msg->header.proc = proc;\n\n    if (virNetMessageEncodeHeader(msg) < 0 ||\n        virNetMessageEncodePayloadEmpty(msg) < 0) {\n        virNetMessageFree(msg);\n        goto error;\n    }\n\n    VIR_DEBUG(\"Sending keepalive %s to client %p\", procstr, ka->client);\n    PROBE(RPC_KEEPALIVE_SEND,\n          \"ka=%p client=%p prog=%d vers=%d proc=%d\",\n          ka, ka->client, msg->header.prog, msg->header.vers, msg->header.proc);\n\n    return msg;\n\n error:\n    VIR_WARN(\"Failed to generate keepalive %s\", procstr);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"connection closed due to keepalive timeout\")"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"connection closed due to keepalive timeout\""
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No response from client %p after %d keepalive messages \"\n                  \"in %d seconds\"",
            "ka->client",
            "ka->count",
            "timeval"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_KEEPALIVE_TIMEOUT",
            "\"ka=%p client=%p countToDeath=%d idle=%d\"",
            "ka",
            "ka->client",
            "ka->countToDeath",
            "timeval"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobCleanStorageSourceRuntime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "636-647",
          "snippet": "static void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic bool\nvirKeepAliveTimerInternal(virKeepAlivePtr ka,\n                          virNetMessagePtr *msg)\n{\n    time_t now = time(NULL);\n    int timeval;\n\n    if (ka->interval <= 0 || ka->intervalStart == 0)\n        return false;\n\n    if (now - ka->intervalStart < ka->interval) {\n        timeval = ka->interval - (now - ka->intervalStart);\n        virEventUpdateTimeout(ka->timer, timeval * 1000);\n        return false;\n    }\n\n    timeval = now - ka->lastPacketReceived;\n    PROBE(RPC_KEEPALIVE_TIMEOUT,\n          \"ka=%p client=%p countToDeath=%d idle=%d\",\n          ka, ka->client, ka->countToDeath, timeval);\n\n    if (ka->countToDeath == 0) {\n        VIR_DEBUG(\"No response from client %p after %d keepalive messages \"\n                  \"in %d seconds\",\n                  ka->client, ka->count, timeval);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"connection closed due to keepalive timeout\"));\n        return true;\n    } else {\n        ka->countToDeath--;\n        ka->intervalStart = now;\n        *msg = virKeepAliveMessage(ka, KEEPALIVE_PROC_PING);\n        virEventUpdateTimeout(ka->timer, ka->interval * 1000);\n        return false;\n    }\n}"
  },
  {
    "function_name": "virKeepAliveMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
    "lines": "67-109",
    "snippet": "static virNetMessagePtr\nvirKeepAliveMessage(virKeepAlivePtr ka, int proc)\n{\n    virNetMessagePtr msg;\n    const char *procstr = NULL;\n\n    switch (proc) {\n    case KEEPALIVE_PROC_PING:\n        procstr = \"request\";\n        break;\n    case KEEPALIVE_PROC_PONG:\n        procstr = \"response\";\n        break;\n    default:\n        VIR_WARN(\"Refusing to send unknown keepalive message: %d\", proc);\n        return NULL;\n    }\n\n    if (!(msg = virNetMessageNew(false)))\n        goto error;\n\n    msg->header.prog = KEEPALIVE_PROGRAM;\n    msg->header.vers = KEEPALIVE_PROTOCOL_VERSION;\n    msg->header.type = VIR_NET_MESSAGE;\n    msg->header.proc = proc;\n\n    if (virNetMessageEncodeHeader(msg) < 0 ||\n        virNetMessageEncodePayloadEmpty(msg) < 0) {\n        virNetMessageFree(msg);\n        goto error;\n    }\n\n    VIR_DEBUG(\"Sending keepalive %s to client %p\", procstr, ka->client);\n    PROBE(RPC_KEEPALIVE_SEND,\n          \"ka=%p client=%p prog=%d vers=%d proc=%d\",\n          ka, ka->client, msg->header.prog, msg->header.vers, msg->header.proc);\n\n    return msg;\n\n error:\n    VIR_WARN(\"Failed to generate keepalive %s\", procstr);\n    return NULL;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virkeepaliveprotocol.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to generate keepalive %s\"",
            "procstr"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_KEEPALIVE_SEND",
            "\"ka=%p client=%p prog=%d vers=%d proc=%d\"",
            "ka",
            "ka->client",
            "msg->header.prog",
            "msg->header.vers",
            "msg->header.proc"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Sending keepalive %s to client %p\"",
            "procstr",
            "ka->client"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "msg"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodePayloadEmpty",
          "args": [
            "msg"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodePayloadEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "487-509",
          "snippet": "int virNetMessageEncodePayloadEmpty(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodePayloadEmpty(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodeHeader",
          "args": [
            "msg"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodeHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "226-272",
          "snippet": "int virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageNew",
          "args": [
            "false"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "37-48",
          "snippet": "virNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Refusing to send unknown keepalive message: %d\"",
            "proc"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic virNetMessagePtr\nvirKeepAliveMessage(virKeepAlivePtr ka, int proc)\n{\n    virNetMessagePtr msg;\n    const char *procstr = NULL;\n\n    switch (proc) {\n    case KEEPALIVE_PROC_PING:\n        procstr = \"request\";\n        break;\n    case KEEPALIVE_PROC_PONG:\n        procstr = \"response\";\n        break;\n    default:\n        VIR_WARN(\"Refusing to send unknown keepalive message: %d\", proc);\n        return NULL;\n    }\n\n    if (!(msg = virNetMessageNew(false)))\n        goto error;\n\n    msg->header.prog = KEEPALIVE_PROGRAM;\n    msg->header.vers = KEEPALIVE_PROTOCOL_VERSION;\n    msg->header.type = VIR_NET_MESSAGE;\n    msg->header.proc = proc;\n\n    if (virNetMessageEncodeHeader(msg) < 0 ||\n        virNetMessageEncodePayloadEmpty(msg) < 0) {\n        virNetMessageFree(msg);\n        goto error;\n    }\n\n    VIR_DEBUG(\"Sending keepalive %s to client %p\", procstr, ka->client);\n    PROBE(RPC_KEEPALIVE_SEND,\n          \"ka=%p client=%p prog=%d vers=%d proc=%d\",\n          ka, ka->client, msg->header.prog, msg->header.vers, msg->header.proc);\n\n    return msg;\n\n error:\n    VIR_WARN(\"Failed to generate keepalive %s\", procstr);\n    return NULL;\n}"
  },
  {
    "function_name": "virKeepAliveOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virkeepalive.c",
    "lines": "57-63",
    "snippet": "static int virKeepAliveOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virKeepAlive, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virkeepalive.h\"",
      "#include \"virkeepaliveprotocol.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virKeepAlive",
            "virClassForObjectLockable()"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObjectLockable",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "116-123",
          "snippet": "virClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectLockableClass;\n\nvirClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virkeepaliveprotocol.h\"\n#include \"virnetsocket.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nstatic int virKeepAliveOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virKeepAlive, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}"
  }
]