[
  {
    "function_name": "virLXCProcessReconnectAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "1742-1747",
    "snippet": "int virLXCProcessReconnectAll(virLXCDriverPtr driver,\n                              virDomainObjListPtr doms)\n{\n    virDomainObjListForEach(doms, false, virLXCProcessReconnectDomain, driver);\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjListForEach",
          "args": [
            "doms",
            "false",
            "virLXCProcessReconnectDomain",
            "driver"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListForEach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "827-844",
          "snippet": "int\nvirDomainObjListForEach(virDomainObjListPtr doms,\n                        bool modify,\n                        virDomainObjListIterator callback,\n                        void *opaque)\n{\n    struct virDomainListIterData data = {\n        callback, opaque, 0,\n    };\n\n    if (modify)\n        virObjectRWLockWrite(doms);\n    else\n        virObjectRWLockRead(doms);\n    virHashForEach(doms->objs, virDomainObjListHelper, &data);\n    virObjectRWUnlock(doms);\n    return data.ret;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDomainObjListForEach(virDomainObjListPtr doms,\n                        bool modify,\n                        virDomainObjListIterator callback,\n                        void *opaque)\n{\n    struct virDomainListIterData data = {\n        callback, opaque, 0,\n    };\n\n    if (modify)\n        virObjectRWLockWrite(doms);\n    else\n        virObjectRWLockRead(doms);\n    virHashForEach(doms->objs, virDomainObjListHelper, &data);\n    virObjectRWUnlock(doms);\n    return data.ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virLXCProcessReconnectAll(virLXCDriverPtr driver,\n                              virDomainObjListPtr doms)\n{\n    virDomainObjListForEach(doms, false, virLXCProcessReconnectDomain, driver);\n    return 0;\n}"
  },
  {
    "function_name": "virLXCProcessReconnectDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "1659-1739",
    "snippet": "static int\nvirLXCProcessReconnectDomain(virDomainObjPtr vm,\n                             void *opaque)\n{\n    virLXCDriverPtr driver = opaque;\n    virLXCDomainObjPrivatePtr priv;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    int ret = -1;\n\n    virObjectLock(vm);\n    VIR_DEBUG(\"Reconnect id=%d pid=%d state=%d\", vm->def->id, vm->pid, vm->state.state);\n\n    priv = vm->privateData;\n\n    if (vm->pid != 0) {\n        vm->def->id = vm->pid;\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_UNKNOWN);\n\n        if (g_atomic_int_add(&driver->nactive, 1) == 0 && driver->inhibitCallback)\n            driver->inhibitCallback(true, driver->inhibitOpaque);\n\n        if (!(priv->monitor = virLXCProcessConnectMonitor(driver, vm)))\n            goto error;\n\n        priv->machineName = virLXCDomainGetMachineName(vm->def, vm->pid);\n        if (!priv->machineName)\n            goto cleanup;\n\n        if (virCgroupNewDetectMachine(vm->def->name, \"lxc\", vm->pid, -1,\n                                      priv->machineName, &priv->cgroup) < 0)\n            goto error;\n\n        if (!priv->cgroup) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"No valid cgroup for machine %s\"),\n                           vm->def->name);\n            goto error;\n        }\n\n        if (virLXCUpdateActiveUSBHostdevs(driver, vm->def) < 0)\n            goto error;\n\n        if (virSecurityManagerReserveLabel(driver->securityManager,\n                                           vm->def, vm->pid) < 0)\n            goto error;\n\n        virLXCProcessReconnectNotifyNets(vm->def);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n            VIR_WARN(\"Cannot update XML for running LXC guest %s\", vm->def->name);\n\n        /* now that we know it's reconnected call the hook if present */\n        if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n            char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n            int hookret;\n\n            /* we can't stop the operation even if the script raised an error */\n            hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                                  VIR_HOOK_LXC_OP_RECONNECT, VIR_HOOK_SUBOP_BEGIN,\n                                  NULL, xml, NULL);\n            VIR_FREE(xml);\n            if (hookret < 0)\n                goto error;\n        }\n\n    } else {\n        vm->def->id = -1;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnref(cfg);\n    virObjectUnlock(vm);\n    return ret;\n\n error:\n    virLXCProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED);\n    virDomainAuditStop(vm, \"failed\");\n    goto cleanup;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainAuditStop",
          "args": [
            "vm",
            "\"failed\""
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainAuditStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_audit.c",
          "lines": "866-870",
          "snippet": "void\nvirDomainAuditStop(virDomainObjPtr vm, const char *reason)\n{\n    virDomainAuditLifecycle(vm, \"stop\", reason, true);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"viruuid.h\"",
            "#include \"viraudit.h\"",
            "#include \"domain_audit.h\"",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"viruuid.h\"\n#include \"viraudit.h\"\n#include \"domain_audit.h\"\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid\nvirDomainAuditStop(virDomainObjPtr vm, const char *reason)\n{\n    virDomainAuditLifecycle(vm, \"stop\", reason, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCProcessStop",
          "args": [
            "driver",
            "vm",
            "VIR_DOMAIN_SHUTOFF_FAILED"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "852-915",
          "snippet": "int virLXCProcessStop(virLXCDriverPtr driver,\n                      virDomainObjPtr vm,\n                      virDomainShutoffReason reason)\n{\n    int rc;\n    virLXCDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"Stopping VM name=%s pid=%d reason=%d\",\n              vm->def->name, (int)vm->pid, (int)reason);\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    priv = vm->privateData;\n\n    /* If the LXC domain is suspended we send all processes a SIGKILL\n     * and thaw them. Upon wakeup the process sees the pending signal\n     * and dies immediately. It is guaranteed that priv->cgroup != NULL\n     * here because the domain has aleady been suspended using the\n     * freezer cgroup.\n     */\n    if (reason == VIR_DOMAIN_SHUTOFF_DESTROYED &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED) {\n        if (virCgroupKillRecursive(priv->cgroup, SIGKILL) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to kill all processes\"));\n            return -1;\n        }\n\n        if (virCgroupSetFreezerState(priv->cgroup, \"THAWED\") < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Unable to thaw all processes\"));\n\n            return -1;\n        }\n\n        goto cleanup;\n    }\n\n    if (priv->cgroup) {\n        rc = virCgroupKillPainfully(priv->cgroup);\n        if (rc < 0)\n            return -1;\n        if (rc > 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Some processes refused to die\"));\n            return -1;\n        }\n    } else if (vm->pid > 0) {\n        /* If cgroup doesn't exist, just try cleaning up the\n         * libvirt_lxc process */\n        if (virProcessKillPainfully(vm->pid, true) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Processes %d refused to die\"), (int)vm->pid);\n            return -1;\n        }\n    }\n\n cleanup:\n    virLXCProcessCleanup(driver, vm, reason);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virLXCProcessStop(virLXCDriverPtr driver,\n                      virDomainObjPtr vm,\n                      virDomainShutoffReason reason)\n{\n    int rc;\n    virLXCDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"Stopping VM name=%s pid=%d reason=%d\",\n              vm->def->name, (int)vm->pid, (int)reason);\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    priv = vm->privateData;\n\n    /* If the LXC domain is suspended we send all processes a SIGKILL\n     * and thaw them. Upon wakeup the process sees the pending signal\n     * and dies immediately. It is guaranteed that priv->cgroup != NULL\n     * here because the domain has aleady been suspended using the\n     * freezer cgroup.\n     */\n    if (reason == VIR_DOMAIN_SHUTOFF_DESTROYED &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED) {\n        if (virCgroupKillRecursive(priv->cgroup, SIGKILL) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to kill all processes\"));\n            return -1;\n        }\n\n        if (virCgroupSetFreezerState(priv->cgroup, \"THAWED\") < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Unable to thaw all processes\"));\n\n            return -1;\n        }\n\n        goto cleanup;\n    }\n\n    if (priv->cgroup) {\n        rc = virCgroupKillPainfully(priv->cgroup);\n        if (rc < 0)\n            return -1;\n        if (rc > 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Some processes refused to die\"));\n            return -1;\n        }\n    } else if (vm->pid > 0) {\n        /* If cgroup doesn't exist, just try cleaning up the\n         * libvirt_lxc process */\n        if (virProcessKillPainfully(vm->pid, true) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Processes %d refused to die\"), (int)vm->pid);\n            return -1;\n        }\n    }\n\n cleanup:\n    virLXCProcessCleanup(driver, vm, reason);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "vm"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHookCall",
          "args": [
            "VIR_HOOK_DRIVER_LXC",
            "vm->def->name",
            "VIR_HOOK_LXC_OP_RECONNECT",
            "VIR_HOOK_SUBOP_BEGIN",
            "NULL",
            "xml",
            "NULL"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "virHookCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "243-341",
          "snippet": "int\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\""
          ],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\"\n\nstatic int virHooksFound = -1;\n\nint\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFormat",
          "args": [
            "vm->def",
            "driver->xmlopt",
            "0"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29496-29508",
          "snippet": "char *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)\n\nchar *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHookPresent",
          "args": [
            "VIR_HOOK_DRIVER_LXC"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "virHookPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "210-222",
          "snippet": "int\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virHooksFound = -1;\n\nint\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Cannot update XML for running LXC guest %s\"",
            "vm->def->name"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjSave",
          "args": [
            "vm",
            "driver->xmlopt",
            "cfg->stateDir"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29706-29723",
          "snippet": "int\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjDispose(void *obj);",
            "static void virDomainXMLOptionDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virDomainObjDispose(void *obj);\nstatic void virDomainXMLOptionDispose(void *obj);\n\nint\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCProcessReconnectNotifyNets",
          "args": [
            "vm->def"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessReconnectNotifyNets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "1632-1656",
          "snippet": "static void\nvirLXCProcessReconnectNotifyNets(virDomainDefPtr def)\n{\n    size_t i;\n    virConnectPtr conn = NULL;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        /* keep others from trying to use the macvtap device name, but\n         * don't return error if this happens, since that causes the\n         * domain to be unceremoniously killed, which would be *very*\n         * impolite.\n         */\n        if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_DIRECT)\n           ignore_value(virNetDevMacVLanReserveName(net->ifname, false));\n\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (!conn && !(conn = virGetConnectNetwork()))\n                continue;\n            virDomainNetNotifyActualDevice(conn, def, net);\n        }\n    }\n\n    virObjectUnref(conn);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic void\nvirLXCProcessReconnectNotifyNets(virDomainDefPtr def)\n{\n    size_t i;\n    virConnectPtr conn = NULL;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        /* keep others from trying to use the macvtap device name, but\n         * don't return error if this happens, since that causes the\n         * domain to be unceremoniously killed, which would be *very*\n         * impolite.\n         */\n        if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_DIRECT)\n           ignore_value(virNetDevMacVLanReserveName(net->ifname, false));\n\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (!conn && !(conn = virGetConnectNetwork()))\n                continue;\n            virDomainNetNotifyActualDevice(conn, def, net);\n        }\n    }\n\n    virObjectUnref(conn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerReserveLabel",
          "args": [
            "driver->securityManager",
            "vm->def",
            "vm->pid"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerReserveLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "716-731",
          "snippet": "int\nvirSecurityManagerReserveLabel(virSecurityManagerPtr mgr,\n                               virDomainDefPtr vm,\n                               pid_t pid)\n{\n    if (mgr->drv->domainReserveSecurityLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainReserveSecurityLabel(mgr, vm, pid);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerReserveLabel(virSecurityManagerPtr mgr,\n                               virDomainDefPtr vm,\n                               pid_t pid)\n{\n    if (mgr->drv->domainReserveSecurityLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainReserveSecurityLabel(mgr, vm, pid);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCUpdateActiveUSBHostdevs",
          "args": [
            "driver",
            "vm->def"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCUpdateActiveUSBHostdevs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_hostdev.c",
          "lines": "34-46",
          "snippet": "int\nvirLXCUpdateActiveUSBHostdevs(virLXCDriverPtr driver,\n                              virDomainDefPtr def)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActiveUSBDevices(hostdev_mgr,\n                                            def->hostdevs, def->nhostdevs,\n                                            LXC_DRIVER_NAME, def->name);\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"lxc_hostdev.h\"\n#include <config.h>\n\nint\nvirLXCUpdateActiveUSBHostdevs(virLXCDriverPtr driver,\n                              virDomainDefPtr def)\n{\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    return virHostdevUpdateActiveUSBDevices(hostdev_mgr,\n                                            def->hostdevs, def->nhostdevs,\n                                            LXC_DRIVER_NAME, def->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"No valid cgroup for machine %s\")",
            "vm->def->name"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No valid cgroup for machine %s\""
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "userns_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2329-2332",
          "snippet": "static int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCgroupNewDetectMachine",
          "args": [
            "vm->def->name",
            "\"lxc\"",
            "vm->pid",
            "-1",
            "priv->machineName",
            "&priv->cgroup"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "virCgroupNewDetectMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircgroup.c",
          "lines": "2849-2860",
          "snippet": "int\nvirCgroupNewDetectMachine(const char *name G_GNUC_UNUSED,\n                          const char *drivername G_GNUC_UNUSED,\n                          pid_t pid G_GNUC_UNUSED,\n                          int controllers G_GNUC_UNUSED,\n                          char *machinename G_GNUC_UNUSED,\n                          virCgroupPtr *group G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircgroupbackend.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"vircgrouppriv.h\"",
            "# include <unistd.h>",
            "# include <dirent.h>",
            "# include <signal.h>",
            "# include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <sys/stat.h>",
            "# include <fcntl.h>",
            "# include <sys/mount.h>",
            "# include <mntent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virhostcpu.h\"\n#include \"virtypedparam.h\"\n#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhashcode.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircgroupbackend.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"vircgrouppriv.h\"\n# include <unistd.h>\n# include <dirent.h>\n# include <signal.h>\n# include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n# include <sys/mount.h>\n# include <mntent.h>\n#include <config.h>\n\nint\nvirCgroupNewDetectMachine(const char *name G_GNUC_UNUSED,\n                          const char *drivername G_GNUC_UNUSED,\n                          pid_t pid G_GNUC_UNUSED,\n                          int controllers G_GNUC_UNUSED,\n                          char *machinename G_GNUC_UNUSED,\n                          virCgroupPtr *group G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCDomainGetMachineName",
          "args": [
            "vm->def",
            "vm->pid"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCDomainGetMachineName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_domain.c",
          "lines": "397-412",
          "snippet": "char *\nvirLXCDomainGetMachineName(virDomainDefPtr def, pid_t pid)\n{\n    char *ret = NULL;\n\n    if (pid) {\n        ret = virSystemdGetMachineNameByPID(pid);\n        if (!ret)\n            virResetLastError();\n    }\n\n    if (!ret)\n        ret = virDomainGenerateMachineName(\"lxc\", NULL, def->id, def->name, true);\n\n    return ret;\n}",
          "includes": [
            "#include \"virinitctl.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virinitctl.h\"\n#include \"virsystemd.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"lxc_domain.h\"\n#include <config.h>\n\nchar *\nvirLXCDomainGetMachineName(virDomainDefPtr def, pid_t pid)\n{\n    char *ret = NULL;\n\n    if (pid) {\n        ret = virSystemdGetMachineNameByPID(pid);\n        if (!ret)\n            virResetLastError();\n    }\n\n    if (!ret)\n        ret = virDomainGenerateMachineName(\"lxc\", NULL, def->id, def->name, true);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCProcessConnectMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessConnectMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "819-849",
          "snippet": "static virLXCMonitorPtr virLXCProcessConnectMonitor(virLXCDriverPtr driver,\n                                                    virDomainObjPtr vm)\n{\n    virLXCMonitorPtr monitor = NULL;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n\n    if (virSecurityManagerSetSocketLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n\n    /* Hold an extra reference because we can't allow 'vm' to be\n     * deleted while the monitor is active. This will be unreffed\n     * during EOFNotify processing. */\n    virObjectRef(vm);\n\n    monitor = virLXCMonitorNew(vm, cfg->stateDir, &monitorCallbacks);\n\n    if (monitor == NULL)\n        virObjectUnref(vm);\n\n    if (virSecurityManagerClearSocketLabel(driver->securityManager, vm->def) < 0) {\n        if (monitor) {\n            virObjectUnref(monitor);\n            monitor = NULL;\n        }\n        goto cleanup;\n    }\n\n cleanup:\n    virObjectUnref(cfg);\n    return monitor;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLXCMonitorCallbacks monitorCallbacks = {\n    .eofNotify = virLXCProcessMonitorEOFNotify,\n    .exitNotify = virLXCProcessMonitorExitNotify,\n    .initNotify = virLXCProcessMonitorInitNotify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virLXCMonitorCallbacks monitorCallbacks = {\n    .eofNotify = virLXCProcessMonitorEOFNotify,\n    .exitNotify = virLXCProcessMonitorExitNotify,\n    .initNotify = virLXCProcessMonitorInitNotify,\n};\n\nstatic virLXCMonitorPtr virLXCProcessConnectMonitor(virLXCDriverPtr driver,\n                                                    virDomainObjPtr vm)\n{\n    virLXCMonitorPtr monitor = NULL;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n\n    if (virSecurityManagerSetSocketLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n\n    /* Hold an extra reference because we can't allow 'vm' to be\n     * deleted while the monitor is active. This will be unreffed\n     * during EOFNotify processing. */\n    virObjectRef(vm);\n\n    monitor = virLXCMonitorNew(vm, cfg->stateDir, &monitorCallbacks);\n\n    if (monitor == NULL)\n        virObjectUnref(vm);\n\n    if (virSecurityManagerClearSocketLabel(driver->securityManager, vm->def) < 0) {\n        if (monitor) {\n            virObjectUnref(monitor);\n            monitor = NULL;\n        }\n        goto cleanup;\n    }\n\n cleanup:\n    virObjectUnref(cfg);\n    return monitor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "driver->inhibitCallback",
          "args": [
            "true",
            "driver->inhibitOpaque"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_atomic_int_add",
          "args": [
            "&driver->nactive",
            "1"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_RUNNING",
            "VIR_DOMAIN_RUNNING_UNKNOWN"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Reconnect id=%d pid=%d state=%d\"",
            "vm->def->id",
            "vm->pid",
            "vm->state.state"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "vm"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
          "lines": "279-286",
          "snippet": "virLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver)\n{\n    virLXCDriverConfigPtr cfg;\n    lxcDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    lxcDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"lxc_container.h\"",
            "#include \"configmake.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_conf.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virnodesuspend.h\"\n#include \"lxc_container.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_conf.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver)\n{\n    virLXCDriverConfigPtr cfg;\n    lxcDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    lxcDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirLXCProcessReconnectDomain(virDomainObjPtr vm,\n                             void *opaque)\n{\n    virLXCDriverPtr driver = opaque;\n    virLXCDomainObjPrivatePtr priv;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    int ret = -1;\n\n    virObjectLock(vm);\n    VIR_DEBUG(\"Reconnect id=%d pid=%d state=%d\", vm->def->id, vm->pid, vm->state.state);\n\n    priv = vm->privateData;\n\n    if (vm->pid != 0) {\n        vm->def->id = vm->pid;\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_UNKNOWN);\n\n        if (g_atomic_int_add(&driver->nactive, 1) == 0 && driver->inhibitCallback)\n            driver->inhibitCallback(true, driver->inhibitOpaque);\n\n        if (!(priv->monitor = virLXCProcessConnectMonitor(driver, vm)))\n            goto error;\n\n        priv->machineName = virLXCDomainGetMachineName(vm->def, vm->pid);\n        if (!priv->machineName)\n            goto cleanup;\n\n        if (virCgroupNewDetectMachine(vm->def->name, \"lxc\", vm->pid, -1,\n                                      priv->machineName, &priv->cgroup) < 0)\n            goto error;\n\n        if (!priv->cgroup) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"No valid cgroup for machine %s\"),\n                           vm->def->name);\n            goto error;\n        }\n\n        if (virLXCUpdateActiveUSBHostdevs(driver, vm->def) < 0)\n            goto error;\n\n        if (virSecurityManagerReserveLabel(driver->securityManager,\n                                           vm->def, vm->pid) < 0)\n            goto error;\n\n        virLXCProcessReconnectNotifyNets(vm->def);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n            VIR_WARN(\"Cannot update XML for running LXC guest %s\", vm->def->name);\n\n        /* now that we know it's reconnected call the hook if present */\n        if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n            char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n            int hookret;\n\n            /* we can't stop the operation even if the script raised an error */\n            hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                                  VIR_HOOK_LXC_OP_RECONNECT, VIR_HOOK_SUBOP_BEGIN,\n                                  NULL, xml, NULL);\n            VIR_FREE(xml);\n            if (hookret < 0)\n                goto error;\n        }\n\n    } else {\n        vm->def->id = -1;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnref(cfg);\n    virObjectUnlock(vm);\n    return ret;\n\n error:\n    virLXCProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED);\n    virDomainAuditStop(vm, \"failed\");\n    goto cleanup;\n}"
  },
  {
    "function_name": "virLXCProcessReconnectNotifyNets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "1632-1656",
    "snippet": "static void\nvirLXCProcessReconnectNotifyNets(virDomainDefPtr def)\n{\n    size_t i;\n    virConnectPtr conn = NULL;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        /* keep others from trying to use the macvtap device name, but\n         * don't return error if this happens, since that causes the\n         * domain to be unceremoniously killed, which would be *very*\n         * impolite.\n         */\n        if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_DIRECT)\n           ignore_value(virNetDevMacVLanReserveName(net->ifname, false));\n\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (!conn && !(conn = virGetConnectNetwork()))\n                continue;\n            virDomainNetNotifyActualDevice(conn, def, net);\n        }\n    }\n\n    virObjectUnref(conn);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "conn"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetNotifyActualDevice",
          "args": [
            "conn",
            "def",
            "net"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetNotifyActualDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "31506-31533",
          "snippet": "void\nvirDomainNetNotifyActualDevice(virConnectPtr conn,\n                               virDomainDefPtr dom,\n                               virDomainNetDefPtr iface)\n{\n    virDomainNetType actualType = virDomainNetGetActualType(iface);\n\n    if (virDomainNetCreatePort(conn, dom, iface,\n                               VIR_NETWORK_PORT_CREATE_RECLAIM) < 0) {\n        return;\n    }\n\n    if (actualType == VIR_DOMAIN_NET_TYPE_NETWORK ||\n        actualType == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n        /*\n         * NB: we can't notify the guest of any MTU change anyway,\n         * so there is no point in trying to learn the actualMTU\n         * (final arg to virNetDevTapReattachBridge())\n         */\n        ignore_value(virNetDevTapReattachBridge(iface->ifname,\n                                                iface->data.network.actual->data.bridge.brname,\n                                                &iface->mac, dom->uuid,\n                                                virDomainNetGetActualVirtPortProfile(iface),\n                                                virDomainNetGetActualVlan(iface),\n                                                virDomainNetGetActualPortOptionsIsolated(iface),\n                                                iface->mtu, NULL));\n    }\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainNetNotifyActualDevice(virConnectPtr conn,\n                               virDomainDefPtr dom,\n                               virDomainNetDefPtr iface)\n{\n    virDomainNetType actualType = virDomainNetGetActualType(iface);\n\n    if (virDomainNetCreatePort(conn, dom, iface,\n                               VIR_NETWORK_PORT_CREATE_RECLAIM) < 0) {\n        return;\n    }\n\n    if (actualType == VIR_DOMAIN_NET_TYPE_NETWORK ||\n        actualType == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n        /*\n         * NB: we can't notify the guest of any MTU change anyway,\n         * so there is no point in trying to learn the actualMTU\n         * (final arg to virNetDevTapReattachBridge())\n         */\n        ignore_value(virNetDevTapReattachBridge(iface->ifname,\n                                                iface->data.network.actual->data.bridge.brname,\n                                                &iface->mac, dom->uuid,\n                                                virDomainNetGetActualVirtPortProfile(iface),\n                                                virDomainNetGetActualVlan(iface),\n                                                virDomainNetGetActualPortOptionsIsolated(iface),\n                                                iface->mtu, NULL));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetConnectNetwork",
          "args": [],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "virGetConnectNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "169-172",
          "snippet": "virConnectPtr virGetConnectNetwork(void)\n{\n    return virGetConnectGeneric(&connectNetwork, \"network\");\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal connectNetwork;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirThreadLocal connectNetwork;\n\nvirConnectPtr virGetConnectNetwork(void)\n{\n    return virGetConnectGeneric(&connectNetwork, \"network\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevMacVLanReserveName(net->ifname, false)"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevMacVLanReserveName",
          "args": [
            "net->ifname",
            "false"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevMacVLanReserveName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevmacvlan.c",
          "lines": "1281-1287",
          "snippet": "int virNetDevMacVLanReserveName(const char *name G_GNUC_UNUSED,\n                                bool quietFail G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Cannot create macvlan devices on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virbitmap.h\"",
            "# include \"virpidfile.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virnetlink.h\"",
            "# include \"virfile.h\"",
            "# include \"viruuid.h\"",
            "# include \"virlog.h\"",
            "# include \"viralloc.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virbitmap.h\"\n# include \"virpidfile.h\"\n# include \"virnetdev.h\"\n# include \"virnetlink.h\"\n# include \"virfile.h\"\n# include \"viruuid.h\"\n# include \"virlog.h\"\n# include \"viralloc.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virnetdevmacvlan.h\"\n#include <config.h>\n\nint virNetDevMacVLanReserveName(const char *name G_GNUC_UNUSED,\n                                bool quietFail G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Cannot create macvlan devices on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualType",
          "args": [
            "net"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30154-30162",
          "snippet": "virDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic void\nvirLXCProcessReconnectNotifyNets(virDomainDefPtr def)\n{\n    size_t i;\n    virConnectPtr conn = NULL;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        /* keep others from trying to use the macvtap device name, but\n         * don't return error if this happens, since that causes the\n         * domain to be unceremoniously killed, which would be *very*\n         * impolite.\n         */\n        if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_DIRECT)\n           ignore_value(virNetDevMacVLanReserveName(net->ifname, false));\n\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (!conn && !(conn = virGetConnectNetwork()))\n                continue;\n            virDomainNetNotifyActualDevice(conn, def, net);\n        }\n    }\n\n    virObjectUnref(conn);\n}"
  },
  {
    "function_name": "virLXCProcessAutostartAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "1611-1629",
    "snippet": "void\nvirLXCProcessAutostartAll(virLXCDriverPtr driver)\n{\n    /* XXX: Figure out a better way todo this. The domain\n     * startup code needs a connection handle in order\n     * to lookup the bridge associated with a virtual\n     * network\n     */\n    virConnectPtr conn = virConnectOpen(\"lxc:///system\");\n    /* Ignoring NULL conn which is mostly harmless here */\n\n    struct virLXCProcessAutostartData data = { driver, conn };\n\n    virDomainObjListForEach(driver->domains, false,\n                            virLXCProcessAutostartDomain,\n                            &data);\n\n    virObjectUnref(conn);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "conn"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListForEach",
          "args": [
            "driver->domains",
            "false",
            "virLXCProcessAutostartDomain",
            "&data"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListForEach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "827-844",
          "snippet": "int\nvirDomainObjListForEach(virDomainObjListPtr doms,\n                        bool modify,\n                        virDomainObjListIterator callback,\n                        void *opaque)\n{\n    struct virDomainListIterData data = {\n        callback, opaque, 0,\n    };\n\n    if (modify)\n        virObjectRWLockWrite(doms);\n    else\n        virObjectRWLockRead(doms);\n    virHashForEach(doms->objs, virDomainObjListHelper, &data);\n    virObjectRWUnlock(doms);\n    return data.ret;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDomainObjListForEach(virDomainObjListPtr doms,\n                        bool modify,\n                        virDomainObjListIterator callback,\n                        void *opaque)\n{\n    struct virDomainListIterData data = {\n        callback, opaque, 0,\n    };\n\n    if (modify)\n        virObjectRWLockWrite(doms);\n    else\n        virObjectRWLockRead(doms);\n    virHashForEach(doms->objs, virDomainObjListHelper, &data);\n    virObjectRWUnlock(doms);\n    return data.ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectOpen",
          "args": [
            "\"lxc:///system\""
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectOpenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "1181-1199",
          "snippet": "virConnectPtr\nvirConnectOpenReadOnly(const char *name)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n    virResetLastError();\n    ret = virConnectOpenInternal(name, NULL, VIR_CONNECT_RO);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirConnectPtr\nvirConnectOpenReadOnly(const char *name)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n    virResetLastError();\n    ret = virConnectOpenInternal(name, NULL, VIR_CONNECT_RO);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid\nvirLXCProcessAutostartAll(virLXCDriverPtr driver)\n{\n    /* XXX: Figure out a better way todo this. The domain\n     * startup code needs a connection handle in order\n     * to lookup the bridge associated with a virtual\n     * network\n     */\n    virConnectPtr conn = virConnectOpen(\"lxc:///system\");\n    /* Ignoring NULL conn which is mostly harmless here */\n\n    struct virLXCProcessAutostartData data = { driver, conn };\n\n    virDomainObjListForEach(driver->domains, false,\n                            virLXCProcessAutostartDomain,\n                            &data);\n\n    virObjectUnref(conn);\n}"
  },
  {
    "function_name": "virLXCProcessAutostartDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "1580-1608",
    "snippet": "static int\nvirLXCProcessAutostartDomain(virDomainObjPtr vm,\n                             void *opaque)\n{\n    const struct virLXCProcessAutostartData *data = opaque;\n    int ret = 0;\n\n    virObjectLock(vm);\n    if (vm->autostart &&\n        !virDomainObjIsActive(vm)) {\n        ret = virLXCProcessStart(data->conn, data->driver, vm,\n                                 0, NULL, false,\n                                 VIR_DOMAIN_RUNNING_BOOTED);\n        virDomainAuditStart(vm, \"booted\", ret >= 0);\n        if (ret < 0) {\n            VIR_ERROR(_(\"Failed to autostart VM '%s': %s\"),\n                      vm->def->name,\n                      virGetLastErrorMessage());\n        } else {\n            virObjectEventPtr event =\n                virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STARTED,\n                                         VIR_DOMAIN_EVENT_STARTED_BOOTED);\n            virObjectEventStateQueue(data->driver->domainEventState, event);\n        }\n    }\n    virObjectUnlock(vm);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "vm"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "data->driver->domainEventState",
            "event"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainEventLifecycleNewFromObj",
          "args": [
            "vm",
            "VIR_DOMAIN_EVENT_STARTED",
            "VIR_DOMAIN_EVENT_STARTED_BOOTED"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainEventLifecycleNewFromObj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_event.c",
          "lines": "610-616",
          "snippet": "virObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainEventDispose(void *obj);",
            "static void virDomainEventLifecycleDispose(void *obj);",
            "static void virDomainEventRTCChangeDispose(void *obj);",
            "static void virDomainEventWatchdogDispose(void *obj);",
            "static void virDomainEventIOErrorDispose(void *obj);",
            "static void virDomainEventGraphicsDispose(void *obj);",
            "static void virDomainEventBlockJobDispose(void *obj);",
            "static void virDomainEventDiskChangeDispose(void *obj);",
            "static void virDomainEventTrayChangeDispose(void *obj);",
            "static void virDomainEventBalloonChangeDispose(void *obj);",
            "static void virDomainEventDeviceRemovedDispose(void *obj);",
            "static void virDomainEventPMDispose(void *obj);",
            "static void virDomainQemuMonitorEventDispose(void *obj);",
            "static void virDomainEventTunableDispose(void *obj);",
            "static void virDomainEventAgentLifecycleDispose(void *obj);",
            "static void virDomainEventDeviceAddedDispose(void *obj);",
            "static void virDomainEventMigrationIterationDispose(void *obj);",
            "static void virDomainEventJobCompletedDispose(void *obj);",
            "static void virDomainEventDeviceRemovalFailedDispose(void *obj);",
            "static void virDomainEventMetadataChangeDispose(void *obj);",
            "static void virDomainEventBlockThresholdDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virDomainEventDispose(void *obj);\nstatic void virDomainEventLifecycleDispose(void *obj);\nstatic void virDomainEventRTCChangeDispose(void *obj);\nstatic void virDomainEventWatchdogDispose(void *obj);\nstatic void virDomainEventIOErrorDispose(void *obj);\nstatic void virDomainEventGraphicsDispose(void *obj);\nstatic void virDomainEventBlockJobDispose(void *obj);\nstatic void virDomainEventDiskChangeDispose(void *obj);\nstatic void virDomainEventTrayChangeDispose(void *obj);\nstatic void virDomainEventBalloonChangeDispose(void *obj);\nstatic void virDomainEventDeviceRemovedDispose(void *obj);\nstatic void virDomainEventPMDispose(void *obj);\nstatic void virDomainQemuMonitorEventDispose(void *obj);\nstatic void virDomainEventTunableDispose(void *obj);\nstatic void virDomainEventAgentLifecycleDispose(void *obj);\nstatic void virDomainEventDeviceAddedDispose(void *obj);\nstatic void virDomainEventMigrationIterationDispose(void *obj);\nstatic void virDomainEventJobCompletedDispose(void *obj);\nstatic void virDomainEventDeviceRemovalFailedDispose(void *obj);\nstatic void virDomainEventMetadataChangeDispose(void *obj);\nstatic void virDomainEventBlockThresholdDispose(void *obj);\n\nvirObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Failed to autostart VM '%s': %s\")",
            "vm->def->name",
            "virGetLastErrorMessage()"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to autostart VM '%s': %s\""
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "userns_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2329-2332",
          "snippet": "static int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainAuditStart",
          "args": [
            "vm",
            "\"booted\"",
            "ret >= 0"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainAuditStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_audit.c",
          "lines": "771-840",
          "snippet": "void\nvirDomainAuditStart(virDomainObjPtr vm, const char *reason, bool success)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->ndisks; i++)\n        virDomainAuditDisk(vm, NULL, vm->def->disks[i]->src, \"start\", true);\n\n    for (i = 0; i < vm->def->nfss; i++) {\n        virDomainFSDefPtr fs = vm->def->fss[i];\n        virDomainAuditFS(vm, NULL, fs, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr net = vm->def->nets[i];\n        virDomainAuditNet(vm, NULL, net, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = vm->def->hostdevs[i];\n        virDomainAuditHostdev(vm, hostdev, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nredirdevs; i++) {\n        virDomainRedirdevDefPtr redirdev = vm->def->redirdevs[i];\n        virDomainAuditRedirdev(vm, redirdev, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nserials; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->serials[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nparallels; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->parallels[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nchannels; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->channels[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        if (i == 0 &&\n            (vm->def->consoles[i]->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_SERIAL ||\n             vm->def->consoles[i]->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_NONE) &&\n             vm->def->os.type == VIR_DOMAIN_OSTYPE_HVM)\n            continue;\n\n        virDomainAuditChardev(vm, NULL, vm->def->consoles[i], \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nsmartcards; i++)\n        virDomainAuditSmartcard(vm, vm->def->smartcards[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nrngs; i++)\n        virDomainAuditRNG(vm, NULL, vm->def->rngs[i], \"start\", true);\n\n    if (vm->def->tpm)\n        virDomainAuditTPM(vm, vm->def->tpm, \"start\", true);\n\n    for (i = 0; i < vm->def->nshmems; i++)\n        virDomainAuditShmem(vm, vm->def->shmems[i], \"start\", true);\n\n    for (i = 0; i < vm->def->ninputs; i++)\n        virDomainAuditInput(vm, vm->def->inputs[i], \"start\", true);\n\n    virDomainAuditMemory(vm, 0, virDomainDefGetMemoryTotal(vm->def),\n                         \"start\", true);\n    virDomainAuditVcpu(vm, 0, virDomainDefGetVcpus(vm->def), \"start\", true);\n    if (vm->def->niothreadids)\n        virDomainAuditIOThread(vm, 0, vm->def->niothreadids, \"start\", true);\n\n    virDomainAuditLifecycle(vm, \"start\", reason, success);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"viruuid.h\"",
            "#include \"viraudit.h\"",
            "#include \"domain_audit.h\"",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"viruuid.h\"\n#include \"viraudit.h\"\n#include \"domain_audit.h\"\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid\nvirDomainAuditStart(virDomainObjPtr vm, const char *reason, bool success)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->ndisks; i++)\n        virDomainAuditDisk(vm, NULL, vm->def->disks[i]->src, \"start\", true);\n\n    for (i = 0; i < vm->def->nfss; i++) {\n        virDomainFSDefPtr fs = vm->def->fss[i];\n        virDomainAuditFS(vm, NULL, fs, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr net = vm->def->nets[i];\n        virDomainAuditNet(vm, NULL, net, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = vm->def->hostdevs[i];\n        virDomainAuditHostdev(vm, hostdev, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nredirdevs; i++) {\n        virDomainRedirdevDefPtr redirdev = vm->def->redirdevs[i];\n        virDomainAuditRedirdev(vm, redirdev, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nserials; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->serials[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nparallels; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->parallels[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nchannels; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->channels[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        if (i == 0 &&\n            (vm->def->consoles[i]->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_SERIAL ||\n             vm->def->consoles[i]->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_NONE) &&\n             vm->def->os.type == VIR_DOMAIN_OSTYPE_HVM)\n            continue;\n\n        virDomainAuditChardev(vm, NULL, vm->def->consoles[i], \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nsmartcards; i++)\n        virDomainAuditSmartcard(vm, vm->def->smartcards[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nrngs; i++)\n        virDomainAuditRNG(vm, NULL, vm->def->rngs[i], \"start\", true);\n\n    if (vm->def->tpm)\n        virDomainAuditTPM(vm, vm->def->tpm, \"start\", true);\n\n    for (i = 0; i < vm->def->nshmems; i++)\n        virDomainAuditShmem(vm, vm->def->shmems[i], \"start\", true);\n\n    for (i = 0; i < vm->def->ninputs; i++)\n        virDomainAuditInput(vm, vm->def->inputs[i], \"start\", true);\n\n    virDomainAuditMemory(vm, 0, virDomainDefGetMemoryTotal(vm->def),\n                         \"start\", true);\n    virDomainAuditVcpu(vm, 0, virDomainDefGetVcpus(vm->def), \"start\", true);\n    if (vm->def->niothreadids)\n        virDomainAuditIOThread(vm, 0, vm->def->niothreadids, \"start\", true);\n\n    virDomainAuditLifecycle(vm, \"start\", reason, success);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCProcessStart",
          "args": [
            "data->conn",
            "data->driver",
            "vm",
            "0",
            "NULL",
            "false",
            "VIR_DOMAIN_RUNNING_BOOTED"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "1182-1573",
          "snippet": "int virLXCProcessStart(virConnectPtr conn,\n                       virLXCDriverPtr  driver,\n                       virDomainObjPtr vm,\n                       unsigned int nfiles, int *files,\n                       bool autoDestroy,\n                       virDomainRunningReason reason)\n{\n    int rc = -1, r;\n    size_t nttyFDs = 0;\n    int *ttyFDs = NULL;\n    size_t i;\n    char *logfile = NULL;\n    int logfd = -1;\n    VIR_AUTOSTRINGLIST veths = NULL;\n    int handshakefds[2] = { -1, -1 };\n    off_t pos = -1;\n    char ebuf[1024];\n    char *timestamp;\n    int nsInheritFDs[VIR_LXC_DOMAIN_NAMESPACE_LAST];\n    virCommandPtr cmd = NULL;\n    virLXCDomainObjPrivatePtr priv = vm->privateData;\n    virCapsPtr caps = NULL;\n    virErrorPtr err = NULL;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    virCgroupPtr selfcgroup;\n    int status;\n    char *pidfile = NULL;\n\n    if (virCgroupNewSelf(&selfcgroup) < 0)\n        return -1;\n\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_CPUACCT)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'cpuacct' cgroups controller mount\"));\n        return -1;\n    }\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_DEVICES)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'devices' cgroups controller mount\"));\n        return -1;\n    }\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_MEMORY)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'memory' cgroups controller mount\"));\n        return -1;\n    }\n    virCgroupFree(&selfcgroup);\n\n    if (vm->def->nconsoles == 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"At least one PTY console is required\"));\n        return -1;\n    }\n\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        if (vm->def->consoles[i]->source->type != VIR_DOMAIN_CHR_TYPE_PTY) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only PTY console types are supported\"));\n            return -1;\n        }\n    }\n\n    if (virFileMakePath(cfg->logDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot create log directory '%s'\"),\n                             cfg->logDir);\n        return -1;\n    }\n\n    if (!vm->def->resource) {\n        virDomainResourceDefPtr res;\n\n        if (VIR_ALLOC(res) < 0)\n            goto cleanup;\n\n        res->partition = g_strdup(\"/machine\");\n\n        vm->def->resource = res;\n    }\n\n    logfile = g_strdup_printf(\"%s/%s.log\", cfg->logDir, vm->def->name);\n\n    if (!(pidfile = virPidFileBuildPath(cfg->stateDir, vm->def->name)))\n        goto cleanup;\n\n    if (!(caps = virLXCDriverGetCapabilities(driver, false)))\n        goto cleanup;\n\n    /* Do this up front, so any part of the startup process can add\n     * runtime state to vm->def that won't be persisted. This let's us\n     * report implicit runtime defaults in the XML, like vnc listen/socket\n     */\n    VIR_DEBUG(\"Setting current domain def as transient\");\n    if (virDomainObjSetDefTransient(driver->xmlopt, vm, NULL) < 0)\n        goto cleanup;\n\n    /* Run an early hook to set-up missing devices */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_PREPARE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    if (virLXCProcessEnsureRootFS(vm) < 0)\n        goto cleanup;\n\n    /* Must be run before security labelling */\n    VIR_DEBUG(\"Preparing host devices\");\n    if (virLXCPrepareHostDevices(driver, vm->def) < 0)\n        goto cleanup;\n\n    /* Here we open all the PTYs we need on the host OS side.\n     * The LXC controller will open the guest OS side PTYs\n     * and forward I/O between them.\n     */\n    nttyFDs = vm->def->nconsoles;\n    if (VIR_ALLOC_N(ttyFDs, nttyFDs) < 0)\n        goto cleanup;\n    for (i = 0; i < vm->def->nconsoles; i++)\n        ttyFDs[i] = -1;\n\n    /* If you are using a SecurityDriver with dynamic labelling,\n       then generate a security label for isolation */\n    VIR_DEBUG(\"Generating domain security label (if required)\");\n\n    if (vm->def->nseclabels &&\n        vm->def->seclabels[0]->type == VIR_DOMAIN_SECLABEL_DEFAULT)\n        vm->def->seclabels[0]->type = VIR_DOMAIN_SECLABEL_NONE;\n\n    if (virSecurityManagerCheckAllLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n\n    if (virSecurityManagerGenLabel(driver->securityManager, vm->def) < 0) {\n        virDomainAuditSecurityLabel(vm, false);\n        goto cleanup;\n    }\n    virDomainAuditSecurityLabel(vm, true);\n\n    VIR_DEBUG(\"Setting domain security labels\");\n    if (virSecurityManagerSetAllLabel(driver->securityManager,\n                                      vm->def, NULL, false, false) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up consoles\");\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        char *ttyPath;\n\n        if (virFileOpenTty(&ttyFDs[i], &ttyPath, 1) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Failed to allocate tty\"));\n            goto cleanup;\n        }\n\n        VIR_FREE(vm->def->consoles[i]->source->data.file.path);\n        vm->def->consoles[i]->source->data.file.path = ttyPath;\n\n        VIR_FREE(vm->def->consoles[i]->info.alias);\n        vm->def->consoles[i]->info.alias = g_strdup_printf(\"console%zu\", i);\n    }\n\n    VIR_DEBUG(\"Setting up Interfaces\");\n    if (virLXCProcessSetupInterfaces(driver, vm->def, &veths) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up namespaces if any\");\n    if (virLXCProcessSetupNamespaces(driver, vm->def->namespaceData, nsInheritFDs) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Preparing to launch\");\n    if ((logfd = open(logfile, O_WRONLY | O_APPEND | O_CREAT,\n             S_IRUSR|S_IWUSR)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to open '%s'\"),\n                             logfile);\n        goto cleanup;\n    }\n\n    if (virPipe(handshakefds) < 0)\n        goto cleanup;\n\n    if (!(cmd = virLXCProcessBuildControllerCmd(driver,\n                                                vm,\n                                                veths,\n                                                ttyFDs, nttyFDs,\n                                                nsInheritFDs,\n                                                files, nfiles,\n                                                handshakefds[1],\n                                                &logfd,\n                                                pidfile)))\n        goto cleanup;\n\n    /* now that we know it is about to start call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_START, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    /* Log timestamp */\n    if ((timestamp = virTimeStringNow()) == NULL)\n        goto cleanup;\n    if (safewrite(logfd, timestamp, strlen(timestamp)) < 0 ||\n        safewrite(logfd, START_POSTFIX, strlen(START_POSTFIX)) < 0) {\n        VIR_WARN(\"Unable to write timestamp to logfile: %s\",\n                 g_strerror(errno));\n    }\n    VIR_FREE(timestamp);\n\n    /* Log generated command line */\n    virCommandWriteArgLog(cmd, logfd);\n    if ((pos = lseek(logfd, 0, SEEK_END)) < 0)\n        VIR_WARN(\"Unable to seek to end of logfile: %s\",\n                 g_strerror(errno));\n\n    VIR_DEBUG(\"Launching container\");\n    virCommandRawStatus(cmd);\n    if (virCommandRun(cmd, &status) < 0)\n        goto cleanup;\n\n    if (status != 0) {\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf,\n                                       sizeof(ebuf)) <= 0) {\n            if (WIFEXITED(status))\n                g_snprintf(ebuf, sizeof(ebuf), _(\"unexpected exit status %d\"),\n                           WEXITSTATUS(status));\n            else\n                g_snprintf(ebuf, sizeof(ebuf), \"%s\", _(\"terminated abnormally\"));\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"guest failed to start: %s\"), ebuf);\n        goto cleanup;\n    }\n\n    /* It has started running, so get its pid */\n    if ((r = virPidFileReadPath(pidfile, &vm->pid)) < 0) {\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf, sizeof(ebuf)) > 0)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), ebuf);\n        else\n            virReportSystemError(-r,\n                                 _(\"Failed to read pid file %s\"),\n                                 pidfile);\n        goto cleanup;\n    }\n\n    priv->stopReason = VIR_DOMAIN_EVENT_STOPPED_FAILED;\n    priv->wantReboot = false;\n    vm->def->id = vm->pid;\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, reason);\n    priv->doneStopEvent = false;\n\n    if (VIR_CLOSE(handshakefds[1]) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"could not close handshake fd\"));\n        goto cleanup;\n    }\n\n    if (virCommandHandshakeWait(cmd) < 0)\n        goto cleanup;\n\n    /* Write domain status to disk for the controller to\n     * read when it starts */\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        goto cleanup;\n\n    /* Allow the child to exec the controller */\n    if (virCommandHandshakeNotify(cmd) < 0)\n        goto cleanup;\n\n    if (g_atomic_int_add(&driver->nactive, 1) == 0 && driver->inhibitCallback)\n        driver->inhibitCallback(true, driver->inhibitOpaque);\n\n    if (lxcContainerWaitForContinue(handshakefds[0]) < 0) {\n        char out[1024];\n\n        if (!(virLXCProcessReadLogOutput(vm, logfile, pos, out, 1024) < 0)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), out);\n        }\n\n        goto cleanup;\n    }\n\n    priv->machineName = virLXCDomainGetMachineName(vm->def, vm->pid);\n    if (!priv->machineName)\n        goto cleanup;\n\n    /* We know the cgroup must exist by this synchronization\n     * point so lets detect that first, since it gives us a\n     * more reliable way to kill everything off if something\n     * goes wrong from here onwards ... */\n    if (virCgroupNewDetectMachine(vm->def->name, \"lxc\",\n                                  vm->pid, -1, priv->machineName,\n                                  &priv->cgroup) < 0)\n        goto cleanup;\n\n    if (!priv->cgroup) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No valid cgroup for machine %s\"),\n                       vm->def->name);\n        goto cleanup;\n    }\n\n    /* And we can get the first monitor connection now too */\n    if (!(priv->monitor = virLXCProcessConnectMonitor(driver, vm))) {\n        /* Intentionally overwrite the real monitor error message,\n         * since a better one is almost always found in the logs\n         */\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf, sizeof(ebuf)) > 0) {\n            virResetLastError();\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), ebuf);\n        }\n        goto cleanup;\n    }\n\n    if (autoDestroy &&\n        virCloseCallbacksSet(driver->closeCallbacks, vm,\n                             conn, lxcProcessAutoDestroy) < 0)\n        goto cleanup;\n\n    /* We don't need the temporary NIC names anymore, clear them */\n    virLXCProcessCleanInterfaces(vm->def);\n\n    /* finally we can call the 'started' hook script if any */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_STARTED, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(logfd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"could not close logfile\"));\n        rc = -1;\n    }\n    if (rc != 0) {\n        virErrorPreserveLast(&err);\n        virLXCProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED);\n    }\n    virCommandFree(cmd);\n    for (i = 0; i < nttyFDs; i++)\n        VIR_FORCE_CLOSE(ttyFDs[i]);\n    VIR_FREE(ttyFDs);\n    VIR_FORCE_CLOSE(handshakefds[0]);\n    VIR_FORCE_CLOSE(handshakefds[1]);\n    VIR_FREE(pidfile);\n    VIR_FREE(logfile);\n    virObjectUnref(cfg);\n    virObjectUnref(caps);\n\n    virErrorRestore(&err);\n\n    return rc;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define START_POSTFIX \": starting up\\n\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define START_POSTFIX \": starting up\\n\"\n\nint virLXCProcessStart(virConnectPtr conn,\n                       virLXCDriverPtr  driver,\n                       virDomainObjPtr vm,\n                       unsigned int nfiles, int *files,\n                       bool autoDestroy,\n                       virDomainRunningReason reason)\n{\n    int rc = -1, r;\n    size_t nttyFDs = 0;\n    int *ttyFDs = NULL;\n    size_t i;\n    char *logfile = NULL;\n    int logfd = -1;\n    VIR_AUTOSTRINGLIST veths = NULL;\n    int handshakefds[2] = { -1, -1 };\n    off_t pos = -1;\n    char ebuf[1024];\n    char *timestamp;\n    int nsInheritFDs[VIR_LXC_DOMAIN_NAMESPACE_LAST];\n    virCommandPtr cmd = NULL;\n    virLXCDomainObjPrivatePtr priv = vm->privateData;\n    virCapsPtr caps = NULL;\n    virErrorPtr err = NULL;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    virCgroupPtr selfcgroup;\n    int status;\n    char *pidfile = NULL;\n\n    if (virCgroupNewSelf(&selfcgroup) < 0)\n        return -1;\n\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_CPUACCT)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'cpuacct' cgroups controller mount\"));\n        return -1;\n    }\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_DEVICES)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'devices' cgroups controller mount\"));\n        return -1;\n    }\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_MEMORY)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'memory' cgroups controller mount\"));\n        return -1;\n    }\n    virCgroupFree(&selfcgroup);\n\n    if (vm->def->nconsoles == 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"At least one PTY console is required\"));\n        return -1;\n    }\n\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        if (vm->def->consoles[i]->source->type != VIR_DOMAIN_CHR_TYPE_PTY) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only PTY console types are supported\"));\n            return -1;\n        }\n    }\n\n    if (virFileMakePath(cfg->logDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot create log directory '%s'\"),\n                             cfg->logDir);\n        return -1;\n    }\n\n    if (!vm->def->resource) {\n        virDomainResourceDefPtr res;\n\n        if (VIR_ALLOC(res) < 0)\n            goto cleanup;\n\n        res->partition = g_strdup(\"/machine\");\n\n        vm->def->resource = res;\n    }\n\n    logfile = g_strdup_printf(\"%s/%s.log\", cfg->logDir, vm->def->name);\n\n    if (!(pidfile = virPidFileBuildPath(cfg->stateDir, vm->def->name)))\n        goto cleanup;\n\n    if (!(caps = virLXCDriverGetCapabilities(driver, false)))\n        goto cleanup;\n\n    /* Do this up front, so any part of the startup process can add\n     * runtime state to vm->def that won't be persisted. This let's us\n     * report implicit runtime defaults in the XML, like vnc listen/socket\n     */\n    VIR_DEBUG(\"Setting current domain def as transient\");\n    if (virDomainObjSetDefTransient(driver->xmlopt, vm, NULL) < 0)\n        goto cleanup;\n\n    /* Run an early hook to set-up missing devices */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_PREPARE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    if (virLXCProcessEnsureRootFS(vm) < 0)\n        goto cleanup;\n\n    /* Must be run before security labelling */\n    VIR_DEBUG(\"Preparing host devices\");\n    if (virLXCPrepareHostDevices(driver, vm->def) < 0)\n        goto cleanup;\n\n    /* Here we open all the PTYs we need on the host OS side.\n     * The LXC controller will open the guest OS side PTYs\n     * and forward I/O between them.\n     */\n    nttyFDs = vm->def->nconsoles;\n    if (VIR_ALLOC_N(ttyFDs, nttyFDs) < 0)\n        goto cleanup;\n    for (i = 0; i < vm->def->nconsoles; i++)\n        ttyFDs[i] = -1;\n\n    /* If you are using a SecurityDriver with dynamic labelling,\n       then generate a security label for isolation */\n    VIR_DEBUG(\"Generating domain security label (if required)\");\n\n    if (vm->def->nseclabels &&\n        vm->def->seclabels[0]->type == VIR_DOMAIN_SECLABEL_DEFAULT)\n        vm->def->seclabels[0]->type = VIR_DOMAIN_SECLABEL_NONE;\n\n    if (virSecurityManagerCheckAllLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n\n    if (virSecurityManagerGenLabel(driver->securityManager, vm->def) < 0) {\n        virDomainAuditSecurityLabel(vm, false);\n        goto cleanup;\n    }\n    virDomainAuditSecurityLabel(vm, true);\n\n    VIR_DEBUG(\"Setting domain security labels\");\n    if (virSecurityManagerSetAllLabel(driver->securityManager,\n                                      vm->def, NULL, false, false) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up consoles\");\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        char *ttyPath;\n\n        if (virFileOpenTty(&ttyFDs[i], &ttyPath, 1) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Failed to allocate tty\"));\n            goto cleanup;\n        }\n\n        VIR_FREE(vm->def->consoles[i]->source->data.file.path);\n        vm->def->consoles[i]->source->data.file.path = ttyPath;\n\n        VIR_FREE(vm->def->consoles[i]->info.alias);\n        vm->def->consoles[i]->info.alias = g_strdup_printf(\"console%zu\", i);\n    }\n\n    VIR_DEBUG(\"Setting up Interfaces\");\n    if (virLXCProcessSetupInterfaces(driver, vm->def, &veths) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up namespaces if any\");\n    if (virLXCProcessSetupNamespaces(driver, vm->def->namespaceData, nsInheritFDs) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Preparing to launch\");\n    if ((logfd = open(logfile, O_WRONLY | O_APPEND | O_CREAT,\n             S_IRUSR|S_IWUSR)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to open '%s'\"),\n                             logfile);\n        goto cleanup;\n    }\n\n    if (virPipe(handshakefds) < 0)\n        goto cleanup;\n\n    if (!(cmd = virLXCProcessBuildControllerCmd(driver,\n                                                vm,\n                                                veths,\n                                                ttyFDs, nttyFDs,\n                                                nsInheritFDs,\n                                                files, nfiles,\n                                                handshakefds[1],\n                                                &logfd,\n                                                pidfile)))\n        goto cleanup;\n\n    /* now that we know it is about to start call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_START, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    /* Log timestamp */\n    if ((timestamp = virTimeStringNow()) == NULL)\n        goto cleanup;\n    if (safewrite(logfd, timestamp, strlen(timestamp)) < 0 ||\n        safewrite(logfd, START_POSTFIX, strlen(START_POSTFIX)) < 0) {\n        VIR_WARN(\"Unable to write timestamp to logfile: %s\",\n                 g_strerror(errno));\n    }\n    VIR_FREE(timestamp);\n\n    /* Log generated command line */\n    virCommandWriteArgLog(cmd, logfd);\n    if ((pos = lseek(logfd, 0, SEEK_END)) < 0)\n        VIR_WARN(\"Unable to seek to end of logfile: %s\",\n                 g_strerror(errno));\n\n    VIR_DEBUG(\"Launching container\");\n    virCommandRawStatus(cmd);\n    if (virCommandRun(cmd, &status) < 0)\n        goto cleanup;\n\n    if (status != 0) {\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf,\n                                       sizeof(ebuf)) <= 0) {\n            if (WIFEXITED(status))\n                g_snprintf(ebuf, sizeof(ebuf), _(\"unexpected exit status %d\"),\n                           WEXITSTATUS(status));\n            else\n                g_snprintf(ebuf, sizeof(ebuf), \"%s\", _(\"terminated abnormally\"));\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"guest failed to start: %s\"), ebuf);\n        goto cleanup;\n    }\n\n    /* It has started running, so get its pid */\n    if ((r = virPidFileReadPath(pidfile, &vm->pid)) < 0) {\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf, sizeof(ebuf)) > 0)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), ebuf);\n        else\n            virReportSystemError(-r,\n                                 _(\"Failed to read pid file %s\"),\n                                 pidfile);\n        goto cleanup;\n    }\n\n    priv->stopReason = VIR_DOMAIN_EVENT_STOPPED_FAILED;\n    priv->wantReboot = false;\n    vm->def->id = vm->pid;\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, reason);\n    priv->doneStopEvent = false;\n\n    if (VIR_CLOSE(handshakefds[1]) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"could not close handshake fd\"));\n        goto cleanup;\n    }\n\n    if (virCommandHandshakeWait(cmd) < 0)\n        goto cleanup;\n\n    /* Write domain status to disk for the controller to\n     * read when it starts */\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        goto cleanup;\n\n    /* Allow the child to exec the controller */\n    if (virCommandHandshakeNotify(cmd) < 0)\n        goto cleanup;\n\n    if (g_atomic_int_add(&driver->nactive, 1) == 0 && driver->inhibitCallback)\n        driver->inhibitCallback(true, driver->inhibitOpaque);\n\n    if (lxcContainerWaitForContinue(handshakefds[0]) < 0) {\n        char out[1024];\n\n        if (!(virLXCProcessReadLogOutput(vm, logfile, pos, out, 1024) < 0)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), out);\n        }\n\n        goto cleanup;\n    }\n\n    priv->machineName = virLXCDomainGetMachineName(vm->def, vm->pid);\n    if (!priv->machineName)\n        goto cleanup;\n\n    /* We know the cgroup must exist by this synchronization\n     * point so lets detect that first, since it gives us a\n     * more reliable way to kill everything off if something\n     * goes wrong from here onwards ... */\n    if (virCgroupNewDetectMachine(vm->def->name, \"lxc\",\n                                  vm->pid, -1, priv->machineName,\n                                  &priv->cgroup) < 0)\n        goto cleanup;\n\n    if (!priv->cgroup) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No valid cgroup for machine %s\"),\n                       vm->def->name);\n        goto cleanup;\n    }\n\n    /* And we can get the first monitor connection now too */\n    if (!(priv->monitor = virLXCProcessConnectMonitor(driver, vm))) {\n        /* Intentionally overwrite the real monitor error message,\n         * since a better one is almost always found in the logs\n         */\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf, sizeof(ebuf)) > 0) {\n            virResetLastError();\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), ebuf);\n        }\n        goto cleanup;\n    }\n\n    if (autoDestroy &&\n        virCloseCallbacksSet(driver->closeCallbacks, vm,\n                             conn, lxcProcessAutoDestroy) < 0)\n        goto cleanup;\n\n    /* We don't need the temporary NIC names anymore, clear them */\n    virLXCProcessCleanInterfaces(vm->def);\n\n    /* finally we can call the 'started' hook script if any */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_STARTED, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(logfd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"could not close logfile\"));\n        rc = -1;\n    }\n    if (rc != 0) {\n        virErrorPreserveLast(&err);\n        virLXCProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED);\n    }\n    virCommandFree(cmd);\n    for (i = 0; i < nttyFDs; i++)\n        VIR_FORCE_CLOSE(ttyFDs[i]);\n    VIR_FREE(ttyFDs);\n    VIR_FORCE_CLOSE(handshakefds[0]);\n    VIR_FORCE_CLOSE(handshakefds[1]);\n    VIR_FREE(pidfile);\n    VIR_FREE(logfile);\n    virObjectUnref(cfg);\n    virObjectUnref(caps);\n\n    virErrorRestore(&err);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjIsActive",
          "args": [
            "vm"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.h",
          "lines": "2845-2849",
          "snippet": "static inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virresctrl.h\"",
            "#include \"virsavecookie.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virperf.h\"",
            "#include \"virgic.h\"",
            "#include \"virprocess.h\"",
            "#include \"virseclabel.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virbitmap.h\"",
            "#include \"device_conf.h\"",
            "#include \"virobject.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"numa_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virthread.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"capabilities.h\"",
            "#include \"virconftypes.h\"",
            "#include \"internal.h\"",
            "#include <libxml/xpath.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parser.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void virDomainMemoryDefFree(virDomainMemoryDefPtr def);",
            "void virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);",
            "unsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);",
            "unsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);",
            "bool virDomainDefHasMemoryHotplug(const virDomainDef *def);",
            "int virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);",
            "bool virDomainDefHasUSB(const virDomainDef *def);",
            "int virDomainObjCheckActive(virDomainObjPtr dom);",
            "bool virDomainDefHasVcpusOffline(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpusMax(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpus(const virDomainDef *def);",
            "virBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);",
            "void virDomainDefVcpuOrderClear(virDomainDefPtr def);",
            "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);",
            "void virDomainInputDefFree(virDomainInputDefPtr def);",
            "void virDomainDiskDefFree(virDomainDiskDefPtr def);",
            "void virDomainLeaseDefFree(virDomainLeaseDefPtr def);",
            "int virDomainDiskGetType(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetSource(virDomainDiskDef const *def);",
            "void virDomainDiskEmptySource(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetDriver(const virDomainDiskDef *def);",
            "int virDomainDiskGetFormat(virDomainDiskDefPtr def);",
            "void virDomainControllerDefFree(virDomainControllerDefPtr def);",
            "void virDomainFSDefFree(virDomainFSDefPtr def);",
            "void virDomainActualNetDefFree(virDomainActualNetDefPtr def);",
            "void virDomainNetDefClear(virDomainNetDefPtr def);",
            "void virDomainNetDefFree(virDomainNetDefPtr def);",
            "void virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);",
            "void virDomainChrDefFree(virDomainChrDefPtr def);",
            "void virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);",
            "void virDomainSoundDefFree(virDomainSoundDefPtr def);",
            "void virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);",
            "void virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);",
            "void virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);",
            "void virDomainVideoDefFree(virDomainVideoDefPtr def);",
            "void virDomainVideoDefClear(virDomainVideoDefPtr def);",
            "void virDomainHostdevDefClear(virDomainHostdevDefPtr def);",
            "void virDomainHostdevDefFree(virDomainHostdevDefPtr def);",
            "void virDomainHubDefFree(virDomainHubDefPtr def);",
            "void virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);",
            "void virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);",
            "void virDomainShmemDefFree(virDomainShmemDefPtr def);",
            "void virDomainDeviceDefFree(virDomainDeviceDefPtr def);",
            "void virDomainTPMDefFree(virDomainTPMDefPtr def);",
            "void virDomainRNGDefFree(virDomainRNGDefPtr def);",
            "int virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);",
            "int virDomainVideoDefaultType(const virDomainDef *def);",
            "void virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);",
            "int virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);",
            "bool\nvirDomainDefHasManagedPR(const virDomainDef *def);",
            "bool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);",
            "bool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);",
            "bool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virresctrl.h\"\n#include \"virsavecookie.h\"\n#include \"virtypedparam.h\"\n#include \"virperf.h\"\n#include \"virgic.h\"\n#include \"virprocess.h\"\n#include \"virseclabel.h\"\n#include \"virstoragefile.h\"\n#include \"virbitmap.h\"\n#include \"device_conf.h\"\n#include \"virobject.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevvlan.h\"\n#include \"virnetdevbandwidth.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virsysinfo.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"numa_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"networkcommon_conf.h\"\n#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virthread.h\"\n#include \"cpu_conf.h\"\n#include \"virstorageencryption.h\"\n#include \"capabilities.h\"\n#include \"virconftypes.h\"\n#include \"internal.h\"\n#include <libxml/xpath.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n\nvoid virDomainMemoryDefFree(virDomainMemoryDefPtr def);\nvoid virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);\nunsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);\nunsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);\nbool virDomainDefHasMemoryHotplug(const virDomainDef *def);\nint virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);\nbool virDomainDefHasUSB(const virDomainDef *def);\nint virDomainObjCheckActive(virDomainObjPtr dom);\nbool virDomainDefHasVcpusOffline(const virDomainDef *def);\nunsigned int virDomainDefGetVcpusMax(const virDomainDef *def);\nunsigned int virDomainDefGetVcpus(const virDomainDef *def);\nvirBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);\nvoid virDomainDefVcpuOrderClear(virDomainDefPtr def);\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);\nvoid virDomainInputDefFree(virDomainInputDefPtr def);\nvoid virDomainDiskDefFree(virDomainDiskDefPtr def);\nvoid virDomainLeaseDefFree(virDomainLeaseDefPtr def);\nint virDomainDiskGetType(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetSource(virDomainDiskDef const *def);\nvoid virDomainDiskEmptySource(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetDriver(const virDomainDiskDef *def);\nint virDomainDiskGetFormat(virDomainDiskDefPtr def);\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def);\nvoid virDomainFSDefFree(virDomainFSDefPtr def);\nvoid virDomainActualNetDefFree(virDomainActualNetDefPtr def);\nvoid virDomainNetDefClear(virDomainNetDefPtr def);\nvoid virDomainNetDefFree(virDomainNetDefPtr def);\nvoid virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);\nvoid virDomainChrDefFree(virDomainChrDefPtr def);\nvoid virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def);\nvoid virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);\nvoid virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);\nvoid virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def);\nvoid virDomainVideoDefClear(virDomainVideoDefPtr def);\nvoid virDomainHostdevDefClear(virDomainHostdevDefPtr def);\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def);\nvoid virDomainHubDefFree(virDomainHubDefPtr def);\nvoid virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);\nvoid virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);\nvoid virDomainShmemDefFree(virDomainShmemDefPtr def);\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def);\nvoid virDomainTPMDefFree(virDomainTPMDefPtr def);\nvoid virDomainRNGDefFree(virDomainRNGDefPtr def);\nint virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);\nint virDomainVideoDefaultType(const virDomainDef *def);\nvoid virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);\nint virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);\nbool\nvirDomainDefHasManagedPR(const virDomainDef *def);\nbool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);\nbool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);\nbool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);\n\nstatic inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "vm"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirLXCProcessAutostartDomain(virDomainObjPtr vm,\n                             void *opaque)\n{\n    const struct virLXCProcessAutostartData *data = opaque;\n    int ret = 0;\n\n    virObjectLock(vm);\n    if (vm->autostart &&\n        !virDomainObjIsActive(vm)) {\n        ret = virLXCProcessStart(data->conn, data->driver, vm,\n                                 0, NULL, false,\n                                 VIR_DOMAIN_RUNNING_BOOTED);\n        virDomainAuditStart(vm, \"booted\", ret >= 0);\n        if (ret < 0) {\n            VIR_ERROR(_(\"Failed to autostart VM '%s': %s\"),\n                      vm->def->name,\n                      virGetLastErrorMessage());\n        } else {\n            virObjectEventPtr event =\n                virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STARTED,\n                                         VIR_DOMAIN_EVENT_STARTED_BOOTED);\n            virObjectEventStateQueue(data->driver->domainEventState, event);\n        }\n    }\n    virObjectUnlock(vm);\n    return ret;\n}"
  },
  {
    "function_name": "virLXCProcessStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "1182-1573",
    "snippet": "int virLXCProcessStart(virConnectPtr conn,\n                       virLXCDriverPtr  driver,\n                       virDomainObjPtr vm,\n                       unsigned int nfiles, int *files,\n                       bool autoDestroy,\n                       virDomainRunningReason reason)\n{\n    int rc = -1, r;\n    size_t nttyFDs = 0;\n    int *ttyFDs = NULL;\n    size_t i;\n    char *logfile = NULL;\n    int logfd = -1;\n    VIR_AUTOSTRINGLIST veths = NULL;\n    int handshakefds[2] = { -1, -1 };\n    off_t pos = -1;\n    char ebuf[1024];\n    char *timestamp;\n    int nsInheritFDs[VIR_LXC_DOMAIN_NAMESPACE_LAST];\n    virCommandPtr cmd = NULL;\n    virLXCDomainObjPrivatePtr priv = vm->privateData;\n    virCapsPtr caps = NULL;\n    virErrorPtr err = NULL;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    virCgroupPtr selfcgroup;\n    int status;\n    char *pidfile = NULL;\n\n    if (virCgroupNewSelf(&selfcgroup) < 0)\n        return -1;\n\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_CPUACCT)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'cpuacct' cgroups controller mount\"));\n        return -1;\n    }\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_DEVICES)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'devices' cgroups controller mount\"));\n        return -1;\n    }\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_MEMORY)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'memory' cgroups controller mount\"));\n        return -1;\n    }\n    virCgroupFree(&selfcgroup);\n\n    if (vm->def->nconsoles == 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"At least one PTY console is required\"));\n        return -1;\n    }\n\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        if (vm->def->consoles[i]->source->type != VIR_DOMAIN_CHR_TYPE_PTY) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only PTY console types are supported\"));\n            return -1;\n        }\n    }\n\n    if (virFileMakePath(cfg->logDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot create log directory '%s'\"),\n                             cfg->logDir);\n        return -1;\n    }\n\n    if (!vm->def->resource) {\n        virDomainResourceDefPtr res;\n\n        if (VIR_ALLOC(res) < 0)\n            goto cleanup;\n\n        res->partition = g_strdup(\"/machine\");\n\n        vm->def->resource = res;\n    }\n\n    logfile = g_strdup_printf(\"%s/%s.log\", cfg->logDir, vm->def->name);\n\n    if (!(pidfile = virPidFileBuildPath(cfg->stateDir, vm->def->name)))\n        goto cleanup;\n\n    if (!(caps = virLXCDriverGetCapabilities(driver, false)))\n        goto cleanup;\n\n    /* Do this up front, so any part of the startup process can add\n     * runtime state to vm->def that won't be persisted. This let's us\n     * report implicit runtime defaults in the XML, like vnc listen/socket\n     */\n    VIR_DEBUG(\"Setting current domain def as transient\");\n    if (virDomainObjSetDefTransient(driver->xmlopt, vm, NULL) < 0)\n        goto cleanup;\n\n    /* Run an early hook to set-up missing devices */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_PREPARE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    if (virLXCProcessEnsureRootFS(vm) < 0)\n        goto cleanup;\n\n    /* Must be run before security labelling */\n    VIR_DEBUG(\"Preparing host devices\");\n    if (virLXCPrepareHostDevices(driver, vm->def) < 0)\n        goto cleanup;\n\n    /* Here we open all the PTYs we need on the host OS side.\n     * The LXC controller will open the guest OS side PTYs\n     * and forward I/O between them.\n     */\n    nttyFDs = vm->def->nconsoles;\n    if (VIR_ALLOC_N(ttyFDs, nttyFDs) < 0)\n        goto cleanup;\n    for (i = 0; i < vm->def->nconsoles; i++)\n        ttyFDs[i] = -1;\n\n    /* If you are using a SecurityDriver with dynamic labelling,\n       then generate a security label for isolation */\n    VIR_DEBUG(\"Generating domain security label (if required)\");\n\n    if (vm->def->nseclabels &&\n        vm->def->seclabels[0]->type == VIR_DOMAIN_SECLABEL_DEFAULT)\n        vm->def->seclabels[0]->type = VIR_DOMAIN_SECLABEL_NONE;\n\n    if (virSecurityManagerCheckAllLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n\n    if (virSecurityManagerGenLabel(driver->securityManager, vm->def) < 0) {\n        virDomainAuditSecurityLabel(vm, false);\n        goto cleanup;\n    }\n    virDomainAuditSecurityLabel(vm, true);\n\n    VIR_DEBUG(\"Setting domain security labels\");\n    if (virSecurityManagerSetAllLabel(driver->securityManager,\n                                      vm->def, NULL, false, false) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up consoles\");\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        char *ttyPath;\n\n        if (virFileOpenTty(&ttyFDs[i], &ttyPath, 1) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Failed to allocate tty\"));\n            goto cleanup;\n        }\n\n        VIR_FREE(vm->def->consoles[i]->source->data.file.path);\n        vm->def->consoles[i]->source->data.file.path = ttyPath;\n\n        VIR_FREE(vm->def->consoles[i]->info.alias);\n        vm->def->consoles[i]->info.alias = g_strdup_printf(\"console%zu\", i);\n    }\n\n    VIR_DEBUG(\"Setting up Interfaces\");\n    if (virLXCProcessSetupInterfaces(driver, vm->def, &veths) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up namespaces if any\");\n    if (virLXCProcessSetupNamespaces(driver, vm->def->namespaceData, nsInheritFDs) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Preparing to launch\");\n    if ((logfd = open(logfile, O_WRONLY | O_APPEND | O_CREAT,\n             S_IRUSR|S_IWUSR)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to open '%s'\"),\n                             logfile);\n        goto cleanup;\n    }\n\n    if (virPipe(handshakefds) < 0)\n        goto cleanup;\n\n    if (!(cmd = virLXCProcessBuildControllerCmd(driver,\n                                                vm,\n                                                veths,\n                                                ttyFDs, nttyFDs,\n                                                nsInheritFDs,\n                                                files, nfiles,\n                                                handshakefds[1],\n                                                &logfd,\n                                                pidfile)))\n        goto cleanup;\n\n    /* now that we know it is about to start call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_START, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    /* Log timestamp */\n    if ((timestamp = virTimeStringNow()) == NULL)\n        goto cleanup;\n    if (safewrite(logfd, timestamp, strlen(timestamp)) < 0 ||\n        safewrite(logfd, START_POSTFIX, strlen(START_POSTFIX)) < 0) {\n        VIR_WARN(\"Unable to write timestamp to logfile: %s\",\n                 g_strerror(errno));\n    }\n    VIR_FREE(timestamp);\n\n    /* Log generated command line */\n    virCommandWriteArgLog(cmd, logfd);\n    if ((pos = lseek(logfd, 0, SEEK_END)) < 0)\n        VIR_WARN(\"Unable to seek to end of logfile: %s\",\n                 g_strerror(errno));\n\n    VIR_DEBUG(\"Launching container\");\n    virCommandRawStatus(cmd);\n    if (virCommandRun(cmd, &status) < 0)\n        goto cleanup;\n\n    if (status != 0) {\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf,\n                                       sizeof(ebuf)) <= 0) {\n            if (WIFEXITED(status))\n                g_snprintf(ebuf, sizeof(ebuf), _(\"unexpected exit status %d\"),\n                           WEXITSTATUS(status));\n            else\n                g_snprintf(ebuf, sizeof(ebuf), \"%s\", _(\"terminated abnormally\"));\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"guest failed to start: %s\"), ebuf);\n        goto cleanup;\n    }\n\n    /* It has started running, so get its pid */\n    if ((r = virPidFileReadPath(pidfile, &vm->pid)) < 0) {\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf, sizeof(ebuf)) > 0)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), ebuf);\n        else\n            virReportSystemError(-r,\n                                 _(\"Failed to read pid file %s\"),\n                                 pidfile);\n        goto cleanup;\n    }\n\n    priv->stopReason = VIR_DOMAIN_EVENT_STOPPED_FAILED;\n    priv->wantReboot = false;\n    vm->def->id = vm->pid;\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, reason);\n    priv->doneStopEvent = false;\n\n    if (VIR_CLOSE(handshakefds[1]) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"could not close handshake fd\"));\n        goto cleanup;\n    }\n\n    if (virCommandHandshakeWait(cmd) < 0)\n        goto cleanup;\n\n    /* Write domain status to disk for the controller to\n     * read when it starts */\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        goto cleanup;\n\n    /* Allow the child to exec the controller */\n    if (virCommandHandshakeNotify(cmd) < 0)\n        goto cleanup;\n\n    if (g_atomic_int_add(&driver->nactive, 1) == 0 && driver->inhibitCallback)\n        driver->inhibitCallback(true, driver->inhibitOpaque);\n\n    if (lxcContainerWaitForContinue(handshakefds[0]) < 0) {\n        char out[1024];\n\n        if (!(virLXCProcessReadLogOutput(vm, logfile, pos, out, 1024) < 0)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), out);\n        }\n\n        goto cleanup;\n    }\n\n    priv->machineName = virLXCDomainGetMachineName(vm->def, vm->pid);\n    if (!priv->machineName)\n        goto cleanup;\n\n    /* We know the cgroup must exist by this synchronization\n     * point so lets detect that first, since it gives us a\n     * more reliable way to kill everything off if something\n     * goes wrong from here onwards ... */\n    if (virCgroupNewDetectMachine(vm->def->name, \"lxc\",\n                                  vm->pid, -1, priv->machineName,\n                                  &priv->cgroup) < 0)\n        goto cleanup;\n\n    if (!priv->cgroup) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No valid cgroup for machine %s\"),\n                       vm->def->name);\n        goto cleanup;\n    }\n\n    /* And we can get the first monitor connection now too */\n    if (!(priv->monitor = virLXCProcessConnectMonitor(driver, vm))) {\n        /* Intentionally overwrite the real monitor error message,\n         * since a better one is almost always found in the logs\n         */\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf, sizeof(ebuf)) > 0) {\n            virResetLastError();\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), ebuf);\n        }\n        goto cleanup;\n    }\n\n    if (autoDestroy &&\n        virCloseCallbacksSet(driver->closeCallbacks, vm,\n                             conn, lxcProcessAutoDestroy) < 0)\n        goto cleanup;\n\n    /* We don't need the temporary NIC names anymore, clear them */\n    virLXCProcessCleanInterfaces(vm->def);\n\n    /* finally we can call the 'started' hook script if any */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_STARTED, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(logfd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"could not close logfile\"));\n        rc = -1;\n    }\n    if (rc != 0) {\n        virErrorPreserveLast(&err);\n        virLXCProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED);\n    }\n    virCommandFree(cmd);\n    for (i = 0; i < nttyFDs; i++)\n        VIR_FORCE_CLOSE(ttyFDs[i]);\n    VIR_FREE(ttyFDs);\n    VIR_FORCE_CLOSE(handshakefds[0]);\n    VIR_FORCE_CLOSE(handshakefds[1]);\n    VIR_FREE(pidfile);\n    VIR_FREE(logfile);\n    virObjectUnref(cfg);\n    virObjectUnref(caps);\n\n    virErrorRestore(&err);\n\n    return rc;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define START_POSTFIX \": starting up\\n\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&err"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "caps"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "logfile"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pidfile"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "handshakefds[1]"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "handshakefds[0]"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ttyFDs"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "ttyFDs[i]"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCProcessStop",
          "args": [
            "driver",
            "vm",
            "VIR_DOMAIN_SHUTOFF_FAILED"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "852-915",
          "snippet": "int virLXCProcessStop(virLXCDriverPtr driver,\n                      virDomainObjPtr vm,\n                      virDomainShutoffReason reason)\n{\n    int rc;\n    virLXCDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"Stopping VM name=%s pid=%d reason=%d\",\n              vm->def->name, (int)vm->pid, (int)reason);\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    priv = vm->privateData;\n\n    /* If the LXC domain is suspended we send all processes a SIGKILL\n     * and thaw them. Upon wakeup the process sees the pending signal\n     * and dies immediately. It is guaranteed that priv->cgroup != NULL\n     * here because the domain has aleady been suspended using the\n     * freezer cgroup.\n     */\n    if (reason == VIR_DOMAIN_SHUTOFF_DESTROYED &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED) {\n        if (virCgroupKillRecursive(priv->cgroup, SIGKILL) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to kill all processes\"));\n            return -1;\n        }\n\n        if (virCgroupSetFreezerState(priv->cgroup, \"THAWED\") < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Unable to thaw all processes\"));\n\n            return -1;\n        }\n\n        goto cleanup;\n    }\n\n    if (priv->cgroup) {\n        rc = virCgroupKillPainfully(priv->cgroup);\n        if (rc < 0)\n            return -1;\n        if (rc > 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Some processes refused to die\"));\n            return -1;\n        }\n    } else if (vm->pid > 0) {\n        /* If cgroup doesn't exist, just try cleaning up the\n         * libvirt_lxc process */\n        if (virProcessKillPainfully(vm->pid, true) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Processes %d refused to die\"), (int)vm->pid);\n            return -1;\n        }\n    }\n\n cleanup:\n    virLXCProcessCleanup(driver, vm, reason);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virLXCProcessStop(virLXCDriverPtr driver,\n                      virDomainObjPtr vm,\n                      virDomainShutoffReason reason)\n{\n    int rc;\n    virLXCDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"Stopping VM name=%s pid=%d reason=%d\",\n              vm->def->name, (int)vm->pid, (int)reason);\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    priv = vm->privateData;\n\n    /* If the LXC domain is suspended we send all processes a SIGKILL\n     * and thaw them. Upon wakeup the process sees the pending signal\n     * and dies immediately. It is guaranteed that priv->cgroup != NULL\n     * here because the domain has aleady been suspended using the\n     * freezer cgroup.\n     */\n    if (reason == VIR_DOMAIN_SHUTOFF_DESTROYED &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED) {\n        if (virCgroupKillRecursive(priv->cgroup, SIGKILL) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to kill all processes\"));\n            return -1;\n        }\n\n        if (virCgroupSetFreezerState(priv->cgroup, \"THAWED\") < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Unable to thaw all processes\"));\n\n            return -1;\n        }\n\n        goto cleanup;\n    }\n\n    if (priv->cgroup) {\n        rc = virCgroupKillPainfully(priv->cgroup);\n        if (rc < 0)\n            return -1;\n        if (rc > 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Some processes refused to die\"));\n            return -1;\n        }\n    } else if (vm->pid > 0) {\n        /* If cgroup doesn't exist, just try cleaning up the\n         * libvirt_lxc process */\n        if (virProcessKillPainfully(vm->pid, true) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Processes %d refused to die\"), (int)vm->pid);\n            return -1;\n        }\n    }\n\n cleanup:\n    virLXCProcessCleanup(driver, vm, reason);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&err"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"could not close logfile\")"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not close logfile\""
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "userns_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2329-2332",
          "snippet": "static int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "logfd"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHookCall",
          "args": [
            "VIR_HOOK_DRIVER_LXC",
            "vm->def->name",
            "VIR_HOOK_LXC_OP_STARTED",
            "VIR_HOOK_SUBOP_BEGIN",
            "NULL",
            "xml",
            "NULL"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "virHookCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "243-341",
          "snippet": "int\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\""
          ],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\"\n\nstatic int virHooksFound = -1;\n\nint\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFormat",
          "args": [
            "vm->def",
            "driver->xmlopt",
            "0"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29496-29508",
          "snippet": "char *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)\n\nchar *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHookPresent",
          "args": [
            "VIR_HOOK_DRIVER_LXC"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "virHookPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "210-222",
          "snippet": "int\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virHooksFound = -1;\n\nint\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCProcessCleanInterfaces",
          "args": [
            "vm->def"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessCleanInterfaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "666-675",
          "snippet": "static void\nvirLXCProcessCleanInterfaces(virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nnets; i++) {\n        VIR_FREE(def->nets[i]->ifname_guest_actual);\n        VIR_DEBUG(\"Cleared net names: %s\", def->nets[i]->ifname_guest);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic void\nvirLXCProcessCleanInterfaces(virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nnets; i++) {\n        VIR_FREE(def->nets[i]->ifname_guest_actual);\n        VIR_DEBUG(\"Cleared net names: %s\", def->nets[i]->ifname_guest);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCloseCallbacksSet",
          "args": [
            "driver->closeCallbacks",
            "vm",
            "conn",
            "lxcProcessAutoDestroy"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "virCloseCallbacksSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virclosecallbacks.c",
          "lines": "89-140",
          "snippet": "int\nvirCloseCallbacksSet(virCloseCallbacksPtr closeCallbacks,\n                     virDomainObjPtr vm,\n                     virConnectPtr conn,\n                     virCloseCallback cb)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    int ret = -1;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s, conn=%p, cb=%p\",\n              vm->def->name, uuidstr, conn, cb);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (closeDef) {\n        if (closeDef->conn != conn) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Close callback for domain %s already registered\"\n                             \" with another connection %p\"),\n                           vm->def->name, closeDef->conn);\n            goto cleanup;\n        }\n        if (closeDef->cb && closeDef->cb != cb) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Another close callback is already defined for\"\n                             \" domain %s\"), vm->def->name);\n            goto cleanup;\n        }\n\n        closeDef->cb = cb;\n    } else {\n        if (VIR_ALLOC(closeDef) < 0)\n            goto cleanup;\n\n        closeDef->conn = conn;\n        closeDef->cb = cb;\n        if (virHashAddEntry(closeCallbacks->list, uuidstr, closeDef) < 0) {\n            VIR_FREE(closeDef);\n            goto cleanup;\n        }\n        virObjectRef(vm);\n    }\n\n    virObjectRef(closeCallbacks);\n    ret = 0;\n cleanup:\n    virObjectUnlock(closeCallbacks);\n    return ret;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virclosecallbacks.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virclosecallbacks.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirCloseCallbacksSet(virCloseCallbacksPtr closeCallbacks,\n                     virDomainObjPtr vm,\n                     virConnectPtr conn,\n                     virCloseCallback cb)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    int ret = -1;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s, conn=%p, cb=%p\",\n              vm->def->name, uuidstr, conn, cb);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (closeDef) {\n        if (closeDef->conn != conn) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Close callback for domain %s already registered\"\n                             \" with another connection %p\"),\n                           vm->def->name, closeDef->conn);\n            goto cleanup;\n        }\n        if (closeDef->cb && closeDef->cb != cb) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Another close callback is already defined for\"\n                             \" domain %s\"), vm->def->name);\n            goto cleanup;\n        }\n\n        closeDef->cb = cb;\n    } else {\n        if (VIR_ALLOC(closeDef) < 0)\n            goto cleanup;\n\n        closeDef->conn = conn;\n        closeDef->cb = cb;\n        if (virHashAddEntry(closeCallbacks->list, uuidstr, closeDef) < 0) {\n            VIR_FREE(closeDef);\n            goto cleanup;\n        }\n        virObjectRef(vm);\n    }\n\n    virObjectRef(closeCallbacks);\n    ret = 0;\n cleanup:\n    virObjectUnlock(closeCallbacks);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"guest failed to start: %s\")",
            "ebuf"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCProcessReadLogOutput",
          "args": [
            "vm",
            "logfile",
            "pos",
            "ebuf",
            "sizeof(ebuf)"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessReadLogOutput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "1106-1138",
          "snippet": "static int\nvirLXCProcessReadLogOutput(virDomainObjPtr vm,\n                           char *logfile,\n                           off_t pos,\n                           char *buf,\n                           size_t buflen)\n{\n    int fd = -1;\n    int ret;\n\n    if ((fd = open(logfile, O_RDONLY)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to open log file %s\"),\n                             logfile);\n        return -1;\n    }\n\n    if (lseek(fd, pos, SEEK_SET) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to seek log file %s to %llu\"),\n                             logfile, (unsigned long long)pos);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    ret = virLXCProcessReadLogOutputData(vm,\n                                         fd,\n                                         buf,\n                                         buflen);\n\n    VIR_FORCE_CLOSE(fd);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirLXCProcessReadLogOutput(virDomainObjPtr vm,\n                           char *logfile,\n                           off_t pos,\n                           char *buf,\n                           size_t buflen)\n{\n    int fd = -1;\n    int ret;\n\n    if ((fd = open(logfile, O_RDONLY)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to open log file %s\"),\n                             logfile);\n        return -1;\n    }\n\n    if (lseek(fd, pos, SEEK_SET) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to seek log file %s to %llu\"),\n                             logfile, (unsigned long long)pos);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    ret = virLXCProcessReadLogOutputData(vm,\n                                         fd,\n                                         buf,\n                                         buflen);\n\n    VIR_FORCE_CLOSE(fd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCProcessConnectMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessConnectMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "819-849",
          "snippet": "static virLXCMonitorPtr virLXCProcessConnectMonitor(virLXCDriverPtr driver,\n                                                    virDomainObjPtr vm)\n{\n    virLXCMonitorPtr monitor = NULL;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n\n    if (virSecurityManagerSetSocketLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n\n    /* Hold an extra reference because we can't allow 'vm' to be\n     * deleted while the monitor is active. This will be unreffed\n     * during EOFNotify processing. */\n    virObjectRef(vm);\n\n    monitor = virLXCMonitorNew(vm, cfg->stateDir, &monitorCallbacks);\n\n    if (monitor == NULL)\n        virObjectUnref(vm);\n\n    if (virSecurityManagerClearSocketLabel(driver->securityManager, vm->def) < 0) {\n        if (monitor) {\n            virObjectUnref(monitor);\n            monitor = NULL;\n        }\n        goto cleanup;\n    }\n\n cleanup:\n    virObjectUnref(cfg);\n    return monitor;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLXCMonitorCallbacks monitorCallbacks = {\n    .eofNotify = virLXCProcessMonitorEOFNotify,\n    .exitNotify = virLXCProcessMonitorExitNotify,\n    .initNotify = virLXCProcessMonitorInitNotify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virLXCMonitorCallbacks monitorCallbacks = {\n    .eofNotify = virLXCProcessMonitorEOFNotify,\n    .exitNotify = virLXCProcessMonitorExitNotify,\n    .initNotify = virLXCProcessMonitorInitNotify,\n};\n\nstatic virLXCMonitorPtr virLXCProcessConnectMonitor(virLXCDriverPtr driver,\n                                                    virDomainObjPtr vm)\n{\n    virLXCMonitorPtr monitor = NULL;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n\n    if (virSecurityManagerSetSocketLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n\n    /* Hold an extra reference because we can't allow 'vm' to be\n     * deleted while the monitor is active. This will be unreffed\n     * during EOFNotify processing. */\n    virObjectRef(vm);\n\n    monitor = virLXCMonitorNew(vm, cfg->stateDir, &monitorCallbacks);\n\n    if (monitor == NULL)\n        virObjectUnref(vm);\n\n    if (virSecurityManagerClearSocketLabel(driver->securityManager, vm->def) < 0) {\n        if (monitor) {\n            virObjectUnref(monitor);\n            monitor = NULL;\n        }\n        goto cleanup;\n    }\n\n cleanup:\n    virObjectUnref(cfg);\n    return monitor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"No valid cgroup for machine %s\")",
            "vm->def->name"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCgroupNewDetectMachine",
          "args": [
            "vm->def->name",
            "\"lxc\"",
            "vm->pid",
            "-1",
            "priv->machineName",
            "&priv->cgroup"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "virCgroupNewDetectMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircgroup.c",
          "lines": "2849-2860",
          "snippet": "int\nvirCgroupNewDetectMachine(const char *name G_GNUC_UNUSED,\n                          const char *drivername G_GNUC_UNUSED,\n                          pid_t pid G_GNUC_UNUSED,\n                          int controllers G_GNUC_UNUSED,\n                          char *machinename G_GNUC_UNUSED,\n                          virCgroupPtr *group G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircgroupbackend.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"vircgrouppriv.h\"",
            "# include <unistd.h>",
            "# include <dirent.h>",
            "# include <signal.h>",
            "# include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <sys/stat.h>",
            "# include <fcntl.h>",
            "# include <sys/mount.h>",
            "# include <mntent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virhostcpu.h\"\n#include \"virtypedparam.h\"\n#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhashcode.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircgroupbackend.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"vircgrouppriv.h\"\n# include <unistd.h>\n# include <dirent.h>\n# include <signal.h>\n# include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n# include <sys/mount.h>\n# include <mntent.h>\n#include <config.h>\n\nint\nvirCgroupNewDetectMachine(const char *name G_GNUC_UNUSED,\n                          const char *drivername G_GNUC_UNUSED,\n                          pid_t pid G_GNUC_UNUSED,\n                          int controllers G_GNUC_UNUSED,\n                          char *machinename G_GNUC_UNUSED,\n                          virCgroupPtr *group G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCDomainGetMachineName",
          "args": [
            "vm->def",
            "vm->pid"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCDomainGetMachineName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_domain.c",
          "lines": "397-412",
          "snippet": "char *\nvirLXCDomainGetMachineName(virDomainDefPtr def, pid_t pid)\n{\n    char *ret = NULL;\n\n    if (pid) {\n        ret = virSystemdGetMachineNameByPID(pid);\n        if (!ret)\n            virResetLastError();\n    }\n\n    if (!ret)\n        ret = virDomainGenerateMachineName(\"lxc\", NULL, def->id, def->name, true);\n\n    return ret;\n}",
          "includes": [
            "#include \"virinitctl.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virinitctl.h\"\n#include \"virsystemd.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"lxc_domain.h\"\n#include <config.h>\n\nchar *\nvirLXCDomainGetMachineName(virDomainDefPtr def, pid_t pid)\n{\n    char *ret = NULL;\n\n    if (pid) {\n        ret = virSystemdGetMachineNameByPID(pid);\n        if (!ret)\n            virResetLastError();\n    }\n\n    if (!ret)\n        ret = virDomainGenerateMachineName(\"lxc\", NULL, def->id, def->name, true);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"guest failed to start: %s\")",
            "out"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxcContainerWaitForContinue",
          "args": [
            "handshakefds[0]"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "lxcContainerWaitForContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "404-423",
          "snippet": "int lxcContainerWaitForContinue(int control)\n{\n    lxc_message_t msg;\n    int readLen;\n\n    VIR_DEBUG(\"Wait continue on fd %d\", control);\n    readLen = saferead(control, &msg, sizeof(msg));\n    VIR_DEBUG(\"Got continue on fd %d %d\", control, readLen);\n    if (readLen != sizeof(msg)) {\n        if (readLen >= 0)\n            errno = EIO;\n        return -1;\n    }\n    if (msg != LXC_CONTINUE_MSG) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LXC_CONTINUE_MSG 'c'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define LXC_CONTINUE_MSG 'c'\n\nint lxcContainerWaitForContinue(int control)\n{\n    lxc_message_t msg;\n    int readLen;\n\n    VIR_DEBUG(\"Wait continue on fd %d\", control);\n    readLen = saferead(control, &msg, sizeof(msg));\n    VIR_DEBUG(\"Got continue on fd %d %d\", control, readLen);\n    if (readLen != sizeof(msg)) {\n        if (readLen >= 0)\n            errno = EIO;\n        return -1;\n    }\n    if (msg != LXC_CONTINUE_MSG) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "driver->inhibitCallback",
          "args": [
            "true",
            "driver->inhibitOpaque"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_atomic_int_add",
          "args": [
            "&driver->nactive",
            "1"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandHandshakeNotify",
          "args": [
            "cmd"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandHandshakeNotify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2975-2980",
          "snippet": "int virCommandHandshakeNotify(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint virCommandHandshakeNotify(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjSave",
          "args": [
            "vm",
            "driver->xmlopt",
            "cfg->stateDir"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29706-29723",
          "snippet": "int\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjDispose(void *obj);",
            "static void virDomainXMLOptionDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virDomainObjDispose(void *obj);\nstatic void virDomainXMLOptionDispose(void *obj);\n\nint\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandHandshakeWait",
          "args": [
            "cmd"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandHandshakeWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2967-2972",
          "snippet": "int virCommandHandshakeWait(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint virCommandHandshakeWait(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"could not close handshake fd\")"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "handshakefds[1]"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_RUNNING",
            "reason"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-r",
            "_(\"Failed to read pid file %s\")",
            "pidfile"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"guest failed to start: %s\")",
            "ebuf"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileReadPath",
          "args": [
            "pidfile",
            "&vm->pid"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReadPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "105-145",
          "snippet": "int virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"guest failed to start: %s\")",
            "ebuf"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "ebuf",
            "sizeof(ebuf)",
            "\"%s\"",
            "_(\"terminated abnormally\")"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "ebuf",
            "sizeof(ebuf)",
            "_(\"unexpected exit status %d\")",
            "WEXITSTATUS(status)"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "&status"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRawStatus",
          "args": [
            "cmd"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRawStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1298-1305",
          "snippet": "void\nvirCommandRawStatus(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->rawStatus = true;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandRawStatus(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->rawStatus = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Launching container\""
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to seek to end of logfile: %s\"",
            "g_strerror(errno)"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "logfd",
            "0",
            "SEEK_END"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandWriteArgLog",
          "args": [
            "cmd",
            "logfd"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandWriteArgLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2039-2067",
          "snippet": "void\nvirCommandWriteArgLog(virCommandPtr cmd, int logfd)\n{\n    int ioError = 0;\n    size_t i;\n\n    /* Any errors will be reported later by virCommandRun, which means\n     * no command will be run, so there is nothing to log. */\n    if (!cmd || cmd->has_error)\n        return;\n\n    for (i = 0; i < cmd->nenv; i++) {\n        if (safewrite(logfd, cmd->env[i], strlen(cmd->env[i])) < 0)\n            ioError = errno;\n        if (safewrite(logfd, \" \", 1) < 0)\n            ioError = errno;\n    }\n    for (i = 0; i < cmd->nargs; i++) {\n        if (safewrite(logfd, cmd->args[i], strlen(cmd->args[i])) < 0)\n            ioError = errno;\n        if (safewrite(logfd, i == cmd->nargs - 1 ? \"\\n\" : \" \", 1) < 0)\n            ioError = errno;\n    }\n\n    if (ioError) {\n        VIR_WARN(\"Unable to write command %s args to logfile: %s\",\n                 cmd->args[0], g_strerror(ioError));\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandWriteArgLog(virCommandPtr cmd, int logfd)\n{\n    int ioError = 0;\n    size_t i;\n\n    /* Any errors will be reported later by virCommandRun, which means\n     * no command will be run, so there is nothing to log. */\n    if (!cmd || cmd->has_error)\n        return;\n\n    for (i = 0; i < cmd->nenv; i++) {\n        if (safewrite(logfd, cmd->env[i], strlen(cmd->env[i])) < 0)\n            ioError = errno;\n        if (safewrite(logfd, \" \", 1) < 0)\n            ioError = errno;\n    }\n    for (i = 0; i < cmd->nargs; i++) {\n        if (safewrite(logfd, cmd->args[i], strlen(cmd->args[i])) < 0)\n            ioError = errno;\n        if (safewrite(logfd, i == cmd->nargs - 1 ? \"\\n\" : \" \", 1) < 0)\n            ioError = errno;\n    }\n\n    if (ioError) {\n        VIR_WARN(\"Unable to write command %s args to logfile: %s\",\n                 cmd->args[0], g_strerror(ioError));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "timestamp"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to write timestamp to logfile: %s\"",
            "g_strerror(errno)"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "logfd",
            "START_POSTFIX",
            "strlen(START_POSTFIX)"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "START_POSTFIX"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "timestamp"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTimeStringNow",
          "args": [],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "virTimeStringNow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtime.c",
          "lines": "256-271",
          "snippet": "char *virTimeStringNow(void)\n{\n    char *ret;\n\n    if (VIR_ALLOC_N(ret, VIR_TIME_STRING_BUFLEN) < 0)\n        return NULL;\n\n    if (virTimeStringNowRaw(ret) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format time\"));\n        VIR_FREE(ret);\n        return NULL;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtime.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtime.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virTimeStringNow(void)\n{\n    char *ret;\n\n    if (VIR_ALLOC_N(ret, VIR_TIME_STRING_BUFLEN) < 0)\n        return NULL;\n\n    if (virTimeStringNowRaw(ret) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format time\"));\n        VIR_FREE(ret);\n        return NULL;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLXCProcessBuildControllerCmd",
          "args": [
            "driver",
            "vm",
            "veths",
            "ttyFDs",
            "nttyFDs",
            "nsInheritFDs",
            "files",
            "nfiles",
            "handshakefds[1]",
            "&logfd",
            "pidfile"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessBuildControllerCmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "918-1022",
          "snippet": "static virCommandPtr\nvirLXCProcessBuildControllerCmd(virLXCDriverPtr driver,\n                                virDomainObjPtr vm,\n                                char **veths,\n                                int *ttyFDs,\n                                size_t nttyFDs,\n                                int *nsInheritFDs,\n                                int *files,\n                                size_t nfiles,\n                                int handshakefd,\n                                int * const logfd,\n                                const char *pidfile)\n{\n    size_t i;\n    char *filterstr;\n    char *outputstr;\n    virCommandPtr cmd;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n\n    cmd = virCommandNew(vm->def->emulator);\n\n    /* The controller may call ip command, so we have to retain PATH. */\n    virCommandAddEnvPass(cmd, \"PATH\");\n\n    virCommandAddEnvFormat(cmd, \"LIBVIRT_DEBUG=%d\",\n                           virLogGetDefaultPriority());\n\n    if (virLogGetNbFilters() > 0) {\n        filterstr = virLogGetFilters();\n        if (!filterstr) {\n            virReportOOMError();\n            goto error;\n        }\n\n        virCommandAddEnvPair(cmd, \"LIBVIRT_LOG_FILTERS\", filterstr);\n        VIR_FREE(filterstr);\n    }\n\n    if (cfg->log_libvirtd) {\n        if (virLogGetNbOutputs() > 0) {\n            outputstr = virLogGetOutputs();\n            if (!outputstr) {\n                virReportOOMError();\n                goto error;\n            }\n\n            virCommandAddEnvPair(cmd, \"LIBVIRT_LOG_OUTPUTS\", outputstr);\n            VIR_FREE(outputstr);\n        }\n    } else {\n        virCommandAddEnvFormat(cmd,\n                               \"LIBVIRT_LOG_OUTPUTS=%d:stderr\",\n                               virLogGetDefaultPriority());\n    }\n\n    virCommandAddArgList(cmd, \"--name\", vm->def->name, NULL);\n    for (i = 0; i < nttyFDs; i++) {\n        virCommandAddArg(cmd, \"--console\");\n        virCommandAddArgFormat(cmd, \"%d\", ttyFDs[i]);\n        virCommandPassFD(cmd, ttyFDs[i], 0);\n    }\n\n    for (i = 0; i < nfiles; i++) {\n        virCommandAddArg(cmd, \"--passfd\");\n        virCommandAddArgFormat(cmd, \"%d\", files[i]);\n        virCommandPassFD(cmd, files[i], 0);\n    }\n\n    for (i = 0; i < VIR_LXC_DOMAIN_NAMESPACE_LAST; i++) {\n        if (nsInheritFDs[i] > 0) {\n            char *tmp = NULL;\n            tmp = g_strdup_printf(\"--share-%s\", nsInfoLocal[i]);\n            virCommandAddArg(cmd, tmp);\n            virCommandAddArgFormat(cmd, \"%d\", nsInheritFDs[i]);\n            virCommandPassFD(cmd, nsInheritFDs[i], 0);\n            VIR_FREE(tmp);\n        }\n    }\n\n    virCommandAddArgPair(cmd, \"--security\",\n                         virSecurityManagerGetModel(driver->securityManager));\n\n    virCommandAddArg(cmd, \"--handshake\");\n    virCommandAddArgFormat(cmd, \"%d\", handshakefd);\n\n    for (i = 0; veths && veths[i]; i++)\n        virCommandAddArgList(cmd, \"--veth\", veths[i], NULL);\n\n    virCommandPassFD(cmd, handshakefd, 0);\n    virCommandDaemonize(cmd);\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandSetOutputFD(cmd, logfd);\n    virCommandSetErrorFD(cmd, logfd);\n    /* So we can pause before exec'ing the controller to\n     * write the live domain status XML with the PID */\n    virCommandRequireHandshake(cmd);\n\n cleanup:\n    virObjectUnref(cfg);\n    return cmd;\n error:\n    virCommandFree(cmd);\n    cmd = NULL;\n    goto cleanup;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *nsInfoLocal[VIR_LXC_DOMAIN_NAMESPACE_LAST] = {\n    [VIR_LXC_DOMAIN_NAMESPACE_SHARENET] = \"net\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREIPC] = \"ipc\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREUTS] = \"uts\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic const char *nsInfoLocal[VIR_LXC_DOMAIN_NAMESPACE_LAST] = {\n    [VIR_LXC_DOMAIN_NAMESPACE_SHARENET] = \"net\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREIPC] = \"ipc\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREUTS] = \"uts\",\n};\n\nstatic virCommandPtr\nvirLXCProcessBuildControllerCmd(virLXCDriverPtr driver,\n                                virDomainObjPtr vm,\n                                char **veths,\n                                int *ttyFDs,\n                                size_t nttyFDs,\n                                int *nsInheritFDs,\n                                int *files,\n                                size_t nfiles,\n                                int handshakefd,\n                                int * const logfd,\n                                const char *pidfile)\n{\n    size_t i;\n    char *filterstr;\n    char *outputstr;\n    virCommandPtr cmd;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n\n    cmd = virCommandNew(vm->def->emulator);\n\n    /* The controller may call ip command, so we have to retain PATH. */\n    virCommandAddEnvPass(cmd, \"PATH\");\n\n    virCommandAddEnvFormat(cmd, \"LIBVIRT_DEBUG=%d\",\n                           virLogGetDefaultPriority());\n\n    if (virLogGetNbFilters() > 0) {\n        filterstr = virLogGetFilters();\n        if (!filterstr) {\n            virReportOOMError();\n            goto error;\n        }\n\n        virCommandAddEnvPair(cmd, \"LIBVIRT_LOG_FILTERS\", filterstr);\n        VIR_FREE(filterstr);\n    }\n\n    if (cfg->log_libvirtd) {\n        if (virLogGetNbOutputs() > 0) {\n            outputstr = virLogGetOutputs();\n            if (!outputstr) {\n                virReportOOMError();\n                goto error;\n            }\n\n            virCommandAddEnvPair(cmd, \"LIBVIRT_LOG_OUTPUTS\", outputstr);\n            VIR_FREE(outputstr);\n        }\n    } else {\n        virCommandAddEnvFormat(cmd,\n                               \"LIBVIRT_LOG_OUTPUTS=%d:stderr\",\n                               virLogGetDefaultPriority());\n    }\n\n    virCommandAddArgList(cmd, \"--name\", vm->def->name, NULL);\n    for (i = 0; i < nttyFDs; i++) {\n        virCommandAddArg(cmd, \"--console\");\n        virCommandAddArgFormat(cmd, \"%d\", ttyFDs[i]);\n        virCommandPassFD(cmd, ttyFDs[i], 0);\n    }\n\n    for (i = 0; i < nfiles; i++) {\n        virCommandAddArg(cmd, \"--passfd\");\n        virCommandAddArgFormat(cmd, \"%d\", files[i]);\n        virCommandPassFD(cmd, files[i], 0);\n    }\n\n    for (i = 0; i < VIR_LXC_DOMAIN_NAMESPACE_LAST; i++) {\n        if (nsInheritFDs[i] > 0) {\n            char *tmp = NULL;\n            tmp = g_strdup_printf(\"--share-%s\", nsInfoLocal[i]);\n            virCommandAddArg(cmd, tmp);\n            virCommandAddArgFormat(cmd, \"%d\", nsInheritFDs[i]);\n            virCommandPassFD(cmd, nsInheritFDs[i], 0);\n            VIR_FREE(tmp);\n        }\n    }\n\n    virCommandAddArgPair(cmd, \"--security\",\n                         virSecurityManagerGetModel(driver->securityManager));\n\n    virCommandAddArg(cmd, \"--handshake\");\n    virCommandAddArgFormat(cmd, \"%d\", handshakefd);\n\n    for (i = 0; veths && veths[i]; i++)\n        virCommandAddArgList(cmd, \"--veth\", veths[i], NULL);\n\n    virCommandPassFD(cmd, handshakefd, 0);\n    virCommandDaemonize(cmd);\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandSetOutputFD(cmd, logfd);\n    virCommandSetErrorFD(cmd, logfd);\n    /* So we can pause before exec'ing the controller to\n     * write the live domain status XML with the PID */\n    virCommandRequireHandshake(cmd);\n\n cleanup:\n    virObjectUnref(cfg);\n    return cmd;\n error:\n    virCommandFree(cmd);\n    cmd = NULL;\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPipe",
          "args": [
            "handshakefds"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "virPipeNonBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1813-1817",
          "snippet": "int\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to open '%s'\")",
            "logfile"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "logfile",
            "O_WRONLY | O_APPEND | O_CREAT",
            "S_IRUSR|S_IWUSR"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockReopenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "3308-3323",
          "snippet": "int\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Preparing to launch\""
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLXCProcessSetupNamespaces",
          "args": [
            "driver",
            "vm->def->namespaceData",
            "nsInheritFDs"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessSetupNamespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "495-529",
          "snippet": "static int\nvirLXCProcessSetupNamespaces(virLXCDriverPtr driver,\n                             lxcDomainDefPtr lxcDef,\n                             int *nsFDs)\n{\n    size_t i;\n\n    for (i = 0; i < VIR_LXC_DOMAIN_NAMESPACE_LAST; i++)\n        nsFDs[i] = -1;\n    /* If there are no namespaces to be opened just return success */\n    if (lxcDef == NULL)\n        return 0;\n\n    for (i = 0; i < VIR_LXC_DOMAIN_NAMESPACE_LAST; i++) {\n        switch (lxcDef->ns_source[i]) {\n        case VIR_LXC_DOMAIN_NAMESPACE_SOURCE_NONE:\n            continue;\n        case VIR_LXC_DOMAIN_NAMESPACE_SOURCE_NAME:\n            if ((nsFDs[i] = virLXCProcessSetupNamespaceName(driver, i,\n                                                            lxcDef->ns_val[i])) < 0)\n                return -1;\n            break;\n        case VIR_LXC_DOMAIN_NAMESPACE_SOURCE_PID:\n            if ((nsFDs[i] = virLXCProcessSetupNamespacePID(i, lxcDef->ns_val[i])) < 0)\n                return -1;\n            break;\n        case VIR_LXC_DOMAIN_NAMESPACE_SOURCE_NETNS:\n            if ((nsFDs[i] = virLXCProcessSetupNamespaceNet(i, lxcDef->ns_val[i])) < 0)\n                return -1;\n            break;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirLXCProcessSetupNamespaces(virLXCDriverPtr driver,\n                             lxcDomainDefPtr lxcDef,\n                             int *nsFDs)\n{\n    size_t i;\n\n    for (i = 0; i < VIR_LXC_DOMAIN_NAMESPACE_LAST; i++)\n        nsFDs[i] = -1;\n    /* If there are no namespaces to be opened just return success */\n    if (lxcDef == NULL)\n        return 0;\n\n    for (i = 0; i < VIR_LXC_DOMAIN_NAMESPACE_LAST; i++) {\n        switch (lxcDef->ns_source[i]) {\n        case VIR_LXC_DOMAIN_NAMESPACE_SOURCE_NONE:\n            continue;\n        case VIR_LXC_DOMAIN_NAMESPACE_SOURCE_NAME:\n            if ((nsFDs[i] = virLXCProcessSetupNamespaceName(driver, i,\n                                                            lxcDef->ns_val[i])) < 0)\n                return -1;\n            break;\n        case VIR_LXC_DOMAIN_NAMESPACE_SOURCE_PID:\n            if ((nsFDs[i] = virLXCProcessSetupNamespacePID(i, lxcDef->ns_val[i])) < 0)\n                return -1;\n            break;\n        case VIR_LXC_DOMAIN_NAMESPACE_SOURCE_NETNS:\n            if ((nsFDs[i] = virLXCProcessSetupNamespaceNet(i, lxcDef->ns_val[i])) < 0)\n                return -1;\n            break;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting up namespaces if any\""
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLXCProcessSetupInterfaces",
          "args": [
            "driver",
            "vm->def",
            "&veths"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessSetupInterfaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "543-664",
          "snippet": "static int\nvirLXCProcessSetupInterfaces(virLXCDriverPtr driver,\n                             virDomainDefPtr def,\n                             char ***veths)\n{\n    int ret = -1;\n    size_t i;\n    size_t niface = 0;\n    virDomainNetDefPtr net;\n    virDomainNetType type;\n    virConnectPtr netconn = NULL;\n    virErrorPtr save_err = NULL;\n\n    if (VIR_ALLOC_N(*veths, def->nnets + 1) < 0)\n        return -1;\n\n    for (i = 0; i < def->nnets; i++) {\n        char *veth = NULL;\n        const virNetDevBandwidth *actualBandwidth;\n        /* If appropriate, grab a physical device from the configured\n         * network's pool of devices, or resolve bridge device name\n         * to the one defined in the network definition.\n         */\n        net = def->nets[i];\n\n        if (virLXCProcessValidateInterface(net) < 0)\n            goto cleanup;\n\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (!netconn && !(netconn = virGetConnectNetwork()))\n                goto cleanup;\n            if (virDomainNetAllocateActualDevice(netconn, def, net) < 0)\n                goto cleanup;\n        }\n\n        /* final validation now that actual type is known */\n        if (virDomainActualNetDefValidate(net) < 0)\n            return -1;\n\n        type = virDomainNetGetActualType(net);\n        switch (type) {\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE: {\n            const char *brname = virDomainNetGetActualBridgeName(net);\n            if (!brname) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"No bridge name specified\"));\n                goto cleanup;\n            }\n            if (!(veth = virLXCProcessSetupInterfaceTap(def, net, brname)))\n                goto cleanup;\n        }   break;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            if (!(veth = virLXCProcessSetupInterfaceTap(def, net, NULL)))\n                goto cleanup;\n            break;\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n            if (!(veth = virLXCProcessSetupInterfaceDirect(driver, def, net)))\n                goto cleanup;\n            break;\n\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unsupported network type %s\"),\n                           virDomainNetTypeToString(type));\n            goto cleanup;\n\n        }\n\n        /* Set bandwidth or warn if requested and not supported. */\n        actualBandwidth = virDomainNetGetActualBandwidth(net);\n        if (actualBandwidth) {\n            if (virNetDevSupportsBandwidth(type)) {\n                if (virNetDevBandwidthSet(net->ifname, actualBandwidth, false,\n                                          !virDomainNetTypeSharesHostView(net)) < 0)\n                    goto cleanup;\n            } else {\n                VIR_WARN(\"setting bandwidth on interfaces of \"\n                         \"type '%s' is not implemented yet\",\n                         virDomainNetTypeToString(type));\n            }\n        }\n\n        (*veths)[i] = veth;\n\n        def->nets[i]->ifname_guest_actual = g_strdup(veth);\n\n        /* Make sure all net definitions will have a name in the container */\n        if (!net->ifname_guest) {\n            net->ifname_guest = g_strdup_printf(\"eth%zu\", niface);\n            niface++;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        virErrorPreserveLast(&save_err);\n        for (i = 0; i < def->nnets; i++) {\n            virDomainNetDefPtr iface = def->nets[i];\n            const virNetDevVPortProfile *vport = virDomainNetGetActualVirtPortProfile(iface);\n            if (vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH)\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                virDomainNetGetActualBridgeName(iface),\n                                iface->ifname));\n            if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK && netconn)\n                virDomainNetReleaseActualDevice(netconn, def, iface);\n        }\n        virErrorRestore(&save_err);\n    }\n    virObjectUnref(netconn);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirLXCProcessSetupInterfaces(virLXCDriverPtr driver,\n                             virDomainDefPtr def,\n                             char ***veths)\n{\n    int ret = -1;\n    size_t i;\n    size_t niface = 0;\n    virDomainNetDefPtr net;\n    virDomainNetType type;\n    virConnectPtr netconn = NULL;\n    virErrorPtr save_err = NULL;\n\n    if (VIR_ALLOC_N(*veths, def->nnets + 1) < 0)\n        return -1;\n\n    for (i = 0; i < def->nnets; i++) {\n        char *veth = NULL;\n        const virNetDevBandwidth *actualBandwidth;\n        /* If appropriate, grab a physical device from the configured\n         * network's pool of devices, or resolve bridge device name\n         * to the one defined in the network definition.\n         */\n        net = def->nets[i];\n\n        if (virLXCProcessValidateInterface(net) < 0)\n            goto cleanup;\n\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (!netconn && !(netconn = virGetConnectNetwork()))\n                goto cleanup;\n            if (virDomainNetAllocateActualDevice(netconn, def, net) < 0)\n                goto cleanup;\n        }\n\n        /* final validation now that actual type is known */\n        if (virDomainActualNetDefValidate(net) < 0)\n            return -1;\n\n        type = virDomainNetGetActualType(net);\n        switch (type) {\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE: {\n            const char *brname = virDomainNetGetActualBridgeName(net);\n            if (!brname) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"No bridge name specified\"));\n                goto cleanup;\n            }\n            if (!(veth = virLXCProcessSetupInterfaceTap(def, net, brname)))\n                goto cleanup;\n        }   break;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            if (!(veth = virLXCProcessSetupInterfaceTap(def, net, NULL)))\n                goto cleanup;\n            break;\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n            if (!(veth = virLXCProcessSetupInterfaceDirect(driver, def, net)))\n                goto cleanup;\n            break;\n\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unsupported network type %s\"),\n                           virDomainNetTypeToString(type));\n            goto cleanup;\n\n        }\n\n        /* Set bandwidth or warn if requested and not supported. */\n        actualBandwidth = virDomainNetGetActualBandwidth(net);\n        if (actualBandwidth) {\n            if (virNetDevSupportsBandwidth(type)) {\n                if (virNetDevBandwidthSet(net->ifname, actualBandwidth, false,\n                                          !virDomainNetTypeSharesHostView(net)) < 0)\n                    goto cleanup;\n            } else {\n                VIR_WARN(\"setting bandwidth on interfaces of \"\n                         \"type '%s' is not implemented yet\",\n                         virDomainNetTypeToString(type));\n            }\n        }\n\n        (*veths)[i] = veth;\n\n        def->nets[i]->ifname_guest_actual = g_strdup(veth);\n\n        /* Make sure all net definitions will have a name in the container */\n        if (!net->ifname_guest) {\n            net->ifname_guest = g_strdup_printf(\"eth%zu\", niface);\n            niface++;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        virErrorPreserveLast(&save_err);\n        for (i = 0; i < def->nnets; i++) {\n            virDomainNetDefPtr iface = def->nets[i];\n            const virNetDevVPortProfile *vport = virDomainNetGetActualVirtPortProfile(iface);\n            if (vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH)\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                virDomainNetGetActualBridgeName(iface),\n                                iface->ifname));\n            if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK && netconn)\n                virDomainNetReleaseActualDevice(netconn, def, iface);\n        }\n        virErrorRestore(&save_err);\n    }\n    virObjectUnref(netconn);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting up Interfaces\""
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"console%zu\"",
            "i"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vm->def->consoles[i]->info.alias"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vm->def->consoles[i]->source->data.file.path"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Failed to allocate tty\")"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileOpenTty",
          "args": [
            "&ttyFDs[i]",
            "&ttyPath",
            "1"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "virFileOpenTty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3209-3217",
          "snippet": "int\nvirFileOpenTty(int *ttymaster G_GNUC_UNUSED,\n               char **ttyName G_GNUC_UNUSED,\n               int rawmode G_GNUC_UNUSED)\n{\n    /* mingw completely lacks pseudo-terminals */\n    errno = ENOSYS;\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileOpenTty(int *ttymaster G_GNUC_UNUSED,\n               char **ttyName G_GNUC_UNUSED,\n               int rawmode G_GNUC_UNUSED)\n{\n    /* mingw completely lacks pseudo-terminals */\n    errno = ENOSYS;\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting up consoles\""
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerSetAllLabel",
          "args": [
            "driver->securityManager",
            "vm->def",
            "NULL",
            "false",
            "false"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerSetAllLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "858-877",
          "snippet": "int\nvirSecurityManagerSetAllLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr vm,\n                              const char *stdin_path,\n                              bool chardevStdioLogd,\n                              bool migrated)\n{\n    if (mgr->drv->domainSetSecurityAllLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityAllLabel(mgr, vm, stdin_path,\n                                                  chardevStdioLogd,\n                                                  migrated);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerSetAllLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr vm,\n                              const char *stdin_path,\n                              bool chardevStdioLogd,\n                              bool migrated)\n{\n    if (mgr->drv->domainSetSecurityAllLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityAllLabel(mgr, vm, stdin_path,\n                                                  chardevStdioLogd,\n                                                  migrated);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting domain security labels\""
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainAuditSecurityLabel",
          "args": [
            "vm",
            "true"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainAuditSecurityLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_audit.c",
          "lines": "872-896",
          "snippet": "void\nvirDomainAuditSecurityLabel(virDomainObjPtr vm, bool success)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *vmname;\n    size_t i;\n    const char *virt = virDomainAuditGetVirtType(vm->def);\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    if (!(vmname = virAuditEncode(\"vm\", vm->def->name))) {\n        VIR_WARN(\"OOM while encoding audit message\");\n        return;\n    }\n\n    for (i = 0; i < vm->def->nseclabels; i++) {\n        VIR_AUDIT(VIR_AUDIT_RECORD_MACHINE_ID, success,\n                  \"virt=%s %s uuid=%s vm-ctx=%s img-ctx=%s model=%s\",\n                  virt, vmname, uuidstr,\n                  VIR_AUDIT_STR(vm->def->seclabels[i]->label),\n                  VIR_AUDIT_STR(vm->def->seclabels[i]->imagelabel),\n                  VIR_AUDIT_STR(vm->def->seclabels[i]->model));\n    }\n\n    VIR_FREE(vmname);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"viruuid.h\"",
            "#include \"viraudit.h\"",
            "#include \"domain_audit.h\"",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"viruuid.h\"\n#include \"viraudit.h\"\n#include \"domain_audit.h\"\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid\nvirDomainAuditSecurityLabel(virDomainObjPtr vm, bool success)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *vmname;\n    size_t i;\n    const char *virt = virDomainAuditGetVirtType(vm->def);\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    if (!(vmname = virAuditEncode(\"vm\", vm->def->name))) {\n        VIR_WARN(\"OOM while encoding audit message\");\n        return;\n    }\n\n    for (i = 0; i < vm->def->nseclabels; i++) {\n        VIR_AUDIT(VIR_AUDIT_RECORD_MACHINE_ID, success,\n                  \"virt=%s %s uuid=%s vm-ctx=%s img-ctx=%s model=%s\",\n                  virt, vmname, uuidstr,\n                  VIR_AUDIT_STR(vm->def->seclabels[i]->label),\n                  VIR_AUDIT_STR(vm->def->seclabels[i]->imagelabel),\n                  VIR_AUDIT_STR(vm->def->seclabels[i]->model));\n    }\n\n    VIR_FREE(vmname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGenLabel",
          "args": [
            "driver->securityManager",
            "vm->def"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGenLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "635-713",
          "snippet": "int\nvirSecurityManagerGenLabel(virSecurityManagerPtr mgr,\n                           virDomainDefPtr vm)\n{\n    int ret = -1;\n    size_t i;\n    virSecurityManagerPtr* sec_managers = NULL;\n    virSecurityLabelDefPtr seclabel;\n    bool generated = false;\n\n    if ((sec_managers = virSecurityManagerGetNested(mgr)) == NULL)\n        return ret;\n\n    virObjectLock(mgr);\n\n    for (i = 0; sec_managers[i]; i++) {\n        generated = false;\n        seclabel = virDomainDefGetSecurityLabelDef(vm, sec_managers[i]->drv->name);\n        if (seclabel == NULL) {\n            /* Only generate seclabel if confinement is enabled */\n            if (!virSecurityManagerGetDefaultConfined(sec_managers[i])) {\n                VIR_DEBUG(\"Skipping auto generated seclabel\");\n                continue;\n            } else {\n                if (!(seclabel = virSecurityLabelDefNew(sec_managers[i]->drv->name)))\n                    goto cleanup;\n                generated = seclabel->implicit = true;\n                seclabel->type = VIR_DOMAIN_SECLABEL_DYNAMIC;\n            }\n        } else {\n            if (seclabel->type == VIR_DOMAIN_SECLABEL_DEFAULT) {\n                if (virSecurityManagerGetDefaultConfined(sec_managers[i])) {\n                    seclabel->type = VIR_DOMAIN_SECLABEL_DYNAMIC;\n                } else {\n                    seclabel->type = VIR_DOMAIN_SECLABEL_NONE;\n                    seclabel->relabel = false;\n                }\n            }\n\n            if (seclabel->type == VIR_DOMAIN_SECLABEL_NONE) {\n                if (virSecurityManagerGetRequireConfined(sec_managers[i])) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Unconfined guests are not allowed on this host\"));\n                    goto cleanup;\n                }\n            }\n        }\n\n        if (!sec_managers[i]->drv->domainGenSecurityLabel) {\n            virReportUnsupportedError();\n            virSecurityLabelDefFree(seclabel);\n            seclabel = NULL;\n        } else {\n            /* The seclabel must be added to @vm prior calling domainGenSecurityLabel\n             * which may require seclabel to be presented already */\n            if (generated &&\n                VIR_APPEND_ELEMENT(vm->seclabels, vm->nseclabels, seclabel) < 0)\n                goto cleanup;\n\n            if (sec_managers[i]->drv->domainGenSecurityLabel(sec_managers[i], vm) < 0) {\n                if (VIR_DELETE_ELEMENT(vm->seclabels,\n                                       vm->nseclabels -1, vm->nseclabels) < 0)\n                    vm->nseclabels--;\n                goto cleanup;\n            }\n\n            seclabel = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(mgr);\n    if (generated)\n        virSecurityLabelDefFree(seclabel);\n    VIR_FREE(sec_managers);\n    return ret;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerGenLabel(virSecurityManagerPtr mgr,\n                           virDomainDefPtr vm)\n{\n    int ret = -1;\n    size_t i;\n    virSecurityManagerPtr* sec_managers = NULL;\n    virSecurityLabelDefPtr seclabel;\n    bool generated = false;\n\n    if ((sec_managers = virSecurityManagerGetNested(mgr)) == NULL)\n        return ret;\n\n    virObjectLock(mgr);\n\n    for (i = 0; sec_managers[i]; i++) {\n        generated = false;\n        seclabel = virDomainDefGetSecurityLabelDef(vm, sec_managers[i]->drv->name);\n        if (seclabel == NULL) {\n            /* Only generate seclabel if confinement is enabled */\n            if (!virSecurityManagerGetDefaultConfined(sec_managers[i])) {\n                VIR_DEBUG(\"Skipping auto generated seclabel\");\n                continue;\n            } else {\n                if (!(seclabel = virSecurityLabelDefNew(sec_managers[i]->drv->name)))\n                    goto cleanup;\n                generated = seclabel->implicit = true;\n                seclabel->type = VIR_DOMAIN_SECLABEL_DYNAMIC;\n            }\n        } else {\n            if (seclabel->type == VIR_DOMAIN_SECLABEL_DEFAULT) {\n                if (virSecurityManagerGetDefaultConfined(sec_managers[i])) {\n                    seclabel->type = VIR_DOMAIN_SECLABEL_DYNAMIC;\n                } else {\n                    seclabel->type = VIR_DOMAIN_SECLABEL_NONE;\n                    seclabel->relabel = false;\n                }\n            }\n\n            if (seclabel->type == VIR_DOMAIN_SECLABEL_NONE) {\n                if (virSecurityManagerGetRequireConfined(sec_managers[i])) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Unconfined guests are not allowed on this host\"));\n                    goto cleanup;\n                }\n            }\n        }\n\n        if (!sec_managers[i]->drv->domainGenSecurityLabel) {\n            virReportUnsupportedError();\n            virSecurityLabelDefFree(seclabel);\n            seclabel = NULL;\n        } else {\n            /* The seclabel must be added to @vm prior calling domainGenSecurityLabel\n             * which may require seclabel to be presented already */\n            if (generated &&\n                VIR_APPEND_ELEMENT(vm->seclabels, vm->nseclabels, seclabel) < 0)\n                goto cleanup;\n\n            if (sec_managers[i]->drv->domainGenSecurityLabel(sec_managers[i], vm) < 0) {\n                if (VIR_DELETE_ELEMENT(vm->seclabels,\n                                       vm->nseclabels -1, vm->nseclabels) < 0)\n                    vm->nseclabels--;\n                goto cleanup;\n            }\n\n            seclabel = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(mgr);\n    if (generated)\n        virSecurityLabelDefFree(seclabel);\n    VIR_FREE(sec_managers);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerCheckAllLabel",
          "args": [
            "driver->securityManager",
            "vm->def"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerCheckAllLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "835-855",
          "snippet": "int virSecurityManagerCheckAllLabel(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr vm)\n{\n    size_t i;\n\n    if (virSecurityManagerCheckDomainLabel(mgr, vm) < 0)\n        return -1;\n\n    for (i = 0; i < vm->ndisks; i++) {\n        if (virSecurityManagerCheckDiskLabel(mgr, vm->disks[i]) < 0)\n            return -1;\n    }\n\n    if (virDomainChrDefForeach(vm,\n                               true,\n                               virSecurityManagerCheckChardevCallback,\n                               mgr) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint virSecurityManagerCheckAllLabel(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr vm)\n{\n    size_t i;\n\n    if (virSecurityManagerCheckDomainLabel(mgr, vm) < 0)\n        return -1;\n\n    for (i = 0; i < vm->ndisks; i++) {\n        if (virSecurityManagerCheckDiskLabel(mgr, vm->disks[i]) < 0)\n            return -1;\n    }\n\n    if (virDomainChrDefForeach(vm,\n                               true,\n                               virSecurityManagerCheckChardevCallback,\n                               mgr) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Generating domain security label (if required)\""
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "ttyFDs",
            "nttyFDs"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLXCPrepareHostDevices",
          "args": [
            "driver",
            "vm->def"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCPrepareHostDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_hostdev.c",
          "lines": "63-115",
          "snippet": "int virLXCPrepareHostDevices(virLXCDriverPtr driver,\n                             virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    /* Sanity check for supported configurations only */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevDefPtr dev = def->hostdevs[i];\n\n        switch (dev->mode) {\n        case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB:\n                break;\n            default:\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Unsupported hostdev type %s\"),\n                               virDomainHostdevSubsysTypeToString(dev->source.subsys.type));\n                return -1;\n            }\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_STORAGE:\n            case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_MISC:\n            case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_NET:\n                break;\n            default:\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Unsupported hostdev type %s\"),\n                               virDomainHostdevSubsysTypeToString(dev->source.subsys.type));\n                return -1;\n            }\n            break;\n\n\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported hostdev mode %s\"),\n                           virDomainHostdevModeTypeToString(dev->mode));\n            return -1;\n        }\n    }\n\n    if (virLXCPrepareHostUSBDevices(driver, def) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"lxc_hostdev.h\"\n#include <config.h>\n\nint virLXCPrepareHostDevices(virLXCDriverPtr driver,\n                             virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def->nhostdevs)\n        return 0;\n\n    /* Sanity check for supported configurations only */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevDefPtr dev = def->hostdevs[i];\n\n        switch (dev->mode) {\n        case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB:\n                break;\n            default:\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Unsupported hostdev type %s\"),\n                               virDomainHostdevSubsysTypeToString(dev->source.subsys.type));\n                return -1;\n            }\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_STORAGE:\n            case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_MISC:\n            case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_NET:\n                break;\n            default:\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Unsupported hostdev type %s\"),\n                               virDomainHostdevSubsysTypeToString(dev->source.subsys.type));\n                return -1;\n            }\n            break;\n\n\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported hostdev mode %s\"),\n                           virDomainHostdevModeTypeToString(dev->mode));\n            return -1;\n        }\n    }\n\n    if (virLXCPrepareHostUSBDevices(driver, def) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Preparing host devices\""
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLXCProcessEnsureRootFS",
          "args": [
            "vm"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessEnsureRootFS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "1141-1168",
          "snippet": "static int\nvirLXCProcessEnsureRootFS(virDomainObjPtr vm)\n{\n    virDomainFSDefPtr root = virDomainGetFilesystemForTarget(vm->def, \"/\");\n\n    if (root)\n        return 0;\n\n    if (!(root = virDomainFSDefNew(NULL)))\n        goto error;\n\n    root->type = VIR_DOMAIN_FS_TYPE_MOUNT;\n\n    root->src->path = g_strdup(\"/\");\n    root->dst = g_strdup(\"/\");\n\n    if (VIR_INSERT_ELEMENT(vm->def->fss,\n                           0,\n                           vm->def->nfss,\n                           root) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDomainFSDefFree(root);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirLXCProcessEnsureRootFS(virDomainObjPtr vm)\n{\n    virDomainFSDefPtr root = virDomainGetFilesystemForTarget(vm->def, \"/\");\n\n    if (root)\n        return 0;\n\n    if (!(root = virDomainFSDefNew(NULL)))\n        goto error;\n\n    root->type = VIR_DOMAIN_FS_TYPE_MOUNT;\n\n    root->src->path = g_strdup(\"/\");\n    root->dst = g_strdup(\"/\");\n\n    if (VIR_INSERT_ELEMENT(vm->def->fss,\n                           0,\n                           vm->def->nfss,\n                           root) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDomainFSDefFree(root);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjSetDefTransient",
          "args": [
            "driver->xmlopt",
            "vm",
            "NULL"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetDefTransient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3711-3727",
          "snippet": "int\nvirDomainObjSetDefTransient(virDomainXMLOptionPtr xmlopt,\n                            virDomainObjPtr domain,\n                            void *parseOpaque)\n{\n    if (!domain->persistent)\n        return 0;\n\n    if (domain->newDef)\n        return 0;\n\n    if (!(domain->newDef = virDomainDefCopy(domain->def, xmlopt,\n                                            parseOpaque, false)))\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainObjSetDefTransient(virDomainXMLOptionPtr xmlopt,\n                            virDomainObjPtr domain,\n                            void *parseOpaque)\n{\n    if (!domain->persistent)\n        return 0;\n\n    if (domain->newDef)\n        return 0;\n\n    if (!(domain->newDef = virDomainDefCopy(domain->def, xmlopt,\n                                            parseOpaque, false)))\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting current domain def as transient\""
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLXCDriverGetCapabilities",
          "args": [
            "driver",
            "false"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCDriverGetCapabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
          "lines": "187-213",
          "snippet": "virCapsPtr virLXCDriverGetCapabilities(virLXCDriverPtr driver,\n                                       bool refresh)\n{\n    virCapsPtr ret;\n    if (refresh) {\n        virCapsPtr caps = NULL;\n        if ((caps = virLXCDriverCapsInit(driver)) == NULL)\n            return NULL;\n\n        lxcDriverLock(driver);\n        virObjectUnref(driver->caps);\n        driver->caps = caps;\n    } else {\n        lxcDriverLock(driver);\n\n        if (driver->caps == NULL) {\n            VIR_DEBUG(\"Capabilities didn't detect any guests. Forcing a \"\n                      \"refresh.\");\n            lxcDriverUnlock(driver);\n            return virLXCDriverGetCapabilities(driver, true);\n        }\n    }\n\n    ret = virObjectRef(driver->caps);\n    lxcDriverUnlock(driver);\n    return ret;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"lxc_container.h\"",
            "#include \"configmake.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_conf.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virnodesuspend.h\"\n#include \"lxc_container.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_conf.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsPtr virLXCDriverGetCapabilities(virLXCDriverPtr driver,\n                                       bool refresh)\n{\n    virCapsPtr ret;\n    if (refresh) {\n        virCapsPtr caps = NULL;\n        if ((caps = virLXCDriverCapsInit(driver)) == NULL)\n            return NULL;\n\n        lxcDriverLock(driver);\n        virObjectUnref(driver->caps);\n        driver->caps = caps;\n    } else {\n        lxcDriverLock(driver);\n\n        if (driver->caps == NULL) {\n            VIR_DEBUG(\"Capabilities didn't detect any guests. Forcing a \"\n                      \"refresh.\");\n            lxcDriverUnlock(driver);\n            return virLXCDriverGetCapabilities(driver, true);\n        }\n    }\n\n    ret = virObjectRef(driver->caps);\n    lxcDriverUnlock(driver);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileBuildPath",
          "args": [
            "cfg->stateDir",
            "vm->def->name"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileBuildPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "43-51",
          "snippet": "char *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "res"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot create log directory '%s'\")",
            "cfg->logDir"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "cfg->logDir"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Only PTY console types are supported\")"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"At least one PTY console is required\")"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCgroupFree",
          "args": [
            "&selfcgroup"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "virCgroupFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircgroup.c",
          "lines": "3544-3563",
          "snippet": "void\nvirCgroupFree(virCgroupPtr *group)\n{\n    size_t i;\n\n    if (*group == NULL)\n        return;\n\n    for (i = 0; i < VIR_CGROUP_CONTROLLER_LAST; i++) {\n        VIR_FREE((*group)->legacy[i].mountPoint);\n        VIR_FREE((*group)->legacy[i].linkPoint);\n        VIR_FREE((*group)->legacy[i].placement);\n    }\n\n    VIR_FREE((*group)->unified.mountPoint);\n    VIR_FREE((*group)->unified.placement);\n\n    VIR_FREE((*group)->path);\n    VIR_FREE(*group);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircgroupbackend.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"vircgrouppriv.h\"",
            "# include <unistd.h>",
            "# include <dirent.h>",
            "# include <signal.h>",
            "# include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <sys/stat.h>",
            "# include <fcntl.h>",
            "# include <sys/mount.h>",
            "# include <mntent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virhostcpu.h\"\n#include \"virtypedparam.h\"\n#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhashcode.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircgroupbackend.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"vircgrouppriv.h\"\n# include <unistd.h>\n# include <dirent.h>\n# include <signal.h>\n# include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n# include <sys/mount.h>\n# include <mntent.h>\n#include <config.h>\n\nvoid\nvirCgroupFree(virCgroupPtr *group)\n{\n    size_t i;\n\n    if (*group == NULL)\n        return;\n\n    for (i = 0; i < VIR_CGROUP_CONTROLLER_LAST; i++) {\n        VIR_FREE((*group)->legacy[i].mountPoint);\n        VIR_FREE((*group)->legacy[i].linkPoint);\n        VIR_FREE((*group)->legacy[i].placement);\n    }\n\n    VIR_FREE((*group)->unified.mountPoint);\n    VIR_FREE((*group)->unified.placement);\n\n    VIR_FREE((*group)->path);\n    VIR_FREE(*group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to find 'memory' cgroups controller mount\")"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCgroupHasController",
          "args": [
            "selfcgroup",
            "VIR_CGROUP_CONTROLLER_MEMORY"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "virCgroupHasController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircgroup.c",
          "lines": "2899-2904",
          "snippet": "bool\nvirCgroupHasController(virCgroupPtr cgroup G_GNUC_UNUSED,\n                       int controller G_GNUC_UNUSED)\n{\n    return false;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircgroupbackend.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"vircgrouppriv.h\"",
            "# include <unistd.h>",
            "# include <dirent.h>",
            "# include <signal.h>",
            "# include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <sys/stat.h>",
            "# include <fcntl.h>",
            "# include <sys/mount.h>",
            "# include <mntent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virhostcpu.h\"\n#include \"virtypedparam.h\"\n#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhashcode.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircgroupbackend.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"vircgrouppriv.h\"\n# include <unistd.h>\n# include <dirent.h>\n# include <signal.h>\n# include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n# include <sys/mount.h>\n# include <mntent.h>\n#include <config.h>\n\nbool\nvirCgroupHasController(virCgroupPtr cgroup G_GNUC_UNUSED,\n                       int controller G_GNUC_UNUSED)\n{\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to find 'devices' cgroups controller mount\")"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to find 'cpuacct' cgroups controller mount\")"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCgroupNewSelf",
          "args": [
            "&selfcgroup"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "virCgroupNewSelf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircgroup.c",
          "lines": "2803-2809",
          "snippet": "int\nvirCgroupNewSelf(virCgroupPtr *group G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircgroupbackend.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"vircgrouppriv.h\"",
            "# include <unistd.h>",
            "# include <dirent.h>",
            "# include <signal.h>",
            "# include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <sys/stat.h>",
            "# include <fcntl.h>",
            "# include <sys/mount.h>",
            "# include <mntent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virhostcpu.h\"\n#include \"virtypedparam.h\"\n#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhashcode.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircgroupbackend.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"vircgrouppriv.h\"\n# include <unistd.h>\n# include <dirent.h>\n# include <signal.h>\n# include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n# include <sys/mount.h>\n# include <mntent.h>\n#include <config.h>\n\nint\nvirCgroupNewSelf(virCgroupPtr *group G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
          "lines": "279-286",
          "snippet": "virLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver)\n{\n    virLXCDriverConfigPtr cfg;\n    lxcDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    lxcDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"lxc_container.h\"",
            "#include \"configmake.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_conf.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virnodesuspend.h\"\n#include \"lxc_container.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_conf.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver)\n{\n    virLXCDriverConfigPtr cfg;\n    lxcDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    lxcDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define START_POSTFIX \": starting up\\n\"\n\nint virLXCProcessStart(virConnectPtr conn,\n                       virLXCDriverPtr  driver,\n                       virDomainObjPtr vm,\n                       unsigned int nfiles, int *files,\n                       bool autoDestroy,\n                       virDomainRunningReason reason)\n{\n    int rc = -1, r;\n    size_t nttyFDs = 0;\n    int *ttyFDs = NULL;\n    size_t i;\n    char *logfile = NULL;\n    int logfd = -1;\n    VIR_AUTOSTRINGLIST veths = NULL;\n    int handshakefds[2] = { -1, -1 };\n    off_t pos = -1;\n    char ebuf[1024];\n    char *timestamp;\n    int nsInheritFDs[VIR_LXC_DOMAIN_NAMESPACE_LAST];\n    virCommandPtr cmd = NULL;\n    virLXCDomainObjPrivatePtr priv = vm->privateData;\n    virCapsPtr caps = NULL;\n    virErrorPtr err = NULL;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    virCgroupPtr selfcgroup;\n    int status;\n    char *pidfile = NULL;\n\n    if (virCgroupNewSelf(&selfcgroup) < 0)\n        return -1;\n\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_CPUACCT)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'cpuacct' cgroups controller mount\"));\n        return -1;\n    }\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_DEVICES)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'devices' cgroups controller mount\"));\n        return -1;\n    }\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_MEMORY)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'memory' cgroups controller mount\"));\n        return -1;\n    }\n    virCgroupFree(&selfcgroup);\n\n    if (vm->def->nconsoles == 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"At least one PTY console is required\"));\n        return -1;\n    }\n\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        if (vm->def->consoles[i]->source->type != VIR_DOMAIN_CHR_TYPE_PTY) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only PTY console types are supported\"));\n            return -1;\n        }\n    }\n\n    if (virFileMakePath(cfg->logDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot create log directory '%s'\"),\n                             cfg->logDir);\n        return -1;\n    }\n\n    if (!vm->def->resource) {\n        virDomainResourceDefPtr res;\n\n        if (VIR_ALLOC(res) < 0)\n            goto cleanup;\n\n        res->partition = g_strdup(\"/machine\");\n\n        vm->def->resource = res;\n    }\n\n    logfile = g_strdup_printf(\"%s/%s.log\", cfg->logDir, vm->def->name);\n\n    if (!(pidfile = virPidFileBuildPath(cfg->stateDir, vm->def->name)))\n        goto cleanup;\n\n    if (!(caps = virLXCDriverGetCapabilities(driver, false)))\n        goto cleanup;\n\n    /* Do this up front, so any part of the startup process can add\n     * runtime state to vm->def that won't be persisted. This let's us\n     * report implicit runtime defaults in the XML, like vnc listen/socket\n     */\n    VIR_DEBUG(\"Setting current domain def as transient\");\n    if (virDomainObjSetDefTransient(driver->xmlopt, vm, NULL) < 0)\n        goto cleanup;\n\n    /* Run an early hook to set-up missing devices */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_PREPARE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    if (virLXCProcessEnsureRootFS(vm) < 0)\n        goto cleanup;\n\n    /* Must be run before security labelling */\n    VIR_DEBUG(\"Preparing host devices\");\n    if (virLXCPrepareHostDevices(driver, vm->def) < 0)\n        goto cleanup;\n\n    /* Here we open all the PTYs we need on the host OS side.\n     * The LXC controller will open the guest OS side PTYs\n     * and forward I/O between them.\n     */\n    nttyFDs = vm->def->nconsoles;\n    if (VIR_ALLOC_N(ttyFDs, nttyFDs) < 0)\n        goto cleanup;\n    for (i = 0; i < vm->def->nconsoles; i++)\n        ttyFDs[i] = -1;\n\n    /* If you are using a SecurityDriver with dynamic labelling,\n       then generate a security label for isolation */\n    VIR_DEBUG(\"Generating domain security label (if required)\");\n\n    if (vm->def->nseclabels &&\n        vm->def->seclabels[0]->type == VIR_DOMAIN_SECLABEL_DEFAULT)\n        vm->def->seclabels[0]->type = VIR_DOMAIN_SECLABEL_NONE;\n\n    if (virSecurityManagerCheckAllLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n\n    if (virSecurityManagerGenLabel(driver->securityManager, vm->def) < 0) {\n        virDomainAuditSecurityLabel(vm, false);\n        goto cleanup;\n    }\n    virDomainAuditSecurityLabel(vm, true);\n\n    VIR_DEBUG(\"Setting domain security labels\");\n    if (virSecurityManagerSetAllLabel(driver->securityManager,\n                                      vm->def, NULL, false, false) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up consoles\");\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        char *ttyPath;\n\n        if (virFileOpenTty(&ttyFDs[i], &ttyPath, 1) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Failed to allocate tty\"));\n            goto cleanup;\n        }\n\n        VIR_FREE(vm->def->consoles[i]->source->data.file.path);\n        vm->def->consoles[i]->source->data.file.path = ttyPath;\n\n        VIR_FREE(vm->def->consoles[i]->info.alias);\n        vm->def->consoles[i]->info.alias = g_strdup_printf(\"console%zu\", i);\n    }\n\n    VIR_DEBUG(\"Setting up Interfaces\");\n    if (virLXCProcessSetupInterfaces(driver, vm->def, &veths) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up namespaces if any\");\n    if (virLXCProcessSetupNamespaces(driver, vm->def->namespaceData, nsInheritFDs) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Preparing to launch\");\n    if ((logfd = open(logfile, O_WRONLY | O_APPEND | O_CREAT,\n             S_IRUSR|S_IWUSR)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to open '%s'\"),\n                             logfile);\n        goto cleanup;\n    }\n\n    if (virPipe(handshakefds) < 0)\n        goto cleanup;\n\n    if (!(cmd = virLXCProcessBuildControllerCmd(driver,\n                                                vm,\n                                                veths,\n                                                ttyFDs, nttyFDs,\n                                                nsInheritFDs,\n                                                files, nfiles,\n                                                handshakefds[1],\n                                                &logfd,\n                                                pidfile)))\n        goto cleanup;\n\n    /* now that we know it is about to start call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_START, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    /* Log timestamp */\n    if ((timestamp = virTimeStringNow()) == NULL)\n        goto cleanup;\n    if (safewrite(logfd, timestamp, strlen(timestamp)) < 0 ||\n        safewrite(logfd, START_POSTFIX, strlen(START_POSTFIX)) < 0) {\n        VIR_WARN(\"Unable to write timestamp to logfile: %s\",\n                 g_strerror(errno));\n    }\n    VIR_FREE(timestamp);\n\n    /* Log generated command line */\n    virCommandWriteArgLog(cmd, logfd);\n    if ((pos = lseek(logfd, 0, SEEK_END)) < 0)\n        VIR_WARN(\"Unable to seek to end of logfile: %s\",\n                 g_strerror(errno));\n\n    VIR_DEBUG(\"Launching container\");\n    virCommandRawStatus(cmd);\n    if (virCommandRun(cmd, &status) < 0)\n        goto cleanup;\n\n    if (status != 0) {\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf,\n                                       sizeof(ebuf)) <= 0) {\n            if (WIFEXITED(status))\n                g_snprintf(ebuf, sizeof(ebuf), _(\"unexpected exit status %d\"),\n                           WEXITSTATUS(status));\n            else\n                g_snprintf(ebuf, sizeof(ebuf), \"%s\", _(\"terminated abnormally\"));\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"guest failed to start: %s\"), ebuf);\n        goto cleanup;\n    }\n\n    /* It has started running, so get its pid */\n    if ((r = virPidFileReadPath(pidfile, &vm->pid)) < 0) {\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf, sizeof(ebuf)) > 0)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), ebuf);\n        else\n            virReportSystemError(-r,\n                                 _(\"Failed to read pid file %s\"),\n                                 pidfile);\n        goto cleanup;\n    }\n\n    priv->stopReason = VIR_DOMAIN_EVENT_STOPPED_FAILED;\n    priv->wantReboot = false;\n    vm->def->id = vm->pid;\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, reason);\n    priv->doneStopEvent = false;\n\n    if (VIR_CLOSE(handshakefds[1]) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"could not close handshake fd\"));\n        goto cleanup;\n    }\n\n    if (virCommandHandshakeWait(cmd) < 0)\n        goto cleanup;\n\n    /* Write domain status to disk for the controller to\n     * read when it starts */\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        goto cleanup;\n\n    /* Allow the child to exec the controller */\n    if (virCommandHandshakeNotify(cmd) < 0)\n        goto cleanup;\n\n    if (g_atomic_int_add(&driver->nactive, 1) == 0 && driver->inhibitCallback)\n        driver->inhibitCallback(true, driver->inhibitOpaque);\n\n    if (lxcContainerWaitForContinue(handshakefds[0]) < 0) {\n        char out[1024];\n\n        if (!(virLXCProcessReadLogOutput(vm, logfile, pos, out, 1024) < 0)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), out);\n        }\n\n        goto cleanup;\n    }\n\n    priv->machineName = virLXCDomainGetMachineName(vm->def, vm->pid);\n    if (!priv->machineName)\n        goto cleanup;\n\n    /* We know the cgroup must exist by this synchronization\n     * point so lets detect that first, since it gives us a\n     * more reliable way to kill everything off if something\n     * goes wrong from here onwards ... */\n    if (virCgroupNewDetectMachine(vm->def->name, \"lxc\",\n                                  vm->pid, -1, priv->machineName,\n                                  &priv->cgroup) < 0)\n        goto cleanup;\n\n    if (!priv->cgroup) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No valid cgroup for machine %s\"),\n                       vm->def->name);\n        goto cleanup;\n    }\n\n    /* And we can get the first monitor connection now too */\n    if (!(priv->monitor = virLXCProcessConnectMonitor(driver, vm))) {\n        /* Intentionally overwrite the real monitor error message,\n         * since a better one is almost always found in the logs\n         */\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf, sizeof(ebuf)) > 0) {\n            virResetLastError();\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), ebuf);\n        }\n        goto cleanup;\n    }\n\n    if (autoDestroy &&\n        virCloseCallbacksSet(driver->closeCallbacks, vm,\n                             conn, lxcProcessAutoDestroy) < 0)\n        goto cleanup;\n\n    /* We don't need the temporary NIC names anymore, clear them */\n    virLXCProcessCleanInterfaces(vm->def);\n\n    /* finally we can call the 'started' hook script if any */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_STARTED, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(logfd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"could not close logfile\"));\n        rc = -1;\n    }\n    if (rc != 0) {\n        virErrorPreserveLast(&err);\n        virLXCProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED);\n    }\n    virCommandFree(cmd);\n    for (i = 0; i < nttyFDs; i++)\n        VIR_FORCE_CLOSE(ttyFDs[i]);\n    VIR_FREE(ttyFDs);\n    VIR_FORCE_CLOSE(handshakefds[0]);\n    VIR_FORCE_CLOSE(handshakefds[1]);\n    VIR_FREE(pidfile);\n    VIR_FREE(logfile);\n    virObjectUnref(cfg);\n    virObjectUnref(caps);\n\n    virErrorRestore(&err);\n\n    return rc;\n}"
  },
  {
    "function_name": "virLXCProcessEnsureRootFS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "1141-1168",
    "snippet": "static int\nvirLXCProcessEnsureRootFS(virDomainObjPtr vm)\n{\n    virDomainFSDefPtr root = virDomainGetFilesystemForTarget(vm->def, \"/\");\n\n    if (root)\n        return 0;\n\n    if (!(root = virDomainFSDefNew(NULL)))\n        goto error;\n\n    root->type = VIR_DOMAIN_FS_TYPE_MOUNT;\n\n    root->src->path = g_strdup(\"/\");\n    root->dst = g_strdup(\"/\");\n\n    if (VIR_INSERT_ELEMENT(vm->def->fss,\n                           0,\n                           vm->def->nfss,\n                           root) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDomainFSDefFree(root);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainFSDefFree",
          "args": [
            "root"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainFSDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2328-2341",
          "snippet": "void virDomainFSDefFree(virDomainFSDefPtr def)\n{\n    if (!def)\n        return;\n\n    virObjectUnref(def->src);\n    VIR_FREE(def->dst);\n    virDomainDeviceInfoClear(&def->info);\n    VIR_FREE(def->virtio);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def->binary);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainFSDefFree(virDomainFSDefPtr def)\n{\n    if (!def)\n        return;\n\n    virObjectUnref(def->src);\n    VIR_FREE(def->dst);\n    virDomainDeviceInfoClear(&def->info);\n    VIR_FREE(def->virtio);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def->binary);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INSERT_ELEMENT",
          "args": [
            "vm->def->fss",
            "0",
            "vm->def->nfss",
            "root"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"/\""
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainFSDefNew",
          "args": [
            "NULL"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainFSDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2304-2326",
          "snippet": "virDomainFSDefPtr\nvirDomainFSDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainFSDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto cleanup;\n\n    if (xmlopt &&\n        xmlopt->privateData.fsNew &&\n        !(ret->privateData = xmlopt->privateData.fsNew()))\n        goto cleanup;\n\n    return ret;\n\n cleanup:\n    virDomainFSDefFree(ret);\n    return NULL;\n\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainFSDefPtr\nvirDomainFSDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainFSDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto cleanup;\n\n    if (xmlopt &&\n        xmlopt->privateData.fsNew &&\n        !(ret->privateData = xmlopt->privateData.fsNew()))\n        goto cleanup;\n\n    return ret;\n\n cleanup:\n    virDomainFSDefFree(ret);\n    return NULL;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainGetFilesystemForTarget",
          "args": [
            "vm->def",
            "\"/\""
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGetFilesystemForTarget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29820-29832",
          "snippet": "virDomainFSDefPtr\nvirDomainGetFilesystemForTarget(virDomainDefPtr def,\n                                const char *target)\n{\n    size_t i;\n\n    for (i = 0; i < def->nfss; i++) {\n        if (STREQ(def->fss[i]->dst, target))\n            return def->fss[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainFSDefPtr\nvirDomainGetFilesystemForTarget(virDomainDefPtr def,\n                                const char *target)\n{\n    size_t i;\n\n    for (i = 0; i < def->nfss; i++) {\n        if (STREQ(def->fss[i]->dst, target))\n            return def->fss[i];\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirLXCProcessEnsureRootFS(virDomainObjPtr vm)\n{\n    virDomainFSDefPtr root = virDomainGetFilesystemForTarget(vm->def, \"/\");\n\n    if (root)\n        return 0;\n\n    if (!(root = virDomainFSDefNew(NULL)))\n        goto error;\n\n    root->type = VIR_DOMAIN_FS_TYPE_MOUNT;\n\n    root->src->path = g_strdup(\"/\");\n    root->dst = g_strdup(\"/\");\n\n    if (VIR_INSERT_ELEMENT(vm->def->fss,\n                           0,\n                           vm->def->nfss,\n                           root) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDomainFSDefFree(root);\n    return -1;\n}"
  },
  {
    "function_name": "virLXCProcessReadLogOutput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "1106-1138",
    "snippet": "static int\nvirLXCProcessReadLogOutput(virDomainObjPtr vm,\n                           char *logfile,\n                           off_t pos,\n                           char *buf,\n                           size_t buflen)\n{\n    int fd = -1;\n    int ret;\n\n    if ((fd = open(logfile, O_RDONLY)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to open log file %s\"),\n                             logfile);\n        return -1;\n    }\n\n    if (lseek(fd, pos, SEEK_SET) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to seek log file %s to %llu\"),\n                             logfile, (unsigned long long)pos);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    ret = virLXCProcessReadLogOutputData(vm,\n                                         fd,\n                                         buf,\n                                         buflen);\n\n    VIR_FORCE_CLOSE(fd);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLXCProcessReadLogOutputData",
          "args": [
            "vm",
            "fd",
            "buf",
            "buflen"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessReadLogOutputData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "1039-1103",
          "snippet": "static int\nvirLXCProcessReadLogOutputData(virDomainObjPtr vm,\n                               int fd,\n                               char *buf,\n                               size_t buflen)\n{\n    int retries = 10;\n    int got = 0;\n    char *filter_next = buf;\n\n    buf[0] = '\\0';\n\n    while (retries) {\n        ssize_t bytes;\n        bool isdead = false;\n        char *eol;\n\n        if (vm->pid <= 0 ||\n            (kill(vm->pid, 0) == -1 && errno == ESRCH))\n            isdead = true;\n\n        /* Any failures should be detected before we read the log, so we\n         * always have something useful to report on failure. */\n        bytes = saferead(fd, buf+got, buflen-got-1);\n        if (bytes < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Failure while reading log output\"));\n            return -1;\n        }\n\n        got += bytes;\n        buf[got] = '\\0';\n\n        /* Filter out debug messages from intermediate libvirt process */\n        while ((eol = strchr(filter_next, '\\n'))) {\n            *eol = '\\0';\n            if (virLXCProcessIgnorableLogLine(filter_next)) {\n                memmove(filter_next, eol + 1, got - (eol - buf));\n                got -= eol + 1 - filter_next;\n            } else {\n                filter_next = eol + 1;\n                *eol = '\\n';\n            }\n        }\n\n        if (got == buflen-1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Out of space while reading log output: %s\"),\n                           buf);\n            return -1;\n        }\n\n        if (isdead)\n            return got;\n\n        g_usleep(100*1000);\n        retries--;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Timed out while reading log output: %s\"),\n                   buf);\n\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirLXCProcessReadLogOutputData(virDomainObjPtr vm,\n                               int fd,\n                               char *buf,\n                               size_t buflen)\n{\n    int retries = 10;\n    int got = 0;\n    char *filter_next = buf;\n\n    buf[0] = '\\0';\n\n    while (retries) {\n        ssize_t bytes;\n        bool isdead = false;\n        char *eol;\n\n        if (vm->pid <= 0 ||\n            (kill(vm->pid, 0) == -1 && errno == ESRCH))\n            isdead = true;\n\n        /* Any failures should be detected before we read the log, so we\n         * always have something useful to report on failure. */\n        bytes = saferead(fd, buf+got, buflen-got-1);\n        if (bytes < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Failure while reading log output\"));\n            return -1;\n        }\n\n        got += bytes;\n        buf[got] = '\\0';\n\n        /* Filter out debug messages from intermediate libvirt process */\n        while ((eol = strchr(filter_next, '\\n'))) {\n            *eol = '\\0';\n            if (virLXCProcessIgnorableLogLine(filter_next)) {\n                memmove(filter_next, eol + 1, got - (eol - buf));\n                got -= eol + 1 - filter_next;\n            } else {\n                filter_next = eol + 1;\n                *eol = '\\n';\n            }\n        }\n\n        if (got == buflen-1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Out of space while reading log output: %s\"),\n                           buf);\n            return -1;\n        }\n\n        if (isdead)\n            return got;\n\n        g_usleep(100*1000);\n        retries--;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Timed out while reading log output: %s\"),\n                   buf);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to seek log file %s to %llu\")",
            "logfile",
            "(unsigned long long)pos"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to seek log file %s to %llu\""
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "userns_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2329-2332",
          "snippet": "static int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "pos",
            "SEEK_SET"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to open log file %s\")",
            "logfile"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "logfile",
            "O_RDONLY"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirLXCProcessReadLogOutput(virDomainObjPtr vm,\n                           char *logfile,\n                           off_t pos,\n                           char *buf,\n                           size_t buflen)\n{\n    int fd = -1;\n    int ret;\n\n    if ((fd = open(logfile, O_RDONLY)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to open log file %s\"),\n                             logfile);\n        return -1;\n    }\n\n    if (lseek(fd, pos, SEEK_SET) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to seek log file %s to %llu\"),\n                             logfile, (unsigned long long)pos);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    ret = virLXCProcessReadLogOutputData(vm,\n                                         fd,\n                                         buf,\n                                         buflen);\n\n    VIR_FORCE_CLOSE(fd);\n    return ret;\n}"
  },
  {
    "function_name": "virLXCProcessReadLogOutputData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "1039-1103",
    "snippet": "static int\nvirLXCProcessReadLogOutputData(virDomainObjPtr vm,\n                               int fd,\n                               char *buf,\n                               size_t buflen)\n{\n    int retries = 10;\n    int got = 0;\n    char *filter_next = buf;\n\n    buf[0] = '\\0';\n\n    while (retries) {\n        ssize_t bytes;\n        bool isdead = false;\n        char *eol;\n\n        if (vm->pid <= 0 ||\n            (kill(vm->pid, 0) == -1 && errno == ESRCH))\n            isdead = true;\n\n        /* Any failures should be detected before we read the log, so we\n         * always have something useful to report on failure. */\n        bytes = saferead(fd, buf+got, buflen-got-1);\n        if (bytes < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Failure while reading log output\"));\n            return -1;\n        }\n\n        got += bytes;\n        buf[got] = '\\0';\n\n        /* Filter out debug messages from intermediate libvirt process */\n        while ((eol = strchr(filter_next, '\\n'))) {\n            *eol = '\\0';\n            if (virLXCProcessIgnorableLogLine(filter_next)) {\n                memmove(filter_next, eol + 1, got - (eol - buf));\n                got -= eol + 1 - filter_next;\n            } else {\n                filter_next = eol + 1;\n                *eol = '\\n';\n            }\n        }\n\n        if (got == buflen-1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Out of space while reading log output: %s\"),\n                           buf);\n            return -1;\n        }\n\n        if (isdead)\n            return got;\n\n        g_usleep(100*1000);\n        retries--;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Timed out while reading log output: %s\"),\n                   buf);\n\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Timed out while reading log output: %s\")",
            "buf"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Timed out while reading log output: %s\""
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "userns_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2329-2332",
          "snippet": "static int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "100*1000"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Out of space while reading log output: %s\")",
            "buf"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "filter_next",
            "eol + 1",
            "got - (eol - buf)"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLXCProcessIgnorableLogLine",
          "args": [
            "filter_next"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessIgnorableLogLine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "1025-1037",
          "snippet": "static bool\nvirLXCProcessIgnorableLogLine(const char *str)\n{\n    if (virLogProbablyLogMessage(str))\n        return true;\n    if (strstr(str, \"PATH=\"))\n        return true;\n    if (strstr(str, \"error receiving signal from container\"))\n        return true;\n    if (STREQ(str, \"\"))\n        return true;\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic bool\nvirLXCProcessIgnorableLogLine(const char *str)\n{\n    if (virLogProbablyLogMessage(str))\n        return true;\n    if (strstr(str, \"PATH=\"))\n        return true;\n    if (strstr(str, \"error receiving signal from container\"))\n        return true;\n    if (STREQ(str, \"\"))\n        return true;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "filter_next",
            "'\\n'"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Failure while reading log output\")"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "saferead",
          "args": [
            "fd",
            "buf+got",
            "buflen-got-1"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "saferead_lim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1330-1372",
          "snippet": "static char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "vm->pid",
            "0"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirLXCProcessReadLogOutputData(virDomainObjPtr vm,\n                               int fd,\n                               char *buf,\n                               size_t buflen)\n{\n    int retries = 10;\n    int got = 0;\n    char *filter_next = buf;\n\n    buf[0] = '\\0';\n\n    while (retries) {\n        ssize_t bytes;\n        bool isdead = false;\n        char *eol;\n\n        if (vm->pid <= 0 ||\n            (kill(vm->pid, 0) == -1 && errno == ESRCH))\n            isdead = true;\n\n        /* Any failures should be detected before we read the log, so we\n         * always have something useful to report on failure. */\n        bytes = saferead(fd, buf+got, buflen-got-1);\n        if (bytes < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Failure while reading log output\"));\n            return -1;\n        }\n\n        got += bytes;\n        buf[got] = '\\0';\n\n        /* Filter out debug messages from intermediate libvirt process */\n        while ((eol = strchr(filter_next, '\\n'))) {\n            *eol = '\\0';\n            if (virLXCProcessIgnorableLogLine(filter_next)) {\n                memmove(filter_next, eol + 1, got - (eol - buf));\n                got -= eol + 1 - filter_next;\n            } else {\n                filter_next = eol + 1;\n                *eol = '\\n';\n            }\n        }\n\n        if (got == buflen-1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Out of space while reading log output: %s\"),\n                           buf);\n            return -1;\n        }\n\n        if (isdead)\n            return got;\n\n        g_usleep(100*1000);\n        retries--;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Timed out while reading log output: %s\"),\n                   buf);\n\n    return -1;\n}"
  },
  {
    "function_name": "virLXCProcessIgnorableLogLine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "1025-1037",
    "snippet": "static bool\nvirLXCProcessIgnorableLogLine(const char *str)\n{\n    if (virLogProbablyLogMessage(str))\n        return true;\n    if (strstr(str, \"PATH=\"))\n        return true;\n    if (strstr(str, \"error receiving signal from container\"))\n        return true;\n    if (STREQ(str, \"\"))\n        return true;\n    return false;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "str",
            "\"\""
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"error receiving signal from container\""
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"PATH=\""
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLogProbablyLogMessage",
          "args": [
            "str"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "virLogProbablyLogMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1233-1240",
          "snippet": "bool virLogProbablyLogMessage(const char *str)\n{\n    if (!virLogRegex)\n        return false;\n    if (g_regex_match(virLogRegex, str, 0, NULL))\n        return true;\n    return false;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static GRegex *virLogRegex;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic GRegex *virLogRegex;\n\nbool virLogProbablyLogMessage(const char *str)\n{\n    if (!virLogRegex)\n        return false;\n    if (g_regex_match(virLogRegex, str, 0, NULL))\n        return true;\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic bool\nvirLXCProcessIgnorableLogLine(const char *str)\n{\n    if (virLogProbablyLogMessage(str))\n        return true;\n    if (strstr(str, \"PATH=\"))\n        return true;\n    if (strstr(str, \"error receiving signal from container\"))\n        return true;\n    if (STREQ(str, \"\"))\n        return true;\n    return false;\n}"
  },
  {
    "function_name": "virLXCProcessBuildControllerCmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "918-1022",
    "snippet": "static virCommandPtr\nvirLXCProcessBuildControllerCmd(virLXCDriverPtr driver,\n                                virDomainObjPtr vm,\n                                char **veths,\n                                int *ttyFDs,\n                                size_t nttyFDs,\n                                int *nsInheritFDs,\n                                int *files,\n                                size_t nfiles,\n                                int handshakefd,\n                                int * const logfd,\n                                const char *pidfile)\n{\n    size_t i;\n    char *filterstr;\n    char *outputstr;\n    virCommandPtr cmd;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n\n    cmd = virCommandNew(vm->def->emulator);\n\n    /* The controller may call ip command, so we have to retain PATH. */\n    virCommandAddEnvPass(cmd, \"PATH\");\n\n    virCommandAddEnvFormat(cmd, \"LIBVIRT_DEBUG=%d\",\n                           virLogGetDefaultPriority());\n\n    if (virLogGetNbFilters() > 0) {\n        filterstr = virLogGetFilters();\n        if (!filterstr) {\n            virReportOOMError();\n            goto error;\n        }\n\n        virCommandAddEnvPair(cmd, \"LIBVIRT_LOG_FILTERS\", filterstr);\n        VIR_FREE(filterstr);\n    }\n\n    if (cfg->log_libvirtd) {\n        if (virLogGetNbOutputs() > 0) {\n            outputstr = virLogGetOutputs();\n            if (!outputstr) {\n                virReportOOMError();\n                goto error;\n            }\n\n            virCommandAddEnvPair(cmd, \"LIBVIRT_LOG_OUTPUTS\", outputstr);\n            VIR_FREE(outputstr);\n        }\n    } else {\n        virCommandAddEnvFormat(cmd,\n                               \"LIBVIRT_LOG_OUTPUTS=%d:stderr\",\n                               virLogGetDefaultPriority());\n    }\n\n    virCommandAddArgList(cmd, \"--name\", vm->def->name, NULL);\n    for (i = 0; i < nttyFDs; i++) {\n        virCommandAddArg(cmd, \"--console\");\n        virCommandAddArgFormat(cmd, \"%d\", ttyFDs[i]);\n        virCommandPassFD(cmd, ttyFDs[i], 0);\n    }\n\n    for (i = 0; i < nfiles; i++) {\n        virCommandAddArg(cmd, \"--passfd\");\n        virCommandAddArgFormat(cmd, \"%d\", files[i]);\n        virCommandPassFD(cmd, files[i], 0);\n    }\n\n    for (i = 0; i < VIR_LXC_DOMAIN_NAMESPACE_LAST; i++) {\n        if (nsInheritFDs[i] > 0) {\n            char *tmp = NULL;\n            tmp = g_strdup_printf(\"--share-%s\", nsInfoLocal[i]);\n            virCommandAddArg(cmd, tmp);\n            virCommandAddArgFormat(cmd, \"%d\", nsInheritFDs[i]);\n            virCommandPassFD(cmd, nsInheritFDs[i], 0);\n            VIR_FREE(tmp);\n        }\n    }\n\n    virCommandAddArgPair(cmd, \"--security\",\n                         virSecurityManagerGetModel(driver->securityManager));\n\n    virCommandAddArg(cmd, \"--handshake\");\n    virCommandAddArgFormat(cmd, \"%d\", handshakefd);\n\n    for (i = 0; veths && veths[i]; i++)\n        virCommandAddArgList(cmd, \"--veth\", veths[i], NULL);\n\n    virCommandPassFD(cmd, handshakefd, 0);\n    virCommandDaemonize(cmd);\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandSetOutputFD(cmd, logfd);\n    virCommandSetErrorFD(cmd, logfd);\n    /* So we can pause before exec'ing the controller to\n     * write the live domain status XML with the PID */\n    virCommandRequireHandshake(cmd);\n\n cleanup:\n    virObjectUnref(cfg);\n    return cmd;\n error:\n    virCommandFree(cmd);\n    cmd = NULL;\n    goto cleanup;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *nsInfoLocal[VIR_LXC_DOMAIN_NAMESPACE_LAST] = {\n    [VIR_LXC_DOMAIN_NAMESPACE_SHARENET] = \"net\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREIPC] = \"ipc\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREUTS] = \"uts\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRequireHandshake",
          "args": [
            "cmd"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRequireHandshake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2958-2964",
          "snippet": "void virCommandRequireHandshake(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->has_error = ENOSYS;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid virCommandRequireHandshake(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->has_error = ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetErrorFD",
          "args": [
            "cmd",
            "logfd"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetErrorFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1984-1997",
          "snippet": "void\nvirCommandSetErrorFD(virCommandPtr cmd, int *errfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errfdptr = errfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetErrorFD(virCommandPtr cmd, int *errfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errfdptr = errfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputFD",
          "args": [
            "cmd",
            "logfd"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1958-1971",
          "snippet": "void\nvirCommandSetOutputFD(virCommandPtr cmd, int *outfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outfdptr = outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputFD(virCommandPtr cmd, int *outfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outfdptr = outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetPidFile",
          "args": [
            "cmd",
            "pidfile"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetPidFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1086-1094",
          "snippet": "void\nvirCommandSetPidFile(virCommandPtr cmd, const char *pidfile)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    VIR_FREE(cmd->pidfile);\n    cmd->pidfile = g_strdup(pidfile);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetPidFile(virCommandPtr cmd, const char *pidfile)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    VIR_FREE(cmd->pidfile);\n    cmd->pidfile = g_strdup(pidfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandDaemonize",
          "args": [
            "cmd"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandDaemonize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1263-1270",
          "snippet": "void\nvirCommandDaemonize(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_DAEMON;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandDaemonize(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_DAEMON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandPassFD",
          "args": [
            "cmd",
            "handshakefd",
            "0"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandPassFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1024-1049",
          "snippet": "void\nvirCommandPassFD(virCommandPtr cmd, int fd, unsigned int flags)\n{\n    int ret = 0;\n\n    if (!cmd) {\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n\n    if (fd <= STDERR_FILENO) {\n        VIR_DEBUG(\"invalid fd %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        if (!cmd->has_error)\n            cmd->has_error = -1;\n        return;\n    }\n\n    if ((ret = virCommandFDSet(cmd, fd, flags)) != 0) {\n        if (!cmd->has_error)\n            cmd->has_error = ret;\n        VIR_DEBUG(\"cannot preserve %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandPassFD(virCommandPtr cmd, int fd, unsigned int flags)\n{\n    int ret = 0;\n\n    if (!cmd) {\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n\n    if (fd <= STDERR_FILENO) {\n        VIR_DEBUG(\"invalid fd %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        if (!cmd->has_error)\n            cmd->has_error = -1;\n        return;\n    }\n\n    if ((ret = virCommandFDSet(cmd, fd, flags)) != 0) {\n        if (!cmd->has_error)\n            cmd->has_error = ret;\n        VIR_DEBUG(\"cannot preserve %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"--veth\"",
            "veths[i]",
            "NULL"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%d\"",
            "handshakefd"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgPair",
          "args": [
            "cmd",
            "\"--security\"",
            "virSecurityManagerGetModel(driver->securityManager)"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1600-1608",
          "snippet": "void\nvirCommandAddArgPair(virCommandPtr cmd, const char *name, const char *val)\n{\n    if (name == NULL || val == NULL) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n    virCommandAddArgFormat(cmd, \"%s=%s\", name, val);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgPair(virCommandPtr cmd, const char *name, const char *val)\n{\n    if (name == NULL || val == NULL) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n    virCommandAddArgFormat(cmd, \"%s=%s\", name, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetModel",
          "args": [
            "driver->securityManager"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "358-371",
          "snippet": "const char *\nvirSecurityManagerGetModel(virSecurityManagerPtr mgr)\n{\n    if (mgr->drv->getModel) {\n        const char *ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->getModel(mgr);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return NULL;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nconst char *\nvirSecurityManagerGetModel(virSecurityManagerPtr mgr)\n{\n    if (mgr->drv->getModel) {\n        const char *ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->getModel(mgr);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"--share-%s\"",
            "nsInfoLocal[i]"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddEnvFormat",
          "args": [
            "cmd",
            "\"LIBVIRT_LOG_OUTPUTS=%d:stderr\"",
            "virLogGetDefaultPriority()"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddEnvFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1346-1360",
          "snippet": "void\nvirCommandAddEnvFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *env;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    env = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    virCommandAddEnv(cmd, env);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *env;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    env = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    virCommandAddEnv(cmd, env);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogGetDefaultPriority",
          "args": [],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "virLogGetDefaultPriority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1063-1067",
          "snippet": "virLogPriority\nvirLogGetDefaultPriority(void)\n{\n    return virLogDefaultPriority;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLogPriority virLogDefaultPriority = VIR_LOG_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic virLogPriority virLogDefaultPriority = VIR_LOG_DEFAULT;\n\nvirLogPriority\nvirLogGetDefaultPriority(void)\n{\n    return virLogDefaultPriority;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "outputstr"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandAddEnvPair",
          "args": [
            "cmd",
            "\"LIBVIRT_LOG_OUTPUTS\"",
            "outputstr"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddEnvPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1371-1375",
          "snippet": "void\nvirCommandAddEnvPair(virCommandPtr cmd, const char *name, const char *value)\n{\n    virCommandAddEnvFormat(cmd, \"%s=%s\", name, value);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvPair(virCommandPtr cmd, const char *name, const char *value)\n{\n    virCommandAddEnvFormat(cmd, \"%s=%s\", name, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLogGetOutputs",
          "args": [],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "virLogGetOutputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1104-1143",
          "snippet": "char *\nvirLogGetOutputs(void)\n{\n    size_t i;\n    virBuffer outputbuf = VIR_BUFFER_INITIALIZER;\n\n    virLogLock();\n    for (i = 0; i < virLogNbOutputs; i++) {\n        virLogDestination dest = virLogOutputs[i]->dest;\n        if (i)\n            virBufferAddChar(&outputbuf, ' ');\n        switch (dest) {\n            case VIR_LOG_TO_SYSLOG:\n            case VIR_LOG_TO_FILE:\n                virBufferAsprintf(&outputbuf, \"%d:%s:%s\",\n                                  virLogOutputs[i]->priority,\n                                  virLogDestinationTypeToString(dest),\n                                  virLogOutputs[i]->name);\n                break;\n            case VIR_LOG_TO_STDERR:\n            case VIR_LOG_TO_JOURNALD:\n                virBufferAsprintf(&outputbuf, \"%d:%s\",\n                                  virLogOutputs[i]->priority,\n                                  virLogDestinationTypeToString(dest));\n                break;\n            case VIR_LOG_TO_OUTPUT_LAST:\n            default:\n                virReportEnumRangeError(virLogDestination, dest);\n                goto error;\n        }\n    }\n\n    virLogUnlock();\n    return virBufferContentAndReset(&outputbuf);\n\n error:\n    virLogUnlock();\n    virBufferFreeAndReset(&outputbuf);\n    return NULL;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLogOutputPtr *virLogOutputs;",
            "static size_t virLogNbOutputs;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic virLogOutputPtr *virLogOutputs;\nstatic size_t virLogNbOutputs;\n\nchar *\nvirLogGetOutputs(void)\n{\n    size_t i;\n    virBuffer outputbuf = VIR_BUFFER_INITIALIZER;\n\n    virLogLock();\n    for (i = 0; i < virLogNbOutputs; i++) {\n        virLogDestination dest = virLogOutputs[i]->dest;\n        if (i)\n            virBufferAddChar(&outputbuf, ' ');\n        switch (dest) {\n            case VIR_LOG_TO_SYSLOG:\n            case VIR_LOG_TO_FILE:\n                virBufferAsprintf(&outputbuf, \"%d:%s:%s\",\n                                  virLogOutputs[i]->priority,\n                                  virLogDestinationTypeToString(dest),\n                                  virLogOutputs[i]->name);\n                break;\n            case VIR_LOG_TO_STDERR:\n            case VIR_LOG_TO_JOURNALD:\n                virBufferAsprintf(&outputbuf, \"%d:%s\",\n                                  virLogOutputs[i]->priority,\n                                  virLogDestinationTypeToString(dest));\n                break;\n            case VIR_LOG_TO_OUTPUT_LAST:\n            default:\n                virReportEnumRangeError(virLogDestination, dest);\n                goto error;\n        }\n    }\n\n    virLogUnlock();\n    return virBufferContentAndReset(&outputbuf);\n\n error:\n    virLogUnlock();\n    virBufferFreeAndReset(&outputbuf);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogGetNbOutputs",
          "args": [],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "virLogGetNbOutputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1163-1167",
          "snippet": "int\nvirLogGetNbOutputs(void)\n{\n    return virLogNbOutputs;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t virLogNbOutputs;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic size_t virLogNbOutputs;\n\nint\nvirLogGetNbOutputs(void)\n{\n    return virLogNbOutputs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "filterstr"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLogGetFilters",
          "args": [],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "virLogGetFilters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1077-1094",
          "snippet": "char *\nvirLogGetFilters(void)\n{\n    size_t i;\n    virBuffer filterbuf = VIR_BUFFER_INITIALIZER;\n\n    virLogLock();\n    for (i = 0; i < virLogNbFilters; i++) {\n        const char *sep = \":\";\n        virBufferAsprintf(&filterbuf, \"%d%s%s \",\n                          virLogFilters[i]->priority,\n                          sep,\n                          virLogFilters[i]->match);\n    }\n    virLogUnlock();\n\n    return virBufferContentAndReset(&filterbuf);\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLogFilterPtr *virLogFilters;",
            "static size_t virLogNbFilters;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic virLogFilterPtr *virLogFilters;\nstatic size_t virLogNbFilters;\n\nchar *\nvirLogGetFilters(void)\n{\n    size_t i;\n    virBuffer filterbuf = VIR_BUFFER_INITIALIZER;\n\n    virLogLock();\n    for (i = 0; i < virLogNbFilters; i++) {\n        const char *sep = \":\";\n        virBufferAsprintf(&filterbuf, \"%d%s%s \",\n                          virLogFilters[i]->priority,\n                          sep,\n                          virLogFilters[i]->match);\n    }\n    virLogUnlock();\n\n    return virBufferContentAndReset(&filterbuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogGetNbFilters",
          "args": [],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "virLogGetNbFilters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1151-1155",
          "snippet": "int\nvirLogGetNbFilters(void)\n{\n    return virLogNbFilters;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t virLogNbFilters;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic size_t virLogNbFilters;\n\nint\nvirLogGetNbFilters(void)\n{\n    return virLogNbFilters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddEnvPass",
          "args": [
            "cmd",
            "\"PATH\""
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddEnvPass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1434-1444",
          "snippet": "void\nvirCommandAddEnvPass(virCommandPtr cmd, const char *name)\n{\n    const char *value;\n    if (!cmd || cmd->has_error)\n        return;\n\n    value = getenv(name);\n    if (value)\n        virCommandAddEnvPair(cmd, name, value);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvPass(virCommandPtr cmd, const char *name)\n{\n    const char *value;\n    if (!cmd || cmd->has_error)\n        return;\n\n    value = getenv(name);\n    if (value)\n        virCommandAddEnvPair(cmd, name, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "vm->def->emulator"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
          "lines": "279-286",
          "snippet": "virLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver)\n{\n    virLXCDriverConfigPtr cfg;\n    lxcDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    lxcDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"lxc_container.h\"",
            "#include \"configmake.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_conf.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virnodesuspend.h\"\n#include \"lxc_container.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_conf.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver)\n{\n    virLXCDriverConfigPtr cfg;\n    lxcDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    lxcDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic const char *nsInfoLocal[VIR_LXC_DOMAIN_NAMESPACE_LAST] = {\n    [VIR_LXC_DOMAIN_NAMESPACE_SHARENET] = \"net\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREIPC] = \"ipc\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREUTS] = \"uts\",\n};\n\nstatic virCommandPtr\nvirLXCProcessBuildControllerCmd(virLXCDriverPtr driver,\n                                virDomainObjPtr vm,\n                                char **veths,\n                                int *ttyFDs,\n                                size_t nttyFDs,\n                                int *nsInheritFDs,\n                                int *files,\n                                size_t nfiles,\n                                int handshakefd,\n                                int * const logfd,\n                                const char *pidfile)\n{\n    size_t i;\n    char *filterstr;\n    char *outputstr;\n    virCommandPtr cmd;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n\n    cmd = virCommandNew(vm->def->emulator);\n\n    /* The controller may call ip command, so we have to retain PATH. */\n    virCommandAddEnvPass(cmd, \"PATH\");\n\n    virCommandAddEnvFormat(cmd, \"LIBVIRT_DEBUG=%d\",\n                           virLogGetDefaultPriority());\n\n    if (virLogGetNbFilters() > 0) {\n        filterstr = virLogGetFilters();\n        if (!filterstr) {\n            virReportOOMError();\n            goto error;\n        }\n\n        virCommandAddEnvPair(cmd, \"LIBVIRT_LOG_FILTERS\", filterstr);\n        VIR_FREE(filterstr);\n    }\n\n    if (cfg->log_libvirtd) {\n        if (virLogGetNbOutputs() > 0) {\n            outputstr = virLogGetOutputs();\n            if (!outputstr) {\n                virReportOOMError();\n                goto error;\n            }\n\n            virCommandAddEnvPair(cmd, \"LIBVIRT_LOG_OUTPUTS\", outputstr);\n            VIR_FREE(outputstr);\n        }\n    } else {\n        virCommandAddEnvFormat(cmd,\n                               \"LIBVIRT_LOG_OUTPUTS=%d:stderr\",\n                               virLogGetDefaultPriority());\n    }\n\n    virCommandAddArgList(cmd, \"--name\", vm->def->name, NULL);\n    for (i = 0; i < nttyFDs; i++) {\n        virCommandAddArg(cmd, \"--console\");\n        virCommandAddArgFormat(cmd, \"%d\", ttyFDs[i]);\n        virCommandPassFD(cmd, ttyFDs[i], 0);\n    }\n\n    for (i = 0; i < nfiles; i++) {\n        virCommandAddArg(cmd, \"--passfd\");\n        virCommandAddArgFormat(cmd, \"%d\", files[i]);\n        virCommandPassFD(cmd, files[i], 0);\n    }\n\n    for (i = 0; i < VIR_LXC_DOMAIN_NAMESPACE_LAST; i++) {\n        if (nsInheritFDs[i] > 0) {\n            char *tmp = NULL;\n            tmp = g_strdup_printf(\"--share-%s\", nsInfoLocal[i]);\n            virCommandAddArg(cmd, tmp);\n            virCommandAddArgFormat(cmd, \"%d\", nsInheritFDs[i]);\n            virCommandPassFD(cmd, nsInheritFDs[i], 0);\n            VIR_FREE(tmp);\n        }\n    }\n\n    virCommandAddArgPair(cmd, \"--security\",\n                         virSecurityManagerGetModel(driver->securityManager));\n\n    virCommandAddArg(cmd, \"--handshake\");\n    virCommandAddArgFormat(cmd, \"%d\", handshakefd);\n\n    for (i = 0; veths && veths[i]; i++)\n        virCommandAddArgList(cmd, \"--veth\", veths[i], NULL);\n\n    virCommandPassFD(cmd, handshakefd, 0);\n    virCommandDaemonize(cmd);\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandSetOutputFD(cmd, logfd);\n    virCommandSetErrorFD(cmd, logfd);\n    /* So we can pause before exec'ing the controller to\n     * write the live domain status XML with the PID */\n    virCommandRequireHandshake(cmd);\n\n cleanup:\n    virObjectUnref(cfg);\n    return cmd;\n error:\n    virCommandFree(cmd);\n    cmd = NULL;\n    goto cleanup;\n}"
  },
  {
    "function_name": "virLXCProcessStop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "852-915",
    "snippet": "int virLXCProcessStop(virLXCDriverPtr driver,\n                      virDomainObjPtr vm,\n                      virDomainShutoffReason reason)\n{\n    int rc;\n    virLXCDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"Stopping VM name=%s pid=%d reason=%d\",\n              vm->def->name, (int)vm->pid, (int)reason);\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    priv = vm->privateData;\n\n    /* If the LXC domain is suspended we send all processes a SIGKILL\n     * and thaw them. Upon wakeup the process sees the pending signal\n     * and dies immediately. It is guaranteed that priv->cgroup != NULL\n     * here because the domain has aleady been suspended using the\n     * freezer cgroup.\n     */\n    if (reason == VIR_DOMAIN_SHUTOFF_DESTROYED &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED) {\n        if (virCgroupKillRecursive(priv->cgroup, SIGKILL) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to kill all processes\"));\n            return -1;\n        }\n\n        if (virCgroupSetFreezerState(priv->cgroup, \"THAWED\") < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Unable to thaw all processes\"));\n\n            return -1;\n        }\n\n        goto cleanup;\n    }\n\n    if (priv->cgroup) {\n        rc = virCgroupKillPainfully(priv->cgroup);\n        if (rc < 0)\n            return -1;\n        if (rc > 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Some processes refused to die\"));\n            return -1;\n        }\n    } else if (vm->pid > 0) {\n        /* If cgroup doesn't exist, just try cleaning up the\n         * libvirt_lxc process */\n        if (virProcessKillPainfully(vm->pid, true) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Processes %d refused to die\"), (int)vm->pid);\n            return -1;\n        }\n    }\n\n cleanup:\n    virLXCProcessCleanup(driver, vm, reason);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLXCProcessCleanup",
          "args": [
            "driver",
            "vm",
            "reason"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessCleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "158-262",
          "snippet": "static void virLXCProcessCleanup(virLXCDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 virDomainShutoffReason reason)\n{\n    size_t i;\n    virLXCDomainObjPrivatePtr priv = vm->privateData;\n    const virNetDevVPortProfile *vport = NULL;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    virConnectPtr conn = NULL;\n\n    VIR_DEBUG(\"Cleanup VM name=%s pid=%d reason=%d\",\n              vm->def->name, (int)vm->pid, (int)reason);\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                    VIR_HOOK_LXC_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n        VIR_FREE(xml);\n    }\n\n    virSecurityManagerRestoreAllLabel(driver->securityManager,\n                                      vm->def, false, false);\n    virSecurityManagerReleaseLabel(driver->securityManager, vm->def);\n    /* Clear out dynamically assigned labels */\n    if (vm->def->nseclabels &&\n        vm->def->seclabels[0]->type == VIR_DOMAIN_SECLABEL_DYNAMIC) {\n        VIR_FREE(vm->def->seclabels[0]->model);\n        VIR_FREE(vm->def->seclabels[0]->label);\n        VIR_FREE(vm->def->seclabels[0]->imagelabel);\n    }\n\n    /* Stop autodestroy in case guest is restarted */\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           lxcProcessAutoDestroy);\n\n    if (priv->monitor) {\n        virLXCMonitorClose(priv->monitor);\n        virObjectUnref(priv->monitor);\n        priv->monitor = NULL;\n    }\n\n    virPidFileDelete(cfg->stateDir, vm->def->name);\n    lxcProcessRemoveDomainStatus(cfg, vm);\n\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    vm->pid = -1;\n    vm->def->id = -1;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    virLXCDomainReAttachHostDevices(driver, vm->def);\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr iface = vm->def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(iface);\n        if (iface->ifname) {\n            if (vport &&\n                vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH)\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                virDomainNetGetActualBridgeName(iface),\n                                iface->ifname));\n            ignore_value(virNetDevVethDelete(iface->ifname));\n        }\n        if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (conn || (conn = virGetConnectNetwork()))\n                virDomainNetReleaseActualDevice(conn, vm->def, iface);\n            else\n                VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(iface->ifname));\n        }\n    }\n\n    virDomainConfVMNWFilterTeardown(vm);\n\n    if (priv->cgroup) {\n        virCgroupRemove(priv->cgroup);\n        virCgroupFree(&priv->cgroup);\n    }\n\n    /* Get machined to terminate the machine as it may not have cleaned it\n     * properly. See https://bugs.freedesktop.org/show_bug.cgi?id=68370 for\n     * the bug we are working around here.\n     */\n    virCgroupTerminateMachine(priv->machineName);\n    VIR_FREE(priv->machineName);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                    VIR_HOOK_LXC_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(cfg);\n    virObjectUnref(conn);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic void virLXCProcessCleanup(virLXCDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 virDomainShutoffReason reason)\n{\n    size_t i;\n    virLXCDomainObjPrivatePtr priv = vm->privateData;\n    const virNetDevVPortProfile *vport = NULL;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    virConnectPtr conn = NULL;\n\n    VIR_DEBUG(\"Cleanup VM name=%s pid=%d reason=%d\",\n              vm->def->name, (int)vm->pid, (int)reason);\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                    VIR_HOOK_LXC_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n        VIR_FREE(xml);\n    }\n\n    virSecurityManagerRestoreAllLabel(driver->securityManager,\n                                      vm->def, false, false);\n    virSecurityManagerReleaseLabel(driver->securityManager, vm->def);\n    /* Clear out dynamically assigned labels */\n    if (vm->def->nseclabels &&\n        vm->def->seclabels[0]->type == VIR_DOMAIN_SECLABEL_DYNAMIC) {\n        VIR_FREE(vm->def->seclabels[0]->model);\n        VIR_FREE(vm->def->seclabels[0]->label);\n        VIR_FREE(vm->def->seclabels[0]->imagelabel);\n    }\n\n    /* Stop autodestroy in case guest is restarted */\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           lxcProcessAutoDestroy);\n\n    if (priv->monitor) {\n        virLXCMonitorClose(priv->monitor);\n        virObjectUnref(priv->monitor);\n        priv->monitor = NULL;\n    }\n\n    virPidFileDelete(cfg->stateDir, vm->def->name);\n    lxcProcessRemoveDomainStatus(cfg, vm);\n\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    vm->pid = -1;\n    vm->def->id = -1;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    virLXCDomainReAttachHostDevices(driver, vm->def);\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr iface = vm->def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(iface);\n        if (iface->ifname) {\n            if (vport &&\n                vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH)\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                virDomainNetGetActualBridgeName(iface),\n                                iface->ifname));\n            ignore_value(virNetDevVethDelete(iface->ifname));\n        }\n        if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (conn || (conn = virGetConnectNetwork()))\n                virDomainNetReleaseActualDevice(conn, vm->def, iface);\n            else\n                VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(iface->ifname));\n        }\n    }\n\n    virDomainConfVMNWFilterTeardown(vm);\n\n    if (priv->cgroup) {\n        virCgroupRemove(priv->cgroup);\n        virCgroupFree(&priv->cgroup);\n    }\n\n    /* Get machined to terminate the machine as it may not have cleaned it\n     * properly. See https://bugs.freedesktop.org/show_bug.cgi?id=68370 for\n     * the bug we are working around here.\n     */\n    virCgroupTerminateMachine(priv->machineName);\n    VIR_FREE(priv->machineName);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                    VIR_HOOK_LXC_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(cfg);\n    virObjectUnref(conn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Processes %d refused to die\")",
            "(int)vm->pid"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Processes %d refused to die\""
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "userns_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2329-2332",
          "snippet": "static int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessKillPainfully",
          "args": [
            "vm->pid",
            "true"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessKillPainfully",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "437-440",
          "snippet": "int virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Some processes refused to die\")"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCgroupKillPainfully",
          "args": [
            "priv->cgroup"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "virCgroupKillPainfully",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircgroup.c",
          "lines": "3397-3403",
          "snippet": "int\nvirCgroupKillPainfully(virCgroupPtr group G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircgroupbackend.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"vircgrouppriv.h\"",
            "# include <unistd.h>",
            "# include <dirent.h>",
            "# include <signal.h>",
            "# include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <sys/stat.h>",
            "# include <fcntl.h>",
            "# include <sys/mount.h>",
            "# include <mntent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virhostcpu.h\"\n#include \"virtypedparam.h\"\n#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhashcode.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircgroupbackend.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"vircgrouppriv.h\"\n# include <unistd.h>\n# include <dirent.h>\n# include <signal.h>\n# include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n# include <sys/mount.h>\n# include <mntent.h>\n#include <config.h>\n\nint\nvirCgroupKillPainfully(virCgroupPtr group G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Unable to thaw all processes\")"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCgroupSetFreezerState",
          "args": [
            "priv->cgroup",
            "\"THAWED\""
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "virCgroupSetFreezerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircgroup.c",
          "lines": "3458-3465",
          "snippet": "int\nvirCgroupSetFreezerState(virCgroupPtr group G_GNUC_UNUSED,\n                         const char *state G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircgroupbackend.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"vircgrouppriv.h\"",
            "# include <unistd.h>",
            "# include <dirent.h>",
            "# include <signal.h>",
            "# include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <sys/stat.h>",
            "# include <fcntl.h>",
            "# include <sys/mount.h>",
            "# include <mntent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virhostcpu.h\"\n#include \"virtypedparam.h\"\n#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhashcode.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircgroupbackend.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"vircgrouppriv.h\"\n# include <unistd.h>\n# include <dirent.h>\n# include <signal.h>\n# include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n# include <sys/mount.h>\n# include <mntent.h>\n#include <config.h>\n\nint\nvirCgroupSetFreezerState(virCgroupPtr group G_GNUC_UNUSED,\n                         const char *state G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to kill all processes\")"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCgroupKillRecursive",
          "args": [
            "priv->cgroup",
            "SIGKILL"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "virCgroupKillRecursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircgroup.c",
          "lines": "3387-3394",
          "snippet": "int\nvirCgroupKillRecursive(virCgroupPtr group G_GNUC_UNUSED,\n                       int signum G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircgroupbackend.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"vircgrouppriv.h\"",
            "# include <unistd.h>",
            "# include <dirent.h>",
            "# include <signal.h>",
            "# include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <sys/stat.h>",
            "# include <fcntl.h>",
            "# include <sys/mount.h>",
            "# include <mntent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virhostcpu.h\"\n#include \"virtypedparam.h\"\n#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhashcode.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircgroupbackend.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"vircgrouppriv.h\"\n# include <unistd.h>\n# include <dirent.h>\n# include <signal.h>\n# include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n# include <sys/mount.h>\n# include <mntent.h>\n#include <config.h>\n\nint\nvirCgroupKillRecursive(virCgroupPtr group G_GNUC_UNUSED,\n                       int signum G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "NULL"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"VM '%s' not active\"",
            "vm->def->name"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjIsActive",
          "args": [
            "vm"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.h",
          "lines": "2845-2849",
          "snippet": "static inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virresctrl.h\"",
            "#include \"virsavecookie.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virperf.h\"",
            "#include \"virgic.h\"",
            "#include \"virprocess.h\"",
            "#include \"virseclabel.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virbitmap.h\"",
            "#include \"device_conf.h\"",
            "#include \"virobject.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"numa_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virthread.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"capabilities.h\"",
            "#include \"virconftypes.h\"",
            "#include \"internal.h\"",
            "#include <libxml/xpath.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parser.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void virDomainMemoryDefFree(virDomainMemoryDefPtr def);",
            "void virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);",
            "unsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);",
            "unsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);",
            "bool virDomainDefHasMemoryHotplug(const virDomainDef *def);",
            "int virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);",
            "bool virDomainDefHasUSB(const virDomainDef *def);",
            "int virDomainObjCheckActive(virDomainObjPtr dom);",
            "bool virDomainDefHasVcpusOffline(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpusMax(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpus(const virDomainDef *def);",
            "virBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);",
            "void virDomainDefVcpuOrderClear(virDomainDefPtr def);",
            "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);",
            "void virDomainInputDefFree(virDomainInputDefPtr def);",
            "void virDomainDiskDefFree(virDomainDiskDefPtr def);",
            "void virDomainLeaseDefFree(virDomainLeaseDefPtr def);",
            "int virDomainDiskGetType(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetSource(virDomainDiskDef const *def);",
            "void virDomainDiskEmptySource(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetDriver(const virDomainDiskDef *def);",
            "int virDomainDiskGetFormat(virDomainDiskDefPtr def);",
            "void virDomainControllerDefFree(virDomainControllerDefPtr def);",
            "void virDomainFSDefFree(virDomainFSDefPtr def);",
            "void virDomainActualNetDefFree(virDomainActualNetDefPtr def);",
            "void virDomainNetDefClear(virDomainNetDefPtr def);",
            "void virDomainNetDefFree(virDomainNetDefPtr def);",
            "void virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);",
            "void virDomainChrDefFree(virDomainChrDefPtr def);",
            "void virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);",
            "void virDomainSoundDefFree(virDomainSoundDefPtr def);",
            "void virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);",
            "void virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);",
            "void virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);",
            "void virDomainVideoDefFree(virDomainVideoDefPtr def);",
            "void virDomainVideoDefClear(virDomainVideoDefPtr def);",
            "void virDomainHostdevDefClear(virDomainHostdevDefPtr def);",
            "void virDomainHostdevDefFree(virDomainHostdevDefPtr def);",
            "void virDomainHubDefFree(virDomainHubDefPtr def);",
            "void virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);",
            "void virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);",
            "void virDomainShmemDefFree(virDomainShmemDefPtr def);",
            "void virDomainDeviceDefFree(virDomainDeviceDefPtr def);",
            "void virDomainTPMDefFree(virDomainTPMDefPtr def);",
            "void virDomainRNGDefFree(virDomainRNGDefPtr def);",
            "int virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);",
            "int virDomainVideoDefaultType(const virDomainDef *def);",
            "void virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);",
            "int virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);",
            "bool\nvirDomainDefHasManagedPR(const virDomainDef *def);",
            "bool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);",
            "bool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);",
            "bool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virresctrl.h\"\n#include \"virsavecookie.h\"\n#include \"virtypedparam.h\"\n#include \"virperf.h\"\n#include \"virgic.h\"\n#include \"virprocess.h\"\n#include \"virseclabel.h\"\n#include \"virstoragefile.h\"\n#include \"virbitmap.h\"\n#include \"device_conf.h\"\n#include \"virobject.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevvlan.h\"\n#include \"virnetdevbandwidth.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virsysinfo.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"numa_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"networkcommon_conf.h\"\n#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virthread.h\"\n#include \"cpu_conf.h\"\n#include \"virstorageencryption.h\"\n#include \"capabilities.h\"\n#include \"virconftypes.h\"\n#include \"internal.h\"\n#include <libxml/xpath.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n\nvoid virDomainMemoryDefFree(virDomainMemoryDefPtr def);\nvoid virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);\nunsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);\nunsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);\nbool virDomainDefHasMemoryHotplug(const virDomainDef *def);\nint virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);\nbool virDomainDefHasUSB(const virDomainDef *def);\nint virDomainObjCheckActive(virDomainObjPtr dom);\nbool virDomainDefHasVcpusOffline(const virDomainDef *def);\nunsigned int virDomainDefGetVcpusMax(const virDomainDef *def);\nunsigned int virDomainDefGetVcpus(const virDomainDef *def);\nvirBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);\nvoid virDomainDefVcpuOrderClear(virDomainDefPtr def);\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);\nvoid virDomainInputDefFree(virDomainInputDefPtr def);\nvoid virDomainDiskDefFree(virDomainDiskDefPtr def);\nvoid virDomainLeaseDefFree(virDomainLeaseDefPtr def);\nint virDomainDiskGetType(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetSource(virDomainDiskDef const *def);\nvoid virDomainDiskEmptySource(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetDriver(const virDomainDiskDef *def);\nint virDomainDiskGetFormat(virDomainDiskDefPtr def);\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def);\nvoid virDomainFSDefFree(virDomainFSDefPtr def);\nvoid virDomainActualNetDefFree(virDomainActualNetDefPtr def);\nvoid virDomainNetDefClear(virDomainNetDefPtr def);\nvoid virDomainNetDefFree(virDomainNetDefPtr def);\nvoid virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);\nvoid virDomainChrDefFree(virDomainChrDefPtr def);\nvoid virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def);\nvoid virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);\nvoid virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);\nvoid virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def);\nvoid virDomainVideoDefClear(virDomainVideoDefPtr def);\nvoid virDomainHostdevDefClear(virDomainHostdevDefPtr def);\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def);\nvoid virDomainHubDefFree(virDomainHubDefPtr def);\nvoid virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);\nvoid virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);\nvoid virDomainShmemDefFree(virDomainShmemDefPtr def);\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def);\nvoid virDomainTPMDefFree(virDomainTPMDefPtr def);\nvoid virDomainRNGDefFree(virDomainRNGDefPtr def);\nint virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);\nint virDomainVideoDefaultType(const virDomainDef *def);\nvoid virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);\nint virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);\nbool\nvirDomainDefHasManagedPR(const virDomainDef *def);\nbool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);\nbool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);\nbool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);\n\nstatic inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Stopping VM name=%s pid=%d reason=%d\"",
            "vm->def->name",
            "(int)vm->pid",
            "(int)reason"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virLXCProcessStop(virLXCDriverPtr driver,\n                      virDomainObjPtr vm,\n                      virDomainShutoffReason reason)\n{\n    int rc;\n    virLXCDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"Stopping VM name=%s pid=%d reason=%d\",\n              vm->def->name, (int)vm->pid, (int)reason);\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    priv = vm->privateData;\n\n    /* If the LXC domain is suspended we send all processes a SIGKILL\n     * and thaw them. Upon wakeup the process sees the pending signal\n     * and dies immediately. It is guaranteed that priv->cgroup != NULL\n     * here because the domain has aleady been suspended using the\n     * freezer cgroup.\n     */\n    if (reason == VIR_DOMAIN_SHUTOFF_DESTROYED &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED) {\n        if (virCgroupKillRecursive(priv->cgroup, SIGKILL) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to kill all processes\"));\n            return -1;\n        }\n\n        if (virCgroupSetFreezerState(priv->cgroup, \"THAWED\") < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Unable to thaw all processes\"));\n\n            return -1;\n        }\n\n        goto cleanup;\n    }\n\n    if (priv->cgroup) {\n        rc = virCgroupKillPainfully(priv->cgroup);\n        if (rc < 0)\n            return -1;\n        if (rc > 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Some processes refused to die\"));\n            return -1;\n        }\n    } else if (vm->pid > 0) {\n        /* If cgroup doesn't exist, just try cleaning up the\n         * libvirt_lxc process */\n        if (virProcessKillPainfully(vm->pid, true) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Processes %d refused to die\"), (int)vm->pid);\n            return -1;\n        }\n    }\n\n cleanup:\n    virLXCProcessCleanup(driver, vm, reason);\n\n    return 0;\n}"
  },
  {
    "function_name": "virLXCProcessConnectMonitor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "819-849",
    "snippet": "static virLXCMonitorPtr virLXCProcessConnectMonitor(virLXCDriverPtr driver,\n                                                    virDomainObjPtr vm)\n{\n    virLXCMonitorPtr monitor = NULL;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n\n    if (virSecurityManagerSetSocketLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n\n    /* Hold an extra reference because we can't allow 'vm' to be\n     * deleted while the monitor is active. This will be unreffed\n     * during EOFNotify processing. */\n    virObjectRef(vm);\n\n    monitor = virLXCMonitorNew(vm, cfg->stateDir, &monitorCallbacks);\n\n    if (monitor == NULL)\n        virObjectUnref(vm);\n\n    if (virSecurityManagerClearSocketLabel(driver->securityManager, vm->def) < 0) {\n        if (monitor) {\n            virObjectUnref(monitor);\n            monitor = NULL;\n        }\n        goto cleanup;\n    }\n\n cleanup:\n    virObjectUnref(cfg);\n    return monitor;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virLXCMonitorCallbacks monitorCallbacks = {\n    .eofNotify = virLXCProcessMonitorEOFNotify,\n    .exitNotify = virLXCProcessMonitorExitNotify,\n    .initNotify = virLXCProcessMonitorInitNotify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerClearSocketLabel",
          "args": [
            "driver->securityManager",
            "vm->def"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerClearSocketLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "515-529",
          "snippet": "int\nvirSecurityManagerClearSocketLabel(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr vm)\n{\n    if (mgr->drv->domainClearSecuritySocketLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainClearSecuritySocketLabel(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerClearSocketLabel(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr vm)\n{\n    if (mgr->drv->domainClearSecuritySocketLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainClearSecuritySocketLabel(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCMonitorNew",
          "args": [
            "vm",
            "cfg->stateDir",
            "&monitorCallbacks"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCMonitorNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_monitor.c",
          "lines": "141-191",
          "snippet": "virLXCMonitorPtr virLXCMonitorNew(virDomainObjPtr vm,\n                                  const char *socketdir,\n                                  virLXCMonitorCallbacksPtr cb)\n{\n    virLXCMonitorPtr mon;\n    char *sockpath = NULL;\n\n    if (virLXCMonitorInitialize() < 0)\n        return NULL;\n\n    if (!(mon = virObjectLockableNew(virLXCMonitorClass)))\n        return NULL;\n\n    sockpath = g_strdup_printf(\"%s/%s.sock\", socketdir, vm->def->name);\n\n    if (!(mon->client = virNetClientNewUNIX(sockpath, false, NULL)))\n        goto error;\n\n    if (virNetClientRegisterAsyncIO(mon->client) < 0)\n        goto error;\n\n    /* avoid deadlock by making this call before assigning virLXCMonitorEvents */\n    virNetClientSetCloseCallback(mon->client, virLXCMonitorEOFNotify, mon,\n                                 virLXCMonitorCloseFreeCallback);\n\n    /* close callback now has its own reference */\n    virObjectRef(mon);\n\n    if (!(mon->program = virNetClientProgramNew(VIR_LXC_MONITOR_PROGRAM,\n                                                VIR_LXC_MONITOR_PROGRAM_VERSION,\n                                                virLXCMonitorEvents,\n                                                G_N_ELEMENTS(virLXCMonitorEvents),\n                                                mon)))\n        goto error;\n\n    if (virNetClientAddProgram(mon->client,\n                               mon->program) < 0)\n        goto error;\n\n    mon->vm = virObjectRef(vm);\n    memcpy(&mon->cb, cb, sizeof(mon->cb));\n\n cleanup:\n    VIR_FREE(sockpath);\n    return mon;\n\n error:\n    virObjectUnref(mon);\n    mon = NULL;\n    goto cleanup;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_monitor_dispatch.h\"",
            "#include \"lxc_conf.h\"",
            "#include \"lxc_monitor.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virLXCMonitorClass;",
            "static virNetClientProgramEvent virLXCMonitorEvents[] = {\n    { VIR_LXC_MONITOR_PROC_EXIT_EVENT,\n      virLXCMonitorHandleEventExit,\n      sizeof(virLXCMonitorExitEventMsg),\n      (xdrproc_t)xdr_virLXCMonitorExitEventMsg },\n    { VIR_LXC_MONITOR_PROC_INIT_EVENT,\n      virLXCMonitorHandleEventInit,\n      sizeof(virLXCMonitorInitEventMsg),\n      (xdrproc_t)xdr_virLXCMonitorInitEventMsg },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"lxc_monitor_dispatch.h\"\n#include \"lxc_conf.h\"\n#include \"lxc_monitor.h\"\n#include <config.h>\n\nstatic virClassPtr virLXCMonitorClass;\nstatic virNetClientProgramEvent virLXCMonitorEvents[] = {\n    { VIR_LXC_MONITOR_PROC_EXIT_EVENT,\n      virLXCMonitorHandleEventExit,\n      sizeof(virLXCMonitorExitEventMsg),\n      (xdrproc_t)xdr_virLXCMonitorExitEventMsg },\n    { VIR_LXC_MONITOR_PROC_INIT_EVENT,\n      virLXCMonitorHandleEventInit,\n      sizeof(virLXCMonitorInitEventMsg),\n      (xdrproc_t)xdr_virLXCMonitorInitEventMsg },\n};\n\nvirLXCMonitorPtr virLXCMonitorNew(virDomainObjPtr vm,\n                                  const char *socketdir,\n                                  virLXCMonitorCallbacksPtr cb)\n{\n    virLXCMonitorPtr mon;\n    char *sockpath = NULL;\n\n    if (virLXCMonitorInitialize() < 0)\n        return NULL;\n\n    if (!(mon = virObjectLockableNew(virLXCMonitorClass)))\n        return NULL;\n\n    sockpath = g_strdup_printf(\"%s/%s.sock\", socketdir, vm->def->name);\n\n    if (!(mon->client = virNetClientNewUNIX(sockpath, false, NULL)))\n        goto error;\n\n    if (virNetClientRegisterAsyncIO(mon->client) < 0)\n        goto error;\n\n    /* avoid deadlock by making this call before assigning virLXCMonitorEvents */\n    virNetClientSetCloseCallback(mon->client, virLXCMonitorEOFNotify, mon,\n                                 virLXCMonitorCloseFreeCallback);\n\n    /* close callback now has its own reference */\n    virObjectRef(mon);\n\n    if (!(mon->program = virNetClientProgramNew(VIR_LXC_MONITOR_PROGRAM,\n                                                VIR_LXC_MONITOR_PROGRAM_VERSION,\n                                                virLXCMonitorEvents,\n                                                G_N_ELEMENTS(virLXCMonitorEvents),\n                                                mon)))\n        goto error;\n\n    if (virNetClientAddProgram(mon->client,\n                               mon->program) < 0)\n        goto error;\n\n    mon->vm = virObjectRef(vm);\n    memcpy(&mon->cb, cb, sizeof(mon->cb));\n\n cleanup:\n    VIR_FREE(sockpath);\n    return mon;\n\n error:\n    virObjectUnref(mon);\n    mon = NULL;\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "vm"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerSetSocketLabel",
          "args": [
            "driver->securityManager",
            "vm->def"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerSetSocketLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "498-512",
          "snippet": "int\nvirSecurityManagerSetSocketLabel(virSecurityManagerPtr mgr,\n                                 virDomainDefPtr vm)\n{\n    if (mgr->drv->domainSetSecuritySocketLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecuritySocketLabel(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerSetSocketLabel(virSecurityManagerPtr mgr,\n                                 virDomainDefPtr vm)\n{\n    if (mgr->drv->domainSetSecuritySocketLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecuritySocketLabel(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
          "lines": "279-286",
          "snippet": "virLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver)\n{\n    virLXCDriverConfigPtr cfg;\n    lxcDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    lxcDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"lxc_container.h\"",
            "#include \"configmake.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_conf.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virnodesuspend.h\"\n#include \"lxc_container.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_conf.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver)\n{\n    virLXCDriverConfigPtr cfg;\n    lxcDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    lxcDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virLXCMonitorCallbacks monitorCallbacks = {\n    .eofNotify = virLXCProcessMonitorEOFNotify,\n    .exitNotify = virLXCProcessMonitorExitNotify,\n    .initNotify = virLXCProcessMonitorInitNotify,\n};\n\nstatic virLXCMonitorPtr virLXCProcessConnectMonitor(virLXCDriverPtr driver,\n                                                    virDomainObjPtr vm)\n{\n    virLXCMonitorPtr monitor = NULL;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n\n    if (virSecurityManagerSetSocketLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n\n    /* Hold an extra reference because we can't allow 'vm' to be\n     * deleted while the monitor is active. This will be unreffed\n     * during EOFNotify processing. */\n    virObjectRef(vm);\n\n    monitor = virLXCMonitorNew(vm, cfg->stateDir, &monitorCallbacks);\n\n    if (monitor == NULL)\n        virObjectUnref(vm);\n\n    if (virSecurityManagerClearSocketLabel(driver->securityManager, vm->def) < 0) {\n        if (monitor) {\n            virObjectUnref(monitor);\n            monitor = NULL;\n        }\n        goto cleanup;\n    }\n\n cleanup:\n    virObjectUnref(cfg);\n    return monitor;\n}"
  },
  {
    "function_name": "virLXCProcessMonitorInitNotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "783-810",
    "snippet": "static void virLXCProcessMonitorInitNotify(virLXCMonitorPtr mon G_GNUC_UNUSED,\n                                           pid_t initpid,\n                                           virDomainObjPtr vm)\n{\n    virLXCDriverPtr driver = lxc_driver;\n    virLXCDomainObjPrivatePtr priv;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    ino_t inode = 0;\n\n    virObjectLock(vm);\n\n    priv = vm->privateData;\n    priv->initpid = initpid;\n\n    if (virLXCProcessGetNsInode(initpid, \"pid\", &inode) < 0) {\n        VIR_WARN(\"Cannot obtain pid NS inode for %lld: %s\",\n                 (long long)initpid,\n                 virGetLastErrorMessage());\n        virResetLastError();\n    }\n    virDomainAuditInit(vm, initpid, inode);\n\n    if (virDomainObjSave(vm, lxc_driver->xmlopt, cfg->stateDir) < 0)\n        VIR_WARN(\"Cannot update XML with PID for LXC %s\", vm->def->name);\n\n    virObjectUnlock(vm);\n    virObjectUnref(cfg);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern virLXCDriverPtr lxc_driver;",
      "extern virLXCDriverPtr lxc_driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "vm"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Cannot update XML with PID for LXC %s\"",
            "vm->def->name"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjSave",
          "args": [
            "vm",
            "lxc_driver->xmlopt",
            "cfg->stateDir"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29706-29723",
          "snippet": "int\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjDispose(void *obj);",
            "static void virDomainXMLOptionDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virDomainObjDispose(void *obj);\nstatic void virDomainXMLOptionDispose(void *obj);\n\nint\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainAuditInit",
          "args": [
            "vm",
            "initpid",
            "inode"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainAuditInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_audit.c",
          "lines": "842-864",
          "snippet": "void\nvirDomainAuditInit(virDomainObjPtr vm,\n                   pid_t initpid,\n                   ino_t pidns)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *vmname;\n    const char *virt = virDomainAuditGetVirtType(vm->def);\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n\n    if (!(vmname = virAuditEncode(\"vm\", vm->def->name))) {\n        VIR_WARN(\"OOM while encoding audit message\");\n        return;\n    }\n\n    VIR_AUDIT(VIR_AUDIT_RECORD_MACHINE_CONTROL, true,\n              \"virt=%s op=init %s uuid=%s vm-pid=%lld init-pid=%lld pid-ns=%lld\",\n              virt, vmname, uuidstr, (long long)vm->pid, (long long)initpid,\n              (long long)pidns);\n\n    VIR_FREE(vmname);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"viruuid.h\"",
            "#include \"viraudit.h\"",
            "#include \"domain_audit.h\"",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"viruuid.h\"\n#include \"viraudit.h\"\n#include \"domain_audit.h\"\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid\nvirDomainAuditInit(virDomainObjPtr vm,\n                   pid_t initpid,\n                   ino_t pidns)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *vmname;\n    const char *virt = virDomainAuditGetVirtType(vm->def);\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n\n    if (!(vmname = virAuditEncode(\"vm\", vm->def->name))) {\n        VIR_WARN(\"OOM while encoding audit message\");\n        return;\n    }\n\n    VIR_AUDIT(VIR_AUDIT_RECORD_MACHINE_CONTROL, true,\n              \"virt=%s op=init %s uuid=%s vm-pid=%lld init-pid=%lld pid-ns=%lld\",\n              virt, vmname, uuidstr, (long long)vm->pid, (long long)initpid,\n              (long long)pidns);\n\n    VIR_FREE(vmname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Cannot obtain pid NS inode for %lld: %s\"",
            "(long long)initpid",
            "virGetLastErrorMessage()"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCProcessGetNsInode",
          "args": [
            "initpid",
            "\"pid\"",
            "&inode"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessGetNsInode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "755-778",
          "snippet": "static int\nvirLXCProcessGetNsInode(pid_t pid,\n                        const char *nsname,\n                        ino_t *inode)\n{\n    char *path = NULL;\n    struct stat sb;\n    int ret = -1;\n\n    path = g_strdup_printf(\"/proc/%lld/ns/%s\", (long long)pid, nsname);\n\n    if (stat(path, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to stat %s\"), path);\n        goto cleanup;\n    }\n\n    *inode = sb.st_ino;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(path);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirLXCProcessGetNsInode(pid_t pid,\n                        const char *nsname,\n                        ino_t *inode)\n{\n    char *path = NULL;\n    struct stat sb;\n    int ret = -1;\n\n    path = g_strdup_printf(\"/proc/%lld/ns/%s\", (long long)pid, nsname);\n\n    if (stat(path, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to stat %s\"), path);\n        goto cleanup;\n    }\n\n    *inode = sb.st_ino;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(path);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "vm"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
          "lines": "279-286",
          "snippet": "virLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver)\n{\n    virLXCDriverConfigPtr cfg;\n    lxcDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    lxcDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"lxc_container.h\"",
            "#include \"configmake.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_conf.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virnodesuspend.h\"\n#include \"lxc_container.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_conf.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver)\n{\n    virLXCDriverConfigPtr cfg;\n    lxcDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    lxcDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nextern virLXCDriverPtr lxc_driver;\nextern virLXCDriverPtr lxc_driver;\n\nstatic void virLXCProcessMonitorInitNotify(virLXCMonitorPtr mon G_GNUC_UNUSED,\n                                           pid_t initpid,\n                                           virDomainObjPtr vm)\n{\n    virLXCDriverPtr driver = lxc_driver;\n    virLXCDomainObjPrivatePtr priv;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    ino_t inode = 0;\n\n    virObjectLock(vm);\n\n    priv = vm->privateData;\n    priv->initpid = initpid;\n\n    if (virLXCProcessGetNsInode(initpid, \"pid\", &inode) < 0) {\n        VIR_WARN(\"Cannot obtain pid NS inode for %lld: %s\",\n                 (long long)initpid,\n                 virGetLastErrorMessage());\n        virResetLastError();\n    }\n    virDomainAuditInit(vm, initpid, inode);\n\n    if (virDomainObjSave(vm, lxc_driver->xmlopt, cfg->stateDir) < 0)\n        VIR_WARN(\"Cannot update XML with PID for LXC %s\", vm->def->name);\n\n    virObjectUnlock(vm);\n    virObjectUnref(cfg);\n}"
  },
  {
    "function_name": "virLXCProcessGetNsInode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "755-778",
    "snippet": "static int\nvirLXCProcessGetNsInode(pid_t pid,\n                        const char *nsname,\n                        ino_t *inode)\n{\n    char *path = NULL;\n    struct stat sb;\n    int ret = -1;\n\n    path = g_strdup_printf(\"/proc/%lld/ns/%s\", (long long)pid, nsname);\n\n    if (stat(path, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to stat %s\"), path);\n        goto cleanup;\n    }\n\n    *inode = sb.st_ino;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(path);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to stat %s\")",
            "path"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to stat %s\""
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "userns_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2329-2332",
          "snippet": "static int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&sb"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "profile_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_apparmor.c",
          "lines": "70-108",
          "snippet": "static int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virmdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viruuid.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"internal.h\"",
            "#include <wait.h>",
            "#include <unistd.h>",
            "#include <sys/apparmor.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virmdev.h\"\n#include \"virscsi.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virscsivhost.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viruuid.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"security_apparmor.h\"\n#include \"internal.h\"\n#include <wait.h>\n#include <unistd.h>\n#include <sys/apparmor.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"/proc/%lld/ns/%s\"",
            "(long long)pid",
            "nsname"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirLXCProcessGetNsInode(pid_t pid,\n                        const char *nsname,\n                        ino_t *inode)\n{\n    char *path = NULL;\n    struct stat sb;\n    int ret = -1;\n\n    path = g_strdup_printf(\"/proc/%lld/ns/%s\", (long long)pid, nsname);\n\n    if (stat(path, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to stat %s\"), path);\n        goto cleanup;\n    }\n\n    *inode = sb.st_ino;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(path);\n    return ret;\n}"
  },
  {
    "function_name": "virLXCProcessMonitorExitNotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "726-753",
    "snippet": "static void virLXCProcessMonitorExitNotify(virLXCMonitorPtr mon G_GNUC_UNUSED,\n                                           virLXCMonitorExitStatus status,\n                                           virDomainObjPtr vm)\n{\n    virLXCDomainObjPrivatePtr priv = vm->privateData;\n\n    virObjectLock(vm);\n\n    switch (status) {\n    case VIR_LXC_MONITOR_EXIT_STATUS_SHUTDOWN:\n        priv->stopReason = VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN;\n        break;\n    case VIR_LXC_MONITOR_EXIT_STATUS_ERROR:\n        priv->stopReason = VIR_DOMAIN_EVENT_STOPPED_FAILED;\n        break;\n    case VIR_LXC_MONITOR_EXIT_STATUS_REBOOT:\n        priv->stopReason = VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN;\n        priv->wantReboot = true;\n        break;\n    default:\n        priv->stopReason = VIR_DOMAIN_EVENT_STOPPED_FAILED;\n        break;\n    }\n    VIR_DEBUG(\"Domain shutoff reason %d (from status %d)\",\n              priv->stopReason, status);\n\n    virObjectUnlock(vm);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "vm"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Domain shutoff reason %d (from status %d)\"",
            "priv->stopReason",
            "status"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "vm"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic void virLXCProcessMonitorExitNotify(virLXCMonitorPtr mon G_GNUC_UNUSED,\n                                           virLXCMonitorExitStatus status,\n                                           virDomainObjPtr vm)\n{\n    virLXCDomainObjPrivatePtr priv = vm->privateData;\n\n    virObjectLock(vm);\n\n    switch (status) {\n    case VIR_LXC_MONITOR_EXIT_STATUS_SHUTDOWN:\n        priv->stopReason = VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN;\n        break;\n    case VIR_LXC_MONITOR_EXIT_STATUS_ERROR:\n        priv->stopReason = VIR_DOMAIN_EVENT_STOPPED_FAILED;\n        break;\n    case VIR_LXC_MONITOR_EXIT_STATUS_REBOOT:\n        priv->stopReason = VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN;\n        priv->wantReboot = true;\n        break;\n    default:\n        priv->stopReason = VIR_DOMAIN_EVENT_STOPPED_FAILED;\n        break;\n    }\n    VIR_DEBUG(\"Domain shutoff reason %d (from status %d)\",\n              priv->stopReason, status);\n\n    virObjectUnlock(vm);\n}"
  },
  {
    "function_name": "virLXCProcessMonitorEOFNotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "679-724",
    "snippet": "static void virLXCProcessMonitorEOFNotify(virLXCMonitorPtr mon,\n                                          virDomainObjPtr vm)\n{\n    virLXCDriverPtr driver = lxc_driver;\n    virObjectEventPtr event = NULL;\n    virLXCDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"mon=%p vm=%p\", mon, vm);\n\n    virObjectLock(vm);\n\n    priv = vm->privateData;\n    virLXCProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n    if (!priv->wantReboot) {\n        virLXCProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n        if (!priv->doneStopEvent) {\n            event = virDomainEventLifecycleNewFromObj(vm,\n                                             VIR_DOMAIN_EVENT_STOPPED,\n                                             priv->stopReason);\n            virDomainAuditStop(vm, \"shutdown\");\n        } else {\n            VIR_DEBUG(\"Stop event has already been sent\");\n        }\n        if (!vm->persistent)\n            virDomainObjListRemove(driver->domains, vm);\n    } else {\n        int ret = virLXCProcessReboot(driver, vm);\n        virDomainAuditStop(vm, \"reboot\");\n        virDomainAuditStart(vm, \"reboot\", ret == 0);\n        if (ret == 0) {\n            event = virDomainEventRebootNewFromObj(vm);\n        } else {\n            event = virDomainEventLifecycleNewFromObj(vm,\n                                             VIR_DOMAIN_EVENT_STOPPED,\n                                             priv->stopReason);\n            if (!vm->persistent)\n                virDomainObjListRemove(driver->domains, vm);\n        }\n    }\n\n    /* NB: virLXCProcessConnectMonitor will perform the virObjectRef(vm)\n     * before adding monitorCallbacks. Since we are now done with the @vm\n     * we can Unref/Unlock */\n    virDomainObjEndAPI(&vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern virLXCDriverPtr lxc_driver;",
      "extern virLXCDriverPtr lxc_driver;",
      "static virLXCMonitorCallbacks monitorCallbacks = {\n    .eofNotify = virLXCProcessMonitorEOFNotify,\n    .exitNotify = virLXCProcessMonitorExitNotify,\n    .initNotify = virLXCProcessMonitorInitNotify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->domainEventState",
            "event"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListRemove",
          "args": [
            "driver->domains",
            "vm"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "401-413",
          "snippet": "void\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainEventLifecycleNewFromObj",
          "args": [
            "vm",
            "VIR_DOMAIN_EVENT_STOPPED",
            "priv->stopReason"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainEventLifecycleNewFromObj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_event.c",
          "lines": "610-616",
          "snippet": "virObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainEventDispose(void *obj);",
            "static void virDomainEventLifecycleDispose(void *obj);",
            "static void virDomainEventRTCChangeDispose(void *obj);",
            "static void virDomainEventWatchdogDispose(void *obj);",
            "static void virDomainEventIOErrorDispose(void *obj);",
            "static void virDomainEventGraphicsDispose(void *obj);",
            "static void virDomainEventBlockJobDispose(void *obj);",
            "static void virDomainEventDiskChangeDispose(void *obj);",
            "static void virDomainEventTrayChangeDispose(void *obj);",
            "static void virDomainEventBalloonChangeDispose(void *obj);",
            "static void virDomainEventDeviceRemovedDispose(void *obj);",
            "static void virDomainEventPMDispose(void *obj);",
            "static void virDomainQemuMonitorEventDispose(void *obj);",
            "static void virDomainEventTunableDispose(void *obj);",
            "static void virDomainEventAgentLifecycleDispose(void *obj);",
            "static void virDomainEventDeviceAddedDispose(void *obj);",
            "static void virDomainEventMigrationIterationDispose(void *obj);",
            "static void virDomainEventJobCompletedDispose(void *obj);",
            "static void virDomainEventDeviceRemovalFailedDispose(void *obj);",
            "static void virDomainEventMetadataChangeDispose(void *obj);",
            "static void virDomainEventBlockThresholdDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virDomainEventDispose(void *obj);\nstatic void virDomainEventLifecycleDispose(void *obj);\nstatic void virDomainEventRTCChangeDispose(void *obj);\nstatic void virDomainEventWatchdogDispose(void *obj);\nstatic void virDomainEventIOErrorDispose(void *obj);\nstatic void virDomainEventGraphicsDispose(void *obj);\nstatic void virDomainEventBlockJobDispose(void *obj);\nstatic void virDomainEventDiskChangeDispose(void *obj);\nstatic void virDomainEventTrayChangeDispose(void *obj);\nstatic void virDomainEventBalloonChangeDispose(void *obj);\nstatic void virDomainEventDeviceRemovedDispose(void *obj);\nstatic void virDomainEventPMDispose(void *obj);\nstatic void virDomainQemuMonitorEventDispose(void *obj);\nstatic void virDomainEventTunableDispose(void *obj);\nstatic void virDomainEventAgentLifecycleDispose(void *obj);\nstatic void virDomainEventDeviceAddedDispose(void *obj);\nstatic void virDomainEventMigrationIterationDispose(void *obj);\nstatic void virDomainEventJobCompletedDispose(void *obj);\nstatic void virDomainEventDeviceRemovalFailedDispose(void *obj);\nstatic void virDomainEventMetadataChangeDispose(void *obj);\nstatic void virDomainEventBlockThresholdDispose(void *obj);\n\nvirObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainEventRebootNewFromObj",
          "args": [
            "vm"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainEventRebootNewFromObj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_event.c",
          "lines": "651-660",
          "snippet": "virObjectEventPtr\nvirDomainEventRebootNewFromObj(virDomainObjPtr obj)\n{\n    if (virDomainEventsInitialize() < 0)\n        return NULL;\n\n    return virDomainEventNew(virDomainEventClass,\n                             VIR_DOMAIN_EVENT_ID_REBOOT,\n                             obj->def->id, obj->def->name, obj->def->uuid);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virDomainEventClass;",
            "static void virDomainEventDispose(void *obj);",
            "static void virDomainEventLifecycleDispose(void *obj);",
            "static void virDomainEventRTCChangeDispose(void *obj);",
            "static void virDomainEventWatchdogDispose(void *obj);",
            "static void virDomainEventIOErrorDispose(void *obj);",
            "static void virDomainEventGraphicsDispose(void *obj);",
            "static void virDomainEventBlockJobDispose(void *obj);",
            "static void virDomainEventDiskChangeDispose(void *obj);",
            "static void virDomainEventTrayChangeDispose(void *obj);",
            "static void virDomainEventBalloonChangeDispose(void *obj);",
            "static void virDomainEventDeviceRemovedDispose(void *obj);",
            "static void virDomainEventPMDispose(void *obj);",
            "static void virDomainQemuMonitorEventDispose(void *obj);",
            "static void virDomainEventTunableDispose(void *obj);",
            "static void virDomainEventAgentLifecycleDispose(void *obj);",
            "static void virDomainEventDeviceAddedDispose(void *obj);",
            "static void virDomainEventMigrationIterationDispose(void *obj);",
            "static void virDomainEventJobCompletedDispose(void *obj);",
            "static void virDomainEventDeviceRemovalFailedDispose(void *obj);",
            "static void virDomainEventMetadataChangeDispose(void *obj);",
            "static void virDomainEventBlockThresholdDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic virClassPtr virDomainEventClass;\nstatic void virDomainEventDispose(void *obj);\nstatic void virDomainEventLifecycleDispose(void *obj);\nstatic void virDomainEventRTCChangeDispose(void *obj);\nstatic void virDomainEventWatchdogDispose(void *obj);\nstatic void virDomainEventIOErrorDispose(void *obj);\nstatic void virDomainEventGraphicsDispose(void *obj);\nstatic void virDomainEventBlockJobDispose(void *obj);\nstatic void virDomainEventDiskChangeDispose(void *obj);\nstatic void virDomainEventTrayChangeDispose(void *obj);\nstatic void virDomainEventBalloonChangeDispose(void *obj);\nstatic void virDomainEventDeviceRemovedDispose(void *obj);\nstatic void virDomainEventPMDispose(void *obj);\nstatic void virDomainQemuMonitorEventDispose(void *obj);\nstatic void virDomainEventTunableDispose(void *obj);\nstatic void virDomainEventAgentLifecycleDispose(void *obj);\nstatic void virDomainEventDeviceAddedDispose(void *obj);\nstatic void virDomainEventMigrationIterationDispose(void *obj);\nstatic void virDomainEventJobCompletedDispose(void *obj);\nstatic void virDomainEventDeviceRemovalFailedDispose(void *obj);\nstatic void virDomainEventMetadataChangeDispose(void *obj);\nstatic void virDomainEventBlockThresholdDispose(void *obj);\n\nvirObjectEventPtr\nvirDomainEventRebootNewFromObj(virDomainObjPtr obj)\n{\n    if (virDomainEventsInitialize() < 0)\n        return NULL;\n\n    return virDomainEventNew(virDomainEventClass,\n                             VIR_DOMAIN_EVENT_ID_REBOOT,\n                             obj->def->id, obj->def->name, obj->def->uuid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainAuditStart",
          "args": [
            "vm",
            "\"reboot\"",
            "ret == 0"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainAuditStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_audit.c",
          "lines": "771-840",
          "snippet": "void\nvirDomainAuditStart(virDomainObjPtr vm, const char *reason, bool success)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->ndisks; i++)\n        virDomainAuditDisk(vm, NULL, vm->def->disks[i]->src, \"start\", true);\n\n    for (i = 0; i < vm->def->nfss; i++) {\n        virDomainFSDefPtr fs = vm->def->fss[i];\n        virDomainAuditFS(vm, NULL, fs, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr net = vm->def->nets[i];\n        virDomainAuditNet(vm, NULL, net, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = vm->def->hostdevs[i];\n        virDomainAuditHostdev(vm, hostdev, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nredirdevs; i++) {\n        virDomainRedirdevDefPtr redirdev = vm->def->redirdevs[i];\n        virDomainAuditRedirdev(vm, redirdev, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nserials; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->serials[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nparallels; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->parallels[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nchannels; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->channels[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        if (i == 0 &&\n            (vm->def->consoles[i]->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_SERIAL ||\n             vm->def->consoles[i]->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_NONE) &&\n             vm->def->os.type == VIR_DOMAIN_OSTYPE_HVM)\n            continue;\n\n        virDomainAuditChardev(vm, NULL, vm->def->consoles[i], \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nsmartcards; i++)\n        virDomainAuditSmartcard(vm, vm->def->smartcards[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nrngs; i++)\n        virDomainAuditRNG(vm, NULL, vm->def->rngs[i], \"start\", true);\n\n    if (vm->def->tpm)\n        virDomainAuditTPM(vm, vm->def->tpm, \"start\", true);\n\n    for (i = 0; i < vm->def->nshmems; i++)\n        virDomainAuditShmem(vm, vm->def->shmems[i], \"start\", true);\n\n    for (i = 0; i < vm->def->ninputs; i++)\n        virDomainAuditInput(vm, vm->def->inputs[i], \"start\", true);\n\n    virDomainAuditMemory(vm, 0, virDomainDefGetMemoryTotal(vm->def),\n                         \"start\", true);\n    virDomainAuditVcpu(vm, 0, virDomainDefGetVcpus(vm->def), \"start\", true);\n    if (vm->def->niothreadids)\n        virDomainAuditIOThread(vm, 0, vm->def->niothreadids, \"start\", true);\n\n    virDomainAuditLifecycle(vm, \"start\", reason, success);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"viruuid.h\"",
            "#include \"viraudit.h\"",
            "#include \"domain_audit.h\"",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"viruuid.h\"\n#include \"viraudit.h\"\n#include \"domain_audit.h\"\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid\nvirDomainAuditStart(virDomainObjPtr vm, const char *reason, bool success)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->ndisks; i++)\n        virDomainAuditDisk(vm, NULL, vm->def->disks[i]->src, \"start\", true);\n\n    for (i = 0; i < vm->def->nfss; i++) {\n        virDomainFSDefPtr fs = vm->def->fss[i];\n        virDomainAuditFS(vm, NULL, fs, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr net = vm->def->nets[i];\n        virDomainAuditNet(vm, NULL, net, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = vm->def->hostdevs[i];\n        virDomainAuditHostdev(vm, hostdev, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nredirdevs; i++) {\n        virDomainRedirdevDefPtr redirdev = vm->def->redirdevs[i];\n        virDomainAuditRedirdev(vm, redirdev, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nserials; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->serials[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nparallels; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->parallels[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nchannels; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->channels[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        if (i == 0 &&\n            (vm->def->consoles[i]->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_SERIAL ||\n             vm->def->consoles[i]->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_NONE) &&\n             vm->def->os.type == VIR_DOMAIN_OSTYPE_HVM)\n            continue;\n\n        virDomainAuditChardev(vm, NULL, vm->def->consoles[i], \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nsmartcards; i++)\n        virDomainAuditSmartcard(vm, vm->def->smartcards[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nrngs; i++)\n        virDomainAuditRNG(vm, NULL, vm->def->rngs[i], \"start\", true);\n\n    if (vm->def->tpm)\n        virDomainAuditTPM(vm, vm->def->tpm, \"start\", true);\n\n    for (i = 0; i < vm->def->nshmems; i++)\n        virDomainAuditShmem(vm, vm->def->shmems[i], \"start\", true);\n\n    for (i = 0; i < vm->def->ninputs; i++)\n        virDomainAuditInput(vm, vm->def->inputs[i], \"start\", true);\n\n    virDomainAuditMemory(vm, 0, virDomainDefGetMemoryTotal(vm->def),\n                         \"start\", true);\n    virDomainAuditVcpu(vm, 0, virDomainDefGetVcpus(vm->def), \"start\", true);\n    if (vm->def->niothreadids)\n        virDomainAuditIOThread(vm, 0, vm->def->niothreadids, \"start\", true);\n\n    virDomainAuditLifecycle(vm, \"start\", reason, success);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainAuditStop",
          "args": [
            "vm",
            "\"reboot\""
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainAuditStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_audit.c",
          "lines": "866-870",
          "snippet": "void\nvirDomainAuditStop(virDomainObjPtr vm, const char *reason)\n{\n    virDomainAuditLifecycle(vm, \"stop\", reason, true);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"viruuid.h\"",
            "#include \"viraudit.h\"",
            "#include \"domain_audit.h\"",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"viruuid.h\"\n#include \"viraudit.h\"\n#include \"domain_audit.h\"\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid\nvirDomainAuditStop(virDomainObjPtr vm, const char *reason)\n{\n    virDomainAuditLifecycle(vm, \"stop\", reason, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCProcessReboot",
          "args": [
            "driver",
            "vm"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessReboot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "91-131",
          "snippet": "static int\nvirLXCProcessReboot(virLXCDriverPtr driver,\n                    virDomainObjPtr vm)\n{\n    virConnectPtr conn = virCloseCallbacksGetConn(driver->closeCallbacks, vm);\n    int reason = vm->state.reason;\n    bool autodestroy = false;\n    int ret = -1;\n    virDomainDefPtr savedDef;\n\n    VIR_DEBUG(\"Faking reboot\");\n\n    if (conn) {\n        virObjectRef(conn);\n        autodestroy = true;\n    } else {\n        conn = virConnectOpen(\"lxc:///system\");\n        /* Ignoring NULL conn which is mostly harmless here */\n    }\n\n    /* In a reboot scenario, we need to make sure we continue\n     * to use the current 'def', and not switch to 'newDef'.\n     * So temporarily hide the newDef and then reinstate it\n     */\n    savedDef = vm->newDef;\n    vm->newDef = NULL;\n    virLXCProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n    vm->newDef = savedDef;\n    if (virLXCProcessStart(conn, driver, vm,\n                           0, NULL, autodestroy, reason) < 0) {\n        VIR_WARN(\"Unable to handle reboot of vm %s\",\n                 vm->def->name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(conn);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirLXCProcessReboot(virLXCDriverPtr driver,\n                    virDomainObjPtr vm)\n{\n    virConnectPtr conn = virCloseCallbacksGetConn(driver->closeCallbacks, vm);\n    int reason = vm->state.reason;\n    bool autodestroy = false;\n    int ret = -1;\n    virDomainDefPtr savedDef;\n\n    VIR_DEBUG(\"Faking reboot\");\n\n    if (conn) {\n        virObjectRef(conn);\n        autodestroy = true;\n    } else {\n        conn = virConnectOpen(\"lxc:///system\");\n        /* Ignoring NULL conn which is mostly harmless here */\n    }\n\n    /* In a reboot scenario, we need to make sure we continue\n     * to use the current 'def', and not switch to 'newDef'.\n     * So temporarily hide the newDef and then reinstate it\n     */\n    savedDef = vm->newDef;\n    vm->newDef = NULL;\n    virLXCProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n    vm->newDef = savedDef;\n    if (virLXCProcessStart(conn, driver, vm,\n                           0, NULL, autodestroy, reason) < 0) {\n        VIR_WARN(\"Unable to handle reboot of vm %s\",\n                 vm->def->name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(conn);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Stop event has already been sent\""
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLXCProcessStop",
          "args": [
            "driver",
            "vm",
            "VIR_DOMAIN_SHUTOFF_SHUTDOWN"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "852-915",
          "snippet": "int virLXCProcessStop(virLXCDriverPtr driver,\n                      virDomainObjPtr vm,\n                      virDomainShutoffReason reason)\n{\n    int rc;\n    virLXCDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"Stopping VM name=%s pid=%d reason=%d\",\n              vm->def->name, (int)vm->pid, (int)reason);\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    priv = vm->privateData;\n\n    /* If the LXC domain is suspended we send all processes a SIGKILL\n     * and thaw them. Upon wakeup the process sees the pending signal\n     * and dies immediately. It is guaranteed that priv->cgroup != NULL\n     * here because the domain has aleady been suspended using the\n     * freezer cgroup.\n     */\n    if (reason == VIR_DOMAIN_SHUTOFF_DESTROYED &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED) {\n        if (virCgroupKillRecursive(priv->cgroup, SIGKILL) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to kill all processes\"));\n            return -1;\n        }\n\n        if (virCgroupSetFreezerState(priv->cgroup, \"THAWED\") < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Unable to thaw all processes\"));\n\n            return -1;\n        }\n\n        goto cleanup;\n    }\n\n    if (priv->cgroup) {\n        rc = virCgroupKillPainfully(priv->cgroup);\n        if (rc < 0)\n            return -1;\n        if (rc > 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Some processes refused to die\"));\n            return -1;\n        }\n    } else if (vm->pid > 0) {\n        /* If cgroup doesn't exist, just try cleaning up the\n         * libvirt_lxc process */\n        if (virProcessKillPainfully(vm->pid, true) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Processes %d refused to die\"), (int)vm->pid);\n            return -1;\n        }\n    }\n\n cleanup:\n    virLXCProcessCleanup(driver, vm, reason);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virLXCProcessStop(virLXCDriverPtr driver,\n                      virDomainObjPtr vm,\n                      virDomainShutoffReason reason)\n{\n    int rc;\n    virLXCDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"Stopping VM name=%s pid=%d reason=%d\",\n              vm->def->name, (int)vm->pid, (int)reason);\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    priv = vm->privateData;\n\n    /* If the LXC domain is suspended we send all processes a SIGKILL\n     * and thaw them. Upon wakeup the process sees the pending signal\n     * and dies immediately. It is guaranteed that priv->cgroup != NULL\n     * here because the domain has aleady been suspended using the\n     * freezer cgroup.\n     */\n    if (reason == VIR_DOMAIN_SHUTOFF_DESTROYED &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED) {\n        if (virCgroupKillRecursive(priv->cgroup, SIGKILL) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to kill all processes\"));\n            return -1;\n        }\n\n        if (virCgroupSetFreezerState(priv->cgroup, \"THAWED\") < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Unable to thaw all processes\"));\n\n            return -1;\n        }\n\n        goto cleanup;\n    }\n\n    if (priv->cgroup) {\n        rc = virCgroupKillPainfully(priv->cgroup);\n        if (rc < 0)\n            return -1;\n        if (rc > 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Some processes refused to die\"));\n            return -1;\n        }\n    } else if (vm->pid > 0) {\n        /* If cgroup doesn't exist, just try cleaning up the\n         * libvirt_lxc process */\n        if (virProcessKillPainfully(vm->pid, true) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Processes %d refused to die\"), (int)vm->pid);\n            return -1;\n        }\n    }\n\n cleanup:\n    virLXCProcessCleanup(driver, vm, reason);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "vm"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p vm=%p\"",
            "mon",
            "vm"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nextern virLXCDriverPtr lxc_driver;\nextern virLXCDriverPtr lxc_driver;\nstatic virLXCMonitorCallbacks monitorCallbacks = {\n    .eofNotify = virLXCProcessMonitorEOFNotify,\n    .exitNotify = virLXCProcessMonitorExitNotify,\n    .initNotify = virLXCProcessMonitorInitNotify,\n};\n\nstatic void virLXCProcessMonitorEOFNotify(virLXCMonitorPtr mon,\n                                          virDomainObjPtr vm)\n{\n    virLXCDriverPtr driver = lxc_driver;\n    virObjectEventPtr event = NULL;\n    virLXCDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"mon=%p vm=%p\", mon, vm);\n\n    virObjectLock(vm);\n\n    priv = vm->privateData;\n    virLXCProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n    if (!priv->wantReboot) {\n        virLXCProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n        if (!priv->doneStopEvent) {\n            event = virDomainEventLifecycleNewFromObj(vm,\n                                             VIR_DOMAIN_EVENT_STOPPED,\n                                             priv->stopReason);\n            virDomainAuditStop(vm, \"shutdown\");\n        } else {\n            VIR_DEBUG(\"Stop event has already been sent\");\n        }\n        if (!vm->persistent)\n            virDomainObjListRemove(driver->domains, vm);\n    } else {\n        int ret = virLXCProcessReboot(driver, vm);\n        virDomainAuditStop(vm, \"reboot\");\n        virDomainAuditStart(vm, \"reboot\", ret == 0);\n        if (ret == 0) {\n            event = virDomainEventRebootNewFromObj(vm);\n        } else {\n            event = virDomainEventLifecycleNewFromObj(vm,\n                                             VIR_DOMAIN_EVENT_STOPPED,\n                                             priv->stopReason);\n            if (!vm->persistent)\n                virDomainObjListRemove(driver->domains, vm);\n        }\n    }\n\n    /* NB: virLXCProcessConnectMonitor will perform the virObjectRef(vm)\n     * before adding monitorCallbacks. Since we are now done with the @vm\n     * we can Unref/Unlock */\n    virDomainObjEndAPI(&vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}"
  },
  {
    "function_name": "virLXCProcessCleanInterfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "666-675",
    "snippet": "static void\nvirLXCProcessCleanInterfaces(virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nnets; i++) {\n        VIR_FREE(def->nets[i]->ifname_guest_actual);\n        VIR_DEBUG(\"Cleared net names: %s\", def->nets[i]->ifname_guest);\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Cleared net names: %s\"",
            "def->nets[i]->ifname_guest"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->nets[i]->ifname_guest_actual"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic void\nvirLXCProcessCleanInterfaces(virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nnets; i++) {\n        VIR_FREE(def->nets[i]->ifname_guest_actual);\n        VIR_DEBUG(\"Cleared net names: %s\", def->nets[i]->ifname_guest);\n    }\n}"
  },
  {
    "function_name": "virLXCProcessSetupInterfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "543-664",
    "snippet": "static int\nvirLXCProcessSetupInterfaces(virLXCDriverPtr driver,\n                             virDomainDefPtr def,\n                             char ***veths)\n{\n    int ret = -1;\n    size_t i;\n    size_t niface = 0;\n    virDomainNetDefPtr net;\n    virDomainNetType type;\n    virConnectPtr netconn = NULL;\n    virErrorPtr save_err = NULL;\n\n    if (VIR_ALLOC_N(*veths, def->nnets + 1) < 0)\n        return -1;\n\n    for (i = 0; i < def->nnets; i++) {\n        char *veth = NULL;\n        const virNetDevBandwidth *actualBandwidth;\n        /* If appropriate, grab a physical device from the configured\n         * network's pool of devices, or resolve bridge device name\n         * to the one defined in the network definition.\n         */\n        net = def->nets[i];\n\n        if (virLXCProcessValidateInterface(net) < 0)\n            goto cleanup;\n\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (!netconn && !(netconn = virGetConnectNetwork()))\n                goto cleanup;\n            if (virDomainNetAllocateActualDevice(netconn, def, net) < 0)\n                goto cleanup;\n        }\n\n        /* final validation now that actual type is known */\n        if (virDomainActualNetDefValidate(net) < 0)\n            return -1;\n\n        type = virDomainNetGetActualType(net);\n        switch (type) {\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE: {\n            const char *brname = virDomainNetGetActualBridgeName(net);\n            if (!brname) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"No bridge name specified\"));\n                goto cleanup;\n            }\n            if (!(veth = virLXCProcessSetupInterfaceTap(def, net, brname)))\n                goto cleanup;\n        }   break;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            if (!(veth = virLXCProcessSetupInterfaceTap(def, net, NULL)))\n                goto cleanup;\n            break;\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n            if (!(veth = virLXCProcessSetupInterfaceDirect(driver, def, net)))\n                goto cleanup;\n            break;\n\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unsupported network type %s\"),\n                           virDomainNetTypeToString(type));\n            goto cleanup;\n\n        }\n\n        /* Set bandwidth or warn if requested and not supported. */\n        actualBandwidth = virDomainNetGetActualBandwidth(net);\n        if (actualBandwidth) {\n            if (virNetDevSupportsBandwidth(type)) {\n                if (virNetDevBandwidthSet(net->ifname, actualBandwidth, false,\n                                          !virDomainNetTypeSharesHostView(net)) < 0)\n                    goto cleanup;\n            } else {\n                VIR_WARN(\"setting bandwidth on interfaces of \"\n                         \"type '%s' is not implemented yet\",\n                         virDomainNetTypeToString(type));\n            }\n        }\n\n        (*veths)[i] = veth;\n\n        def->nets[i]->ifname_guest_actual = g_strdup(veth);\n\n        /* Make sure all net definitions will have a name in the container */\n        if (!net->ifname_guest) {\n            net->ifname_guest = g_strdup_printf(\"eth%zu\", niface);\n            niface++;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        virErrorPreserveLast(&save_err);\n        for (i = 0; i < def->nnets; i++) {\n            virDomainNetDefPtr iface = def->nets[i];\n            const virNetDevVPortProfile *vport = virDomainNetGetActualVirtPortProfile(iface);\n            if (vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH)\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                virDomainNetGetActualBridgeName(iface),\n                                iface->ifname));\n            if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK && netconn)\n                virDomainNetReleaseActualDevice(netconn, def, iface);\n        }\n        virErrorRestore(&save_err);\n    }\n    virObjectUnref(netconn);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "netconn"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&save_err"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetReleaseActualDevice",
          "args": [
            "netconn",
            "def",
            "iface"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetReleaseActualDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "31536-31564",
          "snippet": "int\nvirDomainNetReleaseActualDevice(virConnectPtr conn,\n                                virDomainDefPtr dom G_GNUC_UNUSED,\n                                virDomainNetDefPtr iface)\n{\n    virNetworkPtr net = NULL;\n    virNetworkPortPtr port = NULL;\n    int ret = -1;\n\n    /* Port might not exist if a failure occurred during VM startup */\n    if (!virUUIDIsValid(iface->data.network.portid)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(net = virNetworkLookupByName(conn, iface->data.network.name)))\n        goto cleanup;\n\n    if (!(port = virNetworkPortLookupByUUID(net, iface->data.network.portid)))\n        goto cleanup;\n\n    if (virNetworkPortDelete(port, 0) < 0)\n        goto cleanup;\n\n cleanup:\n    virObjectUnref(port);\n    virObjectUnref(net);\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainNetReleaseActualDevice(virConnectPtr conn,\n                                virDomainDefPtr dom G_GNUC_UNUSED,\n                                virDomainNetDefPtr iface)\n{\n    virNetworkPtr net = NULL;\n    virNetworkPortPtr port = NULL;\n    int ret = -1;\n\n    /* Port might not exist if a failure occurred during VM startup */\n    if (!virUUIDIsValid(iface->data.network.portid)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(net = virNetworkLookupByName(conn, iface->data.network.name)))\n        goto cleanup;\n\n    if (!(port = virNetworkPortLookupByUUID(net, iface->data.network.portid)))\n        goto cleanup;\n\n    if (virNetworkPortDelete(port, 0) < 0)\n        goto cleanup;\n\n cleanup:\n    virObjectUnref(port);\n    virObjectUnref(net);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevOpenvswitchRemovePort(\n                                virDomainNetGetActualBridgeName(iface),\n                                iface->ifname)"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevOpenvswitchRemovePort",
          "args": [
            "virDomainNetGetActualBridgeName(iface)",
            "iface->ifname"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevOpenvswitchRemovePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevopenvswitch.c",
          "lines": "205-220",
          "snippet": "int virNetDevOpenvswitchRemovePort(const char *brname G_GNUC_UNUSED, const char *ifname)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNew(OVSVSCTL);\n    virNetDevOpenvswitchAddTimeout(cmd);\n    virCommandAddArgList(cmd, \"--\", \"--if-exists\", \"del-port\", ifname, NULL);\n\n    if (virCommandRun(cmd, NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to delete port %s from OVS\"), ifname);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virjson.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virjson.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virmacaddr.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevopenvswitch.h\"\n#include <config.h>\n\nint virNetDevOpenvswitchRemovePort(const char *brname G_GNUC_UNUSED, const char *ifname)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNew(OVSVSCTL);\n    virNetDevOpenvswitchAddTimeout(cmd);\n    virCommandAddArgList(cmd, \"--\", \"--if-exists\", \"del-port\", ifname, NULL);\n\n    if (virCommandRun(cmd, NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to delete port %s from OVS\"), ifname);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualBridgeName",
          "args": [
            "iface"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualBridgeName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30164-30175",
          "snippet": "const char *\nvirDomainNetGetActualBridgeName(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_BRIDGE)\n        return iface->data.bridge.brname;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        (iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_BRIDGE ||\n         iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_NETWORK))\n        return iface->data.network.actual->data.bridge.brname;\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainNetGetActualBridgeName(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_BRIDGE)\n        return iface->data.bridge.brname;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        (iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_BRIDGE ||\n         iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_NETWORK))\n        return iface->data.network.actual->data.bridge.brname;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVirtPortProfile",
          "args": [
            "iface"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVirtPortProfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30224-30255",
          "snippet": "const virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&save_err"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"eth%zu\"",
            "niface"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"setting bandwidth on interfaces of \"\n                         \"type '%s' is not implemented yet\"",
            "virDomainNetTypeToString(type)"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetTypeToString",
          "args": [
            "type"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthSet",
          "args": [
            "net->ifname",
            "actualBandwidth",
            "false",
            "!virDomainNetTypeSharesHostView(net)"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "189-392",
          "snippet": "int\nvirNetDevBandwidthSet(const char *ifname,\n                      const virNetDevBandwidth *bandwidth,\n                      bool hierarchical_class,\n                      bool swapped)\n{\n    int ret = -1;\n    virNetDevBandwidthRatePtr rx = NULL, tx = NULL; /* From domain POV */\n    virCommandPtr cmd = NULL;\n    char *average = NULL;\n    char *peak = NULL;\n    char *burst = NULL;\n\n    if (!bandwidth) {\n        /* nothing to be enabled */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (geteuid() != 0) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Network bandwidth tuning is not available\"\n                         \" in session mode\"));\n        return -1;\n    }\n\n    if (!ifname) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Unable to set bandwidth for interface because \"\n                         \"device name is unknown\"));\n        return -1;\n    }\n\n    if (swapped) {\n        rx = bandwidth->out;\n        tx = bandwidth->in;\n    } else {\n        rx = bandwidth->in;\n        tx = bandwidth->out;\n    }\n\n    virNetDevBandwidthClear(ifname);\n\n    if (tx && tx->average) {\n        average = g_strdup_printf(\"%llukbps\", tx->average);\n        if (tx->peak)\n            peak = g_strdup_printf(\"%llukbps\", tx->peak);\n        if (tx->burst)\n            burst = g_strdup_printf(\"%llukb\", tx->burst);\n\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname, \"root\",\n                             \"handle\", \"1:\", \"htb\", \"default\",\n                             hierarchical_class ? \"2\" : \"1\", NULL);\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        /* If we are creating a hierarchical class, all non guaranteed traffic\n         * goes to the 1:2 class which will adjust 'rate' dynamically as NICs\n         * with guaranteed throughput are plugged and unplugged. Class 1:1\n         * exists so we don't exceed the maximum limit for the network. For each\n         * NIC with guaranteed throughput a separate classid will be created.\n         * NB '1:' is just a shorter notation of '1:0'.\n         *\n         * To get a picture how this works:\n         *\n         * +-----+     +---------+     +-----------+      +-----------+     +-----+\n         * |     |     |  qdisc  |     | class 1:1 |      | class 1:2 |     |     |\n         * | NIC |     | def 1:2 |     |   rate    |      |   rate    |     | sfq |\n         * |     | --> |         | --> |   peak    | -+-> |   peak    | --> |     |\n         * +-----+     +---------+     +-----------+  |   +-----------+     +-----+\n         *                                            |\n         *                                            |   +-----------+     +-----+\n         *                                            |   | class 1:3 |     |     |\n         *                                            |   |   rate    |     | sfq |\n         *                                            +-> |   peak    | --> |     |\n         *                                            |   +-----------+     +-----+\n         *                                           ...\n         *                                            |   +-----------+     +-----+\n         *                                            |   | class 1:n |     |     |\n         *                                            |   |   rate    |     | sfq |\n         *                                            +-> |   peak    | --> |     |\n         *                                                +-----------+     +-----+\n         *\n         * After the routing decision, when is it clear a packet is to be sent\n         * via a particular NIC, it is sent to the root qdisc (queuing\n         * discipline). In this case HTB (Hierarchical Token Bucket). It has\n         * only one direct child class (with id 1:1) which shapes the overall\n         * rate that is sent through the NIC.  This class has at least one child\n         * (1:2) which is meant for all non-privileged (non guaranteed) traffic\n         * from all domains. Then, for each interface with guaranteed\n         * throughput, a separate class (1:n) is created. Imagine a class is a\n         * box. Whenever a packet ends up in a class it is stored in this box\n         * until the kernel sends it, then it is removed from box. Packets are\n         * placed into boxes based on rules (filters) - e.g. depending on\n         * destination IP/MAC address. If there is no rule to be applied, the\n         * root qdisc has a default where such packets go (1:2 in this case).\n         * Packets come in over and over again and boxes get filled more and\n         * more. Imagine that kernel sends packets just once a second. So it\n         * starts to traverse through this tree. It starts with the root qdisc\n         * and through 1:1 it gets to 1:2. It sends packets up to 1:2's 'rate'.\n         * Then it moves to 1:3 and again sends packets up to 1:3's 'rate'.  The\n         * whole process is repeated until 1:n is processed. So now we have\n         * ensured each class its guaranteed bandwidth. If the sum of sent data\n         * doesn't exceed the 'rate' in 1:1 class, we can go further and send\n         * more packets. The rest of available bandwidth is distributed to the\n         * 1:2,1:3...1:n classes by ratio of their 'rate'. As soon as the root\n         * 'rate' limit is reached or there are no more packets to send, we stop\n         * sending and wait another second. Each class has an SFQ qdisc which\n         * shuffles packets in boxes stochastically, so one sender cannot\n         * starve others.\n         *\n         * Therefore, whenever we want to plug in a new guaranteed interface, we\n         * need to create a new class and adjust the 'rate' of the 1:2 class.\n         * When unplugging we do the exact opposite - remove the associated\n         * class, and adjust the 'rate'.\n         *\n         * This description is rather long, but it is still a good idea to read\n         * it before you dig into the code.\n         */\n        if (hierarchical_class) {\n            virCommandFree(cmd);\n            cmd = virCommandNew(TC);\n            virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", ifname, \"parent\",\n                                 \"1:\", \"classid\", \"1:1\", \"htb\", \"rate\", average,\n                                 \"ceil\", peak ? peak : average, NULL);\n            virNetDevBandwidthCmdAddOptimalQuantum(cmd, tx);\n            if (virCommandRun(cmd, NULL) < 0)\n                goto cleanup;\n        }\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", ifname, \"parent\",\n                             hierarchical_class ? \"1:1\" : \"1:\", \"classid\",\n                             hierarchical_class ? \"1:2\" : \"1:1\", \"htb\",\n                             \"rate\", average, NULL);\n\n        if (peak)\n            virCommandAddArgList(cmd, \"ceil\", peak, NULL);\n        if (burst)\n            virCommandAddArgList(cmd, \"burst\", burst, NULL);\n\n        virNetDevBandwidthCmdAddOptimalQuantum(cmd, tx);\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname, \"parent\",\n                             hierarchical_class ? \"1:2\" : \"1:1\",\n                             \"handle\", \"2:\", \"sfq\", \"perturb\",\n                             \"10\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"filter\", \"add\", \"dev\", ifname, \"parent\",\n                             \"1:0\", \"protocol\", \"all\", \"prio\", \"1\", \"handle\",\n                             \"1\", \"fw\", \"flowid\", \"1\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        VIR_FREE(average);\n        VIR_FREE(peak);\n        VIR_FREE(burst);\n    }\n\n    if (rx) {\n        average = g_strdup_printf(\"%llukbps\", rx->average);\n        burst = g_strdup_printf(\"%llukb\", rx->burst ? rx->burst : rx->average);\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n            virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname,\n                                 \"ingress\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        /* Set filter to match all ingress traffic */\n        virCommandAddArgList(cmd, \"filter\", \"add\", \"dev\", ifname, \"parent\",\n                             \"ffff:\", \"protocol\", \"all\", \"u32\", \"match\", \"u32\",\n                             \"0\", \"0\", \"police\", \"rate\", average,\n                             \"burst\", burst, \"mtu\", \"64kb\", \"drop\", \"flowid\",\n                             \":1\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(average);\n    VIR_FREE(peak);\n    VIR_FREE(burst);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthSet(const char *ifname,\n                      const virNetDevBandwidth *bandwidth,\n                      bool hierarchical_class,\n                      bool swapped)\n{\n    int ret = -1;\n    virNetDevBandwidthRatePtr rx = NULL, tx = NULL; /* From domain POV */\n    virCommandPtr cmd = NULL;\n    char *average = NULL;\n    char *peak = NULL;\n    char *burst = NULL;\n\n    if (!bandwidth) {\n        /* nothing to be enabled */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (geteuid() != 0) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Network bandwidth tuning is not available\"\n                         \" in session mode\"));\n        return -1;\n    }\n\n    if (!ifname) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Unable to set bandwidth for interface because \"\n                         \"device name is unknown\"));\n        return -1;\n    }\n\n    if (swapped) {\n        rx = bandwidth->out;\n        tx = bandwidth->in;\n    } else {\n        rx = bandwidth->in;\n        tx = bandwidth->out;\n    }\n\n    virNetDevBandwidthClear(ifname);\n\n    if (tx && tx->average) {\n        average = g_strdup_printf(\"%llukbps\", tx->average);\n        if (tx->peak)\n            peak = g_strdup_printf(\"%llukbps\", tx->peak);\n        if (tx->burst)\n            burst = g_strdup_printf(\"%llukb\", tx->burst);\n\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname, \"root\",\n                             \"handle\", \"1:\", \"htb\", \"default\",\n                             hierarchical_class ? \"2\" : \"1\", NULL);\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        /* If we are creating a hierarchical class, all non guaranteed traffic\n         * goes to the 1:2 class which will adjust 'rate' dynamically as NICs\n         * with guaranteed throughput are plugged and unplugged. Class 1:1\n         * exists so we don't exceed the maximum limit for the network. For each\n         * NIC with guaranteed throughput a separate classid will be created.\n         * NB '1:' is just a shorter notation of '1:0'.\n         *\n         * To get a picture how this works:\n         *\n         * +-----+     +---------+     +-----------+      +-----------+     +-----+\n         * |     |     |  qdisc  |     | class 1:1 |      | class 1:2 |     |     |\n         * | NIC |     | def 1:2 |     |   rate    |      |   rate    |     | sfq |\n         * |     | --> |         | --> |   peak    | -+-> |   peak    | --> |     |\n         * +-----+     +---------+     +-----------+  |   +-----------+     +-----+\n         *                                            |\n         *                                            |   +-----------+     +-----+\n         *                                            |   | class 1:3 |     |     |\n         *                                            |   |   rate    |     | sfq |\n         *                                            +-> |   peak    | --> |     |\n         *                                            |   +-----------+     +-----+\n         *                                           ...\n         *                                            |   +-----------+     +-----+\n         *                                            |   | class 1:n |     |     |\n         *                                            |   |   rate    |     | sfq |\n         *                                            +-> |   peak    | --> |     |\n         *                                                +-----------+     +-----+\n         *\n         * After the routing decision, when is it clear a packet is to be sent\n         * via a particular NIC, it is sent to the root qdisc (queuing\n         * discipline). In this case HTB (Hierarchical Token Bucket). It has\n         * only one direct child class (with id 1:1) which shapes the overall\n         * rate that is sent through the NIC.  This class has at least one child\n         * (1:2) which is meant for all non-privileged (non guaranteed) traffic\n         * from all domains. Then, for each interface with guaranteed\n         * throughput, a separate class (1:n) is created. Imagine a class is a\n         * box. Whenever a packet ends up in a class it is stored in this box\n         * until the kernel sends it, then it is removed from box. Packets are\n         * placed into boxes based on rules (filters) - e.g. depending on\n         * destination IP/MAC address. If there is no rule to be applied, the\n         * root qdisc has a default where such packets go (1:2 in this case).\n         * Packets come in over and over again and boxes get filled more and\n         * more. Imagine that kernel sends packets just once a second. So it\n         * starts to traverse through this tree. It starts with the root qdisc\n         * and through 1:1 it gets to 1:2. It sends packets up to 1:2's 'rate'.\n         * Then it moves to 1:3 and again sends packets up to 1:3's 'rate'.  The\n         * whole process is repeated until 1:n is processed. So now we have\n         * ensured each class its guaranteed bandwidth. If the sum of sent data\n         * doesn't exceed the 'rate' in 1:1 class, we can go further and send\n         * more packets. The rest of available bandwidth is distributed to the\n         * 1:2,1:3...1:n classes by ratio of their 'rate'. As soon as the root\n         * 'rate' limit is reached or there are no more packets to send, we stop\n         * sending and wait another second. Each class has an SFQ qdisc which\n         * shuffles packets in boxes stochastically, so one sender cannot\n         * starve others.\n         *\n         * Therefore, whenever we want to plug in a new guaranteed interface, we\n         * need to create a new class and adjust the 'rate' of the 1:2 class.\n         * When unplugging we do the exact opposite - remove the associated\n         * class, and adjust the 'rate'.\n         *\n         * This description is rather long, but it is still a good idea to read\n         * it before you dig into the code.\n         */\n        if (hierarchical_class) {\n            virCommandFree(cmd);\n            cmd = virCommandNew(TC);\n            virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", ifname, \"parent\",\n                                 \"1:\", \"classid\", \"1:1\", \"htb\", \"rate\", average,\n                                 \"ceil\", peak ? peak : average, NULL);\n            virNetDevBandwidthCmdAddOptimalQuantum(cmd, tx);\n            if (virCommandRun(cmd, NULL) < 0)\n                goto cleanup;\n        }\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", ifname, \"parent\",\n                             hierarchical_class ? \"1:1\" : \"1:\", \"classid\",\n                             hierarchical_class ? \"1:2\" : \"1:1\", \"htb\",\n                             \"rate\", average, NULL);\n\n        if (peak)\n            virCommandAddArgList(cmd, \"ceil\", peak, NULL);\n        if (burst)\n            virCommandAddArgList(cmd, \"burst\", burst, NULL);\n\n        virNetDevBandwidthCmdAddOptimalQuantum(cmd, tx);\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname, \"parent\",\n                             hierarchical_class ? \"1:2\" : \"1:1\",\n                             \"handle\", \"2:\", \"sfq\", \"perturb\",\n                             \"10\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"filter\", \"add\", \"dev\", ifname, \"parent\",\n                             \"1:0\", \"protocol\", \"all\", \"prio\", \"1\", \"handle\",\n                             \"1\", \"fw\", \"flowid\", \"1\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        VIR_FREE(average);\n        VIR_FREE(peak);\n        VIR_FREE(burst);\n    }\n\n    if (rx) {\n        average = g_strdup_printf(\"%llukbps\", rx->average);\n        burst = g_strdup_printf(\"%llukb\", rx->burst ? rx->burst : rx->average);\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n            virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname,\n                                 \"ingress\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        /* Set filter to match all ingress traffic */\n        virCommandAddArgList(cmd, \"filter\", \"add\", \"dev\", ifname, \"parent\",\n                             \"ffff:\", \"protocol\", \"all\", \"u32\", \"match\", \"u32\",\n                             \"0\", \"0\", \"police\", \"rate\", average,\n                             \"burst\", burst, \"mtu\", \"64kb\", \"drop\", \"flowid\",\n                             \":1\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(average);\n    VIR_FREE(peak);\n    VIR_FREE(burst);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetTypeSharesHostView",
          "args": [
            "net"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetTypeSharesHostView",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "31122-31144",
          "snippet": "bool\nvirDomainNetTypeSharesHostView(const virDomainNetDef *net)\n{\n    virDomainNetType actualType = virDomainNetGetActualType(net);\n    switch (actualType) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n        return true;\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n        break;\n    }\n    return false;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainNetTypeSharesHostView(const virDomainNetDef *net)\n{\n    virDomainNetType actualType = virDomainNetGetActualType(net);\n    switch (actualType) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n        return true;\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n        break;\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevSupportsBandwidth",
          "args": [
            "type"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevSupportsBandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_bandwidth_conf.c",
          "lines": "302-322",
          "snippet": "bool virNetDevSupportsBandwidth(virDomainNetType type)\n{\n    switch ((virDomainNetType) type) {\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n        return true;\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n        break;\n    }\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include <config.h>\n\nbool virNetDevSupportsBandwidth(virDomainNetType type)\n{\n    switch ((virDomainNetType) type) {\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n        return true;\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n        break;\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualBandwidth",
          "args": [
            "net"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualBandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30257-30267",
          "snippet": "const virNetDevBandwidth *\nvirDomainNetGetActualBandwidth(const virDomainNetDef *iface)\n{\n    /* if there is an ActualNetDef, *always* return\n     * its bandwidth rather than the NetDef's bandwidth.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        return iface->data.network.actual->bandwidth;\n    return iface->bandwidth;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevBandwidth *\nvirDomainNetGetActualBandwidth(const virDomainNetDef *iface)\n{\n    /* if there is an ActualNetDef, *always* return\n     * its bandwidth rather than the NetDef's bandwidth.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        return iface->data.network.actual->bandwidth;\n    return iface->bandwidth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unsupported network type %s\")",
            "virDomainNetTypeToString(type)"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetTypeToString",
          "args": [
            "type"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported network type %s\""
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "userns_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2329-2332",
          "snippet": "static int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCProcessSetupInterfaceDirect",
          "args": [
            "driver",
            "def",
            "net"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessSetupInterfaceDirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "338-396",
          "snippet": "char *\nvirLXCProcessSetupInterfaceDirect(virLXCDriverPtr driver,\n                                  virDomainDefPtr def,\n                                  virDomainNetDefPtr net)\n{\n    char *ret = NULL;\n    char *res_ifname = NULL;\n    const virNetDevBandwidth *bw;\n    const virNetDevVPortProfile *prof;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    const char *linkdev = virDomainNetGetActualDirectDev(net);\n    unsigned int macvlan_create_flags = VIR_NETDEV_MACVLAN_CREATE_IFUP;\n\n    /* XXX how todo bandwidth controls ?\n     * Since the 'net-ifname' is about to be moved to a different\n     * namespace & renamed, there will be no host side visible\n     * interface for the container to attach rules to\n     */\n    bw = virDomainNetGetActualBandwidth(net);\n    if (bw) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Unable to set network bandwidth on direct interfaces\"));\n        return NULL;\n    }\n\n    /* XXX how todo port profiles ?\n     * Although we can do the association during container\n     * startup, at shutdown we are unable to disassociate\n     * because the macvlan device was moved to the container\n     * and automagically dies when the container dies. So\n     * we have no dev to perform disassociation with.\n     */\n    prof = virDomainNetGetActualVirtPortProfile(net);\n    if (prof) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Unable to set port profile on direct interfaces\"));\n        return NULL;\n    }\n\n    if (virNetDevMacVLanCreateWithVPortProfile(\n            net->ifname, &net->mac,\n            linkdev,\n            virDomainNetGetActualDirectMode(net),\n            virDomainNetGetActualVlan(net),\n            def->uuid,\n            prof,\n            &res_ifname,\n            VIR_NETDEV_VPORT_PROFILE_OP_CREATE,\n            cfg->stateDir,\n            NULL, 0,\n            macvlan_create_flags) < 0)\n        goto cleanup;\n\n    ret = res_ifname;\n\n cleanup:\n    virObjectUnref(cfg);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nchar *\nvirLXCProcessSetupInterfaceDirect(virLXCDriverPtr driver,\n                                  virDomainDefPtr def,\n                                  virDomainNetDefPtr net)\n{\n    char *ret = NULL;\n    char *res_ifname = NULL;\n    const virNetDevBandwidth *bw;\n    const virNetDevVPortProfile *prof;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    const char *linkdev = virDomainNetGetActualDirectDev(net);\n    unsigned int macvlan_create_flags = VIR_NETDEV_MACVLAN_CREATE_IFUP;\n\n    /* XXX how todo bandwidth controls ?\n     * Since the 'net-ifname' is about to be moved to a different\n     * namespace & renamed, there will be no host side visible\n     * interface for the container to attach rules to\n     */\n    bw = virDomainNetGetActualBandwidth(net);\n    if (bw) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Unable to set network bandwidth on direct interfaces\"));\n        return NULL;\n    }\n\n    /* XXX how todo port profiles ?\n     * Although we can do the association during container\n     * startup, at shutdown we are unable to disassociate\n     * because the macvlan device was moved to the container\n     * and automagically dies when the container dies. So\n     * we have no dev to perform disassociation with.\n     */\n    prof = virDomainNetGetActualVirtPortProfile(net);\n    if (prof) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Unable to set port profile on direct interfaces\"));\n        return NULL;\n    }\n\n    if (virNetDevMacVLanCreateWithVPortProfile(\n            net->ifname, &net->mac,\n            linkdev,\n            virDomainNetGetActualDirectMode(net),\n            virDomainNetGetActualVlan(net),\n            def->uuid,\n            prof,\n            &res_ifname,\n            VIR_NETDEV_VPORT_PROFILE_OP_CREATE,\n            cfg->stateDir,\n            NULL, 0,\n            macvlan_create_flags) < 0)\n        goto cleanup;\n\n    ret = res_ifname;\n\n cleanup:\n    virObjectUnref(cfg);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCProcessSetupInterfaceTap",
          "args": [
            "def",
            "net",
            "NULL"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessSetupInterfaceTap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "277-335",
          "snippet": "char *\nvirLXCProcessSetupInterfaceTap(virDomainDefPtr vm,\n                               virDomainNetDefPtr net,\n                               const char *brname)\n{\n    char *parentVeth;\n    char *containerVeth = NULL;\n    const virNetDevVPortProfile *vport = virDomainNetGetActualVirtPortProfile(net);\n\n    VIR_DEBUG(\"calling vethCreate()\");\n    parentVeth = net->ifname;\n    if (virNetDevVethCreate(&parentVeth, &containerVeth) < 0)\n        return NULL;\n    VIR_DEBUG(\"parentVeth: %s, containerVeth: %s\", parentVeth, containerVeth);\n\n    if (net->ifname == NULL)\n        net->ifname = parentVeth;\n\n    if (virNetDevSetMAC(containerVeth, &net->mac) < 0)\n        return NULL;\n\n    if (brname) {\n        if (vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n            if (virNetDevOpenvswitchAddPort(brname, parentVeth, &net->mac, vm->uuid,\n                                            vport, virDomainNetGetActualVlan(net)) < 0)\n                return NULL;\n        } else {\n            if (virNetDevBridgeAddPort(brname, parentVeth) < 0)\n                return NULL;\n\n            if (virDomainNetGetActualPortOptionsIsolated(net) == VIR_TRISTATE_BOOL_YES &&\n                virNetDevBridgePortSetIsolated(brname, parentVeth, true) < 0) {\n                virErrorPtr err;\n\n                virErrorPreserveLast(&err);\n                ignore_value(virNetDevBridgeRemovePort(brname, parentVeth));\n                virErrorRestore(&err);\n                return NULL;\n            }\n        }\n    }\n\n    if (virNetDevSetOnline(parentVeth, true) < 0)\n        return NULL;\n\n    if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_ETHERNET) {\n        /* Set IP info for the host side, but only if the type is\n         * 'ethernet'.\n         */\n        if (virNetDevIPInfoAddToDev(parentVeth, &net->hostIP) < 0)\n            return NULL;\n    }\n\n    if (net->filter &&\n        virDomainConfNWFilterInstantiate(vm->name, vm->uuid, net, false) < 0)\n        return NULL;\n\n    return containerVeth;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nchar *\nvirLXCProcessSetupInterfaceTap(virDomainDefPtr vm,\n                               virDomainNetDefPtr net,\n                               const char *brname)\n{\n    char *parentVeth;\n    char *containerVeth = NULL;\n    const virNetDevVPortProfile *vport = virDomainNetGetActualVirtPortProfile(net);\n\n    VIR_DEBUG(\"calling vethCreate()\");\n    parentVeth = net->ifname;\n    if (virNetDevVethCreate(&parentVeth, &containerVeth) < 0)\n        return NULL;\n    VIR_DEBUG(\"parentVeth: %s, containerVeth: %s\", parentVeth, containerVeth);\n\n    if (net->ifname == NULL)\n        net->ifname = parentVeth;\n\n    if (virNetDevSetMAC(containerVeth, &net->mac) < 0)\n        return NULL;\n\n    if (brname) {\n        if (vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n            if (virNetDevOpenvswitchAddPort(brname, parentVeth, &net->mac, vm->uuid,\n                                            vport, virDomainNetGetActualVlan(net)) < 0)\n                return NULL;\n        } else {\n            if (virNetDevBridgeAddPort(brname, parentVeth) < 0)\n                return NULL;\n\n            if (virDomainNetGetActualPortOptionsIsolated(net) == VIR_TRISTATE_BOOL_YES &&\n                virNetDevBridgePortSetIsolated(brname, parentVeth, true) < 0) {\n                virErrorPtr err;\n\n                virErrorPreserveLast(&err);\n                ignore_value(virNetDevBridgeRemovePort(brname, parentVeth));\n                virErrorRestore(&err);\n                return NULL;\n            }\n        }\n    }\n\n    if (virNetDevSetOnline(parentVeth, true) < 0)\n        return NULL;\n\n    if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_ETHERNET) {\n        /* Set IP info for the host side, but only if the type is\n         * 'ethernet'.\n         */\n        if (virNetDevIPInfoAddToDev(parentVeth, &net->hostIP) < 0)\n            return NULL;\n    }\n\n    if (net->filter &&\n        virDomainConfNWFilterInstantiate(vm->name, vm->uuid, net, false) < 0)\n        return NULL;\n\n    return containerVeth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"No bridge name specified\")"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualType",
          "args": [
            "net"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30154-30162",
          "snippet": "virDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainActualNetDefValidate",
          "args": [
            "net"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainActualNetDefValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "6296-6354",
          "snippet": "int\nvirDomainActualNetDefValidate(const virDomainNetDef *net)\n{\n    /* Unlike virDomainNetDefValidate(), which is a static function\n     * called internally to this file, virDomainActualNetDefValidate()\n     * is a public function that can be called from a hypervisor after\n     * it has completely setup the NetDef for use by a domain,\n     * including possibly allocating a port from the network driver\n     * (which could change the effective/\"actual\" type of the NetDef,\n     * thus changing what should/shouldn't be allowed by validation).\n     *\n     * This function should contain validations not specific to a\n     * particular hypervisor (e.g. whether or not specifying bandwidth\n     * is allowed for a type of interface), but *not*\n     * hypervisor-specific things.\n     */\n    char macstr[VIR_MAC_STRING_BUFLEN];\n    virDomainNetType actualType = virDomainNetGetActualType(net);\n    const virNetDevVPortProfile *vport = virDomainNetGetActualVirtPortProfile(net);\n    const virNetDevBandwidth *bandwidth = virDomainNetGetActualBandwidth(net);\n\n    virMacAddrFormat(&net->mac, macstr);\n\n    if (virDomainNetGetActualVlan(net)) {\n        /* vlan configuration via libvirt is only supported for PCI\n         * Passthrough SR-IOV devices (hostdev or macvtap passthru\n         * mode) and openvswitch bridges. Otherwise log an error and\n         * fail\n         */\n        if (!(actualType == VIR_DOMAIN_NET_TYPE_HOSTDEV ||\n              (actualType == VIR_DOMAIN_NET_TYPE_DIRECT &&\n               virDomainNetGetActualDirectMode(net) == VIR_NETDEV_MACVLAN_MODE_PASSTHRU) ||\n              (actualType == VIR_DOMAIN_NET_TYPE_BRIDGE &&\n               vport  && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"interface %s - vlan tag not supported for this connection type\"),\n                           macstr);\n            return -1;\n        }\n    }\n\n    /* bandwidth configuration via libvirt is not supported for\n     * hostdev network devices\n     */\n    if (bandwidth && actualType == VIR_DOMAIN_NET_TYPE_HOSTDEV) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"interface %s - bandwidth settings are not supported \"\n                         \"for hostdev interfaces\"),\n                       macstr);\n        return -1;\n    }\n\n    if (virDomainNetDefValidatePortOptions(macstr, actualType, vport,\n                                           virDomainNetGetActualPortOptionsIsolated(net)) < 0) {\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainActualNetDefValidate(const virDomainNetDef *net)\n{\n    /* Unlike virDomainNetDefValidate(), which is a static function\n     * called internally to this file, virDomainActualNetDefValidate()\n     * is a public function that can be called from a hypervisor after\n     * it has completely setup the NetDef for use by a domain,\n     * including possibly allocating a port from the network driver\n     * (which could change the effective/\"actual\" type of the NetDef,\n     * thus changing what should/shouldn't be allowed by validation).\n     *\n     * This function should contain validations not specific to a\n     * particular hypervisor (e.g. whether or not specifying bandwidth\n     * is allowed for a type of interface), but *not*\n     * hypervisor-specific things.\n     */\n    char macstr[VIR_MAC_STRING_BUFLEN];\n    virDomainNetType actualType = virDomainNetGetActualType(net);\n    const virNetDevVPortProfile *vport = virDomainNetGetActualVirtPortProfile(net);\n    const virNetDevBandwidth *bandwidth = virDomainNetGetActualBandwidth(net);\n\n    virMacAddrFormat(&net->mac, macstr);\n\n    if (virDomainNetGetActualVlan(net)) {\n        /* vlan configuration via libvirt is only supported for PCI\n         * Passthrough SR-IOV devices (hostdev or macvtap passthru\n         * mode) and openvswitch bridges. Otherwise log an error and\n         * fail\n         */\n        if (!(actualType == VIR_DOMAIN_NET_TYPE_HOSTDEV ||\n              (actualType == VIR_DOMAIN_NET_TYPE_DIRECT &&\n               virDomainNetGetActualDirectMode(net) == VIR_NETDEV_MACVLAN_MODE_PASSTHRU) ||\n              (actualType == VIR_DOMAIN_NET_TYPE_BRIDGE &&\n               vport  && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"interface %s - vlan tag not supported for this connection type\"),\n                           macstr);\n            return -1;\n        }\n    }\n\n    /* bandwidth configuration via libvirt is not supported for\n     * hostdev network devices\n     */\n    if (bandwidth && actualType == VIR_DOMAIN_NET_TYPE_HOSTDEV) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"interface %s - bandwidth settings are not supported \"\n                         \"for hostdev interfaces\"),\n                       macstr);\n        return -1;\n    }\n\n    if (virDomainNetDefValidatePortOptions(macstr, actualType, vport,\n                                           virDomainNetGetActualPortOptionsIsolated(net)) < 0) {\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetAllocateActualDevice",
          "args": [
            "netconn",
            "def",
            "net"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetAllocateActualDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "31498-31504",
          "snippet": "int\nvirDomainNetAllocateActualDevice(virConnectPtr conn,\n                                 virDomainDefPtr dom,\n                                 virDomainNetDefPtr iface)\n{\n    return virDomainNetCreatePort(conn, dom, iface, 0);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainNetAllocateActualDevice(virConnectPtr conn,\n                                 virDomainDefPtr dom,\n                                 virDomainNetDefPtr iface)\n{\n    return virDomainNetCreatePort(conn, dom, iface, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetConnectNetwork",
          "args": [],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "virGetConnectNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "169-172",
          "snippet": "virConnectPtr virGetConnectNetwork(void)\n{\n    return virGetConnectGeneric(&connectNetwork, \"network\");\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal connectNetwork;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirThreadLocal connectNetwork;\n\nvirConnectPtr virGetConnectNetwork(void)\n{\n    return virGetConnectGeneric(&connectNetwork, \"network\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCProcessValidateInterface",
          "args": [
            "net"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessValidateInterface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "265-274",
          "snippet": "int\nvirLXCProcessValidateInterface(virDomainNetDefPtr net)\n{\n    if (net->script) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"scripts are not supported on LXC network interfaces\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirLXCProcessValidateInterface(virDomainNetDefPtr net)\n{\n    if (net->script) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"scripts are not supported on LXC network interfaces\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*veths",
            "def->nnets + 1"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirLXCProcessSetupInterfaces(virLXCDriverPtr driver,\n                             virDomainDefPtr def,\n                             char ***veths)\n{\n    int ret = -1;\n    size_t i;\n    size_t niface = 0;\n    virDomainNetDefPtr net;\n    virDomainNetType type;\n    virConnectPtr netconn = NULL;\n    virErrorPtr save_err = NULL;\n\n    if (VIR_ALLOC_N(*veths, def->nnets + 1) < 0)\n        return -1;\n\n    for (i = 0; i < def->nnets; i++) {\n        char *veth = NULL;\n        const virNetDevBandwidth *actualBandwidth;\n        /* If appropriate, grab a physical device from the configured\n         * network's pool of devices, or resolve bridge device name\n         * to the one defined in the network definition.\n         */\n        net = def->nets[i];\n\n        if (virLXCProcessValidateInterface(net) < 0)\n            goto cleanup;\n\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (!netconn && !(netconn = virGetConnectNetwork()))\n                goto cleanup;\n            if (virDomainNetAllocateActualDevice(netconn, def, net) < 0)\n                goto cleanup;\n        }\n\n        /* final validation now that actual type is known */\n        if (virDomainActualNetDefValidate(net) < 0)\n            return -1;\n\n        type = virDomainNetGetActualType(net);\n        switch (type) {\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE: {\n            const char *brname = virDomainNetGetActualBridgeName(net);\n            if (!brname) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"No bridge name specified\"));\n                goto cleanup;\n            }\n            if (!(veth = virLXCProcessSetupInterfaceTap(def, net, brname)))\n                goto cleanup;\n        }   break;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            if (!(veth = virLXCProcessSetupInterfaceTap(def, net, NULL)))\n                goto cleanup;\n            break;\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n            if (!(veth = virLXCProcessSetupInterfaceDirect(driver, def, net)))\n                goto cleanup;\n            break;\n\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unsupported network type %s\"),\n                           virDomainNetTypeToString(type));\n            goto cleanup;\n\n        }\n\n        /* Set bandwidth or warn if requested and not supported. */\n        actualBandwidth = virDomainNetGetActualBandwidth(net);\n        if (actualBandwidth) {\n            if (virNetDevSupportsBandwidth(type)) {\n                if (virNetDevBandwidthSet(net->ifname, actualBandwidth, false,\n                                          !virDomainNetTypeSharesHostView(net)) < 0)\n                    goto cleanup;\n            } else {\n                VIR_WARN(\"setting bandwidth on interfaces of \"\n                         \"type '%s' is not implemented yet\",\n                         virDomainNetTypeToString(type));\n            }\n        }\n\n        (*veths)[i] = veth;\n\n        def->nets[i]->ifname_guest_actual = g_strdup(veth);\n\n        /* Make sure all net definitions will have a name in the container */\n        if (!net->ifname_guest) {\n            net->ifname_guest = g_strdup_printf(\"eth%zu\", niface);\n            niface++;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        virErrorPreserveLast(&save_err);\n        for (i = 0; i < def->nnets; i++) {\n            virDomainNetDefPtr iface = def->nets[i];\n            const virNetDevVPortProfile *vport = virDomainNetGetActualVirtPortProfile(iface);\n            if (vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH)\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                virDomainNetGetActualBridgeName(iface),\n                                iface->ifname));\n            if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK && netconn)\n                virDomainNetReleaseActualDevice(netconn, def, iface);\n        }\n        virErrorRestore(&save_err);\n    }\n    virObjectUnref(netconn);\n    return ret;\n}"
  },
  {
    "function_name": "virLXCProcessSetupNamespaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "495-529",
    "snippet": "static int\nvirLXCProcessSetupNamespaces(virLXCDriverPtr driver,\n                             lxcDomainDefPtr lxcDef,\n                             int *nsFDs)\n{\n    size_t i;\n\n    for (i = 0; i < VIR_LXC_DOMAIN_NAMESPACE_LAST; i++)\n        nsFDs[i] = -1;\n    /* If there are no namespaces to be opened just return success */\n    if (lxcDef == NULL)\n        return 0;\n\n    for (i = 0; i < VIR_LXC_DOMAIN_NAMESPACE_LAST; i++) {\n        switch (lxcDef->ns_source[i]) {\n        case VIR_LXC_DOMAIN_NAMESPACE_SOURCE_NONE:\n            continue;\n        case VIR_LXC_DOMAIN_NAMESPACE_SOURCE_NAME:\n            if ((nsFDs[i] = virLXCProcessSetupNamespaceName(driver, i,\n                                                            lxcDef->ns_val[i])) < 0)\n                return -1;\n            break;\n        case VIR_LXC_DOMAIN_NAMESPACE_SOURCE_PID:\n            if ((nsFDs[i] = virLXCProcessSetupNamespacePID(i, lxcDef->ns_val[i])) < 0)\n                return -1;\n            break;\n        case VIR_LXC_DOMAIN_NAMESPACE_SOURCE_NETNS:\n            if ((nsFDs[i] = virLXCProcessSetupNamespaceNet(i, lxcDef->ns_val[i])) < 0)\n                return -1;\n            break;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLXCProcessSetupNamespaceNet",
          "args": [
            "i",
            "lxcDef->ns_val[i]"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessSetupNamespaceNet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "461-481",
          "snippet": "static int virLXCProcessSetupNamespaceNet(int ns_type, const char *name)\n{\n    char *path;\n    int fd;\n    if (ns_type != VIR_LXC_DOMAIN_NAMESPACE_SHARENET) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"'netns' namespace source can only be \"\n                         \"used with sharenet\"));\n        return -1;\n    }\n\n    path = g_strdup_printf(\"%s/netns/%s\", RUNSTATEDIR, name);\n    fd = open(path, O_RDONLY);\n    VIR_FREE(path);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to open netns %s\"), name);\n        return -1;\n    }\n    return fd;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int virLXCProcessSetupNamespaceNet(int ns_type, const char *name)\n{\n    char *path;\n    int fd;\n    if (ns_type != VIR_LXC_DOMAIN_NAMESPACE_SHARENET) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"'netns' namespace source can only be \"\n                         \"used with sharenet\"));\n        return -1;\n    }\n\n    path = g_strdup_printf(\"%s/netns/%s\", RUNSTATEDIR, name);\n    fd = open(path, O_RDONLY);\n    VIR_FREE(path);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to open netns %s\"), name);\n        return -1;\n    }\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCProcessSetupNamespacePID",
          "args": [
            "i",
            "lxcDef->ns_val[i]"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessSetupNamespacePID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "443-458",
          "snippet": "static int virLXCProcessSetupNamespacePID(int ns_type, const char *name)\n{\n    int fd;\n    char *path;\n\n    path = g_strdup_printf(\"/proc/%s/ns/%s\", name, nsInfoLocal[ns_type]);\n    fd = open(path, O_RDONLY);\n    VIR_FREE(path);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to open ns %s\"),\n                             virLXCDomainNamespaceTypeToString(ns_type));\n        return -1;\n    }\n    return fd;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *nsInfoLocal[VIR_LXC_DOMAIN_NAMESPACE_LAST] = {\n    [VIR_LXC_DOMAIN_NAMESPACE_SHARENET] = \"net\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREIPC] = \"ipc\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREUTS] = \"uts\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic const char *nsInfoLocal[VIR_LXC_DOMAIN_NAMESPACE_LAST] = {\n    [VIR_LXC_DOMAIN_NAMESPACE_SHARENET] = \"net\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREIPC] = \"ipc\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREUTS] = \"uts\",\n};\n\nstatic int virLXCProcessSetupNamespacePID(int ns_type, const char *name)\n{\n    int fd;\n    char *path;\n\n    path = g_strdup_printf(\"/proc/%s/ns/%s\", name, nsInfoLocal[ns_type]);\n    fd = open(path, O_RDONLY);\n    VIR_FREE(path);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to open ns %s\"),\n                             virLXCDomainNamespaceTypeToString(ns_type));\n        return -1;\n    }\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCProcessSetupNamespaceName",
          "args": [
            "driver",
            "i",
            "lxcDef->ns_val[i]"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessSetupNamespaceName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "404-440",
          "snippet": "static int virLXCProcessSetupNamespaceName(virLXCDriverPtr driver,\n                                           int ns_type,\n                                           const char *name)\n{\n    int fd = -1;\n    virDomainObjPtr vm;\n    virLXCDomainObjPrivatePtr priv;\n    g_autofree char *path = NULL;\n\n    vm = virDomainObjListFindByName(driver->domains, name);\n    if (!vm) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with matching name '%s'\"), name);\n        return -1;\n    }\n\n    priv = vm->privateData;\n    if (!priv->initpid) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Init pid is not yet available\"));\n        goto cleanup;\n    }\n\n    path = g_strdup_printf(\"/proc/%lld/ns/%s\", (long long int)priv->initpid,\n                           nsInfoLocal[ns_type]);\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to open ns %s\"),\n                             virLXCDomainNamespaceTypeToString(ns_type));\n        goto cleanup;\n    }\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return fd;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *nsInfoLocal[VIR_LXC_DOMAIN_NAMESPACE_LAST] = {\n    [VIR_LXC_DOMAIN_NAMESPACE_SHARENET] = \"net\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREIPC] = \"ipc\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREUTS] = \"uts\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic const char *nsInfoLocal[VIR_LXC_DOMAIN_NAMESPACE_LAST] = {\n    [VIR_LXC_DOMAIN_NAMESPACE_SHARENET] = \"net\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREIPC] = \"ipc\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREUTS] = \"uts\",\n};\n\nstatic int virLXCProcessSetupNamespaceName(virLXCDriverPtr driver,\n                                           int ns_type,\n                                           const char *name)\n{\n    int fd = -1;\n    virDomainObjPtr vm;\n    virLXCDomainObjPrivatePtr priv;\n    g_autofree char *path = NULL;\n\n    vm = virDomainObjListFindByName(driver->domains, name);\n    if (!vm) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with matching name '%s'\"), name);\n        return -1;\n    }\n\n    priv = vm->privateData;\n    if (!priv->initpid) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Init pid is not yet available\"));\n        goto cleanup;\n    }\n\n    path = g_strdup_printf(\"/proc/%lld/ns/%s\", (long long int)priv->initpid,\n                           nsInfoLocal[ns_type]);\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to open ns %s\"),\n                             virLXCDomainNamespaceTypeToString(ns_type));\n        goto cleanup;\n    }\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirLXCProcessSetupNamespaces(virLXCDriverPtr driver,\n                             lxcDomainDefPtr lxcDef,\n                             int *nsFDs)\n{\n    size_t i;\n\n    for (i = 0; i < VIR_LXC_DOMAIN_NAMESPACE_LAST; i++)\n        nsFDs[i] = -1;\n    /* If there are no namespaces to be opened just return success */\n    if (lxcDef == NULL)\n        return 0;\n\n    for (i = 0; i < VIR_LXC_DOMAIN_NAMESPACE_LAST; i++) {\n        switch (lxcDef->ns_source[i]) {\n        case VIR_LXC_DOMAIN_NAMESPACE_SOURCE_NONE:\n            continue;\n        case VIR_LXC_DOMAIN_NAMESPACE_SOURCE_NAME:\n            if ((nsFDs[i] = virLXCProcessSetupNamespaceName(driver, i,\n                                                            lxcDef->ns_val[i])) < 0)\n                return -1;\n            break;\n        case VIR_LXC_DOMAIN_NAMESPACE_SOURCE_PID:\n            if ((nsFDs[i] = virLXCProcessSetupNamespacePID(i, lxcDef->ns_val[i])) < 0)\n                return -1;\n            break;\n        case VIR_LXC_DOMAIN_NAMESPACE_SOURCE_NETNS:\n            if ((nsFDs[i] = virLXCProcessSetupNamespaceNet(i, lxcDef->ns_val[i])) < 0)\n                return -1;\n            break;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virLXCProcessSetupNamespaceNet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "461-481",
    "snippet": "static int virLXCProcessSetupNamespaceNet(int ns_type, const char *name)\n{\n    char *path;\n    int fd;\n    if (ns_type != VIR_LXC_DOMAIN_NAMESPACE_SHARENET) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"'netns' namespace source can only be \"\n                         \"used with sharenet\"));\n        return -1;\n    }\n\n    path = g_strdup_printf(\"%s/netns/%s\", RUNSTATEDIR, name);\n    fd = open(path, O_RDONLY);\n    VIR_FREE(path);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to open netns %s\"), name);\n        return -1;\n    }\n    return fd;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"failed to open netns %s\")",
            "name"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to open netns %s\""
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "userns_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2329-2332",
          "snippet": "static int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDONLY"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/netns/%s\"",
            "RUNSTATEDIR",
            "name"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"'netns' namespace source can only be \"\n                         \"used with sharenet\")"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int virLXCProcessSetupNamespaceNet(int ns_type, const char *name)\n{\n    char *path;\n    int fd;\n    if (ns_type != VIR_LXC_DOMAIN_NAMESPACE_SHARENET) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"'netns' namespace source can only be \"\n                         \"used with sharenet\"));\n        return -1;\n    }\n\n    path = g_strdup_printf(\"%s/netns/%s\", RUNSTATEDIR, name);\n    fd = open(path, O_RDONLY);\n    VIR_FREE(path);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to open netns %s\"), name);\n        return -1;\n    }\n    return fd;\n}"
  },
  {
    "function_name": "virLXCProcessSetupNamespacePID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "443-458",
    "snippet": "static int virLXCProcessSetupNamespacePID(int ns_type, const char *name)\n{\n    int fd;\n    char *path;\n\n    path = g_strdup_printf(\"/proc/%s/ns/%s\", name, nsInfoLocal[ns_type]);\n    fd = open(path, O_RDONLY);\n    VIR_FREE(path);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to open ns %s\"),\n                             virLXCDomainNamespaceTypeToString(ns_type));\n        return -1;\n    }\n    return fd;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *nsInfoLocal[VIR_LXC_DOMAIN_NAMESPACE_LAST] = {\n    [VIR_LXC_DOMAIN_NAMESPACE_SHARENET] = \"net\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREIPC] = \"ipc\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREUTS] = \"uts\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"failed to open ns %s\")",
            "virLXCDomainNamespaceTypeToString(ns_type)"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLXCDomainNamespaceTypeToString",
          "args": [
            "ns_type"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to open ns %s\""
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "userns_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2329-2332",
          "snippet": "static int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDONLY"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"/proc/%s/ns/%s\"",
            "name",
            "nsInfoLocal[ns_type]"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic const char *nsInfoLocal[VIR_LXC_DOMAIN_NAMESPACE_LAST] = {\n    [VIR_LXC_DOMAIN_NAMESPACE_SHARENET] = \"net\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREIPC] = \"ipc\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREUTS] = \"uts\",\n};\n\nstatic int virLXCProcessSetupNamespacePID(int ns_type, const char *name)\n{\n    int fd;\n    char *path;\n\n    path = g_strdup_printf(\"/proc/%s/ns/%s\", name, nsInfoLocal[ns_type]);\n    fd = open(path, O_RDONLY);\n    VIR_FREE(path);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to open ns %s\"),\n                             virLXCDomainNamespaceTypeToString(ns_type));\n        return -1;\n    }\n    return fd;\n}"
  },
  {
    "function_name": "virLXCProcessSetupNamespaceName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "404-440",
    "snippet": "static int virLXCProcessSetupNamespaceName(virLXCDriverPtr driver,\n                                           int ns_type,\n                                           const char *name)\n{\n    int fd = -1;\n    virDomainObjPtr vm;\n    virLXCDomainObjPrivatePtr priv;\n    g_autofree char *path = NULL;\n\n    vm = virDomainObjListFindByName(driver->domains, name);\n    if (!vm) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with matching name '%s'\"), name);\n        return -1;\n    }\n\n    priv = vm->privateData;\n    if (!priv->initpid) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Init pid is not yet available\"));\n        goto cleanup;\n    }\n\n    path = g_strdup_printf(\"/proc/%lld/ns/%s\", (long long int)priv->initpid,\n                           nsInfoLocal[ns_type]);\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to open ns %s\"),\n                             virLXCDomainNamespaceTypeToString(ns_type));\n        goto cleanup;\n    }\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return fd;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *nsInfoLocal[VIR_LXC_DOMAIN_NAMESPACE_LAST] = {\n    [VIR_LXC_DOMAIN_NAMESPACE_SHARENET] = \"net\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREIPC] = \"ipc\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREUTS] = \"uts\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"failed to open ns %s\")",
            "virLXCDomainNamespaceTypeToString(ns_type)"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLXCDomainNamespaceTypeToString",
          "args": [
            "ns_type"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to open ns %s\""
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "userns_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2329-2332",
          "snippet": "static int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDONLY"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"/proc/%lld/ns/%s\"",
            "(long long int)priv->initpid",
            "nsInfoLocal[ns_type]"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Init pid is not yet available\")"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "_(\"No domain with matching name '%s'\")",
            "name"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjListFindByName",
          "args": [
            "driver->domains",
            "name"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListFindByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "205-222",
          "snippet": "virDomainObjPtr\nvirDomainObjListFindByName(virDomainObjListPtr doms,\n                           const char *name)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByNameLocked(doms, name);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virDomainObjListDispose(void *obj);\n\nvirDomainObjPtr\nvirDomainObjListFindByName(virDomainObjListPtr doms,\n                           const char *name)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virDomainObjListFindByNameLocked(doms, name);\n    virObjectRWUnlock(doms);\n\n    if (obj && obj->removing) {\n        virObjectUnlock(obj);\n        virObjectUnref(obj);\n        obj = NULL;\n    }\n\n    return obj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic const char *nsInfoLocal[VIR_LXC_DOMAIN_NAMESPACE_LAST] = {\n    [VIR_LXC_DOMAIN_NAMESPACE_SHARENET] = \"net\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREIPC] = \"ipc\",\n    [VIR_LXC_DOMAIN_NAMESPACE_SHAREUTS] = \"uts\",\n};\n\nstatic int virLXCProcessSetupNamespaceName(virLXCDriverPtr driver,\n                                           int ns_type,\n                                           const char *name)\n{\n    int fd = -1;\n    virDomainObjPtr vm;\n    virLXCDomainObjPrivatePtr priv;\n    g_autofree char *path = NULL;\n\n    vm = virDomainObjListFindByName(driver->domains, name);\n    if (!vm) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with matching name '%s'\"), name);\n        return -1;\n    }\n\n    priv = vm->privateData;\n    if (!priv->initpid) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Init pid is not yet available\"));\n        goto cleanup;\n    }\n\n    path = g_strdup_printf(\"/proc/%lld/ns/%s\", (long long int)priv->initpid,\n                           nsInfoLocal[ns_type]);\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to open ns %s\"),\n                             virLXCDomainNamespaceTypeToString(ns_type));\n        goto cleanup;\n    }\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return fd;\n}"
  },
  {
    "function_name": "virLXCProcessSetupInterfaceDirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "338-396",
    "snippet": "char *\nvirLXCProcessSetupInterfaceDirect(virLXCDriverPtr driver,\n                                  virDomainDefPtr def,\n                                  virDomainNetDefPtr net)\n{\n    char *ret = NULL;\n    char *res_ifname = NULL;\n    const virNetDevBandwidth *bw;\n    const virNetDevVPortProfile *prof;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    const char *linkdev = virDomainNetGetActualDirectDev(net);\n    unsigned int macvlan_create_flags = VIR_NETDEV_MACVLAN_CREATE_IFUP;\n\n    /* XXX how todo bandwidth controls ?\n     * Since the 'net-ifname' is about to be moved to a different\n     * namespace & renamed, there will be no host side visible\n     * interface for the container to attach rules to\n     */\n    bw = virDomainNetGetActualBandwidth(net);\n    if (bw) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Unable to set network bandwidth on direct interfaces\"));\n        return NULL;\n    }\n\n    /* XXX how todo port profiles ?\n     * Although we can do the association during container\n     * startup, at shutdown we are unable to disassociate\n     * because the macvlan device was moved to the container\n     * and automagically dies when the container dies. So\n     * we have no dev to perform disassociation with.\n     */\n    prof = virDomainNetGetActualVirtPortProfile(net);\n    if (prof) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Unable to set port profile on direct interfaces\"));\n        return NULL;\n    }\n\n    if (virNetDevMacVLanCreateWithVPortProfile(\n            net->ifname, &net->mac,\n            linkdev,\n            virDomainNetGetActualDirectMode(net),\n            virDomainNetGetActualVlan(net),\n            def->uuid,\n            prof,\n            &res_ifname,\n            VIR_NETDEV_VPORT_PROFILE_OP_CREATE,\n            cfg->stateDir,\n            NULL, 0,\n            macvlan_create_flags) < 0)\n        goto cleanup;\n\n    ret = res_ifname;\n\n cleanup:\n    virObjectUnref(cfg);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevMacVLanCreateWithVPortProfile",
          "args": [
            "net->ifname",
            "&net->mac",
            "linkdev",
            "virDomainNetGetActualDirectMode(net)",
            "virDomainNetGetActualVlan(net)",
            "def->uuid",
            "prof",
            "&res_ifname",
            "VIR_NETDEV_VPORT_PROFILE_OP_CREATE",
            "cfg->stateDir",
            "NULL",
            "0",
            "macvlan_create_flags"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevMacVLanCreateWithVPortProfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevmacvlan.c",
          "lines": "1219-1236",
          "snippet": "int virNetDevMacVLanCreateWithVPortProfile(const char *ifname G_GNUC_UNUSED,\n                                           const virMacAddr *macaddress G_GNUC_UNUSED,\n                                           const char *linkdev G_GNUC_UNUSED,\n                                           virNetDevMacVLanMode mode G_GNUC_UNUSED,\n                                           const virNetDevVlan *vlan G_GNUC_UNUSED,\n                                           const unsigned char *vmuuid G_GNUC_UNUSED,\n                                           const virNetDevVPortProfile *virtPortProfile G_GNUC_UNUSED,\n                                           char **res_ifname G_GNUC_UNUSED,\n                                           virNetDevVPortProfileOp vmop G_GNUC_UNUSED,\n                                           char *stateDir G_GNUC_UNUSED,\n                                           int *tapfd G_GNUC_UNUSED,\n                                           size_t tapfdSize G_GNUC_UNUSED,\n                                           unsigned int unused_flags G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Cannot create macvlan devices on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virbitmap.h\"",
            "# include \"virpidfile.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virnetlink.h\"",
            "# include \"virfile.h\"",
            "# include \"viruuid.h\"",
            "# include \"virlog.h\"",
            "# include \"viralloc.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virbitmap.h\"\n# include \"virpidfile.h\"\n# include \"virnetdev.h\"\n# include \"virnetlink.h\"\n# include \"virfile.h\"\n# include \"viruuid.h\"\n# include \"virlog.h\"\n# include \"viralloc.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virnetdevmacvlan.h\"\n#include <config.h>\n\nint virNetDevMacVLanCreateWithVPortProfile(const char *ifname G_GNUC_UNUSED,\n                                           const virMacAddr *macaddress G_GNUC_UNUSED,\n                                           const char *linkdev G_GNUC_UNUSED,\n                                           virNetDevMacVLanMode mode G_GNUC_UNUSED,\n                                           const virNetDevVlan *vlan G_GNUC_UNUSED,\n                                           const unsigned char *vmuuid G_GNUC_UNUSED,\n                                           const virNetDevVPortProfile *virtPortProfile G_GNUC_UNUSED,\n                                           char **res_ifname G_GNUC_UNUSED,\n                                           virNetDevVPortProfileOp vmop G_GNUC_UNUSED,\n                                           char *stateDir G_GNUC_UNUSED,\n                                           int *tapfd G_GNUC_UNUSED,\n                                           size_t tapfdSize G_GNUC_UNUSED,\n                                           unsigned int unused_flags G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Cannot create macvlan devices on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVlan",
          "args": [
            "net"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30269-30284",
          "snippet": "const virNetDevVlan *\nvirDomainNetGetActualVlan(const virDomainNetDef *iface)\n{\n    const virNetDevVlan *vlan = &iface->vlan;\n\n    /* if there is an ActualNetDef, *always* return\n     * its vlan rather than the NetDef's vlan.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        vlan = &iface->data.network.actual->vlan;\n\n    if (vlan->nTags > 0)\n        return vlan;\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVlan *\nvirDomainNetGetActualVlan(const virDomainNetDef *iface)\n{\n    const virNetDevVlan *vlan = &iface->vlan;\n\n    /* if there is an ActualNetDef, *always* return\n     * its vlan rather than the NetDef's vlan.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        vlan = &iface->data.network.actual->vlan;\n\n    if (vlan->nTags > 0)\n        return vlan;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualDirectMode",
          "args": [
            "net"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualDirectMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30200-30210",
          "snippet": "int\nvirDomainNetGetActualDirectMode(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_DIRECT)\n        return iface->data.direct.mode;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_DIRECT)\n        return iface->data.network.actual->data.direct.mode;\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainNetGetActualDirectMode(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_DIRECT)\n        return iface->data.direct.mode;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_DIRECT)\n        return iface->data.network.actual->data.direct.mode;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Unable to set port profile on direct interfaces\")"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to set port profile on direct interfaces\""
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "userns_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2329-2332",
          "snippet": "static int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVirtPortProfile",
          "args": [
            "net"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVirtPortProfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30224-30255",
          "snippet": "const virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Unable to set network bandwidth on direct interfaces\")"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualBandwidth",
          "args": [
            "net"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualBandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30257-30267",
          "snippet": "const virNetDevBandwidth *\nvirDomainNetGetActualBandwidth(const virDomainNetDef *iface)\n{\n    /* if there is an ActualNetDef, *always* return\n     * its bandwidth rather than the NetDef's bandwidth.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        return iface->data.network.actual->bandwidth;\n    return iface->bandwidth;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevBandwidth *\nvirDomainNetGetActualBandwidth(const virDomainNetDef *iface)\n{\n    /* if there is an ActualNetDef, *always* return\n     * its bandwidth rather than the NetDef's bandwidth.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        return iface->data.network.actual->bandwidth;\n    return iface->bandwidth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualDirectDev",
          "args": [
            "net"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualDirectDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30188-30198",
          "snippet": "const char *\nvirDomainNetGetActualDirectDev(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_DIRECT)\n        return iface->data.direct.linkdev;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_DIRECT)\n        return iface->data.network.actual->data.direct.linkdev;\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainNetGetActualDirectDev(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_DIRECT)\n        return iface->data.direct.linkdev;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_DIRECT)\n        return iface->data.network.actual->data.direct.linkdev;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
          "lines": "279-286",
          "snippet": "virLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver)\n{\n    virLXCDriverConfigPtr cfg;\n    lxcDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    lxcDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"lxc_container.h\"",
            "#include \"configmake.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_conf.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virnodesuspend.h\"\n#include \"lxc_container.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_conf.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver)\n{\n    virLXCDriverConfigPtr cfg;\n    lxcDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    lxcDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nchar *\nvirLXCProcessSetupInterfaceDirect(virLXCDriverPtr driver,\n                                  virDomainDefPtr def,\n                                  virDomainNetDefPtr net)\n{\n    char *ret = NULL;\n    char *res_ifname = NULL;\n    const virNetDevBandwidth *bw;\n    const virNetDevVPortProfile *prof;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    const char *linkdev = virDomainNetGetActualDirectDev(net);\n    unsigned int macvlan_create_flags = VIR_NETDEV_MACVLAN_CREATE_IFUP;\n\n    /* XXX how todo bandwidth controls ?\n     * Since the 'net-ifname' is about to be moved to a different\n     * namespace & renamed, there will be no host side visible\n     * interface for the container to attach rules to\n     */\n    bw = virDomainNetGetActualBandwidth(net);\n    if (bw) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Unable to set network bandwidth on direct interfaces\"));\n        return NULL;\n    }\n\n    /* XXX how todo port profiles ?\n     * Although we can do the association during container\n     * startup, at shutdown we are unable to disassociate\n     * because the macvlan device was moved to the container\n     * and automagically dies when the container dies. So\n     * we have no dev to perform disassociation with.\n     */\n    prof = virDomainNetGetActualVirtPortProfile(net);\n    if (prof) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Unable to set port profile on direct interfaces\"));\n        return NULL;\n    }\n\n    if (virNetDevMacVLanCreateWithVPortProfile(\n            net->ifname, &net->mac,\n            linkdev,\n            virDomainNetGetActualDirectMode(net),\n            virDomainNetGetActualVlan(net),\n            def->uuid,\n            prof,\n            &res_ifname,\n            VIR_NETDEV_VPORT_PROFILE_OP_CREATE,\n            cfg->stateDir,\n            NULL, 0,\n            macvlan_create_flags) < 0)\n        goto cleanup;\n\n    ret = res_ifname;\n\n cleanup:\n    virObjectUnref(cfg);\n    return ret;\n}"
  },
  {
    "function_name": "virLXCProcessSetupInterfaceTap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "277-335",
    "snippet": "char *\nvirLXCProcessSetupInterfaceTap(virDomainDefPtr vm,\n                               virDomainNetDefPtr net,\n                               const char *brname)\n{\n    char *parentVeth;\n    char *containerVeth = NULL;\n    const virNetDevVPortProfile *vport = virDomainNetGetActualVirtPortProfile(net);\n\n    VIR_DEBUG(\"calling vethCreate()\");\n    parentVeth = net->ifname;\n    if (virNetDevVethCreate(&parentVeth, &containerVeth) < 0)\n        return NULL;\n    VIR_DEBUG(\"parentVeth: %s, containerVeth: %s\", parentVeth, containerVeth);\n\n    if (net->ifname == NULL)\n        net->ifname = parentVeth;\n\n    if (virNetDevSetMAC(containerVeth, &net->mac) < 0)\n        return NULL;\n\n    if (brname) {\n        if (vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n            if (virNetDevOpenvswitchAddPort(brname, parentVeth, &net->mac, vm->uuid,\n                                            vport, virDomainNetGetActualVlan(net)) < 0)\n                return NULL;\n        } else {\n            if (virNetDevBridgeAddPort(brname, parentVeth) < 0)\n                return NULL;\n\n            if (virDomainNetGetActualPortOptionsIsolated(net) == VIR_TRISTATE_BOOL_YES &&\n                virNetDevBridgePortSetIsolated(brname, parentVeth, true) < 0) {\n                virErrorPtr err;\n\n                virErrorPreserveLast(&err);\n                ignore_value(virNetDevBridgeRemovePort(brname, parentVeth));\n                virErrorRestore(&err);\n                return NULL;\n            }\n        }\n    }\n\n    if (virNetDevSetOnline(parentVeth, true) < 0)\n        return NULL;\n\n    if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_ETHERNET) {\n        /* Set IP info for the host side, but only if the type is\n         * 'ethernet'.\n         */\n        if (virNetDevIPInfoAddToDev(parentVeth, &net->hostIP) < 0)\n            return NULL;\n    }\n\n    if (net->filter &&\n        virDomainConfNWFilterInstantiate(vm->name, vm->uuid, net, false) < 0)\n        return NULL;\n\n    return containerVeth;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainConfNWFilterInstantiate",
          "args": [
            "vm->name",
            "vm->uuid",
            "net",
            "false"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainConfNWFilterInstantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_nwfilter.c",
          "lines": "78-121",
          "snippet": "int\nvirDomainConfNWFilterInstantiate(const char *vmname,\n                                 const unsigned char *vmuuid,\n                                 virDomainNetDefPtr net,\n                                 bool ignoreExists)\n{\n    virConnectPtr conn = virGetConnectNWFilter();\n    virNWFilterBindingDefPtr def = NULL;\n    virNWFilterBindingPtr binding = NULL;\n    char *xml = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"vmname=%s portdev=%s filter=%s ignoreExists=%d\",\n              vmname, NULLSTR(net->ifname), NULLSTR(net->filter), ignoreExists);\n\n    if (!conn)\n        goto cleanup;\n\n    if (ignoreExists) {\n        binding = virNWFilterBindingLookupByPortDev(conn, net->ifname);\n        if (binding) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!(def = virNWFilterBindingDefForNet(vmname, vmuuid, net)))\n        goto cleanup;\n\n    if (!(xml = virNWFilterBindingDefFormat(def)))\n        goto cleanup;\n\n    if (!(binding = virNWFilterBindingCreateXML(conn, xml, 0)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(xml);\n    virNWFilterBindingDefFree(def);\n    virObjectUnref(binding);\n    virObjectUnref(conn);\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnwfilterbindingdef.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnwfilterbindingdef.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDomainConfNWFilterInstantiate(const char *vmname,\n                                 const unsigned char *vmuuid,\n                                 virDomainNetDefPtr net,\n                                 bool ignoreExists)\n{\n    virConnectPtr conn = virGetConnectNWFilter();\n    virNWFilterBindingDefPtr def = NULL;\n    virNWFilterBindingPtr binding = NULL;\n    char *xml = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"vmname=%s portdev=%s filter=%s ignoreExists=%d\",\n              vmname, NULLSTR(net->ifname), NULLSTR(net->filter), ignoreExists);\n\n    if (!conn)\n        goto cleanup;\n\n    if (ignoreExists) {\n        binding = virNWFilterBindingLookupByPortDev(conn, net->ifname);\n        if (binding) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!(def = virNWFilterBindingDefForNet(vmname, vmuuid, net)))\n        goto cleanup;\n\n    if (!(xml = virNWFilterBindingDefFormat(def)))\n        goto cleanup;\n\n    if (!(binding = virNWFilterBindingCreateXML(conn, xml, 0)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(xml);\n    virNWFilterBindingDefFree(def);\n    virObjectUnref(binding);\n    virObjectUnref(conn);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevIPInfoAddToDev",
          "args": [
            "parentVeth",
            "&net->hostIP"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPInfoAddToDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "1071-1113",
          "snippet": "int\nvirNetDevIPInfoAddToDev(const char *ifname,\n                        virNetDevIPInfo const *ipInfo)\n{\n    size_t i;\n    int prefix;\n    g_autofree char *ipStr = NULL;\n\n    /* add all IP addresses */\n    for (i = 0; i < ipInfo->nips; i++) {\n        virNetDevIPAddrPtr ip = ipInfo->ips[i];\n\n        if ((prefix = virSocketAddrGetIPPrefix(&ip->address,\n                                               NULL, ip->prefix)) < 0) {\n            ipStr = virSocketAddrFormat(&ip->address);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to determine prefix for IP address '%s'\"),\n                           NULLSTR(ipStr));\n            return -1;\n        }\n        if (virNetDevIPAddrAdd(ifname, &ip->address, &ip->peer, prefix) < 0)\n            return -1;\n    }\n\n    /* add all routes */\n    for (i = 0; i < ipInfo->nroutes; i++) {\n        virNetDevIPRoutePtr route = ipInfo->routes[i];\n\n        if ((prefix = virNetDevIPRouteGetPrefix(route)) < 0) {\n            ipStr = virSocketAddrFormat(&route->address);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to determine prefix for route with destination '%s'\"),\n                           NULLSTR(ipStr));\n            return -1;\n        }\n        if (virNetDevIPRouteAdd(ifname, &route->address, prefix,\n                                &route->gateway,\n                                virNetDevIPRouteGetMetric(route)) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPInfoAddToDev(const char *ifname,\n                        virNetDevIPInfo const *ipInfo)\n{\n    size_t i;\n    int prefix;\n    g_autofree char *ipStr = NULL;\n\n    /* add all IP addresses */\n    for (i = 0; i < ipInfo->nips; i++) {\n        virNetDevIPAddrPtr ip = ipInfo->ips[i];\n\n        if ((prefix = virSocketAddrGetIPPrefix(&ip->address,\n                                               NULL, ip->prefix)) < 0) {\n            ipStr = virSocketAddrFormat(&ip->address);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to determine prefix for IP address '%s'\"),\n                           NULLSTR(ipStr));\n            return -1;\n        }\n        if (virNetDevIPAddrAdd(ifname, &ip->address, &ip->peer, prefix) < 0)\n            return -1;\n    }\n\n    /* add all routes */\n    for (i = 0; i < ipInfo->nroutes; i++) {\n        virNetDevIPRoutePtr route = ipInfo->routes[i];\n\n        if ((prefix = virNetDevIPRouteGetPrefix(route)) < 0) {\n            ipStr = virSocketAddrFormat(&route->address);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to determine prefix for route with destination '%s'\"),\n                           NULLSTR(ipStr));\n            return -1;\n        }\n        if (virNetDevIPRouteAdd(ifname, &route->address, prefix,\n                                &route->gateway,\n                                virNetDevIPRouteGetMetric(route)) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualType",
          "args": [
            "net"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30154-30162",
          "snippet": "virDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevSetOnline",
          "args": [
            "parentVeth",
            "true"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevSetOnline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "660-665",
          "snippet": "int\nvirNetDevSetOnline(const char *ifname,\n                   bool online)\n{\n    return virNetDevSetIFFlag(ifname, VIR_IFF_UP, online);\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevSetOnline(const char *ifname,\n                   bool online)\n{\n    return virNetDevSetIFFlag(ifname, VIR_IFF_UP, online);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&err"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevBridgeRemovePort(brname, parentVeth)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevBridgeRemovePort",
          "args": [
            "brname",
            "parentVeth"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBridgeRemovePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbridge.c",
          "lines": "727-733",
          "snippet": "int virNetDevBridgeRemovePort(const char *brname,\n                              const char *ifname)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to remove bridge %s port %s\"), brname, ifname);\n    return -1;\n}",
          "includes": [
            "# include <net/if_bridgevar.h>",
            "# include <net/ethernet.h>",
            "# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */",
            "# include <linux/in6.h>",
            "# include <linux/param.h>     /* HZ                 */",
            "# include <linux/sockios.h>",
            "#  include \"virnetlink.h\"",
            "# include <net/if.h>",
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <net/if_bridgevar.h>\n# include <net/ethernet.h>\n# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */\n# include <linux/in6.h>\n# include <linux/param.h>     /* HZ                 */\n# include <linux/sockios.h>\n#  include \"virnetlink.h\"\n# include <net/if.h>\n#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevbridge.h\"\n#include <config.h>\n\nint virNetDevBridgeRemovePort(const char *brname,\n                              const char *ifname)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to remove bridge %s port %s\"), brname, ifname);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&err"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBridgePortSetIsolated",
          "args": [
            "brname",
            "parentVeth",
            "true"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBridgePortSetIsolated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbridge.c",
          "lines": "393-401",
          "snippet": "int\nvirNetDevBridgePortSetIsolated(const char *brname G_GNUC_UNUSED,\n                               const char *ifname G_GNUC_UNUSED,\n                               bool enable G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to set bridge port isolated on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <net/if_bridgevar.h>",
            "# include <net/ethernet.h>",
            "# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */",
            "# include <linux/in6.h>",
            "# include <linux/param.h>     /* HZ                 */",
            "# include <linux/sockios.h>",
            "#  include \"virnetlink.h\"",
            "# include <net/if.h>",
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <net/if_bridgevar.h>\n# include <net/ethernet.h>\n# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */\n# include <linux/in6.h>\n# include <linux/param.h>     /* HZ                 */\n# include <linux/sockios.h>\n#  include \"virnetlink.h\"\n# include <net/if.h>\n#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevbridge.h\"\n#include <config.h>\n\nint\nvirNetDevBridgePortSetIsolated(const char *brname G_GNUC_UNUSED,\n                               const char *ifname G_GNUC_UNUSED,\n                               bool enable G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to set bridge port isolated on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualPortOptionsIsolated",
          "args": [
            "net"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualPortOptionsIsolated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30287-30295",
          "snippet": "virTristateBool\nvirDomainNetGetActualPortOptionsIsolated(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual) {\n        return iface->data.network.actual->isolatedPort;\n    }\n    return iface->isolatedPort;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirTristateBool\nvirDomainNetGetActualPortOptionsIsolated(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual) {\n        return iface->data.network.actual->isolatedPort;\n    }\n    return iface->isolatedPort;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBridgeAddPort",
          "args": [
            "brname",
            "parentVeth"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBridgeAddPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbridge.c",
          "lines": "661-667",
          "snippet": "int virNetDevBridgeAddPort(const char *brname,\n                           const char *ifname)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to add bridge %s port %s\"), brname, ifname);\n    return -1;\n}",
          "includes": [
            "# include <net/if_bridgevar.h>",
            "# include <net/ethernet.h>",
            "# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */",
            "# include <linux/in6.h>",
            "# include <linux/param.h>     /* HZ                 */",
            "# include <linux/sockios.h>",
            "#  include \"virnetlink.h\"",
            "# include <net/if.h>",
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <net/if_bridgevar.h>\n# include <net/ethernet.h>\n# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */\n# include <linux/in6.h>\n# include <linux/param.h>     /* HZ                 */\n# include <linux/sockios.h>\n#  include \"virnetlink.h\"\n# include <net/if.h>\n#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevbridge.h\"\n#include <config.h>\n\nint virNetDevBridgeAddPort(const char *brname,\n                           const char *ifname)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to add bridge %s port %s\"), brname, ifname);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevOpenvswitchAddPort",
          "args": [
            "brname",
            "parentVeth",
            "&net->mac",
            "vm->uuid",
            "vport",
            "virDomainNetGetActualVlan(net)"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevOpenvswitchAddPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevopenvswitch.c",
          "lines": "132-195",
          "snippet": "int virNetDevOpenvswitchAddPort(const char *brname, const char *ifname,\n                                const virMacAddr *macaddr,\n                                const unsigned char *vmuuid,\n                                const virNetDevVPortProfile *ovsport,\n                                const virNetDevVlan *virtVlan)\n{\n    char macaddrstr[VIR_MAC_STRING_BUFLEN];\n    char ifuuidstr[VIR_UUID_STRING_BUFLEN];\n    char vmuuidstr[VIR_UUID_STRING_BUFLEN];\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *attachedmac_ex_id = NULL;\n    g_autofree char *ifaceid_ex_id = NULL;\n    g_autofree char *profile_ex_id = NULL;\n    g_autofree char *vmid_ex_id = NULL;\n\n    virMacAddrFormat(macaddr, macaddrstr);\n    virUUIDFormat(ovsport->interfaceID, ifuuidstr);\n    virUUIDFormat(vmuuid, vmuuidstr);\n\n    attachedmac_ex_id = g_strdup_printf(\"external-ids:attached-mac=\\\"%s\\\"\",\n                                        macaddrstr);\n    ifaceid_ex_id = g_strdup_printf(\"external-ids:iface-id=\\\"%s\\\"\", ifuuidstr);\n    vmid_ex_id = g_strdup_printf(\"external-ids:vm-id=\\\"%s\\\"\", vmuuidstr);\n    if (ovsport->profileID[0] != '\\0') {\n        profile_ex_id = g_strdup_printf(\"external-ids:port-profile=\\\"%s\\\"\",\n                                        ovsport->profileID);\n    }\n\n    cmd = virCommandNew(OVSVSCTL);\n    virNetDevOpenvswitchAddTimeout(cmd);\n    virCommandAddArgList(cmd, \"--\", \"--if-exists\", \"del-port\",\n                         ifname, \"--\", \"add-port\", brname, ifname, NULL);\n\n    if (virNetDevOpenvswitchConstructVlans(cmd, virtVlan) < 0)\n        return -1;\n\n    if (ovsport->profileID[0] == '\\0') {\n        virCommandAddArgList(cmd,\n                             \"--\", \"set\", \"Interface\", ifname, attachedmac_ex_id,\n                             \"--\", \"set\", \"Interface\", ifname, ifaceid_ex_id,\n                             \"--\", \"set\", \"Interface\", ifname, vmid_ex_id,\n                             \"--\", \"set\", \"Interface\", ifname,\n                             \"external-ids:iface-status=active\",\n                             NULL);\n    } else {\n        virCommandAddArgList(cmd,\n                             \"--\", \"set\", \"Interface\", ifname, attachedmac_ex_id,\n                             \"--\", \"set\", \"Interface\", ifname, ifaceid_ex_id,\n                             \"--\", \"set\", \"Interface\", ifname, vmid_ex_id,\n                             \"--\", \"set\", \"Interface\", ifname, profile_ex_id,\n                             \"--\", \"set\", \"Interface\", ifname,\n                             \"external-ids:iface-status=active\",\n                             NULL);\n    }\n\n    if (virCommandRun(cmd, NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to add port %s to OVS bridge %s\"),\n                       ifname, brname);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virjson.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virjson.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virmacaddr.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevopenvswitch.h\"\n#include <config.h>\n\nint virNetDevOpenvswitchAddPort(const char *brname, const char *ifname,\n                                const virMacAddr *macaddr,\n                                const unsigned char *vmuuid,\n                                const virNetDevVPortProfile *ovsport,\n                                const virNetDevVlan *virtVlan)\n{\n    char macaddrstr[VIR_MAC_STRING_BUFLEN];\n    char ifuuidstr[VIR_UUID_STRING_BUFLEN];\n    char vmuuidstr[VIR_UUID_STRING_BUFLEN];\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *attachedmac_ex_id = NULL;\n    g_autofree char *ifaceid_ex_id = NULL;\n    g_autofree char *profile_ex_id = NULL;\n    g_autofree char *vmid_ex_id = NULL;\n\n    virMacAddrFormat(macaddr, macaddrstr);\n    virUUIDFormat(ovsport->interfaceID, ifuuidstr);\n    virUUIDFormat(vmuuid, vmuuidstr);\n\n    attachedmac_ex_id = g_strdup_printf(\"external-ids:attached-mac=\\\"%s\\\"\",\n                                        macaddrstr);\n    ifaceid_ex_id = g_strdup_printf(\"external-ids:iface-id=\\\"%s\\\"\", ifuuidstr);\n    vmid_ex_id = g_strdup_printf(\"external-ids:vm-id=\\\"%s\\\"\", vmuuidstr);\n    if (ovsport->profileID[0] != '\\0') {\n        profile_ex_id = g_strdup_printf(\"external-ids:port-profile=\\\"%s\\\"\",\n                                        ovsport->profileID);\n    }\n\n    cmd = virCommandNew(OVSVSCTL);\n    virNetDevOpenvswitchAddTimeout(cmd);\n    virCommandAddArgList(cmd, \"--\", \"--if-exists\", \"del-port\",\n                         ifname, \"--\", \"add-port\", brname, ifname, NULL);\n\n    if (virNetDevOpenvswitchConstructVlans(cmd, virtVlan) < 0)\n        return -1;\n\n    if (ovsport->profileID[0] == '\\0') {\n        virCommandAddArgList(cmd,\n                             \"--\", \"set\", \"Interface\", ifname, attachedmac_ex_id,\n                             \"--\", \"set\", \"Interface\", ifname, ifaceid_ex_id,\n                             \"--\", \"set\", \"Interface\", ifname, vmid_ex_id,\n                             \"--\", \"set\", \"Interface\", ifname,\n                             \"external-ids:iface-status=active\",\n                             NULL);\n    } else {\n        virCommandAddArgList(cmd,\n                             \"--\", \"set\", \"Interface\", ifname, attachedmac_ex_id,\n                             \"--\", \"set\", \"Interface\", ifname, ifaceid_ex_id,\n                             \"--\", \"set\", \"Interface\", ifname, vmid_ex_id,\n                             \"--\", \"set\", \"Interface\", ifname, profile_ex_id,\n                             \"--\", \"set\", \"Interface\", ifname,\n                             \"external-ids:iface-status=active\",\n                             NULL);\n    }\n\n    if (virCommandRun(cmd, NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to add port %s to OVS bridge %s\"),\n                       ifname, brname);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVlan",
          "args": [
            "net"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30269-30284",
          "snippet": "const virNetDevVlan *\nvirDomainNetGetActualVlan(const virDomainNetDef *iface)\n{\n    const virNetDevVlan *vlan = &iface->vlan;\n\n    /* if there is an ActualNetDef, *always* return\n     * its vlan rather than the NetDef's vlan.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        vlan = &iface->data.network.actual->vlan;\n\n    if (vlan->nTags > 0)\n        return vlan;\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVlan *\nvirDomainNetGetActualVlan(const virDomainNetDef *iface)\n{\n    const virNetDevVlan *vlan = &iface->vlan;\n\n    /* if there is an ActualNetDef, *always* return\n     * its vlan rather than the NetDef's vlan.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        vlan = &iface->data.network.actual->vlan;\n\n    if (vlan->nTags > 0)\n        return vlan;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevSetMAC",
          "args": [
            "containerVeth",
            "&net->mac"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevSetMAC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "346-351",
          "snippet": "int\nvirNetDevSetMAC(const char *ifname,\n                const virMacAddr *macaddr)\n{\n    return virNetDevSetMACInternal(ifname, macaddr, false);\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevSetMAC(const char *ifname,\n                const virMacAddr *macaddr)\n{\n    return virNetDevSetMACInternal(ifname, macaddr, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"parentVeth: %s, containerVeth: %s\"",
            "parentVeth",
            "containerVeth"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVethCreate",
          "args": [
            "&parentVeth",
            "&containerVeth"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVethCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevveth.c",
          "lines": "103-176",
          "snippet": "int virNetDevVethCreate(char** veth1, char** veth2)\n{\n    int ret = -1;\n    int vethNum = 0;\n    size_t i;\n\n    /*\n     * We might race with other containers, but this is reasonably\n     * unlikely, so don't do too many retries for device creation\n     */\n    virMutexLock(&virNetDevVethCreateMutex);\n#define MAX_VETH_RETRIES 10\n\n    for (i = 0; i < MAX_VETH_RETRIES; i++) {\n        g_autofree char *veth1auto = NULL;\n        g_autofree char *veth2auto = NULL;\n        g_autoptr(virCommand) cmd = NULL;\n\n        int status;\n        if (!*veth1) {\n            int veth1num;\n            if ((veth1num = virNetDevVethGetFreeNum(vethNum)) < 0)\n                goto cleanup;\n\n            veth1auto = g_strdup_printf(\"vnet%d\", veth1num);\n            vethNum = veth1num + 1;\n        }\n        if (!*veth2) {\n            int veth2num;\n            if ((veth2num = virNetDevVethGetFreeNum(vethNum)) < 0)\n                goto cleanup;\n\n            veth2auto = g_strdup_printf(\"vnet%d\", veth2num);\n            vethNum = veth2num + 1;\n        }\n\n        cmd = virCommandNew(\"ip\");\n        virCommandAddArgList(cmd, \"link\", \"add\",\n                             *veth1 ? *veth1 : veth1auto,\n                             \"type\", \"veth\", \"peer\", \"name\",\n                             *veth2 ? *veth2 : veth2auto,\n                             NULL);\n\n        if (virCommandRun(cmd, &status) < 0)\n            goto cleanup;\n\n        if (status == 0) {\n            if (veth1auto) {\n                *veth1 = veth1auto;\n                veth1auto = NULL;\n            }\n            if (veth2auto) {\n                *veth2 = veth2auto;\n                veth2auto = NULL;\n            }\n            VIR_DEBUG(\"Create Host: %s guest: %s\", *veth1, *veth2);\n            ret = 0;\n            goto cleanup;\n        }\n\n        VIR_DEBUG(\"Failed to create veth host: %s guest: %s: %d\",\n                  *veth1 ? *veth1 : veth1auto,\n                  *veth2 ? *veth2 : veth2auto,\n                  status);\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Failed to allocate free veth pair after %d attempts\"),\n                   MAX_VETH_RETRIES);\n\n cleanup:\n    virMutexUnlock(&virNetDevVethCreateMutex);\n    return ret;\n}",
          "includes": [
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdevveth.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_VETH_RETRIES 10"
          ],
          "globals_used": [
            "virMutex virNetDevVethCreateMutex = VIR_MUTEX_INITIALIZER;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virnetdevveth.h\"\n#include <config.h>\n\n#define MAX_VETH_RETRIES 10\n\nvirMutex virNetDevVethCreateMutex = VIR_MUTEX_INITIALIZER;\n\nint virNetDevVethCreate(char** veth1, char** veth2)\n{\n    int ret = -1;\n    int vethNum = 0;\n    size_t i;\n\n    /*\n     * We might race with other containers, but this is reasonably\n     * unlikely, so don't do too many retries for device creation\n     */\n    virMutexLock(&virNetDevVethCreateMutex);\n#define MAX_VETH_RETRIES 10\n\n    for (i = 0; i < MAX_VETH_RETRIES; i++) {\n        g_autofree char *veth1auto = NULL;\n        g_autofree char *veth2auto = NULL;\n        g_autoptr(virCommand) cmd = NULL;\n\n        int status;\n        if (!*veth1) {\n            int veth1num;\n            if ((veth1num = virNetDevVethGetFreeNum(vethNum)) < 0)\n                goto cleanup;\n\n            veth1auto = g_strdup_printf(\"vnet%d\", veth1num);\n            vethNum = veth1num + 1;\n        }\n        if (!*veth2) {\n            int veth2num;\n            if ((veth2num = virNetDevVethGetFreeNum(vethNum)) < 0)\n                goto cleanup;\n\n            veth2auto = g_strdup_printf(\"vnet%d\", veth2num);\n            vethNum = veth2num + 1;\n        }\n\n        cmd = virCommandNew(\"ip\");\n        virCommandAddArgList(cmd, \"link\", \"add\",\n                             *veth1 ? *veth1 : veth1auto,\n                             \"type\", \"veth\", \"peer\", \"name\",\n                             *veth2 ? *veth2 : veth2auto,\n                             NULL);\n\n        if (virCommandRun(cmd, &status) < 0)\n            goto cleanup;\n\n        if (status == 0) {\n            if (veth1auto) {\n                *veth1 = veth1auto;\n                veth1auto = NULL;\n            }\n            if (veth2auto) {\n                *veth2 = veth2auto;\n                veth2auto = NULL;\n            }\n            VIR_DEBUG(\"Create Host: %s guest: %s\", *veth1, *veth2);\n            ret = 0;\n            goto cleanup;\n        }\n\n        VIR_DEBUG(\"Failed to create veth host: %s guest: %s: %d\",\n                  *veth1 ? *veth1 : veth1auto,\n                  *veth2 ? *veth2 : veth2auto,\n                  status);\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Failed to allocate free veth pair after %d attempts\"),\n                   MAX_VETH_RETRIES);\n\n cleanup:\n    virMutexUnlock(&virNetDevVethCreateMutex);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"calling vethCreate()\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVirtPortProfile",
          "args": [
            "net"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVirtPortProfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30224-30255",
          "snippet": "const virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nchar *\nvirLXCProcessSetupInterfaceTap(virDomainDefPtr vm,\n                               virDomainNetDefPtr net,\n                               const char *brname)\n{\n    char *parentVeth;\n    char *containerVeth = NULL;\n    const virNetDevVPortProfile *vport = virDomainNetGetActualVirtPortProfile(net);\n\n    VIR_DEBUG(\"calling vethCreate()\");\n    parentVeth = net->ifname;\n    if (virNetDevVethCreate(&parentVeth, &containerVeth) < 0)\n        return NULL;\n    VIR_DEBUG(\"parentVeth: %s, containerVeth: %s\", parentVeth, containerVeth);\n\n    if (net->ifname == NULL)\n        net->ifname = parentVeth;\n\n    if (virNetDevSetMAC(containerVeth, &net->mac) < 0)\n        return NULL;\n\n    if (brname) {\n        if (vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n            if (virNetDevOpenvswitchAddPort(brname, parentVeth, &net->mac, vm->uuid,\n                                            vport, virDomainNetGetActualVlan(net)) < 0)\n                return NULL;\n        } else {\n            if (virNetDevBridgeAddPort(brname, parentVeth) < 0)\n                return NULL;\n\n            if (virDomainNetGetActualPortOptionsIsolated(net) == VIR_TRISTATE_BOOL_YES &&\n                virNetDevBridgePortSetIsolated(brname, parentVeth, true) < 0) {\n                virErrorPtr err;\n\n                virErrorPreserveLast(&err);\n                ignore_value(virNetDevBridgeRemovePort(brname, parentVeth));\n                virErrorRestore(&err);\n                return NULL;\n            }\n        }\n    }\n\n    if (virNetDevSetOnline(parentVeth, true) < 0)\n        return NULL;\n\n    if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_ETHERNET) {\n        /* Set IP info for the host side, but only if the type is\n         * 'ethernet'.\n         */\n        if (virNetDevIPInfoAddToDev(parentVeth, &net->hostIP) < 0)\n            return NULL;\n    }\n\n    if (net->filter &&\n        virDomainConfNWFilterInstantiate(vm->name, vm->uuid, net, false) < 0)\n        return NULL;\n\n    return containerVeth;\n}"
  },
  {
    "function_name": "virLXCProcessValidateInterface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "265-274",
    "snippet": "int\nvirLXCProcessValidateInterface(virDomainNetDefPtr net)\n{\n    if (net->script) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"scripts are not supported on LXC network interfaces\"));\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"scripts are not supported on LXC network interfaces\")"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"scripts are not supported on LXC network interfaces\""
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "userns_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2329-2332",
          "snippet": "static int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirLXCProcessValidateInterface(virDomainNetDefPtr net)\n{\n    if (net->script) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"scripts are not supported on LXC network interfaces\"));\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virLXCProcessCleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "158-262",
    "snippet": "static void virLXCProcessCleanup(virLXCDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 virDomainShutoffReason reason)\n{\n    size_t i;\n    virLXCDomainObjPrivatePtr priv = vm->privateData;\n    const virNetDevVPortProfile *vport = NULL;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    virConnectPtr conn = NULL;\n\n    VIR_DEBUG(\"Cleanup VM name=%s pid=%d reason=%d\",\n              vm->def->name, (int)vm->pid, (int)reason);\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                    VIR_HOOK_LXC_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n        VIR_FREE(xml);\n    }\n\n    virSecurityManagerRestoreAllLabel(driver->securityManager,\n                                      vm->def, false, false);\n    virSecurityManagerReleaseLabel(driver->securityManager, vm->def);\n    /* Clear out dynamically assigned labels */\n    if (vm->def->nseclabels &&\n        vm->def->seclabels[0]->type == VIR_DOMAIN_SECLABEL_DYNAMIC) {\n        VIR_FREE(vm->def->seclabels[0]->model);\n        VIR_FREE(vm->def->seclabels[0]->label);\n        VIR_FREE(vm->def->seclabels[0]->imagelabel);\n    }\n\n    /* Stop autodestroy in case guest is restarted */\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           lxcProcessAutoDestroy);\n\n    if (priv->monitor) {\n        virLXCMonitorClose(priv->monitor);\n        virObjectUnref(priv->monitor);\n        priv->monitor = NULL;\n    }\n\n    virPidFileDelete(cfg->stateDir, vm->def->name);\n    lxcProcessRemoveDomainStatus(cfg, vm);\n\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    vm->pid = -1;\n    vm->def->id = -1;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    virLXCDomainReAttachHostDevices(driver, vm->def);\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr iface = vm->def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(iface);\n        if (iface->ifname) {\n            if (vport &&\n                vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH)\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                virDomainNetGetActualBridgeName(iface),\n                                iface->ifname));\n            ignore_value(virNetDevVethDelete(iface->ifname));\n        }\n        if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (conn || (conn = virGetConnectNetwork()))\n                virDomainNetReleaseActualDevice(conn, vm->def, iface);\n            else\n                VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(iface->ifname));\n        }\n    }\n\n    virDomainConfVMNWFilterTeardown(vm);\n\n    if (priv->cgroup) {\n        virCgroupRemove(priv->cgroup);\n        virCgroupFree(&priv->cgroup);\n    }\n\n    /* Get machined to terminate the machine as it may not have cleaned it\n     * properly. See https://bugs.freedesktop.org/show_bug.cgi?id=68370 for\n     * the bug we are working around here.\n     */\n    virCgroupTerminateMachine(priv->machineName);\n    VIR_FREE(priv->machineName);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                    VIR_HOOK_LXC_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(cfg);\n    virObjectUnref(conn);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "conn"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjRemoveTransientDef",
          "args": [
            "vm"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjRemoveTransientDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3735-3745",
          "snippet": "void\nvirDomainObjRemoveTransientDef(virDomainObjPtr domain)\n{\n    if (!domain->newDef)\n        return;\n\n    virDomainDefFree(domain->def);\n    domain->def = domain->newDef;\n    domain->def->id = -1;\n    domain->newDef = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjRemoveTransientDef(virDomainObjPtr domain)\n{\n    if (!domain->newDef)\n        return;\n\n    virDomainDefFree(domain->def);\n    domain->def = domain->newDef;\n    domain->def->id = -1;\n    domain->newDef = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHookCall",
          "args": [
            "VIR_HOOK_DRIVER_LXC",
            "vm->def->name",
            "VIR_HOOK_LXC_OP_RELEASE",
            "VIR_HOOK_SUBOP_END",
            "NULL",
            "xml",
            "NULL"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "virHookCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "243-341",
          "snippet": "int\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\""
          ],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\"\n\nstatic int virHooksFound = -1;\n\nint\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFormat",
          "args": [
            "vm->def",
            "driver->xmlopt",
            "0"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29496-29508",
          "snippet": "char *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)\n\nchar *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHookPresent",
          "args": [
            "VIR_HOOK_DRIVER_LXC"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "virHookPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "210-222",
          "snippet": "int\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virHooksFound = -1;\n\nint\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->machineName"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCgroupTerminateMachine",
          "args": [
            "priv->machineName"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "virCgroupTerminateMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircgroup.c",
          "lines": "2863-2868",
          "snippet": "int virCgroupTerminateMachine(const char *name G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircgroupbackend.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"vircgrouppriv.h\"",
            "# include <unistd.h>",
            "# include <dirent.h>",
            "# include <signal.h>",
            "# include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <sys/stat.h>",
            "# include <fcntl.h>",
            "# include <sys/mount.h>",
            "# include <mntent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virhostcpu.h\"\n#include \"virtypedparam.h\"\n#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhashcode.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircgroupbackend.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"vircgrouppriv.h\"\n# include <unistd.h>\n# include <dirent.h>\n# include <signal.h>\n# include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n# include <sys/mount.h>\n# include <mntent.h>\n#include <config.h>\n\nint virCgroupTerminateMachine(const char *name G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCgroupFree",
          "args": [
            "&priv->cgroup"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "virCgroupFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircgroup.c",
          "lines": "3544-3563",
          "snippet": "void\nvirCgroupFree(virCgroupPtr *group)\n{\n    size_t i;\n\n    if (*group == NULL)\n        return;\n\n    for (i = 0; i < VIR_CGROUP_CONTROLLER_LAST; i++) {\n        VIR_FREE((*group)->legacy[i].mountPoint);\n        VIR_FREE((*group)->legacy[i].linkPoint);\n        VIR_FREE((*group)->legacy[i].placement);\n    }\n\n    VIR_FREE((*group)->unified.mountPoint);\n    VIR_FREE((*group)->unified.placement);\n\n    VIR_FREE((*group)->path);\n    VIR_FREE(*group);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircgroupbackend.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"vircgrouppriv.h\"",
            "# include <unistd.h>",
            "# include <dirent.h>",
            "# include <signal.h>",
            "# include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <sys/stat.h>",
            "# include <fcntl.h>",
            "# include <sys/mount.h>",
            "# include <mntent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virhostcpu.h\"\n#include \"virtypedparam.h\"\n#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhashcode.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircgroupbackend.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"vircgrouppriv.h\"\n# include <unistd.h>\n# include <dirent.h>\n# include <signal.h>\n# include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n# include <sys/mount.h>\n# include <mntent.h>\n#include <config.h>\n\nvoid\nvirCgroupFree(virCgroupPtr *group)\n{\n    size_t i;\n\n    if (*group == NULL)\n        return;\n\n    for (i = 0; i < VIR_CGROUP_CONTROLLER_LAST; i++) {\n        VIR_FREE((*group)->legacy[i].mountPoint);\n        VIR_FREE((*group)->legacy[i].linkPoint);\n        VIR_FREE((*group)->legacy[i].placement);\n    }\n\n    VIR_FREE((*group)->unified.mountPoint);\n    VIR_FREE((*group)->unified.placement);\n\n    VIR_FREE((*group)->path);\n    VIR_FREE(*group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCgroupRemove",
          "args": [
            "priv->cgroup"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "virCgroupRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircgroup.c",
          "lines": "3378-3384",
          "snippet": "int\nvirCgroupRemove(virCgroupPtr group G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircgroupbackend.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"vircgrouppriv.h\"",
            "# include <unistd.h>",
            "# include <dirent.h>",
            "# include <signal.h>",
            "# include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <sys/stat.h>",
            "# include <fcntl.h>",
            "# include <sys/mount.h>",
            "# include <mntent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virhostcpu.h\"\n#include \"virtypedparam.h\"\n#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhashcode.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircgroupbackend.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"vircgrouppriv.h\"\n# include <unistd.h>\n# include <dirent.h>\n# include <signal.h>\n# include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n# include <sys/mount.h>\n# include <mntent.h>\n#include <config.h>\n\nint\nvirCgroupRemove(virCgroupPtr group G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainConfVMNWFilterTeardown",
          "args": [
            "vm"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainConfVMNWFilterTeardown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_nwfilter.c",
          "lines": "159-178",
          "snippet": "void\nvirDomainConfVMNWFilterTeardown(virDomainObjPtr vm)\n{\n    size_t i;\n    virConnectPtr conn = NULL;\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr net = vm->def->nets[i];\n\n        if (!net->filter)\n            continue;\n\n        if (!conn && !(conn = virGetConnectNWFilter()))\n            return;\n\n        virDomainConfNWFilterTeardownImpl(conn, net);\n    }\n\n    virObjectUnref(conn);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnwfilterbindingdef.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnwfilterbindingdef.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainConfVMNWFilterTeardown(virDomainObjPtr vm)\n{\n    size_t i;\n    virConnectPtr conn = NULL;\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr net = vm->def->nets[i];\n\n        if (!net->filter)\n            continue;\n\n        if (!conn && !(conn = virGetConnectNWFilter()))\n            return;\n\n        virDomainConfNWFilterTeardownImpl(conn, net);\n    }\n\n    virObjectUnref(conn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to release network device '%s'\"",
            "NULLSTR(iface->ifname)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "iface->ifname"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetReleaseActualDevice",
          "args": [
            "conn",
            "vm->def",
            "iface"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetReleaseActualDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "31536-31564",
          "snippet": "int\nvirDomainNetReleaseActualDevice(virConnectPtr conn,\n                                virDomainDefPtr dom G_GNUC_UNUSED,\n                                virDomainNetDefPtr iface)\n{\n    virNetworkPtr net = NULL;\n    virNetworkPortPtr port = NULL;\n    int ret = -1;\n\n    /* Port might not exist if a failure occurred during VM startup */\n    if (!virUUIDIsValid(iface->data.network.portid)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(net = virNetworkLookupByName(conn, iface->data.network.name)))\n        goto cleanup;\n\n    if (!(port = virNetworkPortLookupByUUID(net, iface->data.network.portid)))\n        goto cleanup;\n\n    if (virNetworkPortDelete(port, 0) < 0)\n        goto cleanup;\n\n cleanup:\n    virObjectUnref(port);\n    virObjectUnref(net);\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainNetReleaseActualDevice(virConnectPtr conn,\n                                virDomainDefPtr dom G_GNUC_UNUSED,\n                                virDomainNetDefPtr iface)\n{\n    virNetworkPtr net = NULL;\n    virNetworkPortPtr port = NULL;\n    int ret = -1;\n\n    /* Port might not exist if a failure occurred during VM startup */\n    if (!virUUIDIsValid(iface->data.network.portid)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(net = virNetworkLookupByName(conn, iface->data.network.name)))\n        goto cleanup;\n\n    if (!(port = virNetworkPortLookupByUUID(net, iface->data.network.portid)))\n        goto cleanup;\n\n    if (virNetworkPortDelete(port, 0) < 0)\n        goto cleanup;\n\n cleanup:\n    virObjectUnref(port);\n    virObjectUnref(net);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetConnectNetwork",
          "args": [],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "virGetConnectNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "169-172",
          "snippet": "virConnectPtr virGetConnectNetwork(void)\n{\n    return virGetConnectGeneric(&connectNetwork, \"network\");\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal connectNetwork;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirThreadLocal connectNetwork;\n\nvirConnectPtr virGetConnectNetwork(void)\n{\n    return virGetConnectGeneric(&connectNetwork, \"network\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevVethDelete(iface->ifname)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVethDelete",
          "args": [
            "iface->ifname"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVethDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevveth.c",
          "lines": "189-209",
          "snippet": "int virNetDevVethDelete(const char *veth)\n{\n    int status;\n    g_autoptr(virCommand) cmd = virCommandNewArgList(\"ip\", \"link\",\n                                                       \"del\", veth, NULL);\n\n    if (virCommandRun(cmd, &status) < 0)\n        return -1;\n\n    if (status != 0) {\n        if (!virNetDevExists(veth)) {\n            VIR_DEBUG(\"Device %s already deleted (by kernel namespace cleanup)\", veth);\n            return 0;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to delete veth device %s\"), veth);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdevveth.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virnetdevveth.h\"\n#include <config.h>\n\nint virNetDevVethDelete(const char *veth)\n{\n    int status;\n    g_autoptr(virCommand) cmd = virCommandNewArgList(\"ip\", \"link\",\n                                                       \"del\", veth, NULL);\n\n    if (virCommandRun(cmd, &status) < 0)\n        return -1;\n\n    if (status != 0) {\n        if (!virNetDevExists(veth)) {\n            VIR_DEBUG(\"Device %s already deleted (by kernel namespace cleanup)\", veth);\n            return 0;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to delete veth device %s\"), veth);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevOpenvswitchRemovePort(\n                                virDomainNetGetActualBridgeName(iface),\n                                iface->ifname)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevOpenvswitchRemovePort",
          "args": [
            "virDomainNetGetActualBridgeName(iface)",
            "iface->ifname"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevOpenvswitchRemovePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevopenvswitch.c",
          "lines": "205-220",
          "snippet": "int virNetDevOpenvswitchRemovePort(const char *brname G_GNUC_UNUSED, const char *ifname)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNew(OVSVSCTL);\n    virNetDevOpenvswitchAddTimeout(cmd);\n    virCommandAddArgList(cmd, \"--\", \"--if-exists\", \"del-port\", ifname, NULL);\n\n    if (virCommandRun(cmd, NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to delete port %s from OVS\"), ifname);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virjson.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virjson.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virmacaddr.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevopenvswitch.h\"\n#include <config.h>\n\nint virNetDevOpenvswitchRemovePort(const char *brname G_GNUC_UNUSED, const char *ifname)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNew(OVSVSCTL);\n    virNetDevOpenvswitchAddTimeout(cmd);\n    virCommandAddArgList(cmd, \"--\", \"--if-exists\", \"del-port\", ifname, NULL);\n\n    if (virCommandRun(cmd, NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to delete port %s from OVS\"), ifname);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualBridgeName",
          "args": [
            "iface"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualBridgeName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30164-30175",
          "snippet": "const char *\nvirDomainNetGetActualBridgeName(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_BRIDGE)\n        return iface->data.bridge.brname;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        (iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_BRIDGE ||\n         iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_NETWORK))\n        return iface->data.network.actual->data.bridge.brname;\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainNetGetActualBridgeName(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_BRIDGE)\n        return iface->data.bridge.brname;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        (iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_BRIDGE ||\n         iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_NETWORK))\n        return iface->data.network.actual->data.bridge.brname;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVirtPortProfile",
          "args": [
            "iface"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVirtPortProfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30224-30255",
          "snippet": "const virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCDomainReAttachHostDevices",
          "args": [
            "driver",
            "vm->def"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCDomainReAttachHostDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_hostdev.c",
          "lines": "130-138",
          "snippet": "void virLXCDomainReAttachHostDevices(virLXCDriverPtr driver,\n                                     virDomainDefPtr def)\n{\n    if (!def->nhostdevs)\n        return;\n\n    virLXCDomainReAttachHostUSBDevices(driver, def->name, def->hostdevs,\n                                       def->nhostdevs);\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"lxc_hostdev.h\"\n#include <config.h>\n\nvoid virLXCDomainReAttachHostDevices(virLXCDriverPtr driver,\n                                     virDomainDefPtr def)\n{\n    if (!def->nhostdevs)\n        return;\n\n    virLXCDomainReAttachHostUSBDevices(driver, def->name, def->hostdevs,\n                                       def->nhostdevs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "driver->inhibitCallback",
          "args": [
            "false",
            "driver->inhibitOpaque"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_atomic_int_dec_and_test",
          "args": [
            "&driver->nactive"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_SHUTOFF",
            "reason"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxcProcessRemoveDomainStatus",
          "args": [
            "cfg",
            "vm"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "lxcProcessRemoveDomainStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "134-146",
          "snippet": "static void\nlxcProcessRemoveDomainStatus(virLXCDriverConfigPtr cfg,\n                              virDomainObjPtr vm)\n{\n    char *file = NULL;\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_WARN(\"Failed to remove domain XML for %s: %s\",\n                 vm->def->name, g_strerror(errno));\n    VIR_FREE(file);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic void\nlxcProcessRemoveDomainStatus(virLXCDriverConfigPtr cfg,\n                              virDomainObjPtr vm)\n{\n    char *file = NULL;\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_WARN(\"Failed to remove domain XML for %s: %s\",\n                 vm->def->name, g_strerror(errno));\n    VIR_FREE(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileDelete",
          "args": [
            "cfg->stateDir",
            "vm->def->name"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "316-328",
          "snippet": "int virPidFileDelete(const char *dir,\n                     const char *name)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileDeletePath(pidfile);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileDelete(const char *dir,\n                     const char *name)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileDeletePath(pidfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCMonitorClose",
          "args": [
            "priv->monitor"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCMonitorClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_monitor.c",
          "lines": "206-232",
          "snippet": "void virLXCMonitorClose(virLXCMonitorPtr mon)\n{\n    virDomainObjPtr vm;\n    virNetClientPtr client;\n\n    VIR_DEBUG(\"mon=%p\", mon);\n    if (mon->client) {\n        /* When manually closing the monitor, we don't\n         * want to have callbacks back into us, since\n         * the caller is not re-entrant safe\n         */\n        VIR_DEBUG(\"Clear EOF callback mon=%p\", mon);\n        vm = mon->vm;\n        client = mon->client;\n        mon->client = NULL;\n        mon->cb.eofNotify = NULL;\n\n        virObjectRef(vm);\n        virObjectUnlock(vm);\n\n        virNetClientClose(client);\n        virObjectUnref(client);\n\n        virObjectLock(vm);\n        virObjectUnref(vm);\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_monitor_dispatch.h\"",
            "#include \"lxc_conf.h\"",
            "#include \"lxc_monitor.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"lxc_monitor_dispatch.h\"\n#include \"lxc_conf.h\"\n#include \"lxc_monitor.h\"\n#include <config.h>\n\nvoid virLXCMonitorClose(virLXCMonitorPtr mon)\n{\n    virDomainObjPtr vm;\n    virNetClientPtr client;\n\n    VIR_DEBUG(\"mon=%p\", mon);\n    if (mon->client) {\n        /* When manually closing the monitor, we don't\n         * want to have callbacks back into us, since\n         * the caller is not re-entrant safe\n         */\n        VIR_DEBUG(\"Clear EOF callback mon=%p\", mon);\n        vm = mon->vm;\n        client = mon->client;\n        mon->client = NULL;\n        mon->cb.eofNotify = NULL;\n\n        virObjectRef(vm);\n        virObjectUnlock(vm);\n\n        virNetClientClose(client);\n        virObjectUnref(client);\n\n        virObjectLock(vm);\n        virObjectUnref(vm);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCloseCallbacksUnset",
          "args": [
            "driver->closeCallbacks",
            "vm",
            "lxcProcessAutoDestroy"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "virCloseCallbacksUnset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virclosecallbacks.c",
          "lines": "142-178",
          "snippet": "int\nvirCloseCallbacksUnset(virCloseCallbacksPtr closeCallbacks,\n                       virDomainObjPtr vm,\n                       virCloseCallback cb)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    int ret = -1;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s, cb=%p\",\n              vm->def->name, uuidstr, cb);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (!closeDef)\n        goto cleanup;\n\n    if (closeDef->cb && closeDef->cb != cb) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Trying to remove mismatching close callback for\"\n                         \" domain %s\"), vm->def->name);\n        goto cleanup;\n    }\n\n    if (virHashRemoveEntry(closeCallbacks->list, uuidstr) < 0)\n        goto cleanup;\n\n    virObjectUnref(vm);\n    ret = 0;\n cleanup:\n    virObjectUnlock(closeCallbacks);\n    if (!ret)\n        virObjectUnref(closeCallbacks);\n    return ret;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virclosecallbacks.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virclosecallbacks.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirCloseCallbacksUnset(virCloseCallbacksPtr closeCallbacks,\n                       virDomainObjPtr vm,\n                       virCloseCallback cb)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    int ret = -1;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s, cb=%p\",\n              vm->def->name, uuidstr, cb);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (!closeDef)\n        goto cleanup;\n\n    if (closeDef->cb && closeDef->cb != cb) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Trying to remove mismatching close callback for\"\n                         \" domain %s\"), vm->def->name);\n        goto cleanup;\n    }\n\n    if (virHashRemoveEntry(closeCallbacks->list, uuidstr) < 0)\n        goto cleanup;\n\n    virObjectUnref(vm);\n    ret = 0;\n cleanup:\n    virObjectUnlock(closeCallbacks);\n    if (!ret)\n        virObjectUnref(closeCallbacks);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vm->def->seclabels[0]->imagelabel"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vm->def->seclabels[0]->label"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vm->def->seclabels[0]->model"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerReleaseLabel",
          "args": [
            "driver->securityManager",
            "vm->def"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerReleaseLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "734-748",
          "snippet": "int\nvirSecurityManagerReleaseLabel(virSecurityManagerPtr mgr,\n                               virDomainDefPtr vm)\n{\n    if (mgr->drv->domainReleaseSecurityLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainReleaseSecurityLabel(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerReleaseLabel(virSecurityManagerPtr mgr,\n                               virDomainDefPtr vm)\n{\n    if (mgr->drv->domainReleaseSecurityLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainReleaseSecurityLabel(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerRestoreAllLabel",
          "args": [
            "driver->securityManager",
            "vm->def",
            "false",
            "false"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerRestoreAllLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "880-897",
          "snippet": "int\nvirSecurityManagerRestoreAllLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr vm,\n                                  bool migrated,\n                                  bool chardevStdioLogd)\n{\n    if (mgr->drv->domainRestoreSecurityAllLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSecurityAllLabel(mgr, vm, migrated,\n                                                      chardevStdioLogd);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerRestoreAllLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr vm,\n                                  bool migrated,\n                                  bool chardevStdioLogd)\n{\n    if (mgr->drv->domainRestoreSecurityAllLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSecurityAllLabel(mgr, vm, migrated,\n                                                      chardevStdioLogd);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Cleanup VM name=%s pid=%d reason=%d\"",
            "vm->def->name",
            "(int)vm->pid",
            "(int)reason"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLXCDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
          "lines": "279-286",
          "snippet": "virLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver)\n{\n    virLXCDriverConfigPtr cfg;\n    lxcDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    lxcDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"lxc_container.h\"",
            "#include \"configmake.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_conf.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virnodesuspend.h\"\n#include \"lxc_container.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_conf.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver)\n{\n    virLXCDriverConfigPtr cfg;\n    lxcDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    lxcDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic void virLXCProcessCleanup(virLXCDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 virDomainShutoffReason reason)\n{\n    size_t i;\n    virLXCDomainObjPrivatePtr priv = vm->privateData;\n    const virNetDevVPortProfile *vport = NULL;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    virConnectPtr conn = NULL;\n\n    VIR_DEBUG(\"Cleanup VM name=%s pid=%d reason=%d\",\n              vm->def->name, (int)vm->pid, (int)reason);\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                    VIR_HOOK_LXC_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n        VIR_FREE(xml);\n    }\n\n    virSecurityManagerRestoreAllLabel(driver->securityManager,\n                                      vm->def, false, false);\n    virSecurityManagerReleaseLabel(driver->securityManager, vm->def);\n    /* Clear out dynamically assigned labels */\n    if (vm->def->nseclabels &&\n        vm->def->seclabels[0]->type == VIR_DOMAIN_SECLABEL_DYNAMIC) {\n        VIR_FREE(vm->def->seclabels[0]->model);\n        VIR_FREE(vm->def->seclabels[0]->label);\n        VIR_FREE(vm->def->seclabels[0]->imagelabel);\n    }\n\n    /* Stop autodestroy in case guest is restarted */\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           lxcProcessAutoDestroy);\n\n    if (priv->monitor) {\n        virLXCMonitorClose(priv->monitor);\n        virObjectUnref(priv->monitor);\n        priv->monitor = NULL;\n    }\n\n    virPidFileDelete(cfg->stateDir, vm->def->name);\n    lxcProcessRemoveDomainStatus(cfg, vm);\n\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    vm->pid = -1;\n    vm->def->id = -1;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    virLXCDomainReAttachHostDevices(driver, vm->def);\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr iface = vm->def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(iface);\n        if (iface->ifname) {\n            if (vport &&\n                vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH)\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                virDomainNetGetActualBridgeName(iface),\n                                iface->ifname));\n            ignore_value(virNetDevVethDelete(iface->ifname));\n        }\n        if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (conn || (conn = virGetConnectNetwork()))\n                virDomainNetReleaseActualDevice(conn, vm->def, iface);\n            else\n                VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(iface->ifname));\n        }\n    }\n\n    virDomainConfVMNWFilterTeardown(vm);\n\n    if (priv->cgroup) {\n        virCgroupRemove(priv->cgroup);\n        virCgroupFree(&priv->cgroup);\n    }\n\n    /* Get machined to terminate the machine as it may not have cleaned it\n     * properly. See https://bugs.freedesktop.org/show_bug.cgi?id=68370 for\n     * the bug we are working around here.\n     */\n    virCgroupTerminateMachine(priv->machineName);\n    VIR_FREE(priv->machineName);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                    VIR_HOOK_LXC_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(cfg);\n    virObjectUnref(conn);\n}"
  },
  {
    "function_name": "lxcProcessRemoveDomainStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "134-146",
    "snippet": "static void\nlxcProcessRemoveDomainStatus(virLXCDriverConfigPtr cfg,\n                              virDomainObjPtr vm)\n{\n    char *file = NULL;\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_WARN(\"Failed to remove domain XML for %s: %s\",\n                 vm->def->name, g_strerror(errno));\n    VIR_FREE(file);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "file"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to remove domain XML for %s: %s\"",
            "vm->def->name",
            "g_strerror(errno)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "file"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s.xml\"",
            "cfg->stateDir",
            "vm->def->name"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic void\nlxcProcessRemoveDomainStatus(virLXCDriverConfigPtr cfg,\n                              virDomainObjPtr vm)\n{\n    char *file = NULL;\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_WARN(\"Failed to remove domain XML for %s: %s\",\n                 vm->def->name, g_strerror(errno));\n    VIR_FREE(file);\n}"
  },
  {
    "function_name": "virLXCProcessReboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "91-131",
    "snippet": "static int\nvirLXCProcessReboot(virLXCDriverPtr driver,\n                    virDomainObjPtr vm)\n{\n    virConnectPtr conn = virCloseCallbacksGetConn(driver->closeCallbacks, vm);\n    int reason = vm->state.reason;\n    bool autodestroy = false;\n    int ret = -1;\n    virDomainDefPtr savedDef;\n\n    VIR_DEBUG(\"Faking reboot\");\n\n    if (conn) {\n        virObjectRef(conn);\n        autodestroy = true;\n    } else {\n        conn = virConnectOpen(\"lxc:///system\");\n        /* Ignoring NULL conn which is mostly harmless here */\n    }\n\n    /* In a reboot scenario, we need to make sure we continue\n     * to use the current 'def', and not switch to 'newDef'.\n     * So temporarily hide the newDef and then reinstate it\n     */\n    savedDef = vm->newDef;\n    vm->newDef = NULL;\n    virLXCProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n    vm->newDef = savedDef;\n    if (virLXCProcessStart(conn, driver, vm,\n                           0, NULL, autodestroy, reason) < 0) {\n        VIR_WARN(\"Unable to handle reboot of vm %s\",\n                 vm->def->name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(conn);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "conn"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to handle reboot of vm %s\"",
            "vm->def->name"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLXCProcessStart",
          "args": [
            "conn",
            "driver",
            "vm",
            "0",
            "NULL",
            "autodestroy",
            "reason"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "1182-1573",
          "snippet": "int virLXCProcessStart(virConnectPtr conn,\n                       virLXCDriverPtr  driver,\n                       virDomainObjPtr vm,\n                       unsigned int nfiles, int *files,\n                       bool autoDestroy,\n                       virDomainRunningReason reason)\n{\n    int rc = -1, r;\n    size_t nttyFDs = 0;\n    int *ttyFDs = NULL;\n    size_t i;\n    char *logfile = NULL;\n    int logfd = -1;\n    VIR_AUTOSTRINGLIST veths = NULL;\n    int handshakefds[2] = { -1, -1 };\n    off_t pos = -1;\n    char ebuf[1024];\n    char *timestamp;\n    int nsInheritFDs[VIR_LXC_DOMAIN_NAMESPACE_LAST];\n    virCommandPtr cmd = NULL;\n    virLXCDomainObjPrivatePtr priv = vm->privateData;\n    virCapsPtr caps = NULL;\n    virErrorPtr err = NULL;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    virCgroupPtr selfcgroup;\n    int status;\n    char *pidfile = NULL;\n\n    if (virCgroupNewSelf(&selfcgroup) < 0)\n        return -1;\n\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_CPUACCT)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'cpuacct' cgroups controller mount\"));\n        return -1;\n    }\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_DEVICES)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'devices' cgroups controller mount\"));\n        return -1;\n    }\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_MEMORY)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'memory' cgroups controller mount\"));\n        return -1;\n    }\n    virCgroupFree(&selfcgroup);\n\n    if (vm->def->nconsoles == 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"At least one PTY console is required\"));\n        return -1;\n    }\n\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        if (vm->def->consoles[i]->source->type != VIR_DOMAIN_CHR_TYPE_PTY) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only PTY console types are supported\"));\n            return -1;\n        }\n    }\n\n    if (virFileMakePath(cfg->logDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot create log directory '%s'\"),\n                             cfg->logDir);\n        return -1;\n    }\n\n    if (!vm->def->resource) {\n        virDomainResourceDefPtr res;\n\n        if (VIR_ALLOC(res) < 0)\n            goto cleanup;\n\n        res->partition = g_strdup(\"/machine\");\n\n        vm->def->resource = res;\n    }\n\n    logfile = g_strdup_printf(\"%s/%s.log\", cfg->logDir, vm->def->name);\n\n    if (!(pidfile = virPidFileBuildPath(cfg->stateDir, vm->def->name)))\n        goto cleanup;\n\n    if (!(caps = virLXCDriverGetCapabilities(driver, false)))\n        goto cleanup;\n\n    /* Do this up front, so any part of the startup process can add\n     * runtime state to vm->def that won't be persisted. This let's us\n     * report implicit runtime defaults in the XML, like vnc listen/socket\n     */\n    VIR_DEBUG(\"Setting current domain def as transient\");\n    if (virDomainObjSetDefTransient(driver->xmlopt, vm, NULL) < 0)\n        goto cleanup;\n\n    /* Run an early hook to set-up missing devices */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_PREPARE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    if (virLXCProcessEnsureRootFS(vm) < 0)\n        goto cleanup;\n\n    /* Must be run before security labelling */\n    VIR_DEBUG(\"Preparing host devices\");\n    if (virLXCPrepareHostDevices(driver, vm->def) < 0)\n        goto cleanup;\n\n    /* Here we open all the PTYs we need on the host OS side.\n     * The LXC controller will open the guest OS side PTYs\n     * and forward I/O between them.\n     */\n    nttyFDs = vm->def->nconsoles;\n    if (VIR_ALLOC_N(ttyFDs, nttyFDs) < 0)\n        goto cleanup;\n    for (i = 0; i < vm->def->nconsoles; i++)\n        ttyFDs[i] = -1;\n\n    /* If you are using a SecurityDriver with dynamic labelling,\n       then generate a security label for isolation */\n    VIR_DEBUG(\"Generating domain security label (if required)\");\n\n    if (vm->def->nseclabels &&\n        vm->def->seclabels[0]->type == VIR_DOMAIN_SECLABEL_DEFAULT)\n        vm->def->seclabels[0]->type = VIR_DOMAIN_SECLABEL_NONE;\n\n    if (virSecurityManagerCheckAllLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n\n    if (virSecurityManagerGenLabel(driver->securityManager, vm->def) < 0) {\n        virDomainAuditSecurityLabel(vm, false);\n        goto cleanup;\n    }\n    virDomainAuditSecurityLabel(vm, true);\n\n    VIR_DEBUG(\"Setting domain security labels\");\n    if (virSecurityManagerSetAllLabel(driver->securityManager,\n                                      vm->def, NULL, false, false) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up consoles\");\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        char *ttyPath;\n\n        if (virFileOpenTty(&ttyFDs[i], &ttyPath, 1) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Failed to allocate tty\"));\n            goto cleanup;\n        }\n\n        VIR_FREE(vm->def->consoles[i]->source->data.file.path);\n        vm->def->consoles[i]->source->data.file.path = ttyPath;\n\n        VIR_FREE(vm->def->consoles[i]->info.alias);\n        vm->def->consoles[i]->info.alias = g_strdup_printf(\"console%zu\", i);\n    }\n\n    VIR_DEBUG(\"Setting up Interfaces\");\n    if (virLXCProcessSetupInterfaces(driver, vm->def, &veths) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up namespaces if any\");\n    if (virLXCProcessSetupNamespaces(driver, vm->def->namespaceData, nsInheritFDs) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Preparing to launch\");\n    if ((logfd = open(logfile, O_WRONLY | O_APPEND | O_CREAT,\n             S_IRUSR|S_IWUSR)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to open '%s'\"),\n                             logfile);\n        goto cleanup;\n    }\n\n    if (virPipe(handshakefds) < 0)\n        goto cleanup;\n\n    if (!(cmd = virLXCProcessBuildControllerCmd(driver,\n                                                vm,\n                                                veths,\n                                                ttyFDs, nttyFDs,\n                                                nsInheritFDs,\n                                                files, nfiles,\n                                                handshakefds[1],\n                                                &logfd,\n                                                pidfile)))\n        goto cleanup;\n\n    /* now that we know it is about to start call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_START, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    /* Log timestamp */\n    if ((timestamp = virTimeStringNow()) == NULL)\n        goto cleanup;\n    if (safewrite(logfd, timestamp, strlen(timestamp)) < 0 ||\n        safewrite(logfd, START_POSTFIX, strlen(START_POSTFIX)) < 0) {\n        VIR_WARN(\"Unable to write timestamp to logfile: %s\",\n                 g_strerror(errno));\n    }\n    VIR_FREE(timestamp);\n\n    /* Log generated command line */\n    virCommandWriteArgLog(cmd, logfd);\n    if ((pos = lseek(logfd, 0, SEEK_END)) < 0)\n        VIR_WARN(\"Unable to seek to end of logfile: %s\",\n                 g_strerror(errno));\n\n    VIR_DEBUG(\"Launching container\");\n    virCommandRawStatus(cmd);\n    if (virCommandRun(cmd, &status) < 0)\n        goto cleanup;\n\n    if (status != 0) {\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf,\n                                       sizeof(ebuf)) <= 0) {\n            if (WIFEXITED(status))\n                g_snprintf(ebuf, sizeof(ebuf), _(\"unexpected exit status %d\"),\n                           WEXITSTATUS(status));\n            else\n                g_snprintf(ebuf, sizeof(ebuf), \"%s\", _(\"terminated abnormally\"));\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"guest failed to start: %s\"), ebuf);\n        goto cleanup;\n    }\n\n    /* It has started running, so get its pid */\n    if ((r = virPidFileReadPath(pidfile, &vm->pid)) < 0) {\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf, sizeof(ebuf)) > 0)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), ebuf);\n        else\n            virReportSystemError(-r,\n                                 _(\"Failed to read pid file %s\"),\n                                 pidfile);\n        goto cleanup;\n    }\n\n    priv->stopReason = VIR_DOMAIN_EVENT_STOPPED_FAILED;\n    priv->wantReboot = false;\n    vm->def->id = vm->pid;\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, reason);\n    priv->doneStopEvent = false;\n\n    if (VIR_CLOSE(handshakefds[1]) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"could not close handshake fd\"));\n        goto cleanup;\n    }\n\n    if (virCommandHandshakeWait(cmd) < 0)\n        goto cleanup;\n\n    /* Write domain status to disk for the controller to\n     * read when it starts */\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        goto cleanup;\n\n    /* Allow the child to exec the controller */\n    if (virCommandHandshakeNotify(cmd) < 0)\n        goto cleanup;\n\n    if (g_atomic_int_add(&driver->nactive, 1) == 0 && driver->inhibitCallback)\n        driver->inhibitCallback(true, driver->inhibitOpaque);\n\n    if (lxcContainerWaitForContinue(handshakefds[0]) < 0) {\n        char out[1024];\n\n        if (!(virLXCProcessReadLogOutput(vm, logfile, pos, out, 1024) < 0)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), out);\n        }\n\n        goto cleanup;\n    }\n\n    priv->machineName = virLXCDomainGetMachineName(vm->def, vm->pid);\n    if (!priv->machineName)\n        goto cleanup;\n\n    /* We know the cgroup must exist by this synchronization\n     * point so lets detect that first, since it gives us a\n     * more reliable way to kill everything off if something\n     * goes wrong from here onwards ... */\n    if (virCgroupNewDetectMachine(vm->def->name, \"lxc\",\n                                  vm->pid, -1, priv->machineName,\n                                  &priv->cgroup) < 0)\n        goto cleanup;\n\n    if (!priv->cgroup) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No valid cgroup for machine %s\"),\n                       vm->def->name);\n        goto cleanup;\n    }\n\n    /* And we can get the first monitor connection now too */\n    if (!(priv->monitor = virLXCProcessConnectMonitor(driver, vm))) {\n        /* Intentionally overwrite the real monitor error message,\n         * since a better one is almost always found in the logs\n         */\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf, sizeof(ebuf)) > 0) {\n            virResetLastError();\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), ebuf);\n        }\n        goto cleanup;\n    }\n\n    if (autoDestroy &&\n        virCloseCallbacksSet(driver->closeCallbacks, vm,\n                             conn, lxcProcessAutoDestroy) < 0)\n        goto cleanup;\n\n    /* We don't need the temporary NIC names anymore, clear them */\n    virLXCProcessCleanInterfaces(vm->def);\n\n    /* finally we can call the 'started' hook script if any */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_STARTED, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(logfd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"could not close logfile\"));\n        rc = -1;\n    }\n    if (rc != 0) {\n        virErrorPreserveLast(&err);\n        virLXCProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED);\n    }\n    virCommandFree(cmd);\n    for (i = 0; i < nttyFDs; i++)\n        VIR_FORCE_CLOSE(ttyFDs[i]);\n    VIR_FREE(ttyFDs);\n    VIR_FORCE_CLOSE(handshakefds[0]);\n    VIR_FORCE_CLOSE(handshakefds[1]);\n    VIR_FREE(pidfile);\n    VIR_FREE(logfile);\n    virObjectUnref(cfg);\n    virObjectUnref(caps);\n\n    virErrorRestore(&err);\n\n    return rc;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define START_POSTFIX \": starting up\\n\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define START_POSTFIX \": starting up\\n\"\n\nint virLXCProcessStart(virConnectPtr conn,\n                       virLXCDriverPtr  driver,\n                       virDomainObjPtr vm,\n                       unsigned int nfiles, int *files,\n                       bool autoDestroy,\n                       virDomainRunningReason reason)\n{\n    int rc = -1, r;\n    size_t nttyFDs = 0;\n    int *ttyFDs = NULL;\n    size_t i;\n    char *logfile = NULL;\n    int logfd = -1;\n    VIR_AUTOSTRINGLIST veths = NULL;\n    int handshakefds[2] = { -1, -1 };\n    off_t pos = -1;\n    char ebuf[1024];\n    char *timestamp;\n    int nsInheritFDs[VIR_LXC_DOMAIN_NAMESPACE_LAST];\n    virCommandPtr cmd = NULL;\n    virLXCDomainObjPrivatePtr priv = vm->privateData;\n    virCapsPtr caps = NULL;\n    virErrorPtr err = NULL;\n    virLXCDriverConfigPtr cfg = virLXCDriverGetConfig(driver);\n    virCgroupPtr selfcgroup;\n    int status;\n    char *pidfile = NULL;\n\n    if (virCgroupNewSelf(&selfcgroup) < 0)\n        return -1;\n\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_CPUACCT)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'cpuacct' cgroups controller mount\"));\n        return -1;\n    }\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_DEVICES)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'devices' cgroups controller mount\"));\n        return -1;\n    }\n    if (!virCgroupHasController(selfcgroup,\n                                VIR_CGROUP_CONTROLLER_MEMORY)) {\n        virCgroupFree(&selfcgroup);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to find 'memory' cgroups controller mount\"));\n        return -1;\n    }\n    virCgroupFree(&selfcgroup);\n\n    if (vm->def->nconsoles == 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"At least one PTY console is required\"));\n        return -1;\n    }\n\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        if (vm->def->consoles[i]->source->type != VIR_DOMAIN_CHR_TYPE_PTY) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only PTY console types are supported\"));\n            return -1;\n        }\n    }\n\n    if (virFileMakePath(cfg->logDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot create log directory '%s'\"),\n                             cfg->logDir);\n        return -1;\n    }\n\n    if (!vm->def->resource) {\n        virDomainResourceDefPtr res;\n\n        if (VIR_ALLOC(res) < 0)\n            goto cleanup;\n\n        res->partition = g_strdup(\"/machine\");\n\n        vm->def->resource = res;\n    }\n\n    logfile = g_strdup_printf(\"%s/%s.log\", cfg->logDir, vm->def->name);\n\n    if (!(pidfile = virPidFileBuildPath(cfg->stateDir, vm->def->name)))\n        goto cleanup;\n\n    if (!(caps = virLXCDriverGetCapabilities(driver, false)))\n        goto cleanup;\n\n    /* Do this up front, so any part of the startup process can add\n     * runtime state to vm->def that won't be persisted. This let's us\n     * report implicit runtime defaults in the XML, like vnc listen/socket\n     */\n    VIR_DEBUG(\"Setting current domain def as transient\");\n    if (virDomainObjSetDefTransient(driver->xmlopt, vm, NULL) < 0)\n        goto cleanup;\n\n    /* Run an early hook to set-up missing devices */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_PREPARE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    if (virLXCProcessEnsureRootFS(vm) < 0)\n        goto cleanup;\n\n    /* Must be run before security labelling */\n    VIR_DEBUG(\"Preparing host devices\");\n    if (virLXCPrepareHostDevices(driver, vm->def) < 0)\n        goto cleanup;\n\n    /* Here we open all the PTYs we need on the host OS side.\n     * The LXC controller will open the guest OS side PTYs\n     * and forward I/O between them.\n     */\n    nttyFDs = vm->def->nconsoles;\n    if (VIR_ALLOC_N(ttyFDs, nttyFDs) < 0)\n        goto cleanup;\n    for (i = 0; i < vm->def->nconsoles; i++)\n        ttyFDs[i] = -1;\n\n    /* If you are using a SecurityDriver with dynamic labelling,\n       then generate a security label for isolation */\n    VIR_DEBUG(\"Generating domain security label (if required)\");\n\n    if (vm->def->nseclabels &&\n        vm->def->seclabels[0]->type == VIR_DOMAIN_SECLABEL_DEFAULT)\n        vm->def->seclabels[0]->type = VIR_DOMAIN_SECLABEL_NONE;\n\n    if (virSecurityManagerCheckAllLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n\n    if (virSecurityManagerGenLabel(driver->securityManager, vm->def) < 0) {\n        virDomainAuditSecurityLabel(vm, false);\n        goto cleanup;\n    }\n    virDomainAuditSecurityLabel(vm, true);\n\n    VIR_DEBUG(\"Setting domain security labels\");\n    if (virSecurityManagerSetAllLabel(driver->securityManager,\n                                      vm->def, NULL, false, false) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up consoles\");\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        char *ttyPath;\n\n        if (virFileOpenTty(&ttyFDs[i], &ttyPath, 1) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Failed to allocate tty\"));\n            goto cleanup;\n        }\n\n        VIR_FREE(vm->def->consoles[i]->source->data.file.path);\n        vm->def->consoles[i]->source->data.file.path = ttyPath;\n\n        VIR_FREE(vm->def->consoles[i]->info.alias);\n        vm->def->consoles[i]->info.alias = g_strdup_printf(\"console%zu\", i);\n    }\n\n    VIR_DEBUG(\"Setting up Interfaces\");\n    if (virLXCProcessSetupInterfaces(driver, vm->def, &veths) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up namespaces if any\");\n    if (virLXCProcessSetupNamespaces(driver, vm->def->namespaceData, nsInheritFDs) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Preparing to launch\");\n    if ((logfd = open(logfile, O_WRONLY | O_APPEND | O_CREAT,\n             S_IRUSR|S_IWUSR)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to open '%s'\"),\n                             logfile);\n        goto cleanup;\n    }\n\n    if (virPipe(handshakefds) < 0)\n        goto cleanup;\n\n    if (!(cmd = virLXCProcessBuildControllerCmd(driver,\n                                                vm,\n                                                veths,\n                                                ttyFDs, nttyFDs,\n                                                nsInheritFDs,\n                                                files, nfiles,\n                                                handshakefds[1],\n                                                &logfd,\n                                                pidfile)))\n        goto cleanup;\n\n    /* now that we know it is about to start call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_START, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    /* Log timestamp */\n    if ((timestamp = virTimeStringNow()) == NULL)\n        goto cleanup;\n    if (safewrite(logfd, timestamp, strlen(timestamp)) < 0 ||\n        safewrite(logfd, START_POSTFIX, strlen(START_POSTFIX)) < 0) {\n        VIR_WARN(\"Unable to write timestamp to logfile: %s\",\n                 g_strerror(errno));\n    }\n    VIR_FREE(timestamp);\n\n    /* Log generated command line */\n    virCommandWriteArgLog(cmd, logfd);\n    if ((pos = lseek(logfd, 0, SEEK_END)) < 0)\n        VIR_WARN(\"Unable to seek to end of logfile: %s\",\n                 g_strerror(errno));\n\n    VIR_DEBUG(\"Launching container\");\n    virCommandRawStatus(cmd);\n    if (virCommandRun(cmd, &status) < 0)\n        goto cleanup;\n\n    if (status != 0) {\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf,\n                                       sizeof(ebuf)) <= 0) {\n            if (WIFEXITED(status))\n                g_snprintf(ebuf, sizeof(ebuf), _(\"unexpected exit status %d\"),\n                           WEXITSTATUS(status));\n            else\n                g_snprintf(ebuf, sizeof(ebuf), \"%s\", _(\"terminated abnormally\"));\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"guest failed to start: %s\"), ebuf);\n        goto cleanup;\n    }\n\n    /* It has started running, so get its pid */\n    if ((r = virPidFileReadPath(pidfile, &vm->pid)) < 0) {\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf, sizeof(ebuf)) > 0)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), ebuf);\n        else\n            virReportSystemError(-r,\n                                 _(\"Failed to read pid file %s\"),\n                                 pidfile);\n        goto cleanup;\n    }\n\n    priv->stopReason = VIR_DOMAIN_EVENT_STOPPED_FAILED;\n    priv->wantReboot = false;\n    vm->def->id = vm->pid;\n    virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, reason);\n    priv->doneStopEvent = false;\n\n    if (VIR_CLOSE(handshakefds[1]) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"could not close handshake fd\"));\n        goto cleanup;\n    }\n\n    if (virCommandHandshakeWait(cmd) < 0)\n        goto cleanup;\n\n    /* Write domain status to disk for the controller to\n     * read when it starts */\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        goto cleanup;\n\n    /* Allow the child to exec the controller */\n    if (virCommandHandshakeNotify(cmd) < 0)\n        goto cleanup;\n\n    if (g_atomic_int_add(&driver->nactive, 1) == 0 && driver->inhibitCallback)\n        driver->inhibitCallback(true, driver->inhibitOpaque);\n\n    if (lxcContainerWaitForContinue(handshakefds[0]) < 0) {\n        char out[1024];\n\n        if (!(virLXCProcessReadLogOutput(vm, logfile, pos, out, 1024) < 0)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), out);\n        }\n\n        goto cleanup;\n    }\n\n    priv->machineName = virLXCDomainGetMachineName(vm->def, vm->pid);\n    if (!priv->machineName)\n        goto cleanup;\n\n    /* We know the cgroup must exist by this synchronization\n     * point so lets detect that first, since it gives us a\n     * more reliable way to kill everything off if something\n     * goes wrong from here onwards ... */\n    if (virCgroupNewDetectMachine(vm->def->name, \"lxc\",\n                                  vm->pid, -1, priv->machineName,\n                                  &priv->cgroup) < 0)\n        goto cleanup;\n\n    if (!priv->cgroup) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No valid cgroup for machine %s\"),\n                       vm->def->name);\n        goto cleanup;\n    }\n\n    /* And we can get the first monitor connection now too */\n    if (!(priv->monitor = virLXCProcessConnectMonitor(driver, vm))) {\n        /* Intentionally overwrite the real monitor error message,\n         * since a better one is almost always found in the logs\n         */\n        if (virLXCProcessReadLogOutput(vm, logfile, pos, ebuf, sizeof(ebuf)) > 0) {\n            virResetLastError();\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"guest failed to start: %s\"), ebuf);\n        }\n        goto cleanup;\n    }\n\n    if (autoDestroy &&\n        virCloseCallbacksSet(driver->closeCallbacks, vm,\n                             conn, lxcProcessAutoDestroy) < 0)\n        goto cleanup;\n\n    /* We don't need the temporary NIC names anymore, clear them */\n    virLXCProcessCleanInterfaces(vm->def);\n\n    /* finally we can call the 'started' hook script if any */\n    if (virHookPresent(VIR_HOOK_DRIVER_LXC)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LXC, vm->def->name,\n                              VIR_HOOK_LXC_OP_STARTED, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup;\n    }\n\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(logfd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"could not close logfile\"));\n        rc = -1;\n    }\n    if (rc != 0) {\n        virErrorPreserveLast(&err);\n        virLXCProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED);\n    }\n    virCommandFree(cmd);\n    for (i = 0; i < nttyFDs; i++)\n        VIR_FORCE_CLOSE(ttyFDs[i]);\n    VIR_FREE(ttyFDs);\n    VIR_FORCE_CLOSE(handshakefds[0]);\n    VIR_FORCE_CLOSE(handshakefds[1]);\n    VIR_FREE(pidfile);\n    VIR_FREE(logfile);\n    virObjectUnref(cfg);\n    virObjectUnref(caps);\n\n    virErrorRestore(&err);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCProcessStop",
          "args": [
            "driver",
            "vm",
            "VIR_DOMAIN_SHUTOFF_SHUTDOWN"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "852-915",
          "snippet": "int virLXCProcessStop(virLXCDriverPtr driver,\n                      virDomainObjPtr vm,\n                      virDomainShutoffReason reason)\n{\n    int rc;\n    virLXCDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"Stopping VM name=%s pid=%d reason=%d\",\n              vm->def->name, (int)vm->pid, (int)reason);\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    priv = vm->privateData;\n\n    /* If the LXC domain is suspended we send all processes a SIGKILL\n     * and thaw them. Upon wakeup the process sees the pending signal\n     * and dies immediately. It is guaranteed that priv->cgroup != NULL\n     * here because the domain has aleady been suspended using the\n     * freezer cgroup.\n     */\n    if (reason == VIR_DOMAIN_SHUTOFF_DESTROYED &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED) {\n        if (virCgroupKillRecursive(priv->cgroup, SIGKILL) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to kill all processes\"));\n            return -1;\n        }\n\n        if (virCgroupSetFreezerState(priv->cgroup, \"THAWED\") < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Unable to thaw all processes\"));\n\n            return -1;\n        }\n\n        goto cleanup;\n    }\n\n    if (priv->cgroup) {\n        rc = virCgroupKillPainfully(priv->cgroup);\n        if (rc < 0)\n            return -1;\n        if (rc > 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Some processes refused to die\"));\n            return -1;\n        }\n    } else if (vm->pid > 0) {\n        /* If cgroup doesn't exist, just try cleaning up the\n         * libvirt_lxc process */\n        if (virProcessKillPainfully(vm->pid, true) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Processes %d refused to die\"), (int)vm->pid);\n            return -1;\n        }\n    }\n\n cleanup:\n    virLXCProcessCleanup(driver, vm, reason);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virLXCProcessStop(virLXCDriverPtr driver,\n                      virDomainObjPtr vm,\n                      virDomainShutoffReason reason)\n{\n    int rc;\n    virLXCDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"Stopping VM name=%s pid=%d reason=%d\",\n              vm->def->name, (int)vm->pid, (int)reason);\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    priv = vm->privateData;\n\n    /* If the LXC domain is suspended we send all processes a SIGKILL\n     * and thaw them. Upon wakeup the process sees the pending signal\n     * and dies immediately. It is guaranteed that priv->cgroup != NULL\n     * here because the domain has aleady been suspended using the\n     * freezer cgroup.\n     */\n    if (reason == VIR_DOMAIN_SHUTOFF_DESTROYED &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED) {\n        if (virCgroupKillRecursive(priv->cgroup, SIGKILL) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to kill all processes\"));\n            return -1;\n        }\n\n        if (virCgroupSetFreezerState(priv->cgroup, \"THAWED\") < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Unable to thaw all processes\"));\n\n            return -1;\n        }\n\n        goto cleanup;\n    }\n\n    if (priv->cgroup) {\n        rc = virCgroupKillPainfully(priv->cgroup);\n        if (rc < 0)\n            return -1;\n        if (rc > 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Some processes refused to die\"));\n            return -1;\n        }\n    } else if (vm->pid > 0) {\n        /* If cgroup doesn't exist, just try cleaning up the\n         * libvirt_lxc process */\n        if (virProcessKillPainfully(vm->pid, true) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Processes %d refused to die\"), (int)vm->pid);\n            return -1;\n        }\n    }\n\n cleanup:\n    virLXCProcessCleanup(driver, vm, reason);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectOpen",
          "args": [
            "\"lxc:///system\""
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectOpenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "1181-1199",
          "snippet": "virConnectPtr\nvirConnectOpenReadOnly(const char *name)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n    virResetLastError();\n    ret = virConnectOpenInternal(name, NULL, VIR_CONNECT_RO);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirConnectPtr\nvirConnectOpenReadOnly(const char *name)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n    virResetLastError();\n    ret = virConnectOpenInternal(name, NULL, VIR_CONNECT_RO);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "conn"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Faking reboot\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCloseCallbacksGetConn",
          "args": [
            "driver->closeCallbacks",
            "vm"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "virCloseCallbacksGetConn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virclosecallbacks.c",
          "lines": "205-226",
          "snippet": "virConnectPtr\nvirCloseCallbacksGetConn(virCloseCallbacksPtr closeCallbacks,\n                         virDomainObjPtr vm)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    virConnectPtr conn = NULL;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s\", vm->def->name, uuidstr);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (closeDef)\n        conn = closeDef->conn;\n\n    virObjectUnlock(closeCallbacks);\n\n    VIR_DEBUG(\"conn=%p\", conn);\n    return conn;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virclosecallbacks.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virclosecallbacks.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvirConnectPtr\nvirCloseCallbacksGetConn(virCloseCallbacksPtr closeCallbacks,\n                         virDomainObjPtr vm)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    virConnectPtr conn = NULL;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s\", vm->def->name, uuidstr);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (closeDef)\n        conn = closeDef->conn;\n\n    virObjectUnlock(closeCallbacks);\n\n    VIR_DEBUG(\"conn=%p\", conn);\n    return conn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirLXCProcessReboot(virLXCDriverPtr driver,\n                    virDomainObjPtr vm)\n{\n    virConnectPtr conn = virCloseCallbacksGetConn(driver->closeCallbacks, vm);\n    int reason = vm->state.reason;\n    bool autodestroy = false;\n    int ret = -1;\n    virDomainDefPtr savedDef;\n\n    VIR_DEBUG(\"Faking reboot\");\n\n    if (conn) {\n        virObjectRef(conn);\n        autodestroy = true;\n    } else {\n        conn = virConnectOpen(\"lxc:///system\");\n        /* Ignoring NULL conn which is mostly harmless here */\n    }\n\n    /* In a reboot scenario, we need to make sure we continue\n     * to use the current 'def', and not switch to 'newDef'.\n     * So temporarily hide the newDef and then reinstate it\n     */\n    savedDef = vm->newDef;\n    vm->newDef = NULL;\n    virLXCProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n    vm->newDef = savedDef;\n    if (virLXCProcessStart(conn, driver, vm,\n                           0, NULL, autodestroy, reason) < 0) {\n        VIR_WARN(\"Unable to handle reboot of vm %s\",\n                 vm->def->name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(conn);\n    return ret;\n}"
  },
  {
    "function_name": "lxcProcessAutoDestroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
    "lines": "62-86",
    "snippet": "static void\nlxcProcessAutoDestroy(virDomainObjPtr dom,\n                      virConnectPtr conn,\n                      void *opaque)\n{\n    virLXCDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    virLXCDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"driver=%p dom=%s conn=%p\", driver, dom->def->name, conn);\n\n    priv = dom->privateData;\n    VIR_DEBUG(\"Killing domain\");\n    virLXCProcessStop(driver, dom, VIR_DOMAIN_SHUTOFF_DESTROYED);\n    virDomainAuditStop(dom, \"destroyed\");\n    event = virDomainEventLifecycleNewFromObj(dom,\n                                     VIR_DOMAIN_EVENT_STOPPED,\n                                     VIR_DOMAIN_EVENT_STOPPED_DESTROYED);\n    priv->doneStopEvent = true;\n\n    if (!dom->persistent)\n        virDomainObjListRemove(driver->domains, dom);\n\n    virObjectEventStateQueue(driver->domainEventState, event);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virsystemd.h\"",
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"lxc_hostdev.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"domain_audit.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_nwfilter.h\"",
      "#include \"virtime.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevveth.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"lxc_fuse.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_container.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_process.h\"",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->domainEventState",
            "event"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListRemove",
          "args": [
            "driver->domains",
            "dom"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "401-413",
          "snippet": "void\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainEventLifecycleNewFromObj",
          "args": [
            "dom",
            "VIR_DOMAIN_EVENT_STOPPED",
            "VIR_DOMAIN_EVENT_STOPPED_DESTROYED"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainEventLifecycleNewFromObj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_event.c",
          "lines": "610-616",
          "snippet": "virObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainEventDispose(void *obj);",
            "static void virDomainEventLifecycleDispose(void *obj);",
            "static void virDomainEventRTCChangeDispose(void *obj);",
            "static void virDomainEventWatchdogDispose(void *obj);",
            "static void virDomainEventIOErrorDispose(void *obj);",
            "static void virDomainEventGraphicsDispose(void *obj);",
            "static void virDomainEventBlockJobDispose(void *obj);",
            "static void virDomainEventDiskChangeDispose(void *obj);",
            "static void virDomainEventTrayChangeDispose(void *obj);",
            "static void virDomainEventBalloonChangeDispose(void *obj);",
            "static void virDomainEventDeviceRemovedDispose(void *obj);",
            "static void virDomainEventPMDispose(void *obj);",
            "static void virDomainQemuMonitorEventDispose(void *obj);",
            "static void virDomainEventTunableDispose(void *obj);",
            "static void virDomainEventAgentLifecycleDispose(void *obj);",
            "static void virDomainEventDeviceAddedDispose(void *obj);",
            "static void virDomainEventMigrationIterationDispose(void *obj);",
            "static void virDomainEventJobCompletedDispose(void *obj);",
            "static void virDomainEventDeviceRemovalFailedDispose(void *obj);",
            "static void virDomainEventMetadataChangeDispose(void *obj);",
            "static void virDomainEventBlockThresholdDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virDomainEventDispose(void *obj);\nstatic void virDomainEventLifecycleDispose(void *obj);\nstatic void virDomainEventRTCChangeDispose(void *obj);\nstatic void virDomainEventWatchdogDispose(void *obj);\nstatic void virDomainEventIOErrorDispose(void *obj);\nstatic void virDomainEventGraphicsDispose(void *obj);\nstatic void virDomainEventBlockJobDispose(void *obj);\nstatic void virDomainEventDiskChangeDispose(void *obj);\nstatic void virDomainEventTrayChangeDispose(void *obj);\nstatic void virDomainEventBalloonChangeDispose(void *obj);\nstatic void virDomainEventDeviceRemovedDispose(void *obj);\nstatic void virDomainEventPMDispose(void *obj);\nstatic void virDomainQemuMonitorEventDispose(void *obj);\nstatic void virDomainEventTunableDispose(void *obj);\nstatic void virDomainEventAgentLifecycleDispose(void *obj);\nstatic void virDomainEventDeviceAddedDispose(void *obj);\nstatic void virDomainEventMigrationIterationDispose(void *obj);\nstatic void virDomainEventJobCompletedDispose(void *obj);\nstatic void virDomainEventDeviceRemovalFailedDispose(void *obj);\nstatic void virDomainEventMetadataChangeDispose(void *obj);\nstatic void virDomainEventBlockThresholdDispose(void *obj);\n\nvirObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainAuditStop",
          "args": [
            "dom",
            "\"destroyed\""
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainAuditStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_audit.c",
          "lines": "866-870",
          "snippet": "void\nvirDomainAuditStop(virDomainObjPtr vm, const char *reason)\n{\n    virDomainAuditLifecycle(vm, \"stop\", reason, true);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"viruuid.h\"",
            "#include \"viraudit.h\"",
            "#include \"domain_audit.h\"",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"viruuid.h\"\n#include \"viraudit.h\"\n#include \"domain_audit.h\"\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid\nvirDomainAuditStop(virDomainObjPtr vm, const char *reason)\n{\n    virDomainAuditLifecycle(vm, \"stop\", reason, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCProcessStop",
          "args": [
            "driver",
            "dom",
            "VIR_DOMAIN_SHUTOFF_DESTROYED"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCProcessStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_process.c",
          "lines": "852-915",
          "snippet": "int virLXCProcessStop(virLXCDriverPtr driver,\n                      virDomainObjPtr vm,\n                      virDomainShutoffReason reason)\n{\n    int rc;\n    virLXCDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"Stopping VM name=%s pid=%d reason=%d\",\n              vm->def->name, (int)vm->pid, (int)reason);\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    priv = vm->privateData;\n\n    /* If the LXC domain is suspended we send all processes a SIGKILL\n     * and thaw them. Upon wakeup the process sees the pending signal\n     * and dies immediately. It is guaranteed that priv->cgroup != NULL\n     * here because the domain has aleady been suspended using the\n     * freezer cgroup.\n     */\n    if (reason == VIR_DOMAIN_SHUTOFF_DESTROYED &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED) {\n        if (virCgroupKillRecursive(priv->cgroup, SIGKILL) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to kill all processes\"));\n            return -1;\n        }\n\n        if (virCgroupSetFreezerState(priv->cgroup, \"THAWED\") < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Unable to thaw all processes\"));\n\n            return -1;\n        }\n\n        goto cleanup;\n    }\n\n    if (priv->cgroup) {\n        rc = virCgroupKillPainfully(priv->cgroup);\n        if (rc < 0)\n            return -1;\n        if (rc > 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Some processes refused to die\"));\n            return -1;\n        }\n    } else if (vm->pid > 0) {\n        /* If cgroup doesn't exist, just try cleaning up the\n         * libvirt_lxc process */\n        if (virProcessKillPainfully(vm->pid, true) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Processes %d refused to die\"), (int)vm->pid);\n            return -1;\n        }\n    }\n\n cleanup:\n    virLXCProcessCleanup(driver, vm, reason);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"lxc_hostdev.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_audit.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virtime.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"lxc_fuse.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_process.h\"",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virLXCProcessStop(virLXCDriverPtr driver,\n                      virDomainObjPtr vm,\n                      virDomainShutoffReason reason)\n{\n    int rc;\n    virLXCDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"Stopping VM name=%s pid=%d reason=%d\",\n              vm->def->name, (int)vm->pid, (int)reason);\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        return 0;\n    }\n\n    priv = vm->privateData;\n\n    /* If the LXC domain is suspended we send all processes a SIGKILL\n     * and thaw them. Upon wakeup the process sees the pending signal\n     * and dies immediately. It is guaranteed that priv->cgroup != NULL\n     * here because the domain has aleady been suspended using the\n     * freezer cgroup.\n     */\n    if (reason == VIR_DOMAIN_SHUTOFF_DESTROYED &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED) {\n        if (virCgroupKillRecursive(priv->cgroup, SIGKILL) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to kill all processes\"));\n            return -1;\n        }\n\n        if (virCgroupSetFreezerState(priv->cgroup, \"THAWED\") < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Unable to thaw all processes\"));\n\n            return -1;\n        }\n\n        goto cleanup;\n    }\n\n    if (priv->cgroup) {\n        rc = virCgroupKillPainfully(priv->cgroup);\n        if (rc < 0)\n            return -1;\n        if (rc > 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Some processes refused to die\"));\n            return -1;\n        }\n    } else if (vm->pid > 0) {\n        /* If cgroup doesn't exist, just try cleaning up the\n         * libvirt_lxc process */\n        if (virProcessKillPainfully(vm->pid, true) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Processes %d refused to die\"), (int)vm->pid);\n            return -1;\n        }\n    }\n\n cleanup:\n    virLXCProcessCleanup(driver, vm, reason);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Killing domain\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver=%p dom=%s conn=%p\"",
            "driver",
            "dom->def->name",
            "conn"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virsystemd.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"lxc_hostdev.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"domain_audit.h\"\n#include \"viralloc.h\"\n#include \"domain_nwfilter.h\"\n#include \"virtime.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevveth.h\"\n#include \"virnetdev.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"lxc_fuse.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_process.h\"\n#include <signal.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic void\nlxcProcessAutoDestroy(virDomainObjPtr dom,\n                      virConnectPtr conn,\n                      void *opaque)\n{\n    virLXCDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    virLXCDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"driver=%p dom=%s conn=%p\", driver, dom->def->name, conn);\n\n    priv = dom->privateData;\n    VIR_DEBUG(\"Killing domain\");\n    virLXCProcessStop(driver, dom, VIR_DOMAIN_SHUTOFF_DESTROYED);\n    virDomainAuditStop(dom, \"destroyed\");\n    event = virDomainEventLifecycleNewFromObj(dom,\n                                     VIR_DOMAIN_EVENT_STOPPED,\n                                     VIR_DOMAIN_EVENT_STOPPED_DESTROYED);\n    priv->doneStopEvent = true;\n\n    if (!dom->persistent)\n        virDomainObjListRemove(driver->domains, dom);\n\n    virObjectEventStateQueue(driver->domainEventState, event);\n}"
  }
]