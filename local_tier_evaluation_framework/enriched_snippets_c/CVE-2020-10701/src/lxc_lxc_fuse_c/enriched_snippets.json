[
  {
    "function_name": "lxcFreeFuse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
    "lines": "375-377",
    "snippet": "void lxcFreeFuse(virLXCFusePtr *f G_GNUC_UNUSED)\n{\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_fuse.h\"",
      "#include <unistd.h>",
      "#include <mntent.h>",
      "#include <sys/mount.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid lxcFreeFuse(virLXCFusePtr *f G_GNUC_UNUSED)\n{\n}"
  },
  {
    "function_name": "lxcStartFuse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
    "lines": "370-373",
    "snippet": "int lxcStartFuse(virLXCFusePtr f G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_fuse.h\"",
      "#include <unistd.h>",
      "#include <mntent.h>",
      "#include <sys/mount.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nint lxcStartFuse(virLXCFusePtr f G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "lxcSetupFuse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
    "lines": "364-368",
    "snippet": "int lxcSetupFuse(virLXCFusePtr *f G_GNUC_UNUSED,\n                  virDomainDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_fuse.h\"",
      "#include <unistd.h>",
      "#include <mntent.h>",
      "#include <sys/mount.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nint lxcSetupFuse(virLXCFusePtr *f G_GNUC_UNUSED,\n                  virDomainDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "lxcFreeFuse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
    "lines": "347-362",
    "snippet": "void lxcFreeFuse(virLXCFusePtr *f)\n{\n    virLXCFusePtr fuse = *f;\n    /* lxcFuseRun thread create success */\n    if (fuse) {\n        /* exit fuse_loop, lxcFuseRun thread may try to destroy\n         * fuse->fuse at the same time,so add a lock here. */\n        virMutexLock(&fuse->lock);\n        if (fuse->fuse)\n            fuse_exit(fuse->fuse);\n        virMutexUnlock(&fuse->lock);\n\n        VIR_FREE(fuse->mountpoint);\n        VIR_FREE(*f);\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_fuse.h\"",
      "#include <unistd.h>",
      "#include <mntent.h>",
      "#include <sys/mount.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*f"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fuse->mountpoint"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&fuse->lock"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_exit",
          "args": [
            "fuse->fuse"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&fuse->lock"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid lxcFreeFuse(virLXCFusePtr *f)\n{\n    virLXCFusePtr fuse = *f;\n    /* lxcFuseRun thread create success */\n    if (fuse) {\n        /* exit fuse_loop, lxcFuseRun thread may try to destroy\n         * fuse->fuse at the same time,so add a lock here. */\n        virMutexLock(&fuse->lock);\n        if (fuse->fuse)\n            fuse_exit(fuse->fuse);\n        virMutexUnlock(&fuse->lock);\n\n        VIR_FREE(fuse->mountpoint);\n        VIR_FREE(*f);\n    }\n}"
  },
  {
    "function_name": "lxcStartFuse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
    "lines": "336-345",
    "snippet": "int lxcStartFuse(virLXCFusePtr fuse)\n{\n    if (virThreadCreateFull(&fuse->thread, false, lxcFuseRun,\n                            \"lxc-fuse\", false, (void *)fuse) < 0) {\n        lxcFuseDestroy(fuse);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_fuse.h\"",
      "#include <unistd.h>",
      "#include <mntent.h>",
      "#include <sys/mount.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxcFuseDestroy",
          "args": [
            "fuse"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "lxcFuseDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
          "lines": "263-270",
          "snippet": "static void lxcFuseDestroy(virLXCFusePtr fuse)\n{\n    virMutexLock(&fuse->lock);\n    fuse_unmount(fuse->mountpoint, fuse->ch);\n    fuse_destroy(fuse->fuse);\n    fuse->fuse = NULL;\n    virMutexUnlock(&fuse->lock);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_fuse.h\"",
            "#include <unistd.h>",
            "#include <mntent.h>",
            "#include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void lxcFuseDestroy(virLXCFusePtr fuse)\n{\n    virMutexLock(&fuse->lock);\n    fuse_unmount(fuse->mountpoint, fuse->ch);\n    fuse_destroy(fuse->fuse);\n    fuse->fuse = NULL;\n    virMutexUnlock(&fuse->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadCreateFull",
          "args": [
            "&fuse->thread",
            "false",
            "lxcFuseRun",
            "\"lxc-fuse\"",
            "false",
            "(void *)fuse"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadCreateFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "242-283",
          "snippet": "int virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nint lxcStartFuse(virLXCFusePtr fuse)\n{\n    if (virThreadCreateFull(&fuse->thread, false, lxcFuseRun,\n                            \"lxc-fuse\", false, (void *)fuse) < 0) {\n        lxcFuseDestroy(fuse);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "lxcSetupFuse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
    "lines": "283-334",
    "snippet": "int lxcSetupFuse(virLXCFusePtr *f, virDomainDefPtr def)\n{\n    int ret = -1;\n    struct fuse_args args = FUSE_ARGS_INIT(0, NULL);\n    virLXCFusePtr fuse = NULL;\n\n    if (VIR_ALLOC(fuse) < 0)\n        goto cleanup;\n\n    fuse->def = def;\n\n    if (virMutexInit(&fuse->lock) < 0)\n        goto cleanup2;\n\n    fuse->mountpoint = g_strdup_printf(\"%s/%s.fuse/\", LXC_STATE_DIR, def->name);\n\n    if (virFileMakePath(fuse->mountpoint) < 0) {\n        virReportSystemError(errno, _(\"Cannot create %s\"),\n                             fuse->mountpoint);\n        goto cleanup1;\n    }\n\n    /* process name is libvirt_lxc */\n    if (fuse_opt_add_arg(&args, \"libvirt_lxc\") == -1 ||\n        fuse_opt_add_arg(&args, \"-odirect_io\") == -1 ||\n        fuse_opt_add_arg(&args, \"-oallow_other\") == -1 ||\n        fuse_opt_add_arg(&args, \"-ofsname=libvirt\") == -1)\n        goto cleanup1;\n\n    fuse->ch = fuse_mount(fuse->mountpoint, &args);\n    if (fuse->ch == NULL)\n        goto cleanup1;\n\n    fuse->fuse = fuse_new(fuse->ch, &args, &lxcProcOper,\n                          sizeof(lxcProcOper), fuse->def);\n    if (fuse->fuse == NULL) {\n        fuse_unmount(fuse->mountpoint, fuse->ch);\n        goto cleanup1;\n    }\n\n    ret = 0;\n cleanup:\n    fuse_opt_free_args(&args);\n    *f = fuse;\n    return ret;\n cleanup1:\n    VIR_FREE(fuse->mountpoint);\n    virMutexDestroy(&fuse->lock);\n cleanup2:\n    VIR_FREE(fuse);\n    goto cleanup;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_fuse.h\"",
      "#include <unistd.h>",
      "#include <mntent.h>",
      "#include <sys/mount.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fuse"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "&fuse->lock"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fuse->mountpoint"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_opt_free_args",
          "args": [
            "&args"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_unmount",
          "args": [
            "fuse->mountpoint",
            "fuse->ch"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_new",
          "args": [
            "fuse->ch",
            "&args",
            "&lxcProcOper",
            "sizeof(lxcProcOper)",
            "fuse->def"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_mount",
          "args": [
            "fuse->mountpoint",
            "&args"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_opt_add_arg",
          "args": [
            "&args",
            "\"-ofsname=libvirt\""
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_opt_add_arg",
          "args": [
            "&args",
            "\"-oallow_other\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_opt_add_arg",
          "args": [
            "&args",
            "\"-odirect_io\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_opt_add_arg",
          "args": [
            "&args",
            "\"libvirt_lxc\""
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot create %s\")",
            "fuse->mountpoint"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot create %s\""
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "userns_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2329-2332",
          "snippet": "static int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "fuse->mountpoint"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s.fuse/\"",
            "LXC_STATE_DIR",
            "def->name"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexInit",
          "args": [
            "&fuse->lock"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexInitRecursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "61-74",
          "snippet": "int virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "fuse"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS_INIT",
          "args": [
            "0",
            "NULL"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nint lxcSetupFuse(virLXCFusePtr *f, virDomainDefPtr def)\n{\n    int ret = -1;\n    struct fuse_args args = FUSE_ARGS_INIT(0, NULL);\n    virLXCFusePtr fuse = NULL;\n\n    if (VIR_ALLOC(fuse) < 0)\n        goto cleanup;\n\n    fuse->def = def;\n\n    if (virMutexInit(&fuse->lock) < 0)\n        goto cleanup2;\n\n    fuse->mountpoint = g_strdup_printf(\"%s/%s.fuse/\", LXC_STATE_DIR, def->name);\n\n    if (virFileMakePath(fuse->mountpoint) < 0) {\n        virReportSystemError(errno, _(\"Cannot create %s\"),\n                             fuse->mountpoint);\n        goto cleanup1;\n    }\n\n    /* process name is libvirt_lxc */\n    if (fuse_opt_add_arg(&args, \"libvirt_lxc\") == -1 ||\n        fuse_opt_add_arg(&args, \"-odirect_io\") == -1 ||\n        fuse_opt_add_arg(&args, \"-oallow_other\") == -1 ||\n        fuse_opt_add_arg(&args, \"-ofsname=libvirt\") == -1)\n        goto cleanup1;\n\n    fuse->ch = fuse_mount(fuse->mountpoint, &args);\n    if (fuse->ch == NULL)\n        goto cleanup1;\n\n    fuse->fuse = fuse_new(fuse->ch, &args, &lxcProcOper,\n                          sizeof(lxcProcOper), fuse->def);\n    if (fuse->fuse == NULL) {\n        fuse_unmount(fuse->mountpoint, fuse->ch);\n        goto cleanup1;\n    }\n\n    ret = 0;\n cleanup:\n    fuse_opt_free_args(&args);\n    *f = fuse;\n    return ret;\n cleanup1:\n    VIR_FREE(fuse->mountpoint);\n    virMutexDestroy(&fuse->lock);\n cleanup2:\n    VIR_FREE(fuse);\n    goto cleanup;\n}"
  },
  {
    "function_name": "lxcFuseRun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
    "lines": "272-281",
    "snippet": "static void lxcFuseRun(void *opaque)\n{\n    virLXCFusePtr fuse = opaque;\n\n    if (fuse_loop(fuse->fuse) < 0)\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"fuse_loop failed\"));\n\n    lxcFuseDestroy(fuse);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_fuse.h\"",
      "#include <unistd.h>",
      "#include <mntent.h>",
      "#include <sys/mount.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxcFuseDestroy",
          "args": [
            "fuse"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "lxcFuseDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
          "lines": "263-270",
          "snippet": "static void lxcFuseDestroy(virLXCFusePtr fuse)\n{\n    virMutexLock(&fuse->lock);\n    fuse_unmount(fuse->mountpoint, fuse->ch);\n    fuse_destroy(fuse->fuse);\n    fuse->fuse = NULL;\n    virMutexUnlock(&fuse->lock);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_fuse.h\"",
            "#include <unistd.h>",
            "#include <mntent.h>",
            "#include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void lxcFuseDestroy(virLXCFusePtr fuse)\n{\n    virMutexLock(&fuse->lock);\n    fuse_unmount(fuse->mountpoint, fuse->ch);\n    fuse_destroy(fuse->fuse);\n    fuse->fuse = NULL;\n    virMutexUnlock(&fuse->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"fuse_loop failed\")"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"fuse_loop failed\""
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "userns_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2329-2332",
          "snippet": "static int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_loop",
          "args": [
            "fuse->fuse"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void lxcFuseRun(void *opaque)\n{\n    virLXCFusePtr fuse = opaque;\n\n    if (fuse_loop(fuse->fuse) < 0)\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"fuse_loop failed\"));\n\n    lxcFuseDestroy(fuse);\n}"
  },
  {
    "function_name": "lxcFuseDestroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
    "lines": "263-270",
    "snippet": "static void lxcFuseDestroy(virLXCFusePtr fuse)\n{\n    virMutexLock(&fuse->lock);\n    fuse_unmount(fuse->mountpoint, fuse->ch);\n    fuse_destroy(fuse->fuse);\n    fuse->fuse = NULL;\n    virMutexUnlock(&fuse->lock);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_fuse.h\"",
      "#include <unistd.h>",
      "#include <mntent.h>",
      "#include <sys/mount.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&fuse->lock"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_destroy",
          "args": [
            "fuse->fuse"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_unmount",
          "args": [
            "fuse->mountpoint",
            "fuse->ch"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&fuse->lock"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void lxcFuseDestroy(virLXCFusePtr fuse)\n{\n    virMutexLock(&fuse->lock);\n    fuse_unmount(fuse->mountpoint, fuse->ch);\n    fuse_destroy(fuse->fuse);\n    fuse->fuse = NULL;\n    virMutexUnlock(&fuse->lock);\n}"
  },
  {
    "function_name": "lxcProcRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
    "lines": "232-254",
    "snippet": "static int lxcProcRead(const char *path G_GNUC_UNUSED,\n                       char *buf G_GNUC_UNUSED,\n                       size_t size G_GNUC_UNUSED,\n                       off_t offset G_GNUC_UNUSED,\n                       struct fuse_file_info *fi G_GNUC_UNUSED)\n{\n    int res = -ENOENT;\n    g_autofree char *hostpath = NULL;\n    struct fuse_context *context = NULL;\n    virDomainDefPtr def = NULL;\n\n    hostpath = g_strdup_printf(\"/proc/%s\", path);\n\n    context = fuse_get_context();\n    def = (virDomainDefPtr)context->private_data;\n\n    if (STREQ(path, fuse_meminfo_path)) {\n        if ((res = lxcProcReadMeminfo(hostpath, def, buf, size, offset)) < 0)\n            res = lxcProcHostRead(hostpath, buf, size, offset);\n    }\n\n    return res;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_fuse.h\"",
      "#include <unistd.h>",
      "#include <mntent.h>",
      "#include <sys/mount.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxcProcHostRead",
          "args": [
            "hostpath",
            "buf",
            "size",
            "offset"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "lxcProcHostRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
          "lines": "104-118",
          "snippet": "static int lxcProcHostRead(char *path, char *buf, size_t size, off_t offset)\n{\n    int fd;\n    int res;\n\n    fd = open(path, O_RDONLY);\n    if (fd == -1)\n        return -errno;\n\n    if ((res = pread(fd, buf, size, offset)) < 0)\n        res = -errno;\n\n    VIR_FORCE_CLOSE(fd);\n    return res;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_fuse.h\"",
            "#include <unistd.h>",
            "#include <mntent.h>",
            "#include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int lxcProcHostRead(char *path, char *buf, size_t size, off_t offset)\n{\n    int fd;\n    int res;\n\n    fd = open(path, O_RDONLY);\n    if (fd == -1)\n        return -errno;\n\n    if ((res = pread(fd, buf, size, offset)) < 0)\n        res = -errno;\n\n    VIR_FORCE_CLOSE(fd);\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxcProcReadMeminfo",
          "args": [
            "hostpath",
            "def",
            "buf",
            "size",
            "offset"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "lxcProcReadMeminfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
          "lines": "120-230",
          "snippet": "static int lxcProcReadMeminfo(char *hostpath, virDomainDefPtr def,\n                              char *buf, size_t size, off_t offset)\n{\n    int res;\n    FILE *fd = NULL;\n    g_autofree char *line = NULL;\n    size_t n;\n    struct virLXCMeminfo meminfo;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    virBufferPtr new_meminfo = &buffer;\n\n    if (virLXCCgroupGetMeminfo(&meminfo) < 0) {\n        virErrorSetErrnoFromLastError();\n        return -errno;\n    }\n\n    fd = fopen(hostpath, \"r\");\n    if (fd == NULL) {\n        virReportSystemError(errno, _(\"Cannot open %s\"), hostpath);\n        res = -errno;\n        goto cleanup;\n    }\n\n    if (fseek(fd, offset, SEEK_SET) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"fseek failed\"));\n        res = -errno;\n        goto cleanup;\n    }\n\n    res = -1;\n    while (getline(&line, &n, fd) > 0) {\n        char *ptr = strchr(line, ':');\n        if (!ptr)\n            continue;\n        *ptr = '\\0';\n\n        if (STREQ(line, \"MemTotal\") &&\n            (virMemoryLimitIsSet(def->mem.hard_limit) ||\n             virDomainDefGetMemoryTotal(def))) {\n            virBufferAsprintf(new_meminfo, \"MemTotal:       %8llu kB\\n\",\n                              meminfo.memtotal);\n        } else if (STREQ(line, \"MemFree\") &&\n                   (virMemoryLimitIsSet(def->mem.hard_limit) ||\n                    virDomainDefGetMemoryTotal(def))) {\n            virBufferAsprintf(new_meminfo, \"MemFree:        %8llu kB\\n\",\n                              (meminfo.memtotal - meminfo.memusage));\n        } else if (STREQ(line, \"MemAvailable\") &&\n                   (virMemoryLimitIsSet(def->mem.hard_limit) ||\n                    virDomainDefGetMemoryTotal(def))) {\n            /* MemAvailable is actually MemFree + SRReclaimable +\n               some other bits, but MemFree is the closest approximation\n               we have */\n            virBufferAsprintf(new_meminfo, \"MemAvailable:   %8llu kB\\n\",\n                              (meminfo.memtotal - meminfo.memusage));\n        } else if (STREQ(line, \"Buffers\")) {\n            virBufferAsprintf(new_meminfo, \"Buffers:        %8d kB\\n\", 0);\n        } else if (STREQ(line, \"Cached\")) {\n            virBufferAsprintf(new_meminfo, \"Cached:         %8llu kB\\n\",\n                              meminfo.cached);\n        } else if (STREQ(line, \"Active\")) {\n            virBufferAsprintf(new_meminfo, \"Active:         %8llu kB\\n\",\n                              (meminfo.active_anon + meminfo.active_file));\n        } else if (STREQ(line, \"Inactive\")) {\n            virBufferAsprintf(new_meminfo, \"Inactive:       %8llu kB\\n\",\n                              (meminfo.inactive_anon + meminfo.inactive_file));\n        } else if (STREQ(line, \"Active(anon)\")) {\n            virBufferAsprintf(new_meminfo, \"Active(anon):   %8llu kB\\n\",\n                              meminfo.active_anon);\n        } else if (STREQ(line, \"Inactive(anon)\")) {\n            virBufferAsprintf(new_meminfo, \"Inactive(anon): %8llu kB\\n\",\n                              meminfo.inactive_anon);\n        } else if (STREQ(line, \"Active(file)\")) {\n            virBufferAsprintf(new_meminfo, \"Active(file):   %8llu kB\\n\",\n                              meminfo.active_file);\n        } else if (STREQ(line, \"Inactive(file)\")) {\n            virBufferAsprintf(new_meminfo, \"Inactive(file): %8llu kB\\n\",\n                              meminfo.inactive_file);\n        } else if (STREQ(line, \"Unevictable\")) {\n            virBufferAsprintf(new_meminfo, \"Unevictable:    %8llu kB\\n\",\n                              meminfo.unevictable);\n        } else if (STREQ(line, \"SwapTotal\") &&\n                   virMemoryLimitIsSet(def->mem.swap_hard_limit)) {\n            virBufferAsprintf(new_meminfo, \"SwapTotal:      %8llu kB\\n\",\n                              (meminfo.swaptotal - meminfo.memtotal));\n        } else if (STREQ(line, \"SwapFree\") &&\n                   virMemoryLimitIsSet(def->mem.swap_hard_limit)) {\n            virBufferAsprintf(new_meminfo, \"SwapFree:       %8llu kB\\n\",\n                              (meminfo.swaptotal - meminfo.memtotal -\n                               meminfo.swapusage + meminfo.memusage));\n        } else if (STREQ(line, \"Slab\")) {\n            virBufferAsprintf(new_meminfo, \"Slab:           %8d kB\\n\", 0);\n        } else if (STREQ(line, \"SReclaimable\")) {\n            virBufferAsprintf(new_meminfo, \"SReclaimable:   %8d kB\\n\", 0);\n        } else if (STREQ(line, \"SUnreclaim\")) {\n            virBufferAsprintf(new_meminfo, \"SUnreclaim:     %8d kB\\n\", 0);\n        } else {\n            *ptr = ':';\n            virBufferAdd(new_meminfo, line, -1);\n        }\n\n    }\n    res = strlen(virBufferCurrentContent(new_meminfo));\n    if (res > size)\n        res = size;\n    memcpy(buf, virBufferCurrentContent(new_meminfo), res);\n\n cleanup:\n    virBufferFreeAndReset(new_meminfo);\n    VIR_FORCE_FCLOSE(fd);\n    return res;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include \"lxc_fuse.h\"",
            "#include <unistd.h>",
            "#include <mntent.h>",
            "#include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int lxcProcReadMeminfo(char *hostpath, virDomainDefPtr def,\n                              char *buf, size_t size, off_t offset)\n{\n    int res;\n    FILE *fd = NULL;\n    g_autofree char *line = NULL;\n    size_t n;\n    struct virLXCMeminfo meminfo;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    virBufferPtr new_meminfo = &buffer;\n\n    if (virLXCCgroupGetMeminfo(&meminfo) < 0) {\n        virErrorSetErrnoFromLastError();\n        return -errno;\n    }\n\n    fd = fopen(hostpath, \"r\");\n    if (fd == NULL) {\n        virReportSystemError(errno, _(\"Cannot open %s\"), hostpath);\n        res = -errno;\n        goto cleanup;\n    }\n\n    if (fseek(fd, offset, SEEK_SET) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"fseek failed\"));\n        res = -errno;\n        goto cleanup;\n    }\n\n    res = -1;\n    while (getline(&line, &n, fd) > 0) {\n        char *ptr = strchr(line, ':');\n        if (!ptr)\n            continue;\n        *ptr = '\\0';\n\n        if (STREQ(line, \"MemTotal\") &&\n            (virMemoryLimitIsSet(def->mem.hard_limit) ||\n             virDomainDefGetMemoryTotal(def))) {\n            virBufferAsprintf(new_meminfo, \"MemTotal:       %8llu kB\\n\",\n                              meminfo.memtotal);\n        } else if (STREQ(line, \"MemFree\") &&\n                   (virMemoryLimitIsSet(def->mem.hard_limit) ||\n                    virDomainDefGetMemoryTotal(def))) {\n            virBufferAsprintf(new_meminfo, \"MemFree:        %8llu kB\\n\",\n                              (meminfo.memtotal - meminfo.memusage));\n        } else if (STREQ(line, \"MemAvailable\") &&\n                   (virMemoryLimitIsSet(def->mem.hard_limit) ||\n                    virDomainDefGetMemoryTotal(def))) {\n            /* MemAvailable is actually MemFree + SRReclaimable +\n               some other bits, but MemFree is the closest approximation\n               we have */\n            virBufferAsprintf(new_meminfo, \"MemAvailable:   %8llu kB\\n\",\n                              (meminfo.memtotal - meminfo.memusage));\n        } else if (STREQ(line, \"Buffers\")) {\n            virBufferAsprintf(new_meminfo, \"Buffers:        %8d kB\\n\", 0);\n        } else if (STREQ(line, \"Cached\")) {\n            virBufferAsprintf(new_meminfo, \"Cached:         %8llu kB\\n\",\n                              meminfo.cached);\n        } else if (STREQ(line, \"Active\")) {\n            virBufferAsprintf(new_meminfo, \"Active:         %8llu kB\\n\",\n                              (meminfo.active_anon + meminfo.active_file));\n        } else if (STREQ(line, \"Inactive\")) {\n            virBufferAsprintf(new_meminfo, \"Inactive:       %8llu kB\\n\",\n                              (meminfo.inactive_anon + meminfo.inactive_file));\n        } else if (STREQ(line, \"Active(anon)\")) {\n            virBufferAsprintf(new_meminfo, \"Active(anon):   %8llu kB\\n\",\n                              meminfo.active_anon);\n        } else if (STREQ(line, \"Inactive(anon)\")) {\n            virBufferAsprintf(new_meminfo, \"Inactive(anon): %8llu kB\\n\",\n                              meminfo.inactive_anon);\n        } else if (STREQ(line, \"Active(file)\")) {\n            virBufferAsprintf(new_meminfo, \"Active(file):   %8llu kB\\n\",\n                              meminfo.active_file);\n        } else if (STREQ(line, \"Inactive(file)\")) {\n            virBufferAsprintf(new_meminfo, \"Inactive(file): %8llu kB\\n\",\n                              meminfo.inactive_file);\n        } else if (STREQ(line, \"Unevictable\")) {\n            virBufferAsprintf(new_meminfo, \"Unevictable:    %8llu kB\\n\",\n                              meminfo.unevictable);\n        } else if (STREQ(line, \"SwapTotal\") &&\n                   virMemoryLimitIsSet(def->mem.swap_hard_limit)) {\n            virBufferAsprintf(new_meminfo, \"SwapTotal:      %8llu kB\\n\",\n                              (meminfo.swaptotal - meminfo.memtotal));\n        } else if (STREQ(line, \"SwapFree\") &&\n                   virMemoryLimitIsSet(def->mem.swap_hard_limit)) {\n            virBufferAsprintf(new_meminfo, \"SwapFree:       %8llu kB\\n\",\n                              (meminfo.swaptotal - meminfo.memtotal -\n                               meminfo.swapusage + meminfo.memusage));\n        } else if (STREQ(line, \"Slab\")) {\n            virBufferAsprintf(new_meminfo, \"Slab:           %8d kB\\n\", 0);\n        } else if (STREQ(line, \"SReclaimable\")) {\n            virBufferAsprintf(new_meminfo, \"SReclaimable:   %8d kB\\n\", 0);\n        } else if (STREQ(line, \"SUnreclaim\")) {\n            virBufferAsprintf(new_meminfo, \"SUnreclaim:     %8d kB\\n\", 0);\n        } else {\n            *ptr = ':';\n            virBufferAdd(new_meminfo, line, -1);\n        }\n\n    }\n    res = strlen(virBufferCurrentContent(new_meminfo));\n    if (res > size)\n        res = size;\n    memcpy(buf, virBufferCurrentContent(new_meminfo), res);\n\n cleanup:\n    virBufferFreeAndReset(new_meminfo);\n    VIR_FORCE_FCLOSE(fd);\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "path",
            "fuse_meminfo_path"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_get_context",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"/proc/%s\"",
            "path"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int lxcProcRead(const char *path G_GNUC_UNUSED,\n                       char *buf G_GNUC_UNUSED,\n                       size_t size G_GNUC_UNUSED,\n                       off_t offset G_GNUC_UNUSED,\n                       struct fuse_file_info *fi G_GNUC_UNUSED)\n{\n    int res = -ENOENT;\n    g_autofree char *hostpath = NULL;\n    struct fuse_context *context = NULL;\n    virDomainDefPtr def = NULL;\n\n    hostpath = g_strdup_printf(\"/proc/%s\", path);\n\n    context = fuse_get_context();\n    def = (virDomainDefPtr)context->private_data;\n\n    if (STREQ(path, fuse_meminfo_path)) {\n        if ((res = lxcProcReadMeminfo(hostpath, def, buf, size, offset)) < 0)\n            res = lxcProcHostRead(hostpath, buf, size, offset);\n    }\n\n    return res;\n}"
  },
  {
    "function_name": "lxcProcReadMeminfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
    "lines": "120-230",
    "snippet": "static int lxcProcReadMeminfo(char *hostpath, virDomainDefPtr def,\n                              char *buf, size_t size, off_t offset)\n{\n    int res;\n    FILE *fd = NULL;\n    g_autofree char *line = NULL;\n    size_t n;\n    struct virLXCMeminfo meminfo;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    virBufferPtr new_meminfo = &buffer;\n\n    if (virLXCCgroupGetMeminfo(&meminfo) < 0) {\n        virErrorSetErrnoFromLastError();\n        return -errno;\n    }\n\n    fd = fopen(hostpath, \"r\");\n    if (fd == NULL) {\n        virReportSystemError(errno, _(\"Cannot open %s\"), hostpath);\n        res = -errno;\n        goto cleanup;\n    }\n\n    if (fseek(fd, offset, SEEK_SET) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"fseek failed\"));\n        res = -errno;\n        goto cleanup;\n    }\n\n    res = -1;\n    while (getline(&line, &n, fd) > 0) {\n        char *ptr = strchr(line, ':');\n        if (!ptr)\n            continue;\n        *ptr = '\\0';\n\n        if (STREQ(line, \"MemTotal\") &&\n            (virMemoryLimitIsSet(def->mem.hard_limit) ||\n             virDomainDefGetMemoryTotal(def))) {\n            virBufferAsprintf(new_meminfo, \"MemTotal:       %8llu kB\\n\",\n                              meminfo.memtotal);\n        } else if (STREQ(line, \"MemFree\") &&\n                   (virMemoryLimitIsSet(def->mem.hard_limit) ||\n                    virDomainDefGetMemoryTotal(def))) {\n            virBufferAsprintf(new_meminfo, \"MemFree:        %8llu kB\\n\",\n                              (meminfo.memtotal - meminfo.memusage));\n        } else if (STREQ(line, \"MemAvailable\") &&\n                   (virMemoryLimitIsSet(def->mem.hard_limit) ||\n                    virDomainDefGetMemoryTotal(def))) {\n            /* MemAvailable is actually MemFree + SRReclaimable +\n               some other bits, but MemFree is the closest approximation\n               we have */\n            virBufferAsprintf(new_meminfo, \"MemAvailable:   %8llu kB\\n\",\n                              (meminfo.memtotal - meminfo.memusage));\n        } else if (STREQ(line, \"Buffers\")) {\n            virBufferAsprintf(new_meminfo, \"Buffers:        %8d kB\\n\", 0);\n        } else if (STREQ(line, \"Cached\")) {\n            virBufferAsprintf(new_meminfo, \"Cached:         %8llu kB\\n\",\n                              meminfo.cached);\n        } else if (STREQ(line, \"Active\")) {\n            virBufferAsprintf(new_meminfo, \"Active:         %8llu kB\\n\",\n                              (meminfo.active_anon + meminfo.active_file));\n        } else if (STREQ(line, \"Inactive\")) {\n            virBufferAsprintf(new_meminfo, \"Inactive:       %8llu kB\\n\",\n                              (meminfo.inactive_anon + meminfo.inactive_file));\n        } else if (STREQ(line, \"Active(anon)\")) {\n            virBufferAsprintf(new_meminfo, \"Active(anon):   %8llu kB\\n\",\n                              meminfo.active_anon);\n        } else if (STREQ(line, \"Inactive(anon)\")) {\n            virBufferAsprintf(new_meminfo, \"Inactive(anon): %8llu kB\\n\",\n                              meminfo.inactive_anon);\n        } else if (STREQ(line, \"Active(file)\")) {\n            virBufferAsprintf(new_meminfo, \"Active(file):   %8llu kB\\n\",\n                              meminfo.active_file);\n        } else if (STREQ(line, \"Inactive(file)\")) {\n            virBufferAsprintf(new_meminfo, \"Inactive(file): %8llu kB\\n\",\n                              meminfo.inactive_file);\n        } else if (STREQ(line, \"Unevictable\")) {\n            virBufferAsprintf(new_meminfo, \"Unevictable:    %8llu kB\\n\",\n                              meminfo.unevictable);\n        } else if (STREQ(line, \"SwapTotal\") &&\n                   virMemoryLimitIsSet(def->mem.swap_hard_limit)) {\n            virBufferAsprintf(new_meminfo, \"SwapTotal:      %8llu kB\\n\",\n                              (meminfo.swaptotal - meminfo.memtotal));\n        } else if (STREQ(line, \"SwapFree\") &&\n                   virMemoryLimitIsSet(def->mem.swap_hard_limit)) {\n            virBufferAsprintf(new_meminfo, \"SwapFree:       %8llu kB\\n\",\n                              (meminfo.swaptotal - meminfo.memtotal -\n                               meminfo.swapusage + meminfo.memusage));\n        } else if (STREQ(line, \"Slab\")) {\n            virBufferAsprintf(new_meminfo, \"Slab:           %8d kB\\n\", 0);\n        } else if (STREQ(line, \"SReclaimable\")) {\n            virBufferAsprintf(new_meminfo, \"SReclaimable:   %8d kB\\n\", 0);\n        } else if (STREQ(line, \"SUnreclaim\")) {\n            virBufferAsprintf(new_meminfo, \"SUnreclaim:     %8d kB\\n\", 0);\n        } else {\n            *ptr = ':';\n            virBufferAdd(new_meminfo, line, -1);\n        }\n\n    }\n    res = strlen(virBufferCurrentContent(new_meminfo));\n    if (res > size)\n        res = size;\n    memcpy(buf, virBufferCurrentContent(new_meminfo), res);\n\n cleanup:\n    virBufferFreeAndReset(new_meminfo);\n    VIR_FORCE_FCLOSE(fd);\n    return res;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_fuse.h\"",
      "#include <unistd.h>",
      "#include <mntent.h>",
      "#include <sys/mount.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_FCLOSE",
          "args": [
            "fd"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "new_meminfo"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "virBufferCurrentContent(new_meminfo)",
            "res"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferCurrentContent",
          "args": [
            "new_meminfo"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferCurrentContent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "222-233",
          "snippet": "const char *\nvirBufferCurrentContent(virBufferPtr buf)\n{\n    if (!buf)\n        return NULL;\n\n    if (!buf->str ||\n        buf->str->len == 0)\n        return \"\";\n\n    return buf->str->str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirBufferCurrentContent(virBufferPtr buf)\n{\n    if (!buf)\n        return NULL;\n\n    if (!buf->str ||\n        buf->str->len == 0)\n        return \"\";\n\n    return buf->str->str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "virBufferCurrentContent(new_meminfo)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "new_meminfo",
            "line",
            "-1"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "new_meminfo",
            "\"SUnreclaim:     %8d kB\\n\"",
            "0"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "line",
            "\"SUnreclaim\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "line",
            "\"SReclaimable\""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "line",
            "\"Slab\""
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMemoryLimitIsSet",
          "args": [
            "def->mem.swap_hard_limit"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "virMemoryLimitIsSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1628-1632",
          "snippet": "bool\nvirMemoryLimitIsSet(unsigned long long value)\n{\n    return value < VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirMemoryLimitIsSet(unsigned long long value)\n{\n    return value < VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "line",
            "\"SwapFree\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "line",
            "\"SwapTotal\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "line",
            "\"Unevictable\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "line",
            "\"Inactive(file)\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "line",
            "\"Active(file)\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "line",
            "\"Inactive(anon)\""
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "line",
            "\"Active(anon)\""
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "line",
            "\"Inactive\""
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "line",
            "\"Active\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "line",
            "\"Cached\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "line",
            "\"Buffers\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetMemoryTotal",
          "args": [
            "def"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetMemoryTotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10946-10950",
          "snippet": "unsigned long long\nvirDomainDefGetMemoryTotal(const virDomainDef *def)\n{\n    return def->mem.total_memory;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned long long\nvirDomainDefGetMemoryTotal(const virDomainDef *def)\n{\n    return def->mem.total_memory;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "line",
            "\"MemAvailable\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "line",
            "\"MemFree\""
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "line",
            "\"MemTotal\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "':'"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&n",
            "fd"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"fseek failed\")"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"fseek failed\""
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "userns_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2329-2332",
          "snippet": "static int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fseek",
          "args": [
            "fd",
            "offset",
            "SEEK_SET"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot open %s\")",
            "hostpath"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "hostpath",
            "\"r\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorSetErrnoFromLastError",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorSetErrnoFromLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1408-1418",
          "snippet": "void virErrorSetErrnoFromLastError(void)\n{\n    virErrorPtr err = virGetLastError();\n    if (err && err->code == VIR_ERR_SYSTEM_ERROR) {\n        errno = err->int1;\n    } else if (err && err->code == VIR_ERR_NO_MEMORY) {\n        errno = ENOMEM;\n    } else {\n        errno = EIO;\n    }\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virErrorSetErrnoFromLastError(void)\n{\n    virErrorPtr err = virGetLastError();\n    if (err && err->code == VIR_ERR_SYSTEM_ERROR) {\n        errno = err->int1;\n    } else if (err && err->code == VIR_ERR_NO_MEMORY) {\n        errno = ENOMEM;\n    } else {\n        errno = EIO;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCCgroupGetMeminfo",
          "args": [
            "&meminfo"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCCgroupGetMeminfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_cgroup.c",
          "lines": "147-174",
          "snippet": "int virLXCCgroupGetMeminfo(virLXCMeminfoPtr meminfo)\n{\n    int ret = -1;\n    virCgroupPtr cgroup;\n\n    if (virCgroupNewSelf(&cgroup) < 0)\n        return -1;\n\n    if (virLXCCgroupGetMemStat(cgroup, meminfo) < 0)\n        goto cleanup;\n\n    if (virLXCCgroupGetMemTotal(cgroup, meminfo) < 0)\n        goto cleanup;\n\n    if (virLXCCgroupGetMemUsage(cgroup, meminfo) < 0)\n        goto cleanup;\n\n    if (virLXCCgroupGetMemSwapTotal(cgroup, meminfo) < 0)\n        goto cleanup;\n\n    if (virLXCCgroupGetMemSwapUsage(cgroup, meminfo) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virCgroupFree(&cgroup);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"lxc_container.h\"",
            "#include \"lxc_cgroup.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"domain_cgroup.h\"\n#include \"lxc_container.h\"\n#include \"lxc_cgroup.h\"\n#include <config.h>\n\nint virLXCCgroupGetMeminfo(virLXCMeminfoPtr meminfo)\n{\n    int ret = -1;\n    virCgroupPtr cgroup;\n\n    if (virCgroupNewSelf(&cgroup) < 0)\n        return -1;\n\n    if (virLXCCgroupGetMemStat(cgroup, meminfo) < 0)\n        goto cleanup;\n\n    if (virLXCCgroupGetMemTotal(cgroup, meminfo) < 0)\n        goto cleanup;\n\n    if (virLXCCgroupGetMemUsage(cgroup, meminfo) < 0)\n        goto cleanup;\n\n    if (virLXCCgroupGetMemSwapTotal(cgroup, meminfo) < 0)\n        goto cleanup;\n\n    if (virLXCCgroupGetMemSwapUsage(cgroup, meminfo) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virCgroupFree(&cgroup);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int lxcProcReadMeminfo(char *hostpath, virDomainDefPtr def,\n                              char *buf, size_t size, off_t offset)\n{\n    int res;\n    FILE *fd = NULL;\n    g_autofree char *line = NULL;\n    size_t n;\n    struct virLXCMeminfo meminfo;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    virBufferPtr new_meminfo = &buffer;\n\n    if (virLXCCgroupGetMeminfo(&meminfo) < 0) {\n        virErrorSetErrnoFromLastError();\n        return -errno;\n    }\n\n    fd = fopen(hostpath, \"r\");\n    if (fd == NULL) {\n        virReportSystemError(errno, _(\"Cannot open %s\"), hostpath);\n        res = -errno;\n        goto cleanup;\n    }\n\n    if (fseek(fd, offset, SEEK_SET) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"fseek failed\"));\n        res = -errno;\n        goto cleanup;\n    }\n\n    res = -1;\n    while (getline(&line, &n, fd) > 0) {\n        char *ptr = strchr(line, ':');\n        if (!ptr)\n            continue;\n        *ptr = '\\0';\n\n        if (STREQ(line, \"MemTotal\") &&\n            (virMemoryLimitIsSet(def->mem.hard_limit) ||\n             virDomainDefGetMemoryTotal(def))) {\n            virBufferAsprintf(new_meminfo, \"MemTotal:       %8llu kB\\n\",\n                              meminfo.memtotal);\n        } else if (STREQ(line, \"MemFree\") &&\n                   (virMemoryLimitIsSet(def->mem.hard_limit) ||\n                    virDomainDefGetMemoryTotal(def))) {\n            virBufferAsprintf(new_meminfo, \"MemFree:        %8llu kB\\n\",\n                              (meminfo.memtotal - meminfo.memusage));\n        } else if (STREQ(line, \"MemAvailable\") &&\n                   (virMemoryLimitIsSet(def->mem.hard_limit) ||\n                    virDomainDefGetMemoryTotal(def))) {\n            /* MemAvailable is actually MemFree + SRReclaimable +\n               some other bits, but MemFree is the closest approximation\n               we have */\n            virBufferAsprintf(new_meminfo, \"MemAvailable:   %8llu kB\\n\",\n                              (meminfo.memtotal - meminfo.memusage));\n        } else if (STREQ(line, \"Buffers\")) {\n            virBufferAsprintf(new_meminfo, \"Buffers:        %8d kB\\n\", 0);\n        } else if (STREQ(line, \"Cached\")) {\n            virBufferAsprintf(new_meminfo, \"Cached:         %8llu kB\\n\",\n                              meminfo.cached);\n        } else if (STREQ(line, \"Active\")) {\n            virBufferAsprintf(new_meminfo, \"Active:         %8llu kB\\n\",\n                              (meminfo.active_anon + meminfo.active_file));\n        } else if (STREQ(line, \"Inactive\")) {\n            virBufferAsprintf(new_meminfo, \"Inactive:       %8llu kB\\n\",\n                              (meminfo.inactive_anon + meminfo.inactive_file));\n        } else if (STREQ(line, \"Active(anon)\")) {\n            virBufferAsprintf(new_meminfo, \"Active(anon):   %8llu kB\\n\",\n                              meminfo.active_anon);\n        } else if (STREQ(line, \"Inactive(anon)\")) {\n            virBufferAsprintf(new_meminfo, \"Inactive(anon): %8llu kB\\n\",\n                              meminfo.inactive_anon);\n        } else if (STREQ(line, \"Active(file)\")) {\n            virBufferAsprintf(new_meminfo, \"Active(file):   %8llu kB\\n\",\n                              meminfo.active_file);\n        } else if (STREQ(line, \"Inactive(file)\")) {\n            virBufferAsprintf(new_meminfo, \"Inactive(file): %8llu kB\\n\",\n                              meminfo.inactive_file);\n        } else if (STREQ(line, \"Unevictable\")) {\n            virBufferAsprintf(new_meminfo, \"Unevictable:    %8llu kB\\n\",\n                              meminfo.unevictable);\n        } else if (STREQ(line, \"SwapTotal\") &&\n                   virMemoryLimitIsSet(def->mem.swap_hard_limit)) {\n            virBufferAsprintf(new_meminfo, \"SwapTotal:      %8llu kB\\n\",\n                              (meminfo.swaptotal - meminfo.memtotal));\n        } else if (STREQ(line, \"SwapFree\") &&\n                   virMemoryLimitIsSet(def->mem.swap_hard_limit)) {\n            virBufferAsprintf(new_meminfo, \"SwapFree:       %8llu kB\\n\",\n                              (meminfo.swaptotal - meminfo.memtotal -\n                               meminfo.swapusage + meminfo.memusage));\n        } else if (STREQ(line, \"Slab\")) {\n            virBufferAsprintf(new_meminfo, \"Slab:           %8d kB\\n\", 0);\n        } else if (STREQ(line, \"SReclaimable\")) {\n            virBufferAsprintf(new_meminfo, \"SReclaimable:   %8d kB\\n\", 0);\n        } else if (STREQ(line, \"SUnreclaim\")) {\n            virBufferAsprintf(new_meminfo, \"SUnreclaim:     %8d kB\\n\", 0);\n        } else {\n            *ptr = ':';\n            virBufferAdd(new_meminfo, line, -1);\n        }\n\n    }\n    res = strlen(virBufferCurrentContent(new_meminfo));\n    if (res > size)\n        res = size;\n    memcpy(buf, virBufferCurrentContent(new_meminfo), res);\n\n cleanup:\n    virBufferFreeAndReset(new_meminfo);\n    VIR_FORCE_FCLOSE(fd);\n    return res;\n}"
  },
  {
    "function_name": "lxcProcHostRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
    "lines": "104-118",
    "snippet": "static int lxcProcHostRead(char *path, char *buf, size_t size, off_t offset)\n{\n    int fd;\n    int res;\n\n    fd = open(path, O_RDONLY);\n    if (fd == -1)\n        return -errno;\n\n    if ((res = pread(fd, buf, size, offset)) < 0)\n        res = -errno;\n\n    VIR_FORCE_CLOSE(fd);\n    return res;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_fuse.h\"",
      "#include <unistd.h>",
      "#include <mntent.h>",
      "#include <sys/mount.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pread",
          "args": [
            "fd",
            "buf",
            "size",
            "offset"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDONLY"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int lxcProcHostRead(char *path, char *buf, size_t size, off_t offset)\n{\n    int fd;\n    int res;\n\n    fd = open(path, O_RDONLY);\n    if (fd == -1)\n        return -errno;\n\n    if ((res = pread(fd, buf, size, offset)) < 0)\n        res = -errno;\n\n    VIR_FORCE_CLOSE(fd);\n    return res;\n}"
  },
  {
    "function_name": "lxcProcOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
    "lines": "92-102",
    "snippet": "static int lxcProcOpen(const char *path G_GNUC_UNUSED,\n                       struct fuse_file_info *fi G_GNUC_UNUSED)\n{\n    if (STRNEQ(path, fuse_meminfo_path))\n        return -ENOENT;\n\n    if ((fi->flags & 3) != O_RDONLY)\n        return -EACCES;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_fuse.h\"",
      "#include <unistd.h>",
      "#include <mntent.h>",
      "#include <sys/mount.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "path",
            "fuse_meminfo_path"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int lxcProcOpen(const char *path G_GNUC_UNUSED,\n                       struct fuse_file_info *fi G_GNUC_UNUSED)\n{\n    if (STRNEQ(path, fuse_meminfo_path))\n        return -ENOENT;\n\n    if ((fi->flags & 3) != O_RDONLY)\n        return -EACCES;\n\n    return 0;\n}"
  },
  {
    "function_name": "lxcProcReaddir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
    "lines": "77-90",
    "snippet": "static int lxcProcReaddir(const char *path, void *buf,\n                          fuse_fill_dir_t filler,\n                          off_t offset G_GNUC_UNUSED,\n                          struct fuse_file_info *fi G_GNUC_UNUSED)\n{\n    if (STRNEQ(path, \"/\"))\n        return -ENOENT;\n\n    filler(buf, \".\", NULL, 0);\n    filler(buf, \"..\", NULL, 0);\n    filler(buf, fuse_meminfo_path + 1, NULL, 0);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_fuse.h\"",
      "#include <unistd.h>",
      "#include <mntent.h>",
      "#include <sys/mount.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filler",
          "args": [
            "buf",
            "fuse_meminfo_path + 1",
            "NULL",
            "0"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filler",
          "args": [
            "buf",
            "\"..\"",
            "NULL",
            "0"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filler",
          "args": [
            "buf",
            "\".\"",
            "NULL",
            "0"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "path",
            "\"/\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int lxcProcReaddir(const char *path, void *buf,\n                          fuse_fill_dir_t filler,\n                          off_t offset G_GNUC_UNUSED,\n                          struct fuse_file_info *fi G_GNUC_UNUSED)\n{\n    if (STRNEQ(path, \"/\"))\n        return -ENOENT;\n\n    filler(buf, \".\", NULL, 0);\n    filler(buf, \"..\", NULL, 0);\n    filler(buf, fuse_meminfo_path + 1, NULL, 0);\n\n    return 0;\n}"
  },
  {
    "function_name": "lxcProcGetattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_fuse.c",
    "lines": "43-75",
    "snippet": "static int lxcProcGetattr(const char *path, struct stat *stbuf)\n{\n    g_autofree char *mempath = NULL;\n    struct stat sb;\n    struct fuse_context *context = fuse_get_context();\n    virDomainDefPtr def = (virDomainDefPtr)context->private_data;\n\n    memset(stbuf, 0, sizeof(struct stat));\n    mempath = g_strdup_printf(\"/proc/%s\", path);\n\n    if (STREQ(path, \"/\")) {\n        stbuf->st_mode = S_IFDIR | 0755;\n        stbuf->st_nlink = 2;\n    } else if (STREQ(path, fuse_meminfo_path)) {\n        if (stat(mempath, &sb) < 0)\n            return -errno;\n\n        stbuf->st_uid = def->idmap.uidmap ? def->idmap.uidmap[0].target : 0;\n        stbuf->st_gid = def->idmap.gidmap ? def->idmap.gidmap[0].target : 0;\n        stbuf->st_mode = sb.st_mode;\n        stbuf->st_nlink = 1;\n        stbuf->st_blksize = sb.st_blksize;\n        stbuf->st_blocks = sb.st_blocks;\n        stbuf->st_size = sb.st_size;\n        stbuf->st_atime = sb.st_atime;\n        stbuf->st_ctime = sb.st_ctime;\n        stbuf->st_mtime = sb.st_mtime;\n    } else {\n        return -ENOENT;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_cgroup.h\"",
      "#include \"lxc_fuse.h\"",
      "#include <unistd.h>",
      "#include <mntent.h>",
      "#include <sys/mount.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "mempath",
            "&sb"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "profile_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_apparmor.c",
          "lines": "70-108",
          "snippet": "static int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virmdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viruuid.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"internal.h\"",
            "#include <wait.h>",
            "#include <unistd.h>",
            "#include <sys/apparmor.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virmdev.h\"\n#include \"virscsi.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virscsivhost.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viruuid.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"security_apparmor.h\"\n#include \"internal.h\"\n#include <wait.h>\n#include <unistd.h>\n#include <sys/apparmor.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "path",
            "fuse_meminfo_path"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "path",
            "\"/\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"/proc/%s\"",
            "path"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "stbuf",
            "0",
            "sizeof(struct stat)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_get_context",
          "args": [],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lxc_cgroup.h\"\n#include \"lxc_fuse.h\"\n#include <unistd.h>\n#include <mntent.h>\n#include <sys/mount.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int lxcProcGetattr(const char *path, struct stat *stbuf)\n{\n    g_autofree char *mempath = NULL;\n    struct stat sb;\n    struct fuse_context *context = fuse_get_context();\n    virDomainDefPtr def = (virDomainDefPtr)context->private_data;\n\n    memset(stbuf, 0, sizeof(struct stat));\n    mempath = g_strdup_printf(\"/proc/%s\", path);\n\n    if (STREQ(path, \"/\")) {\n        stbuf->st_mode = S_IFDIR | 0755;\n        stbuf->st_nlink = 2;\n    } else if (STREQ(path, fuse_meminfo_path)) {\n        if (stat(mempath, &sb) < 0)\n            return -errno;\n\n        stbuf->st_uid = def->idmap.uidmap ? def->idmap.uidmap[0].target : 0;\n        stbuf->st_gid = def->idmap.gidmap ? def->idmap.gidmap[0].target : 0;\n        stbuf->st_mode = sb.st_mode;\n        stbuf->st_nlink = 1;\n        stbuf->st_blksize = sb.st_blksize;\n        stbuf->st_blocks = sb.st_blocks;\n        stbuf->st_size = sb.st_size;\n        stbuf->st_atime = sb.st_atime;\n        stbuf->st_ctime = sb.st_ctime;\n        stbuf->st_mtime = sb.st_mtime;\n    } else {\n        return -ENOENT;\n    }\n\n    return 0;\n}"
  }
]