[
  {
    "function_name": "qemuMonitorTransactionBackup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4578-4588",
    "snippet": "int\nqemuMonitorTransactionBackup(virJSONValuePtr actions,\n                             const char *device,\n                             const char *jobname,\n                             const char *target,\n                             const char *bitmap,\n                             qemuMonitorTransactionBackupSyncMode syncmode)\n{\n    return qemuMonitorJSONTransactionBackup(actions, device, jobname, target,\n                                            bitmap, syncmode);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONTransactionBackup",
          "args": [
            "actions",
            "device",
            "jobname",
            "target",
            "bitmap",
            "syncmode"
          ],
          "line": 4586
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONTransactionBackup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "9281-9301",
          "snippet": "int\nqemuMonitorJSONTransactionBackup(virJSONValuePtr actions,\n                                 const char *device,\n                                 const char *jobname,\n                                 const char *target,\n                                 const char *bitmap,\n                                 qemuMonitorTransactionBackupSyncMode syncmode)\n{\n    const char *syncmodestr = qemuMonitorTransactionBackupSyncModeTypeToString(syncmode);\n\n    return qemuMonitorJSONTransactionAdd(actions,\n                                         \"blockdev-backup\",\n                                         \"s:device\", device,\n                                         \"s:job-id\", jobname,\n                                         \"s:target\", target,\n                                         \"s:sync\", syncmodestr,\n                                         \"S:bitmap\", bitmap,\n                                         \"T:auto-finalize\", VIR_TRISTATE_BOOL_YES,\n                                         \"T:auto-dismiss\", VIR_TRISTATE_BOOL_NO,\n                                         NULL);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONTransactionBackup(virJSONValuePtr actions,\n                                 const char *device,\n                                 const char *jobname,\n                                 const char *target,\n                                 const char *bitmap,\n                                 qemuMonitorTransactionBackupSyncMode syncmode)\n{\n    const char *syncmodestr = qemuMonitorTransactionBackupSyncModeTypeToString(syncmode);\n\n    return qemuMonitorJSONTransactionAdd(actions,\n                                         \"blockdev-backup\",\n                                         \"s:device\", device,\n                                         \"s:job-id\", jobname,\n                                         \"s:target\", target,\n                                         \"s:sync\", syncmodestr,\n                                         \"S:bitmap\", bitmap,\n                                         \"T:auto-finalize\", VIR_TRISTATE_BOOL_YES,\n                                         \"T:auto-dismiss\", VIR_TRISTATE_BOOL_NO,\n                                         NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransactionBackup(virJSONValuePtr actions,\n                             const char *device,\n                             const char *jobname,\n                             const char *target,\n                             const char *bitmap,\n                             qemuMonitorTransactionBackupSyncMode syncmode)\n{\n    return qemuMonitorJSONTransactionBackup(actions, device, jobname, target,\n                                            bitmap, syncmode);\n}"
  },
  {
    "function_name": "qemuMonitorTransactionSnapshotBlockdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4569-4575",
    "snippet": "int\nqemuMonitorTransactionSnapshotBlockdev(virJSONValuePtr actions,\n                                       const char *node,\n                                       const char *overlay)\n{\n    return qemuMonitorJSONTransactionSnapshotBlockdev(actions, node, overlay);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONTransactionSnapshotBlockdev",
          "args": [
            "actions",
            "node",
            "overlay"
          ],
          "line": 4574
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONTransactionSnapshotBlockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "9262-9272",
          "snippet": "int\nqemuMonitorJSONTransactionSnapshotBlockdev(virJSONValuePtr actions,\n                                           const char *node,\n                                           const char *overlay)\n{\n    return qemuMonitorJSONTransactionAdd(actions,\n                                         \"blockdev-snapshot\",\n                                         \"s:node\", node,\n                                         \"s:overlay\", overlay,\n                                         NULL);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONTransactionSnapshotBlockdev(virJSONValuePtr actions,\n                                           const char *node,\n                                           const char *overlay)\n{\n    return qemuMonitorJSONTransactionAdd(actions,\n                                         \"blockdev-snapshot\",\n                                         \"s:node\", node,\n                                         \"s:overlay\", overlay,\n                                         NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransactionSnapshotBlockdev(virJSONValuePtr actions,\n                                       const char *node,\n                                       const char *overlay)\n{\n    return qemuMonitorJSONTransactionSnapshotBlockdev(actions, node, overlay);\n}"
  },
  {
    "function_name": "qemuMonitorTransactionSnapshotLegacy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4557-4566",
    "snippet": "int\nqemuMonitorTransactionSnapshotLegacy(virJSONValuePtr actions,\n                                     const char *device,\n                                     const char *path,\n                                     const char *format,\n                                     bool existing)\n{\n    return qemuMonitorJSONTransactionSnapshotLegacy(actions, device, path,\n                                                    format, existing);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONTransactionSnapshotLegacy",
          "args": [
            "actions",
            "device",
            "path",
            "format",
            "existing"
          ],
          "line": 4564
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONTransactionSnapshotLegacy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "9240-9259",
          "snippet": "int\nqemuMonitorJSONTransactionSnapshotLegacy(virJSONValuePtr actions,\n                                         const char *device,\n                                         const char *path,\n                                         const char *format,\n                                         bool existing)\n{\n    const char *mode = NULL;\n\n    if (existing)\n        mode = \"existing\";\n\n    return qemuMonitorJSONTransactionAdd(actions,\n                                         \"blockdev-snapshot-sync\",\n                                         \"s:device\", device,\n                                         \"s:snapshot-file\", path,\n                                         \"s:format\", format,\n                                         \"S:mode\", mode,\n                                         NULL);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONTransactionSnapshotLegacy(virJSONValuePtr actions,\n                                         const char *device,\n                                         const char *path,\n                                         const char *format,\n                                         bool existing)\n{\n    const char *mode = NULL;\n\n    if (existing)\n        mode = \"existing\";\n\n    return qemuMonitorJSONTransactionAdd(actions,\n                                         \"blockdev-snapshot-sync\",\n                                         \"s:device\", device,\n                                         \"s:snapshot-file\", path,\n                                         \"s:format\", format,\n                                         \"S:mode\", mode,\n                                         NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransactionSnapshotLegacy(virJSONValuePtr actions,\n                                     const char *device,\n                                     const char *path,\n                                     const char *format,\n                                     bool existing)\n{\n    return qemuMonitorJSONTransactionSnapshotLegacy(actions, device, path,\n                                                    format, existing);\n}"
  },
  {
    "function_name": "qemuMonitorTransactionBitmapMergeSourceAddBitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4548-4554",
    "snippet": "int\nqemuMonitorTransactionBitmapMergeSourceAddBitmap(virJSONValuePtr sources,\n                                                 const char *sourcenode,\n                                                 const char *sourcebitmap)\n{\n    return qemuMonitorJSONTransactionBitmapMergeSourceAddBitmap(sources, sourcenode, sourcebitmap);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONTransactionBitmapMergeSourceAddBitmap",
          "args": [
            "sources",
            "sourcenode",
            "sourcebitmap"
          ],
          "line": 4553
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONTransactionBitmapMergeSourceAddBitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "9219-9237",
          "snippet": "int\nqemuMonitorJSONTransactionBitmapMergeSourceAddBitmap(virJSONValuePtr sources,\n                                                     const char *sourcenode,\n                                                     const char *sourcebitmap)\n{\n    g_autoptr(virJSONValue) sourceobj = NULL;\n\n    if (virJSONValueObjectCreate(&sourceobj,\n                                 \"s:node\", sourcenode,\n                                 \"s:name\", sourcebitmap,\n                                 NULL) < 0)\n        return -1;\n\n    if (virJSONValueArrayAppend(sources, sourceobj) < 0)\n        return -1;\n\n    sourceobj = NULL;\n    return 0;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONTransactionBitmapMergeSourceAddBitmap(virJSONValuePtr sources,\n                                                     const char *sourcenode,\n                                                     const char *sourcebitmap)\n{\n    g_autoptr(virJSONValue) sourceobj = NULL;\n\n    if (virJSONValueObjectCreate(&sourceobj,\n                                 \"s:node\", sourcenode,\n                                 \"s:name\", sourcebitmap,\n                                 NULL) < 0)\n        return -1;\n\n    if (virJSONValueArrayAppend(sources, sourceobj) < 0)\n        return -1;\n\n    sourceobj = NULL;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransactionBitmapMergeSourceAddBitmap(virJSONValuePtr sources,\n                                                 const char *sourcenode,\n                                                 const char *sourcebitmap)\n{\n    return qemuMonitorJSONTransactionBitmapMergeSourceAddBitmap(sources, sourcenode, sourcebitmap);\n}"
  },
  {
    "function_name": "qemuMonitorTransactionBitmapMerge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4538-4545",
    "snippet": "int\nqemuMonitorTransactionBitmapMerge(virJSONValuePtr actions,\n                                  const char *node,\n                                  const char *target,\n                                  virJSONValuePtr *sources)\n{\n    return qemuMonitorJSONTransactionBitmapMerge(actions, node, target, sources);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONTransactionBitmapMerge",
          "args": [
            "actions",
            "node",
            "target",
            "sources"
          ],
          "line": 4544
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONTransactionBitmapMerge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "9204-9216",
          "snippet": "int\nqemuMonitorJSONTransactionBitmapMerge(virJSONValuePtr actions,\n                                      const char *node,\n                                      const char *target,\n                                      virJSONValuePtr *sources)\n{\n    return qemuMonitorJSONTransactionAdd(actions,\n                                         \"block-dirty-bitmap-merge\",\n                                         \"s:node\", node,\n                                         \"s:target\", target,\n                                         \"a:bitmaps\", sources,\n                                         NULL);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONTransactionBitmapMerge(virJSONValuePtr actions,\n                                      const char *node,\n                                      const char *target,\n                                      virJSONValuePtr *sources)\n{\n    return qemuMonitorJSONTransactionAdd(actions,\n                                         \"block-dirty-bitmap-merge\",\n                                         \"s:node\", node,\n                                         \"s:target\", target,\n                                         \"a:bitmaps\", sources,\n                                         NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransactionBitmapMerge(virJSONValuePtr actions,\n                                  const char *node,\n                                  const char *target,\n                                  virJSONValuePtr *sources)\n{\n    return qemuMonitorJSONTransactionBitmapMerge(actions, node, target, sources);\n}"
  },
  {
    "function_name": "qemuMonitorTransactionBitmapDisable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4529-4535",
    "snippet": "int\nqemuMonitorTransactionBitmapDisable(virJSONValuePtr actions,\n                                    const char *node,\n                                    const char *name)\n{\n    return qemuMonitorJSONTransactionBitmapDisable(actions, node, name);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONTransactionBitmapDisable",
          "args": [
            "actions",
            "node",
            "name"
          ],
          "line": 4534
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONTransactionBitmapDisable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "9191-9201",
          "snippet": "int\nqemuMonitorJSONTransactionBitmapDisable(virJSONValuePtr actions,\n                                        const char *node,\n                                        const char *name)\n{\n    return qemuMonitorJSONTransactionAdd(actions,\n                                         \"block-dirty-bitmap-disable\",\n                                         \"s:node\", node,\n                                         \"s:name\", name,\n                                         NULL);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONTransactionBitmapDisable(virJSONValuePtr actions,\n                                        const char *node,\n                                        const char *name)\n{\n    return qemuMonitorJSONTransactionAdd(actions,\n                                         \"block-dirty-bitmap-disable\",\n                                         \"s:node\", node,\n                                         \"s:name\", name,\n                                         NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransactionBitmapDisable(virJSONValuePtr actions,\n                                    const char *node,\n                                    const char *name)\n{\n    return qemuMonitorJSONTransactionBitmapDisable(actions, node, name);\n}"
  },
  {
    "function_name": "qemuMonitorTransactionBitmapEnable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4520-4526",
    "snippet": "int\nqemuMonitorTransactionBitmapEnable(virJSONValuePtr actions,\n                                   const char *node,\n                                   const char *name)\n{\n    return qemuMonitorJSONTransactionBitmapEnable(actions, node, name);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONTransactionBitmapEnable",
          "args": [
            "actions",
            "node",
            "name"
          ],
          "line": 4525
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONTransactionBitmapEnable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "9178-9188",
          "snippet": "int\nqemuMonitorJSONTransactionBitmapEnable(virJSONValuePtr actions,\n                                       const char *node,\n                                       const char *name)\n{\n    return qemuMonitorJSONTransactionAdd(actions,\n                                         \"block-dirty-bitmap-enable\",\n                                         \"s:node\", node,\n                                         \"s:name\", name,\n                                         NULL);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONTransactionBitmapEnable(virJSONValuePtr actions,\n                                       const char *node,\n                                       const char *name)\n{\n    return qemuMonitorJSONTransactionAdd(actions,\n                                         \"block-dirty-bitmap-enable\",\n                                         \"s:node\", node,\n                                         \"s:name\", name,\n                                         NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransactionBitmapEnable(virJSONValuePtr actions,\n                                   const char *node,\n                                   const char *name)\n{\n    return qemuMonitorJSONTransactionBitmapEnable(actions, node, name);\n}"
  },
  {
    "function_name": "qemuMonitorTransactionBitmapRemove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4511-4517",
    "snippet": "int\nqemuMonitorTransactionBitmapRemove(virJSONValuePtr actions,\n                                   const char *node,\n                                   const char *name)\n{\n    return qemuMonitorJSONTransactionBitmapRemove(actions, node, name);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONTransactionBitmapRemove",
          "args": [
            "actions",
            "node",
            "name"
          ],
          "line": 4516
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONTransactionBitmapRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "9165-9175",
          "snippet": "int\nqemuMonitorJSONTransactionBitmapRemove(virJSONValuePtr actions,\n                                       const char *node,\n                                       const char *name)\n{\n    return qemuMonitorJSONTransactionAdd(actions,\n                                         \"block-dirty-bitmap-remove\",\n                                         \"s:node\", node,\n                                         \"s:name\", name,\n                                         NULL);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONTransactionBitmapRemove(virJSONValuePtr actions,\n                                       const char *node,\n                                       const char *name)\n{\n    return qemuMonitorJSONTransactionAdd(actions,\n                                         \"block-dirty-bitmap-remove\",\n                                         \"s:node\", node,\n                                         \"s:name\", name,\n                                         NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransactionBitmapRemove(virJSONValuePtr actions,\n                                   const char *node,\n                                   const char *name)\n{\n    return qemuMonitorJSONTransactionBitmapRemove(actions, node, name);\n}"
  },
  {
    "function_name": "qemuMonitorTransactionBitmapAdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4498-4508",
    "snippet": "int\nqemuMonitorTransactionBitmapAdd(virJSONValuePtr actions,\n                                const char *node,\n                                const char *name,\n                                bool persistent,\n                                bool disabled,\n                                unsigned long long granularity)\n{\n    return qemuMonitorJSONTransactionBitmapAdd(actions, node, name, persistent,\n                                               disabled, granularity);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONTransactionBitmapAdd",
          "args": [
            "actions",
            "node",
            "name",
            "persistent",
            "disabled",
            "granularity"
          ],
          "line": 4506
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONTransactionBitmapAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "9146-9162",
          "snippet": "int\nqemuMonitorJSONTransactionBitmapAdd(virJSONValuePtr actions,\n                                    const char *node,\n                                    const char *name,\n                                    bool persistent,\n                                    bool disabled,\n                                    unsigned long long granularity)\n{\n    return qemuMonitorJSONTransactionAdd(actions,\n                                         \"block-dirty-bitmap-add\",\n                                         \"s:node\", node,\n                                         \"s:name\", name,\n                                         \"b:persistent\", persistent,\n                                         \"b:disabled\", disabled,\n                                         \"P:granularity\", granularity,\n                                         NULL);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONTransactionBitmapAdd(virJSONValuePtr actions,\n                                    const char *node,\n                                    const char *name,\n                                    bool persistent,\n                                    bool disabled,\n                                    unsigned long long granularity)\n{\n    return qemuMonitorJSONTransactionAdd(actions,\n                                         \"block-dirty-bitmap-add\",\n                                         \"s:node\", node,\n                                         \"s:name\", name,\n                                         \"b:persistent\", persistent,\n                                         \"b:disabled\", disabled,\n                                         \"P:granularity\", granularity,\n                                         NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransactionBitmapAdd(virJSONValuePtr actions,\n                                const char *node,\n                                const char *name,\n                                bool persistent,\n                                bool disabled,\n                                unsigned long long granularity)\n{\n    return qemuMonitorJSONTransactionBitmapAdd(actions, node, name, persistent,\n                                               disabled, granularity);\n}"
  },
  {
    "function_name": "qemuMonitorGetJobInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4487-4495",
    "snippet": "int\nqemuMonitorGetJobInfo(qemuMonitorPtr mon,\n                      qemuMonitorJobInfoPtr **jobs,\n                      size_t *njobs)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetJobInfo(mon, jobs, njobs);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetJobInfo",
          "args": [
            "mon",
            "jobs",
            "njobs"
          ],
          "line": 4494
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetJobInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "9340-9372",
          "snippet": "int\nqemuMonitorJSONGetJobInfo(qemuMonitorPtr mon,\n                          qemuMonitorJobInfoPtr **jobs,\n                          size_t *njobs)\n{\n    virJSONValuePtr data;\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n    size_t i;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-jobs\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        return -1;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n\n    for (i = 0; i < virJSONValueArraySize(data); i++) {\n        qemuMonitorJobInfoPtr job = NULL;\n\n        if (!(job = qemuMonitorJSONGetJobInfoOne(virJSONValueArrayGet(data, i))))\n            return -1;\n\n        if (VIR_APPEND_ELEMENT(*jobs, *njobs, job) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint\nqemuMonitorJSONGetJobInfo(qemuMonitorPtr mon,\n                          qemuMonitorJobInfoPtr **jobs,\n                          size_t *njobs)\n{\n    virJSONValuePtr data;\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n    size_t i;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-jobs\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        return -1;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n\n    for (i = 0; i < virJSONValueArraySize(data); i++) {\n        qemuMonitorJobInfoPtr job = NULL;\n\n        if (!(job = qemuMonitorJSONGetJobInfoOne(virJSONValueArrayGet(data, i))))\n            return -1;\n\n        if (VIR_APPEND_ELEMENT(*jobs, *njobs, job) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetJobInfo(qemuMonitorPtr mon,\n                      qemuMonitorJobInfoPtr **jobs,\n                      size_t *njobs)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetJobInfo(mon, jobs, njobs);\n}"
  },
  {
    "function_name": "qemuMonitorJobInfoFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4475-4484",
    "snippet": "void\nqemuMonitorJobInfoFree(qemuMonitorJobInfoPtr job)\n{\n    if (!job)\n        return;\n\n    VIR_FREE(job->id);\n    VIR_FREE(job->error);\n    VIR_FREE(job);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "job"
          ],
          "line": 4483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "job->error"
          ],
          "line": 4482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "job->id"
          ],
          "line": 4481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorJobInfoFree(qemuMonitorJobInfoPtr job)\n{\n    if (!job)\n        return;\n\n    VIR_FREE(job->id);\n    VIR_FREE(job->error);\n    VIR_FREE(job);\n}"
  },
  {
    "function_name": "qemuMonitorGetCurrentMachineInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4465-4472",
    "snippet": "int\nqemuMonitorGetCurrentMachineInfo(qemuMonitorPtr mon,\n                                 qemuMonitorCurrentMachineInfoPtr info)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCurrentMachineInfo(mon, info);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetCurrentMachineInfo",
          "args": [
            "mon",
            "info"
          ],
          "line": 4471
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetCurrentMachineInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "9119-9143",
          "snippet": "int\nqemuMonitorJSONGetCurrentMachineInfo(qemuMonitorPtr mon,\n                                     qemuMonitorCurrentMachineInfoPtr info)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-current-machine\",\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorJSONExtractCurrentMachineInfo(reply, info);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONGetCurrentMachineInfo(qemuMonitorPtr mon,\n                                     qemuMonitorCurrentMachineInfoPtr info)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-current-machine\",\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorJSONExtractCurrentMachineInfo(reply, info);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetCurrentMachineInfo(qemuMonitorPtr mon,\n                                 qemuMonitorCurrentMachineInfoPtr info)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCurrentMachineInfo(mon, info);\n}"
  },
  {
    "function_name": "qemuMonitorGetPRManagerInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4440-4462",
    "snippet": "int\nqemuMonitorGetPRManagerInfo(qemuMonitorPtr mon,\n                            virHashTablePtr *retinfo)\n{\n    int ret = -1;\n    virHashTablePtr info = NULL;\n\n    *retinfo = NULL;\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (!(info = virHashCreate(10, virHashValueFree)))\n        goto cleanup;\n\n    if (qemuMonitorJSONGetPRManagerInfo(mon, info) < 0)\n        goto cleanup;\n\n    *retinfo = g_steal_pointer(&info);\n    ret = 0;\n cleanup:\n    virHashFree(info);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "info"
          ],
          "line": 4460
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&info"
          ],
          "line": 4457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetPRManagerInfo",
          "args": [
            "mon",
            "info"
          ],
          "line": 4454
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetPRManagerInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "9069-9093",
          "snippet": "int\nqemuMonitorJSONGetPRManagerInfo(qemuMonitorPtr mon,\n                                virHashTablePtr info)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-pr-managers\",\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorJSONExtractPRManagerInfo(reply, info);\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONGetPRManagerInfo(qemuMonitorPtr mon,\n                                virHashTablePtr info)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-pr-managers\",\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorJSONExtractPRManagerInfo(reply, info);\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "10",
            "virHashValueFree"
          ],
          "line": 4451
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetPRManagerInfo(qemuMonitorPtr mon,\n                            virHashTablePtr *retinfo)\n{\n    int ret = -1;\n    virHashTablePtr info = NULL;\n\n    *retinfo = NULL;\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (!(info = virHashCreate(10, virHashValueFree)))\n        goto cleanup;\n\n    if (qemuMonitorJSONGetPRManagerInfo(mon, info) < 0)\n        goto cleanup;\n\n    *retinfo = g_steal_pointer(&info);\n    ret = 0;\n cleanup:\n    virHashFree(info);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorGetSEVMeasurement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4431-4437",
    "snippet": "char *\nqemuMonitorGetSEVMeasurement(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    return qemuMonitorJSONGetSEVMeasurement(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetSEVMeasurement",
          "args": [
            "mon"
          ],
          "line": 4436
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetSEVMeasurement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8985-9014",
          "snippet": "char *\nqemuMonitorJSONGetSEVMeasurement(qemuMonitorPtr mon)\n{\n    const char *tmp;\n    char *measurement = NULL;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-sev-launch-measure\", NULL)))\n         return NULL;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (!(tmp = virJSONValueObjectGetString(data, \"data\")))\n        goto cleanup;\n\n    measurement = g_strdup(tmp);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return measurement;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nchar *\nqemuMonitorJSONGetSEVMeasurement(qemuMonitorPtr mon)\n{\n    const char *tmp;\n    char *measurement = NULL;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-sev-launch-measure\", NULL)))\n         return NULL;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (!(tmp = virJSONValueObjectGetString(data, \"data\")))\n        goto cleanup;\n\n    measurement = g_strdup(tmp);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return measurement;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR_NULL",
          "args": [
            "mon"
          ],
          "line": 4434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nchar *\nqemuMonitorGetSEVMeasurement(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    return qemuMonitorJSONGetSEVMeasurement(mon);\n}"
  },
  {
    "function_name": "qemuMonitorBlockdevMediumInsert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4418-4428",
    "snippet": "int\nqemuMonitorBlockdevMediumInsert(qemuMonitorPtr mon,\n                                const char *id,\n                                const char *nodename)\n{\n    VIR_DEBUG(\"id=%s nodename=%s\", id, nodename);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevMediumInsert(mon, id, nodename);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONBlockdevMediumInsert",
          "args": [
            "mon",
            "id",
            "nodename"
          ],
          "line": 4427
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONBlockdevMediumInsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8945-8972",
          "snippet": "int\nqemuMonitorJSONBlockdevMediumInsert(qemuMonitorPtr mon,\n                                    const char *id,\n                                    const char *nodename)\n{\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    int ret = -1;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"blockdev-insert-medium\",\n                                           \"s:id\", id,\n                                           \"s:node-name\", nodename,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONBlockdevMediumInsert(qemuMonitorPtr mon,\n                                    const char *id,\n                                    const char *nodename)\n{\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    int ret = -1;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"blockdev-insert-medium\",\n                                           \"s:id\", id,\n                                           \"s:node-name\", nodename,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"id=%s nodename=%s\"",
            "id",
            "nodename"
          ],
          "line": 4423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockdevMediumInsert(qemuMonitorPtr mon,\n                                const char *id,\n                                const char *nodename)\n{\n    VIR_DEBUG(\"id=%s nodename=%s\", id, nodename);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevMediumInsert(mon, id, nodename);\n}"
  },
  {
    "function_name": "qemuMonitorBlockdevMediumRemove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4406-4415",
    "snippet": "int\nqemuMonitorBlockdevMediumRemove(qemuMonitorPtr mon,\n                                const char *id)\n{\n    VIR_DEBUG(\"id=%s\", id);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevMediumRemove(mon, id);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONBlockdevMediumRemove",
          "args": [
            "mon",
            "id"
          ],
          "line": 4414
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONBlockdevMediumRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8918-8942",
          "snippet": "int\nqemuMonitorJSONBlockdevMediumRemove(qemuMonitorPtr mon,\n                                    const char *id)\n{\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    int ret = -1;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"blockdev-remove-medium\",\n                                           \"s:id\", id, NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONBlockdevMediumRemove(qemuMonitorPtr mon,\n                                    const char *id)\n{\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    int ret = -1;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"blockdev-remove-medium\",\n                                           \"s:id\", id, NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"id=%s\"",
            "id"
          ],
          "line": 4410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockdevMediumRemove(qemuMonitorPtr mon,\n                                const char *id)\n{\n    VIR_DEBUG(\"id=%s\", id);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevMediumRemove(mon, id);\n}"
  },
  {
    "function_name": "qemuMonitorBlockdevTrayClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4394-4403",
    "snippet": "int\nqemuMonitorBlockdevTrayClose(qemuMonitorPtr mon,\n                             const char *id)\n{\n    VIR_DEBUG(\"id=%s\", id);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevTrayClose(mon, id);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONBlockdevTrayClose",
          "args": [
            "mon",
            "id"
          ],
          "line": 4402
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONBlockdevTrayClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8891-8915",
          "snippet": "int\nqemuMonitorJSONBlockdevTrayClose(qemuMonitorPtr mon,\n                                 const char *id)\n{\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    int ret = -1;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"blockdev-close-tray\",\n                                           \"s:id\", id, NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONBlockdevTrayClose(qemuMonitorPtr mon,\n                                 const char *id)\n{\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    int ret = -1;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"blockdev-close-tray\",\n                                           \"s:id\", id, NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"id=%s\"",
            "id"
          ],
          "line": 4398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockdevTrayClose(qemuMonitorPtr mon,\n                             const char *id)\n{\n    VIR_DEBUG(\"id=%s\", id);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevTrayClose(mon, id);\n}"
  },
  {
    "function_name": "qemuMonitorBlockdevTrayOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4381-4391",
    "snippet": "int\nqemuMonitorBlockdevTrayOpen(qemuMonitorPtr mon,\n                            const char *id,\n                            bool force)\n{\n    VIR_DEBUG(\"id=%s force=%d\", id, force);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevTrayOpen(mon, id, force);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONBlockdevTrayOpen",
          "args": [
            "mon",
            "id",
            "force"
          ],
          "line": 4390
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONBlockdevTrayOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8862-8888",
          "snippet": "int\nqemuMonitorJSONBlockdevTrayOpen(qemuMonitorPtr mon,\n                                const char *id,\n                                bool force)\n{\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    int ret = -1;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"blockdev-open-tray\",\n                                           \"s:id\", id,\n                                           \"b:force\", force, NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONBlockdevTrayOpen(qemuMonitorPtr mon,\n                                const char *id,\n                                bool force)\n{\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    int ret = -1;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"blockdev-open-tray\",\n                                           \"s:id\", id,\n                                           \"b:force\", force, NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"id=%s force=%d\"",
            "id",
            "force"
          ],
          "line": 4386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockdevTrayOpen(qemuMonitorPtr mon,\n                            const char *id,\n                            bool force)\n{\n    VIR_DEBUG(\"id=%s force=%d\", id, force);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevTrayOpen(mon, id, force);\n}"
  },
  {
    "function_name": "qemuMonitorBlockdevDel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4370-4379",
    "snippet": "int\nqemuMonitorBlockdevDel(qemuMonitorPtr mon,\n                       const char *nodename)\n{\n    VIR_DEBUG(\"nodename=%s\", nodename);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevDel(mon, nodename);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONBlockdevDel",
          "args": [
            "mon",
            "nodename"
          ],
          "line": 4378
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONBlockdevDel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8840-8859",
          "snippet": "int\nqemuMonitorJSONBlockdevDel(qemuMonitorPtr mon,\n                           const char *nodename)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"blockdev-del\",\n                                           \"s:node-name\", nodename,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONBlockdevDel(qemuMonitorPtr mon,\n                           const char *nodename)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"blockdev-del\",\n                                           \"s:node-name\", nodename,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"nodename=%s\"",
            "nodename"
          ],
          "line": 4374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockdevDel(qemuMonitorPtr mon,\n                       const char *nodename)\n{\n    VIR_DEBUG(\"nodename=%s\", nodename);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevDel(mon, nodename);\n}"
  },
  {
    "function_name": "qemuMonitorBlockdevReopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4357-4367",
    "snippet": "int\nqemuMonitorBlockdevReopen(qemuMonitorPtr mon,\n                          virJSONValuePtr *props)\n{\n    VIR_DEBUG(\"props=%p (node-name=%s)\", *props,\n              NULLSTR(virJSONValueObjectGetString(*props, \"node-name\")));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevReopen(mon, props);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONBlockdevReopen",
          "args": [
            "mon",
            "props"
          ],
          "line": 4366
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONBlockdevReopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8819-8837",
          "snippet": "int\nqemuMonitorJSONBlockdevReopen(qemuMonitorPtr mon,\n                              virJSONValuePtr *props)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n    virJSONValuePtr pr = g_steal_pointer(props);\n\n    if (!(cmd = qemuMonitorJSONMakeCommandInternal(\"blockdev-reopen\", pr)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONBlockdevReopen(qemuMonitorPtr mon,\n                              virJSONValuePtr *props)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n    virJSONValuePtr pr = g_steal_pointer(props);\n\n    if (!(cmd = qemuMonitorJSONMakeCommandInternal(\"blockdev-reopen\", pr)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"props=%p (node-name=%s)\"",
            "*props",
            "NULLSTR(virJSONValueObjectGetString(*props, \"node-name\"))"
          ],
          "line": 4361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "virJSONValueObjectGetString(*props, \"node-name\")"
          ],
          "line": 4362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "*props",
            "\"node-name\""
          ],
          "line": 4362
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockdevReopen(qemuMonitorPtr mon,\n                          virJSONValuePtr *props)\n{\n    VIR_DEBUG(\"props=%p (node-name=%s)\", *props,\n              NULLSTR(virJSONValueObjectGetString(*props, \"node-name\")));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevReopen(mon, props);\n}"
  },
  {
    "function_name": "qemuMonitorBlockdevAdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4344-4354",
    "snippet": "int\nqemuMonitorBlockdevAdd(qemuMonitorPtr mon,\n                       virJSONValuePtr *props)\n{\n    VIR_DEBUG(\"props=%p (node-name=%s)\", *props,\n              NULLSTR(virJSONValueObjectGetString(*props, \"node-name\")));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevAdd(mon, props);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONBlockdevAdd",
          "args": [
            "mon",
            "props"
          ],
          "line": 4353
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONBlockdevAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8798-8816",
          "snippet": "int\nqemuMonitorJSONBlockdevAdd(qemuMonitorPtr mon,\n                           virJSONValuePtr *props)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n    virJSONValuePtr pr = g_steal_pointer(props);\n\n    if (!(cmd = qemuMonitorJSONMakeCommandInternal(\"blockdev-add\", pr)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONBlockdevAdd(qemuMonitorPtr mon,\n                           virJSONValuePtr *props)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n    virJSONValuePtr pr = g_steal_pointer(props);\n\n    if (!(cmd = qemuMonitorJSONMakeCommandInternal(\"blockdev-add\", pr)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"props=%p (node-name=%s)\"",
            "*props",
            "NULLSTR(virJSONValueObjectGetString(*props, \"node-name\"))"
          ],
          "line": 4348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "virJSONValueObjectGetString(*props, \"node-name\")"
          ],
          "line": 4349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "*props",
            "\"node-name\""
          ],
          "line": 4349
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockdevAdd(qemuMonitorPtr mon,\n                       virJSONValuePtr *props)\n{\n    VIR_DEBUG(\"props=%p (node-name=%s)\", *props,\n              NULLSTR(virJSONValueObjectGetString(*props, \"node-name\")));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevAdd(mon, props);\n}"
  },
  {
    "function_name": "qemuMonitorBlockdevCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4320-4334",
    "snippet": "int\nqemuMonitorBlockdevCreate(qemuMonitorPtr mon,\n                          const char *jobname,\n                          virJSONValuePtr props)\n{\n    VIR_DEBUG(\"jobname=%s props=%p\", jobname, props);\n\n    QEMU_CHECK_MONITOR_GOTO(mon, error);\n\n    return qemuMonitorJSONBlockdevCreate(mon, jobname, props);\n\n error:\n    virJSONValueFree(props);\n    return -1;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueFree",
          "args": [
            "props"
          ],
          "line": 4332
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "391-423",
          "snippet": "void\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvoid\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONBlockdevCreate",
          "args": [
            "mon",
            "jobname",
            "props"
          ],
          "line": 4329
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONBlockdevCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8772-8795",
          "snippet": "int\nqemuMonitorJSONBlockdevCreate(qemuMonitorPtr mon,\n                              const char *jobname,\n                              virJSONValuePtr props)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"blockdev-create\",\n                                     \"s:job-id\", jobname,\n                                     \"a:options\", &props,\n                                     NULL);\n    virJSONValueFree(props);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONBlockdevCreate(qemuMonitorPtr mon,\n                              const char *jobname,\n                              virJSONValuePtr props)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"blockdev-create\",\n                                     \"s:job-id\", jobname,\n                                     \"a:options\", &props,\n                                     NULL);\n    virJSONValueFree(props);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR_GOTO",
          "args": [
            "mon",
            "error"
          ],
          "line": 4327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"jobname=%s props=%p\"",
            "jobname",
            "props"
          ],
          "line": 4325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockdevCreate(qemuMonitorPtr mon,\n                          const char *jobname,\n                          virJSONValuePtr props)\n{\n    VIR_DEBUG(\"jobname=%s props=%p\", jobname, props);\n\n    QEMU_CHECK_MONITOR_GOTO(mon, error);\n\n    return qemuMonitorJSONBlockdevCreate(mon, jobname, props);\n\n error:\n    virJSONValueFree(props);\n    return -1;\n}"
  },
  {
    "function_name": "qemuMonitorSetWatchdogAction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4294-4303",
    "snippet": "int\nqemuMonitorSetWatchdogAction(qemuMonitorPtr mon,\n                             const char *action)\n{\n    VIR_DEBUG(\"watchdogAction=%s\", action);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetWatchdogAction(mon, action);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSetWatchdogAction",
          "args": [
            "mon",
            "action"
          ],
          "line": 4302
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSetWatchdogAction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8744-8769",
          "snippet": "int\nqemuMonitorJSONSetWatchdogAction(qemuMonitorPtr mon,\n                                 const char *action)\n{\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    int ret = -1;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"watchdog-set-action\",\n                                           \"s:action\", action,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONSetWatchdogAction(qemuMonitorPtr mon,\n                                 const char *action)\n{\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    int ret = -1;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"watchdog-set-action\",\n                                           \"s:action\", action,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"watchdogAction=%s\"",
            "action"
          ],
          "line": 4298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSetWatchdogAction(qemuMonitorPtr mon,\n                             const char *action)\n{\n    VIR_DEBUG(\"watchdogAction=%s\", action);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetWatchdogAction(mon, action);\n}"
  },
  {
    "function_name": "qemuMonitorEventRdmaGidStatusFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4283-4291",
    "snippet": "void\nqemuMonitorEventRdmaGidStatusFree(qemuMonitorRdmaGidStatusPtr info)\n{\n    if (!info)\n        return;\n\n    VIR_FREE(info->netdev);\n    VIR_FREE(info);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "info"
          ],
          "line": 4290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "info->netdev"
          ],
          "line": 4289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorEventRdmaGidStatusFree(qemuMonitorRdmaGidStatusPtr info)\n{\n    if (!info)\n        return;\n\n    VIR_FREE(info->netdev);\n    VIR_FREE(info);\n}"
  },
  {
    "function_name": "qemuMonitorEventPanicInfoFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4263-4280",
    "snippet": "void\nqemuMonitorEventPanicInfoFree(qemuMonitorEventPanicInfoPtr info)\n{\n    if (!info)\n        return;\n\n    switch (info->type) {\n    case QEMU_MONITOR_EVENT_PANIC_INFO_TYPE_S390:\n        VIR_FREE(info->data.s390.reason);\n        break;\n    case QEMU_MONITOR_EVENT_PANIC_INFO_TYPE_NONE:\n    case QEMU_MONITOR_EVENT_PANIC_INFO_TYPE_HYPERV:\n    case QEMU_MONITOR_EVENT_PANIC_INFO_TYPE_LAST:\n        break;\n    }\n\n    VIR_FREE(info);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "info"
          ],
          "line": 4279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "info->data.s390.reason"
          ],
          "line": 4271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorEventPanicInfoFree(qemuMonitorEventPanicInfoPtr info)\n{\n    if (!info)\n        return;\n\n    switch (info->type) {\n    case QEMU_MONITOR_EVENT_PANIC_INFO_TYPE_S390:\n        VIR_FREE(info->data.s390.reason);\n        break;\n    case QEMU_MONITOR_EVENT_PANIC_INFO_TYPE_NONE:\n    case QEMU_MONITOR_EVENT_PANIC_INFO_TYPE_HYPERV:\n    case QEMU_MONITOR_EVENT_PANIC_INFO_TYPE_LAST:\n        break;\n    }\n\n    VIR_FREE(info);\n}"
  },
  {
    "function_name": "qemuMonitorGuestPanicEventInfoFormatMsg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4233-4260",
    "snippet": "char *\nqemuMonitorGuestPanicEventInfoFormatMsg(qemuMonitorEventPanicInfoPtr info)\n{\n    char *ret = NULL;\n\n    switch (info->type) {\n    case QEMU_MONITOR_EVENT_PANIC_INFO_TYPE_HYPERV:\n        ret = g_strdup_printf(\"hyper-v: arg1='0x%llx', arg2='0x%llx', \"\n                              \"arg3='0x%llx', arg4='0x%llx', arg5='0x%llx'\",\n                              info->data.hyperv.arg1, info->data.hyperv.arg2,\n                              info->data.hyperv.arg3, info->data.hyperv.arg4,\n                              info->data.hyperv.arg5);\n        break;\n    case QEMU_MONITOR_EVENT_PANIC_INFO_TYPE_S390:\n        ret = g_strdup_printf(\"s390: core='%d' psw-mask='0x%016llx' \"\n                              \"psw-addr='0x%016llx' reason='%s'\",\n                              info->data.s390.core,\n                              info->data.s390.psw_mask,\n                              info->data.s390.psw_addr,\n                              info->data.s390.reason);\n        break;\n    case QEMU_MONITOR_EVENT_PANIC_INFO_TYPE_NONE:\n    case QEMU_MONITOR_EVENT_PANIC_INFO_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"s390: core='%d' psw-mask='0x%016llx' \"\n                              \"psw-addr='0x%016llx' reason='%s'\"",
            "info->data.s390.core",
            "info->data.s390.psw_mask",
            "info->data.s390.psw_addr",
            "info->data.s390.reason"
          ],
          "line": 4247
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nchar *\nqemuMonitorGuestPanicEventInfoFormatMsg(qemuMonitorEventPanicInfoPtr info)\n{\n    char *ret = NULL;\n\n    switch (info->type) {\n    case QEMU_MONITOR_EVENT_PANIC_INFO_TYPE_HYPERV:\n        ret = g_strdup_printf(\"hyper-v: arg1='0x%llx', arg2='0x%llx', \"\n                              \"arg3='0x%llx', arg4='0x%llx', arg5='0x%llx'\",\n                              info->data.hyperv.arg1, info->data.hyperv.arg2,\n                              info->data.hyperv.arg3, info->data.hyperv.arg4,\n                              info->data.hyperv.arg5);\n        break;\n    case QEMU_MONITOR_EVENT_PANIC_INFO_TYPE_S390:\n        ret = g_strdup_printf(\"s390: core='%d' psw-mask='0x%016llx' \"\n                              \"psw-addr='0x%016llx' reason='%s'\",\n                              info->data.s390.core,\n                              info->data.s390.psw_mask,\n                              info->data.s390.psw_addr,\n                              info->data.s390.reason);\n        break;\n    case QEMU_MONITOR_EVENT_PANIC_INFO_TYPE_NONE:\n    case QEMU_MONITOR_EVENT_PANIC_INFO_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorQueryNamedBlockNodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4224-4230",
    "snippet": "virJSONValuePtr\nqemuMonitorQueryNamedBlockNodes(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    return qemuMonitorJSONQueryNamedBlockNodes(mon, false);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONQueryNamedBlockNodes",
          "args": [
            "mon",
            "false"
          ],
          "line": 4229
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONQueryNamedBlockNodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8722-8741",
          "snippet": "virJSONValuePtr\nqemuMonitorJSONQueryNamedBlockNodes(qemuMonitorPtr mon,\n                                    bool flat)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-named-block-nodes\",\n                                           \"B:flat\", flat,\n                                           NULL)))\n        return NULL;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return NULL;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        return NULL;\n\n    return virJSONValueObjectStealArray(reply, \"return\");\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirJSONValuePtr\nqemuMonitorJSONQueryNamedBlockNodes(qemuMonitorPtr mon,\n                                    bool flat)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-named-block-nodes\",\n                                           \"B:flat\", flat,\n                                           NULL)))\n        return NULL;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return NULL;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        return NULL;\n\n    return virJSONValueObjectStealArray(reply, \"return\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR_NULL",
          "args": [
            "mon"
          ],
          "line": 4227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirJSONValuePtr\nqemuMonitorQueryNamedBlockNodes(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    return qemuMonitorJSONQueryNamedBlockNodes(mon, false);\n}"
  },
  {
    "function_name": "qemuMonitorSetBlockThreshold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4211-4221",
    "snippet": "int\nqemuMonitorSetBlockThreshold(qemuMonitorPtr mon,\n                             const char *nodename,\n                             unsigned long long threshold)\n{\n    VIR_DEBUG(\"node='%s', threshold=%llu\", nodename, threshold);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetBlockThreshold(mon, nodename, threshold);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSetBlockThreshold",
          "args": [
            "mon",
            "nodename",
            "threshold"
          ],
          "line": 4220
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSetBlockThreshold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8691-8719",
          "snippet": "int\nqemuMonitorJSONSetBlockThreshold(qemuMonitorPtr mon,\n                                 const char *nodename,\n                                 unsigned long long threshold)\n{\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    int ret = -1;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"block-set-write-threshold\",\n                                           \"s:node-name\", nodename,\n                                           \"U:write-threshold\", threshold,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONSetBlockThreshold(qemuMonitorPtr mon,\n                                 const char *nodename,\n                                 unsigned long long threshold)\n{\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    int ret = -1;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"block-set-write-threshold\",\n                                           \"s:node-name\", nodename,\n                                           \"U:write-threshold\", threshold,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"node='%s', threshold=%llu\"",
            "nodename",
            "threshold"
          ],
          "line": 4216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSetBlockThreshold(qemuMonitorPtr mon,\n                             const char *nodename,\n                             unsigned long long threshold)\n{\n    VIR_DEBUG(\"node='%s', threshold=%llu\", nodename, threshold);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetBlockThreshold(mon, nodename, threshold);\n}"
  },
  {
    "function_name": "qemuMonitorQueryQMPSchema",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4202-4208",
    "snippet": "virJSONValuePtr\nqemuMonitorQueryQMPSchema(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    return qemuMonitorJSONQueryQMPSchema(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONQueryQMPSchema",
          "args": [
            "mon"
          ],
          "line": 4207
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONQueryQMPSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8665-8688",
          "snippet": "virJSONValuePtr\nqemuMonitorJSONQueryQMPSchema(qemuMonitorPtr mon)\n{\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr ret = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-qmp-schema\", NULL)))\n        return NULL;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    ret = virJSONValueObjectStealArray(reply, \"return\");\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirJSONValuePtr\nqemuMonitorJSONQueryQMPSchema(qemuMonitorPtr mon)\n{\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr ret = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-qmp-schema\", NULL)))\n        return NULL;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    ret = virJSONValueObjectStealArray(reply, \"return\");\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR_NULL",
          "args": [
            "mon"
          ],
          "line": 4205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirJSONValuePtr\nqemuMonitorQueryQMPSchema(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    return qemuMonitorJSONQueryQMPSchema(mon);\n}"
  },
  {
    "function_name": "qemuMonitorGetRTCTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4192-4199",
    "snippet": "int\nqemuMonitorGetRTCTime(qemuMonitorPtr mon,\n                      struct tm *tm)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetRTCTime(mon, tm);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetRTCTime",
          "args": [
            "mon",
            "tm"
          ],
          "line": 4198
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetRTCTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8453-8492",
          "snippet": "int\nqemuMonitorJSONGetRTCTime(qemuMonitorPtr mon,\n                          struct tm *tm)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"qom-get\",\n                                           \"s:path\", \"/machine\",\n                                           \"s:property\", \"rtc-time\",\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGet(reply, \"return\");\n\n    if (virJSONValueObjectGetNumberInt(data, \"tm_year\", &tm->tm_year) < 0 ||\n        virJSONValueObjectGetNumberInt(data, \"tm_mon\", &tm->tm_mon) < 0 ||\n        virJSONValueObjectGetNumberInt(data, \"tm_mday\", &tm->tm_mday) < 0 ||\n        virJSONValueObjectGetNumberInt(data, \"tm_hour\", &tm->tm_hour) < 0 ||\n        virJSONValueObjectGetNumberInt(data, \"tm_min\", &tm->tm_min) < 0 ||\n        virJSONValueObjectGetNumberInt(data, \"tm_sec\", &tm->tm_sec) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"qemu returned malformed time\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint\nqemuMonitorJSONGetRTCTime(qemuMonitorPtr mon,\n                          struct tm *tm)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"qom-get\",\n                                           \"s:path\", \"/machine\",\n                                           \"s:property\", \"rtc-time\",\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGet(reply, \"return\");\n\n    if (virJSONValueObjectGetNumberInt(data, \"tm_year\", &tm->tm_year) < 0 ||\n        virJSONValueObjectGetNumberInt(data, \"tm_mon\", &tm->tm_mon) < 0 ||\n        virJSONValueObjectGetNumberInt(data, \"tm_mday\", &tm->tm_mday) < 0 ||\n        virJSONValueObjectGetNumberInt(data, \"tm_hour\", &tm->tm_hour) < 0 ||\n        virJSONValueObjectGetNumberInt(data, \"tm_min\", &tm->tm_min) < 0 ||\n        virJSONValueObjectGetNumberInt(data, \"tm_sec\", &tm->tm_sec) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"qemu returned malformed time\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetRTCTime(qemuMonitorPtr mon,\n                      struct tm *tm)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetRTCTime(mon, tm);\n}"
  },
  {
    "function_name": "qemuMonitorMigrateContinue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4180-4189",
    "snippet": "int\nqemuMonitorMigrateContinue(qemuMonitorPtr mon,\n                           qemuMonitorMigrationStatus status)\n{\n    VIR_DEBUG(\"status=%s\", qemuMonitorMigrationStatusTypeToString(status));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateContinue(mon, status);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONMigrateContinue",
          "args": [
            "mon",
            "status"
          ],
          "line": 4188
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONMigrateContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8427-8450",
          "snippet": "int\nqemuMonitorJSONMigrateContinue(qemuMonitorPtr mon,\n                               qemuMonitorMigrationStatus status)\n{\n    const char *statusStr = qemuMonitorMigrationStatusTypeToString(status);\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"migrate-continue\",\n                                           \"s:state\", statusStr,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorJSONCheckError(cmd, reply);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONMigrateContinue(qemuMonitorPtr mon,\n                               qemuMonitorMigrationStatus status)\n{\n    const char *statusStr = qemuMonitorMigrationStatusTypeToString(status);\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"migrate-continue\",\n                                           \"s:state\", statusStr,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorJSONCheckError(cmd, reply);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"status=%s\"",
            "qemuMonitorMigrationStatusTypeToString(status)"
          ],
          "line": 4184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorMigrationStatusTypeToString",
          "args": [
            "status"
          ],
          "line": 4184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorMigrateContinue(qemuMonitorPtr mon,\n                           qemuMonitorMigrationStatus status)\n{\n    VIR_DEBUG(\"status=%s\", qemuMonitorMigrationStatusTypeToString(status));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateContinue(mon, status);\n}"
  },
  {
    "function_name": "qemuMonitorMigrateStartPostCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4171-4177",
    "snippet": "int\nqemuMonitorMigrateStartPostCopy(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateStartPostCopy(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONMigrateStartPostCopy",
          "args": [
            "mon"
          ],
          "line": 4176
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONMigrateStartPostCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8405-8424",
          "snippet": "int\nqemuMonitorJSONMigrateStartPostCopy(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"migrate-start-postcopy\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorJSONCheckError(cmd, reply);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONMigrateStartPostCopy(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"migrate-start-postcopy\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorJSONCheckError(cmd, reply);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorMigrateStartPostCopy(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateStartPostCopy(mon);\n}"
  },
  {
    "function_name": "qemuMonitorMigrateIncoming",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4159-4168",
    "snippet": "int\nqemuMonitorMigrateIncoming(qemuMonitorPtr mon,\n                           const char *uri)\n{\n    VIR_DEBUG(\"uri=%s\", uri);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateIncoming(mon, uri);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONMigrateIncoming",
          "args": [
            "mon",
            "uri"
          ],
          "line": 4167
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONMigrateIncoming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8380-8402",
          "snippet": "int\nqemuMonitorJSONMigrateIncoming(qemuMonitorPtr mon,\n                               const char *uri)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"migrate-incoming\",\n                                           \"s:uri\", uri,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorJSONCheckError(cmd, reply);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONMigrateIncoming(qemuMonitorPtr mon,\n                               const char *uri)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"migrate-incoming\",\n                                           \"s:uri\", uri,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorJSONCheckError(cmd, reply);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"uri=%s\"",
            "uri"
          ],
          "line": 4163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorMigrateIncoming(qemuMonitorPtr mon,\n                           const char *uri)\n{\n    VIR_DEBUG(\"uri=%s\", uri);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateIncoming(mon, uri);\n}"
  },
  {
    "function_name": "qemuMonitorGetMemoryDeviceInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4136-4156",
    "snippet": "int\nqemuMonitorGetMemoryDeviceInfo(qemuMonitorPtr mon,\n                               virHashTablePtr *info)\n{\n    VIR_DEBUG(\"info=%p\", info);\n    int ret;\n\n    *info = NULL;\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (!(*info = virHashCreate(10, virHashValueFree)))\n        return -1;\n\n    if ((ret = qemuMonitorJSONGetMemoryDeviceInfo(mon, *info)) < 0) {\n        virHashFree(*info);\n        *info = NULL;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "*info"
          ],
          "line": 4151
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetMemoryDeviceInfo",
          "args": [
            "mon",
            "*info"
          ],
          "line": 4150
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetMemoryDeviceInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8132-8235",
          "snippet": "int\nqemuMonitorJSONGetMemoryDeviceInfo(qemuMonitorPtr mon,\n                                   virHashTablePtr info)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data = NULL;\n    qemuMonitorMemoryDeviceInfoPtr meminfo = NULL;\n    size_t i;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-memory-devices\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n        ret = -2;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n\n    for (i = 0; i < virJSONValueArraySize(data); i++) {\n        virJSONValuePtr elem = virJSONValueArrayGet(data, i);\n        const char *type;\n\n        if (!(type = virJSONValueObjectGetString(elem, \"type\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-memory-devices reply data doesn't contain \"\n                             \"enum type discriminator\"));\n            goto cleanup;\n        }\n\n        /* dimm memory devices */\n        if (STREQ(type, \"dimm\")) {\n            virJSONValuePtr dimminfo;\n            const char *devalias;\n\n            if (!(dimminfo = virJSONValueObjectGetObject(elem, \"data\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"query-memory-devices reply data doesn't \"\n                                 \"contain enum data\"));\n                goto cleanup;\n            }\n\n            if (!(devalias = virJSONValueObjectGetString(dimminfo, \"id\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"dimm memory info data is missing 'id'\"));\n                goto cleanup;\n            }\n\n            if (VIR_ALLOC(meminfo) < 0)\n                goto cleanup;\n\n            if (virJSONValueObjectGetNumberUlong(dimminfo, \"addr\",\n                                                 &meminfo->address) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed/missing addr in dimm memory info\"));\n                goto cleanup;\n            }\n\n            if (virJSONValueObjectGetNumberUint(dimminfo, \"slot\",\n                                                &meminfo->slot) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed/missing slot in dimm memory info\"));\n                goto cleanup;\n            }\n\n            if (virJSONValueObjectGetBoolean(dimminfo, \"hotplugged\",\n                                             &meminfo->hotplugged) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed/missing hotplugged in dimm memory info\"));\n                goto cleanup;\n\n            }\n\n            if (virJSONValueObjectGetBoolean(dimminfo, \"hotpluggable\",\n                                             &meminfo->hotpluggable) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed/missing hotpluggable in dimm memory info\"));\n                goto cleanup;\n\n            }\n\n            if (virHashAddEntry(info, devalias, meminfo) < 0)\n                goto cleanup;\n\n            meminfo = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(meminfo);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint\nqemuMonitorJSONGetMemoryDeviceInfo(qemuMonitorPtr mon,\n                                   virHashTablePtr info)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data = NULL;\n    qemuMonitorMemoryDeviceInfoPtr meminfo = NULL;\n    size_t i;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-memory-devices\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n        ret = -2;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n\n    for (i = 0; i < virJSONValueArraySize(data); i++) {\n        virJSONValuePtr elem = virJSONValueArrayGet(data, i);\n        const char *type;\n\n        if (!(type = virJSONValueObjectGetString(elem, \"type\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-memory-devices reply data doesn't contain \"\n                             \"enum type discriminator\"));\n            goto cleanup;\n        }\n\n        /* dimm memory devices */\n        if (STREQ(type, \"dimm\")) {\n            virJSONValuePtr dimminfo;\n            const char *devalias;\n\n            if (!(dimminfo = virJSONValueObjectGetObject(elem, \"data\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"query-memory-devices reply data doesn't \"\n                                 \"contain enum data\"));\n                goto cleanup;\n            }\n\n            if (!(devalias = virJSONValueObjectGetString(dimminfo, \"id\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"dimm memory info data is missing 'id'\"));\n                goto cleanup;\n            }\n\n            if (VIR_ALLOC(meminfo) < 0)\n                goto cleanup;\n\n            if (virJSONValueObjectGetNumberUlong(dimminfo, \"addr\",\n                                                 &meminfo->address) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed/missing addr in dimm memory info\"));\n                goto cleanup;\n            }\n\n            if (virJSONValueObjectGetNumberUint(dimminfo, \"slot\",\n                                                &meminfo->slot) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed/missing slot in dimm memory info\"));\n                goto cleanup;\n            }\n\n            if (virJSONValueObjectGetBoolean(dimminfo, \"hotplugged\",\n                                             &meminfo->hotplugged) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed/missing hotplugged in dimm memory info\"));\n                goto cleanup;\n\n            }\n\n            if (virJSONValueObjectGetBoolean(dimminfo, \"hotpluggable\",\n                                             &meminfo->hotpluggable) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed/missing hotpluggable in dimm memory info\"));\n                goto cleanup;\n\n            }\n\n            if (virHashAddEntry(info, devalias, meminfo) < 0)\n                goto cleanup;\n\n            meminfo = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(meminfo);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "10",
            "virHashValueFree"
          ],
          "line": 4147
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"info=%p\"",
            "info"
          ],
          "line": 4140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetMemoryDeviceInfo(qemuMonitorPtr mon,\n                               virHashTablePtr *info)\n{\n    VIR_DEBUG(\"info=%p\", info);\n    int ret;\n\n    *info = NULL;\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (!(*info = virHashCreate(10, virHashValueFree)))\n        return -1;\n\n    if ((ret = qemuMonitorJSONGetMemoryDeviceInfo(mon, *info)) < 0) {\n        virHashFree(*info);\n        *info = NULL;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorSetIOThread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4112-4121",
    "snippet": "int\nqemuMonitorSetIOThread(qemuMonitorPtr mon,\n                       qemuMonitorIOThreadInfoPtr iothreadInfo)\n{\n    VIR_DEBUG(\"iothread=%p\", iothreadInfo);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetIOThread(mon, iothreadInfo);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSetIOThread",
          "args": [
            "mon",
            "iothreadInfo"
          ],
          "line": 4120
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSetIOThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8099-8129",
          "snippet": "int\nqemuMonitorJSONSetIOThread(qemuMonitorPtr mon,\n                           qemuMonitorIOThreadInfoPtr iothreadInfo)\n{\n    int ret = -1;\n    char *path = NULL;\n    qemuMonitorJSONObjectProperty prop;\n\n    path = g_strdup_printf(\"/objects/iothread%u\", iothreadInfo->iothread_id);\n\n#define VIR_IOTHREAD_SET_PROP(propName, propVal) \\\n    if (iothreadInfo->set_##propVal) { \\\n        memset(&prop, 0, sizeof(qemuMonitorJSONObjectProperty)); \\\n        prop.type = QEMU_MONITOR_OBJECT_PROPERTY_INT; \\\n        prop.val.iv = iothreadInfo->propVal; \\\n        if (qemuMonitorJSONSetObjectProperty(mon, path, propName, &prop) < 0) \\\n            goto cleanup; \\\n    }\n\n    VIR_IOTHREAD_SET_PROP(\"poll-max-ns\", poll_max_ns);\n    VIR_IOTHREAD_SET_PROP(\"poll-grow\", poll_grow);\n    VIR_IOTHREAD_SET_PROP(\"poll-shrink\", poll_shrink);\n\n#undef VIR_IOTHREAD_SET_PROP\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(path);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONSetIOThread(qemuMonitorPtr mon,\n                           qemuMonitorIOThreadInfoPtr iothreadInfo)\n{\n    int ret = -1;\n    char *path = NULL;\n    qemuMonitorJSONObjectProperty prop;\n\n    path = g_strdup_printf(\"/objects/iothread%u\", iothreadInfo->iothread_id);\n\n#define VIR_IOTHREAD_SET_PROP(propName, propVal) \\\n    if (iothreadInfo->set_##propVal) { \\\n        memset(&prop, 0, sizeof(qemuMonitorJSONObjectProperty)); \\\n        prop.type = QEMU_MONITOR_OBJECT_PROPERTY_INT; \\\n        prop.val.iv = iothreadInfo->propVal; \\\n        if (qemuMonitorJSONSetObjectProperty(mon, path, propName, &prop) < 0) \\\n            goto cleanup; \\\n    }\n\n    VIR_IOTHREAD_SET_PROP(\"poll-max-ns\", poll_max_ns);\n    VIR_IOTHREAD_SET_PROP(\"poll-grow\", poll_grow);\n    VIR_IOTHREAD_SET_PROP(\"poll-shrink\", poll_shrink);\n\n#undef VIR_IOTHREAD_SET_PROP\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(path);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"iothread=%p\"",
            "iothreadInfo"
          ],
          "line": 4116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSetIOThread(qemuMonitorPtr mon,\n                       qemuMonitorIOThreadInfoPtr iothreadInfo)\n{\n    VIR_DEBUG(\"iothread=%p\", iothreadInfo);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetIOThread(mon, iothreadInfo);\n}"
  },
  {
    "function_name": "qemuMonitorGetIOThreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4093-4102",
    "snippet": "int\nqemuMonitorGetIOThreads(qemuMonitorPtr mon,\n                        qemuMonitorIOThreadInfoPtr **iothreads)\n{\n    VIR_DEBUG(\"iothreads=%p\", iothreads);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetIOThreads(mon, iothreads);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetIOThreads",
          "args": [
            "mon",
            "iothreads"
          ],
          "line": 4101
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetIOThreads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8002-8096",
          "snippet": "int\nqemuMonitorJSONGetIOThreads(qemuMonitorPtr mon,\n                            qemuMonitorIOThreadInfoPtr **iothreads)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    qemuMonitorIOThreadInfoPtr *infolist = NULL;\n    size_t n = 0;\n    size_t i;\n\n    *iothreads = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-iothreads\", NULL)))\n        return ret;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n    n = virJSONValueArraySize(data);\n\n    /* null-terminated list */\n    if (VIR_ALLOC_N(infolist, n + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(data, i);\n        const char *tmp;\n        qemuMonitorIOThreadInfoPtr info;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"id\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-iothreads reply data was missing 'id'\"));\n            goto cleanup;\n        }\n\n        if (!STRPREFIX(tmp, \"iothread\"))\n            continue;\n\n        if (VIR_ALLOC(info) < 0)\n            goto cleanup;\n\n        infolist[i] = info;\n\n        if (virStrToLong_ui(tmp + strlen(\"iothread\"),\n                            NULL, 10, &info->iothread_id) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to find iothread id for '%s'\"),\n                           tmp);\n            goto cleanup;\n        }\n\n        if (virJSONValueObjectGetNumberInt(child, \"thread-id\",\n                                           &info->thread_id) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-iothreads reply has malformed \"\n                             \"'thread-id' data\"));\n            goto cleanup;\n        }\n\n        /* Fetch poll values (since QEMU 2.9 ) if available. QEMU\n         * stores these values as int64_t's; however, the qapi type\n         * is an int. The qapi/misc.json also mis-describes the grow\n         * and shrink values as pure add/remove values. The source\n         * util/aio-posix.c function aio_poll uses them as a factor\n         * or divisor in it's calculation. We will fetch and store\n         * them as defined in our structures. */\n        if (virJSONValueObjectGetNumberUlong(child, \"poll-max-ns\",\n                                             &info->poll_max_ns) == 0 &&\n            virJSONValueObjectGetNumberUint(child, \"poll-grow\",\n                                            &info->poll_grow) == 0 &&\n            virJSONValueObjectGetNumberUint(child, \"poll-shrink\",\n                                            &info->poll_shrink) == 0)\n            info->poll_valid = true;\n    }\n\n    ret = n;\n    *iothreads = infolist;\n    infolist = NULL;\n\n cleanup:\n    if (infolist) {\n        for (i = 0; i < n; i++)\n            VIR_FREE(infolist[i]);\n        VIR_FREE(infolist);\n    }\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint\nqemuMonitorJSONGetIOThreads(qemuMonitorPtr mon,\n                            qemuMonitorIOThreadInfoPtr **iothreads)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    qemuMonitorIOThreadInfoPtr *infolist = NULL;\n    size_t n = 0;\n    size_t i;\n\n    *iothreads = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-iothreads\", NULL)))\n        return ret;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n    n = virJSONValueArraySize(data);\n\n    /* null-terminated list */\n    if (VIR_ALLOC_N(infolist, n + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(data, i);\n        const char *tmp;\n        qemuMonitorIOThreadInfoPtr info;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"id\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-iothreads reply data was missing 'id'\"));\n            goto cleanup;\n        }\n\n        if (!STRPREFIX(tmp, \"iothread\"))\n            continue;\n\n        if (VIR_ALLOC(info) < 0)\n            goto cleanup;\n\n        infolist[i] = info;\n\n        if (virStrToLong_ui(tmp + strlen(\"iothread\"),\n                            NULL, 10, &info->iothread_id) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to find iothread id for '%s'\"),\n                           tmp);\n            goto cleanup;\n        }\n\n        if (virJSONValueObjectGetNumberInt(child, \"thread-id\",\n                                           &info->thread_id) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-iothreads reply has malformed \"\n                             \"'thread-id' data\"));\n            goto cleanup;\n        }\n\n        /* Fetch poll values (since QEMU 2.9 ) if available. QEMU\n         * stores these values as int64_t's; however, the qapi type\n         * is an int. The qapi/misc.json also mis-describes the grow\n         * and shrink values as pure add/remove values. The source\n         * util/aio-posix.c function aio_poll uses them as a factor\n         * or divisor in it's calculation. We will fetch and store\n         * them as defined in our structures. */\n        if (virJSONValueObjectGetNumberUlong(child, \"poll-max-ns\",\n                                             &info->poll_max_ns) == 0 &&\n            virJSONValueObjectGetNumberUint(child, \"poll-grow\",\n                                            &info->poll_grow) == 0 &&\n            virJSONValueObjectGetNumberUint(child, \"poll-shrink\",\n                                            &info->poll_shrink) == 0)\n            info->poll_valid = true;\n    }\n\n    ret = n;\n    *iothreads = infolist;\n    infolist = NULL;\n\n cleanup:\n    if (infolist) {\n        for (i = 0; i < n; i++)\n            VIR_FREE(infolist[i]);\n        VIR_FREE(infolist);\n    }\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"iothreads=%p\"",
            "iothreads"
          ],
          "line": 4097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetIOThreads(qemuMonitorPtr mon,\n                        qemuMonitorIOThreadInfoPtr **iothreads)\n{\n    VIR_DEBUG(\"iothreads=%p\", iothreads);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetIOThreads(mon, iothreads);\n}"
  },
  {
    "function_name": "qemuMonitorRTCResetReinjection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4073-4079",
    "snippet": "int\nqemuMonitorRTCResetReinjection(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONRTCResetReinjection(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONRTCResetReinjection",
          "args": [
            "mon"
          ],
          "line": 4078
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONRTCResetReinjection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "7972-7994",
          "snippet": "int\nqemuMonitorJSONRTCResetReinjection(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"rtc-reset-reinjection\",\n                                           NULL)))\n        return ret;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONRTCResetReinjection(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"rtc-reset-reinjection\",\n                                           NULL)))\n        return ret;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorRTCResetReinjection(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONRTCResetReinjection(mon);\n}"
  },
  {
    "function_name": "qemuMonitorGetGuestCPU",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4039-4058",
    "snippet": "int\nqemuMonitorGetGuestCPU(qemuMonitorPtr mon,\n                       virArch arch,\n                       qemuMonitorCPUFeatureTranslationCallback translate,\n                       void *opaque,\n                       virCPUDataPtr *enabled,\n                       virCPUDataPtr *disabled)\n{\n    VIR_DEBUG(\"arch=%s translate=%p opaque=%p enabled=%p disabled=%p\",\n              virArchToString(arch), translate, opaque, enabled, disabled);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    *enabled = NULL;\n    if (disabled)\n        *disabled = NULL;\n\n    return qemuMonitorJSONGetGuestCPU(mon, arch, translate, opaque,\n                                      enabled, disabled);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetGuestCPU",
          "args": [
            "mon",
            "arch",
            "translate",
            "opaque",
            "enabled",
            "disabled"
          ],
          "line": 4056
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetGuestCPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "7936-7969",
          "snippet": "int\nqemuMonitorJSONGetGuestCPU(qemuMonitorPtr mon,\n                           virArch arch,\n                           qemuMonitorCPUFeatureTranslationCallback translate,\n                           void *opaque,\n                           virCPUDataPtr *enabled,\n                           virCPUDataPtr *disabled)\n{\n    virCPUDataPtr cpuEnabled = NULL;\n    virCPUDataPtr cpuDisabled = NULL;\n    int ret = -1;\n\n    if (!(cpuEnabled = virCPUDataNew(arch)) ||\n        !(cpuDisabled = virCPUDataNew(arch)))\n        goto cleanup;\n\n    if (qemuMonitorJSONGetCPUData(mon, translate, opaque, cpuEnabled) < 0)\n        goto cleanup;\n\n    if (disabled &&\n        qemuMonitorJSONGetCPUDataDisabled(mon, translate, opaque, cpuDisabled) < 0)\n        goto cleanup;\n\n    *enabled = g_steal_pointer(&cpuEnabled);\n    if (disabled)\n        *disabled = g_steal_pointer(&cpuDisabled);\n\n    ret = 0;\n\n cleanup:\n    virCPUDataFree(cpuEnabled);\n    virCPUDataFree(cpuDisabled);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONGetGuestCPU(qemuMonitorPtr mon,\n                           virArch arch,\n                           qemuMonitorCPUFeatureTranslationCallback translate,\n                           void *opaque,\n                           virCPUDataPtr *enabled,\n                           virCPUDataPtr *disabled)\n{\n    virCPUDataPtr cpuEnabled = NULL;\n    virCPUDataPtr cpuDisabled = NULL;\n    int ret = -1;\n\n    if (!(cpuEnabled = virCPUDataNew(arch)) ||\n        !(cpuDisabled = virCPUDataNew(arch)))\n        goto cleanup;\n\n    if (qemuMonitorJSONGetCPUData(mon, translate, opaque, cpuEnabled) < 0)\n        goto cleanup;\n\n    if (disabled &&\n        qemuMonitorJSONGetCPUDataDisabled(mon, translate, opaque, cpuDisabled) < 0)\n        goto cleanup;\n\n    *enabled = g_steal_pointer(&cpuEnabled);\n    if (disabled)\n        *disabled = g_steal_pointer(&cpuDisabled);\n\n    ret = 0;\n\n cleanup:\n    virCPUDataFree(cpuEnabled);\n    virCPUDataFree(cpuDisabled);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s translate=%p opaque=%p enabled=%p disabled=%p\"",
            "virArchToString(arch)",
            "translate",
            "opaque",
            "enabled",
            "disabled"
          ],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 4048
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetGuestCPU(qemuMonitorPtr mon,\n                       virArch arch,\n                       qemuMonitorCPUFeatureTranslationCallback translate,\n                       void *opaque,\n                       virCPUDataPtr *enabled,\n                       virCPUDataPtr *disabled)\n{\n    VIR_DEBUG(\"arch=%s translate=%p opaque=%p enabled=%p disabled=%p\",\n              virArchToString(arch), translate, opaque, enabled, disabled);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    *enabled = NULL;\n    if (disabled)\n        *disabled = NULL;\n\n    return qemuMonitorJSONGetGuestCPU(mon, arch, translate, opaque,\n                                      enabled, disabled);\n}"
  },
  {
    "function_name": "qemuMonitorGetGuestCPUx86",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "4008-4022",
    "snippet": "int\nqemuMonitorGetGuestCPUx86(qemuMonitorPtr mon,\n                          virCPUDataPtr *data,\n                          virCPUDataPtr *disabled)\n{\n    VIR_DEBUG(\"data=%p disabled=%p\", data, disabled);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    *data = NULL;\n    if (disabled)\n        *disabled = NULL;\n\n    return qemuMonitorJSONGetGuestCPUx86(mon, data, disabled);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetGuestCPUx86",
          "args": [
            "mon",
            "data",
            "disabled"
          ],
          "line": 4021
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetGuestCPUx86",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "7803-7835",
          "snippet": "int\nqemuMonitorJSONGetGuestCPUx86(qemuMonitorPtr mon,\n                              virCPUDataPtr *data,\n                              virCPUDataPtr *disabled)\n{\n    virCPUDataPtr cpuEnabled = NULL;\n    virCPUDataPtr cpuDisabled = NULL;\n    int rc;\n\n    if ((rc = qemuMonitorJSONCheckCPUx86(mon)) < 0)\n        return -1;\n    else if (!rc)\n        return -2;\n\n    if (qemuMonitorJSONGetCPUx86Data(mon, \"feature-words\",\n                                     &cpuEnabled) < 0)\n        goto error;\n\n    if (disabled &&\n        qemuMonitorJSONGetCPUx86Data(mon, \"filtered-features\",\n                                     &cpuDisabled) < 0)\n        goto error;\n\n    *data = cpuEnabled;\n    if (disabled)\n        *disabled = cpuDisabled;\n    return 0;\n\n error:\n    virCPUDataFree(cpuEnabled);\n    virCPUDataFree(cpuDisabled);\n    return -1;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint\nqemuMonitorJSONGetGuestCPUx86(qemuMonitorPtr mon,\n                              virCPUDataPtr *data,\n                              virCPUDataPtr *disabled)\n{\n    virCPUDataPtr cpuEnabled = NULL;\n    virCPUDataPtr cpuDisabled = NULL;\n    int rc;\n\n    if ((rc = qemuMonitorJSONCheckCPUx86(mon)) < 0)\n        return -1;\n    else if (!rc)\n        return -2;\n\n    if (qemuMonitorJSONGetCPUx86Data(mon, \"feature-words\",\n                                     &cpuEnabled) < 0)\n        goto error;\n\n    if (disabled &&\n        qemuMonitorJSONGetCPUx86Data(mon, \"filtered-features\",\n                                     &cpuDisabled) < 0)\n        goto error;\n\n    *data = cpuEnabled;\n    if (disabled)\n        *disabled = cpuDisabled;\n    return 0;\n\n error:\n    virCPUDataFree(cpuEnabled);\n    virCPUDataFree(cpuDisabled);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 4015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"data=%p disabled=%p\"",
            "data",
            "disabled"
          ],
          "line": 4013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetGuestCPUx86(qemuMonitorPtr mon,\n                          virCPUDataPtr *data,\n                          virCPUDataPtr *disabled)\n{\n    VIR_DEBUG(\"data=%p disabled=%p\", data, disabled);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    *data = NULL;\n    if (disabled)\n        *disabled = NULL;\n\n    return qemuMonitorJSONGetGuestCPUx86(mon, data, disabled);\n}"
  },
  {
    "function_name": "qemuMonitorSetDomainLog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3985-3994",
    "snippet": "void\nqemuMonitorSetDomainLog(qemuMonitorPtr mon,\n                        qemuMonitorReportDomainLogError func,\n                        void *opaque,\n                        virFreeCallback destroy)\n{\n    virObjectLock(mon);\n    qemuMonitorSetDomainLogLocked(mon, func, opaque, destroy);\n    virObjectUnlock(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mon"
          ],
          "line": 3993
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorSetDomainLogLocked",
          "args": [
            "mon",
            "func",
            "opaque",
            "destroy"
          ],
          "line": 3992
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorSetDomainLogLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3959-3971",
          "snippet": "void\nqemuMonitorSetDomainLogLocked(qemuMonitorPtr mon,\n                              qemuMonitorReportDomainLogError func,\n                              void *opaque,\n                              virFreeCallback destroy)\n{\n    if (mon->logDestroy && mon->logOpaque)\n        mon->logDestroy(mon->logOpaque);\n\n    mon->logFunc = func;\n    mon->logOpaque = opaque;\n    mon->logDestroy = destroy;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorSetDomainLogLocked(qemuMonitorPtr mon,\n                              qemuMonitorReportDomainLogError func,\n                              void *opaque,\n                              virFreeCallback destroy)\n{\n    if (mon->logDestroy && mon->logOpaque)\n        mon->logDestroy(mon->logOpaque);\n\n    mon->logFunc = func;\n    mon->logOpaque = opaque;\n    mon->logDestroy = destroy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mon"
          ],
          "line": 3991
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorSetDomainLog(qemuMonitorPtr mon,\n                        qemuMonitorReportDomainLogError func,\n                        void *opaque,\n                        virFreeCallback destroy)\n{\n    virObjectLock(mon);\n    qemuMonitorSetDomainLogLocked(mon, func, opaque, destroy);\n    virObjectUnlock(mon);\n}"
  },
  {
    "function_name": "qemuMonitorSetDomainLogLocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3959-3971",
    "snippet": "void\nqemuMonitorSetDomainLogLocked(qemuMonitorPtr mon,\n                              qemuMonitorReportDomainLogError func,\n                              void *opaque,\n                              virFreeCallback destroy)\n{\n    if (mon->logDestroy && mon->logOpaque)\n        mon->logDestroy(mon->logOpaque);\n\n    mon->logFunc = func;\n    mon->logOpaque = opaque;\n    mon->logDestroy = destroy;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mon->logDestroy",
          "args": [
            "mon->logOpaque"
          ],
          "line": 3966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorSetDomainLogLocked(qemuMonitorPtr mon,\n                              qemuMonitorReportDomainLogError func,\n                              void *opaque,\n                              virFreeCallback destroy)\n{\n    if (mon->logDestroy && mon->logOpaque)\n        mon->logDestroy(mon->logOpaque);\n\n    mon->logFunc = func;\n    mon->logOpaque = opaque;\n    mon->logDestroy = destroy;\n}"
  },
  {
    "function_name": "qemuMonitorGetDeviceAliases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3936-3945",
    "snippet": "int\nqemuMonitorGetDeviceAliases(qemuMonitorPtr mon,\n                            char ***aliases)\n{\n    VIR_DEBUG(\"aliases=%p\", aliases);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetDeviceAliases(mon, aliases);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetDeviceAliases",
          "args": [
            "mon",
            "aliases"
          ],
          "line": 3944
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetDeviceAliases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "7588-7623",
          "snippet": "int\nqemuMonitorJSONGetDeviceAliases(qemuMonitorPtr mon,\n                                char ***aliases)\n{\n    qemuMonitorJSONListPathPtr *paths = NULL;\n    char **alias;\n    int ret = -1;\n    size_t i;\n    int n;\n\n    *aliases = NULL;\n\n    n = qemuMonitorJSONGetObjectListPaths(mon, \"/machine/peripheral\", &paths);\n    if (n < 0)\n        return -1;\n\n    if (VIR_ALLOC_N(*aliases, n + 1) < 0)\n        goto cleanup;\n\n    alias = *aliases;\n    for (i = 0; i < n; i++) {\n        if (STRPREFIX(paths[i]->type, \"child<\")) {\n            *alias = paths[i]->name;\n            paths[i]->name = NULL;\n            alias++;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    for (i = 0; i < n; i++)\n        qemuMonitorJSONListPathFree(paths[i]);\n    VIR_FREE(paths);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONGetDeviceAliases(qemuMonitorPtr mon,\n                                char ***aliases)\n{\n    qemuMonitorJSONListPathPtr *paths = NULL;\n    char **alias;\n    int ret = -1;\n    size_t i;\n    int n;\n\n    *aliases = NULL;\n\n    n = qemuMonitorJSONGetObjectListPaths(mon, \"/machine/peripheral\", &paths);\n    if (n < 0)\n        return -1;\n\n    if (VIR_ALLOC_N(*aliases, n + 1) < 0)\n        goto cleanup;\n\n    alias = *aliases;\n    for (i = 0; i < n; i++) {\n        if (STRPREFIX(paths[i]->type, \"child<\")) {\n            *alias = paths[i]->name;\n            paths[i]->name = NULL;\n            alias++;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    for (i = 0; i < n; i++)\n        qemuMonitorJSONListPathFree(paths[i]);\n    VIR_FREE(paths);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"aliases=%p\"",
            "aliases"
          ],
          "line": 3940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetDeviceAliases(qemuMonitorPtr mon,\n                            char ***aliases)\n{\n    VIR_DEBUG(\"aliases=%p\", aliases);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetDeviceAliases(mon, aliases);\n}"
  },
  {
    "function_name": "qemuMonitorDetachCharDev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3924-3933",
    "snippet": "int\nqemuMonitorDetachCharDev(qemuMonitorPtr mon,\n                         const char *chrID)\n{\n    VIR_DEBUG(\"chrID=%s\", chrID);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONDetachCharDev(mon, chrID);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONDetachCharDev",
          "args": [
            "mon",
            "chrID"
          ],
          "line": 3932
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONDetachCharDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "7561-7585",
          "snippet": "int\nqemuMonitorJSONDetachCharDev(qemuMonitorPtr mon,\n                             const char *chrID)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"chardev-remove\",\n                                           \"s:id\", chrID,\n                                           NULL)))\n        return ret;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONDetachCharDev(qemuMonitorPtr mon,\n                             const char *chrID)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"chardev-remove\",\n                                           \"s:id\", chrID,\n                                           NULL)))\n        return ret;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"chrID=%s\"",
            "chrID"
          ],
          "line": 3928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorDetachCharDev(qemuMonitorPtr mon,\n                         const char *chrID)\n{\n    VIR_DEBUG(\"chrID=%s\", chrID);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONDetachCharDev(mon, chrID);\n}"
  },
  {
    "function_name": "qemuMonitorAttachCharDev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3911-3921",
    "snippet": "int\nqemuMonitorAttachCharDev(qemuMonitorPtr mon,\n                         const char *chrID,\n                         virDomainChrSourceDefPtr chr)\n{\n    VIR_DEBUG(\"chrID=%s chr=%p\", chrID, chr);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONAttachCharDev(mon, chrID, chr);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONAttachCharDev",
          "args": [
            "mon",
            "chrID",
            "chr"
          ],
          "line": 3920
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONAttachCharDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "7517-7559",
          "snippet": "int\nqemuMonitorJSONAttachCharDev(qemuMonitorPtr mon,\n                             const char *chrID,\n                             virDomainChrSourceDefPtr chr)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONAttachCharDevCommand(chrID, chr)))\n        return ret;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (chr->type == VIR_DOMAIN_CHR_TYPE_PTY) {\n        if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n            goto cleanup;\n    } else {\n        if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n            goto cleanup;\n    }\n\n    if (chr->type == VIR_DOMAIN_CHR_TYPE_PTY) {\n        virJSONValuePtr data = virJSONValueObjectGetObject(reply, \"return\");\n        const char *path;\n\n        if (!(path = virJSONValueObjectGetString(data, \"pty\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"chardev-add reply was missing pty path\"));\n            goto cleanup;\n        }\n\n        chr->data.file.path = g_strdup(path);\n    }\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint\nqemuMonitorJSONAttachCharDev(qemuMonitorPtr mon,\n                             const char *chrID,\n                             virDomainChrSourceDefPtr chr)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONAttachCharDevCommand(chrID, chr)))\n        return ret;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (chr->type == VIR_DOMAIN_CHR_TYPE_PTY) {\n        if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n            goto cleanup;\n    } else {\n        if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n            goto cleanup;\n    }\n\n    if (chr->type == VIR_DOMAIN_CHR_TYPE_PTY) {\n        virJSONValuePtr data = virJSONValueObjectGetObject(reply, \"return\");\n        const char *path;\n\n        if (!(path = virJSONValueObjectGetString(data, \"pty\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"chardev-add reply was missing pty path\"));\n            goto cleanup;\n        }\n\n        chr->data.file.path = g_strdup(path);\n    }\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"chrID=%s chr=%p\"",
            "chrID",
            "chr"
          ],
          "line": 3916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorAttachCharDev(qemuMonitorPtr mon,\n                         const char *chrID,\n                         virDomainChrSourceDefPtr chr)\n{\n    VIR_DEBUG(\"chrID=%s chr=%p\", chrID, chr);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONAttachCharDev(mon, chrID, chr);\n}"
  },
  {
    "function_name": "qemuMonitorGetTPMTypes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3899-3908",
    "snippet": "int\nqemuMonitorGetTPMTypes(qemuMonitorPtr mon,\n                       char ***tpmtypes)\n{\n    VIR_DEBUG(\"tpmtypes=%p\", tpmtypes);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetTPMTypes(mon, tpmtypes);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetTPMTypes",
          "args": [
            "mon",
            "tpmtypes"
          ],
          "line": 3907
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetTPMTypes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "7343-7347",
          "snippet": "int qemuMonitorJSONGetTPMTypes(qemuMonitorPtr mon,\n                               char ***tpmtypes)\n{\n    return qemuMonitorJSONGetStringArray(mon, \"query-tpm-types\", tpmtypes);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONGetTPMTypes(qemuMonitorPtr mon,\n                               char ***tpmtypes)\n{\n    return qemuMonitorJSONGetStringArray(mon, \"query-tpm-types\", tpmtypes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"tpmtypes=%p\"",
            "tpmtypes"
          ],
          "line": 3903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetTPMTypes(qemuMonitorPtr mon,\n                       char ***tpmtypes)\n{\n    VIR_DEBUG(\"tpmtypes=%p\", tpmtypes);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetTPMTypes(mon, tpmtypes);\n}"
  },
  {
    "function_name": "qemuMonitorGetTPMModels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3887-3896",
    "snippet": "int\nqemuMonitorGetTPMModels(qemuMonitorPtr mon,\n                            char ***tpmmodels)\n{\n    VIR_DEBUG(\"tpmmodels=%p\", tpmmodels);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetTPMModels(mon, tpmmodels);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetTPMModels",
          "args": [
            "mon",
            "tpmmodels"
          ],
          "line": 3895
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetTPMModels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "7336-7340",
          "snippet": "int qemuMonitorJSONGetTPMModels(qemuMonitorPtr mon,\n                                char ***tpmmodels)\n{\n    return qemuMonitorJSONGetStringArray(mon, \"query-tpm-models\", tpmmodels);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONGetTPMModels(qemuMonitorPtr mon,\n                                char ***tpmmodels)\n{\n    return qemuMonitorJSONGetStringArray(mon, \"query-tpm-models\", tpmmodels);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"tpmmodels=%p\"",
            "tpmmodels"
          ],
          "line": 3891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetTPMModels(qemuMonitorPtr mon,\n                            char ***tpmmodels)\n{\n    VIR_DEBUG(\"tpmmodels=%p\", tpmmodels);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetTPMModels(mon, tpmmodels);\n}"
  },
  {
    "function_name": "qemuMonitorNBDServerStop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3878-3884",
    "snippet": "int\nqemuMonitorNBDServerStop(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerStop(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONNBDServerStop",
          "args": [
            "mon"
          ],
          "line": 3883
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONNBDServerStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "7251-7273",
          "snippet": "int\nqemuMonitorJSONNBDServerStop(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"nbd-server-stop\",\n                                           NULL)))\n        return ret;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONNBDServerStop(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"nbd-server-stop\",\n                                           NULL)))\n        return ret;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorNBDServerStop(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerStop(mon);\n}"
  },
  {
    "function_name": "qemuMonitorNBDServerAdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3861-3875",
    "snippet": "int\nqemuMonitorNBDServerAdd(qemuMonitorPtr mon,\n                        const char *deviceID,\n                        const char *export,\n                        bool writable,\n                        const char *bitmap)\n{\n    VIR_DEBUG(\"deviceID=%s, export=%s, bitmap=%s\", deviceID, NULLSTR(export),\n              NULLSTR(bitmap));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerAdd(mon, deviceID, export, writable,\n                                       bitmap);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONNBDServerAdd",
          "args": [
            "mon",
            "deviceID",
            "export",
            "writable",
            "bitmap"
          ],
          "line": 3873
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONNBDServerAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "7218-7249",
          "snippet": "int\nqemuMonitorJSONNBDServerAdd(qemuMonitorPtr mon,\n                            const char *deviceID,\n                            const char *export,\n                            bool writable,\n                            const char *bitmap)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    /* Note: bitmap must be NULL if QEMU_CAPS_NBD_BITMAP is lacking */\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"nbd-server-add\",\n                                           \"s:device\", deviceID,\n                                           \"S:name\", export,\n                                           \"b:writable\", writable,\n                                           \"S:bitmap\", bitmap,\n                                           NULL)))\n        return ret;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONNBDServerAdd(qemuMonitorPtr mon,\n                            const char *deviceID,\n                            const char *export,\n                            bool writable,\n                            const char *bitmap)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    /* Note: bitmap must be NULL if QEMU_CAPS_NBD_BITMAP is lacking */\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"nbd-server-add\",\n                                           \"s:device\", deviceID,\n                                           \"S:name\", export,\n                                           \"b:writable\", writable,\n                                           \"S:bitmap\", bitmap,\n                                           NULL)))\n        return ret;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"deviceID=%s, export=%s, bitmap=%s\"",
            "deviceID",
            "NULLSTR(export)",
            "NULLSTR(bitmap)"
          ],
          "line": 3868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "bitmap"
          ],
          "line": 3869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "export"
          ],
          "line": 3868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorNBDServerAdd(qemuMonitorPtr mon,\n                        const char *deviceID,\n                        const char *export,\n                        bool writable,\n                        const char *bitmap)\n{\n    VIR_DEBUG(\"deviceID=%s, export=%s, bitmap=%s\", deviceID, NULLSTR(export),\n              NULLSTR(bitmap));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerAdd(mon, deviceID, export, writable,\n                                       bitmap);\n}"
  },
  {
    "function_name": "qemuMonitorNBDServerStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3842-3858",
    "snippet": "int\nqemuMonitorNBDServerStart(qemuMonitorPtr mon,\n                          const virStorageNetHostDef *server,\n                          const char *tls_alias)\n{\n    /* Peek inside the struct for nicer logging */\n    if (server->transport == VIR_STORAGE_NET_HOST_TRANS_TCP)\n        VIR_DEBUG(\"server={tcp host=%s port=%u} tls_alias=%s\",\n                  NULLSTR(server->name), server->port, NULLSTR(tls_alias));\n    else\n        VIR_DEBUG(\"server={unix socket=%s} tls_alias=%s\",\n                  NULLSTR(server->socket), NULLSTR(tls_alias));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerStart(mon, server, tls_alias);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONNBDServerStart",
          "args": [
            "mon",
            "server",
            "tls_alias"
          ],
          "line": 3857
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONNBDServerStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "7168-7216",
          "snippet": "int\nqemuMonitorJSONNBDServerStart(qemuMonitorPtr mon,\n                              const virStorageNetHostDef *server,\n                              const char *tls_alias)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr addr = NULL;\n    char *port_str = NULL;\n\n    switch ((virStorageNetHostTransport)server->transport) {\n    case VIR_STORAGE_NET_HOST_TRANS_TCP:\n        port_str = g_strdup_printf(\"%u\", server->port);\n        addr = qemuMonitorJSONBuildInetSocketAddress(server->name, port_str);\n        break;\n    case VIR_STORAGE_NET_HOST_TRANS_UNIX:\n        addr = qemuMonitorJSONBuildUnixSocketAddress(server->socket);\n        break;\n    case VIR_STORAGE_NET_HOST_TRANS_RDMA:\n    case VIR_STORAGE_NET_HOST_TRANS_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid server address\"));\n        goto cleanup;\n    }\n    if (!addr)\n        goto cleanup;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"nbd-server-start\",\n                                           \"a:addr\", &addr,\n                                           \"S:tls-creds\", tls_alias,\n                                           NULL)))\n        goto cleanup;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(port_str);\n    virJSONValueFree(reply);\n    virJSONValueFree(cmd);\n    virJSONValueFree(addr);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONNBDServerStart(qemuMonitorPtr mon,\n                              const virStorageNetHostDef *server,\n                              const char *tls_alias)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr addr = NULL;\n    char *port_str = NULL;\n\n    switch ((virStorageNetHostTransport)server->transport) {\n    case VIR_STORAGE_NET_HOST_TRANS_TCP:\n        port_str = g_strdup_printf(\"%u\", server->port);\n        addr = qemuMonitorJSONBuildInetSocketAddress(server->name, port_str);\n        break;\n    case VIR_STORAGE_NET_HOST_TRANS_UNIX:\n        addr = qemuMonitorJSONBuildUnixSocketAddress(server->socket);\n        break;\n    case VIR_STORAGE_NET_HOST_TRANS_RDMA:\n    case VIR_STORAGE_NET_HOST_TRANS_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid server address\"));\n        goto cleanup;\n    }\n    if (!addr)\n        goto cleanup;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"nbd-server-start\",\n                                           \"a:addr\", &addr,\n                                           \"S:tls-creds\", tls_alias,\n                                           NULL)))\n        goto cleanup;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(port_str);\n    virJSONValueFree(reply);\n    virJSONValueFree(cmd);\n    virJSONValueFree(addr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"server={unix socket=%s} tls_alias=%s\"",
            "NULLSTR(server->socket)",
            "NULLSTR(tls_alias)"
          ],
          "line": 3852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "tls_alias"
          ],
          "line": 3853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "server->socket"
          ],
          "line": 3853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"server={tcp host=%s port=%u} tls_alias=%s\"",
            "NULLSTR(server->name)",
            "server->port",
            "NULLSTR(tls_alias)"
          ],
          "line": 3849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "tls_alias"
          ],
          "line": 3850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "server->name"
          ],
          "line": 3850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorNBDServerStart(qemuMonitorPtr mon,\n                          const virStorageNetHostDef *server,\n                          const char *tls_alias)\n{\n    /* Peek inside the struct for nicer logging */\n    if (server->transport == VIR_STORAGE_NET_HOST_TRANS_TCP)\n        VIR_DEBUG(\"server={tcp host=%s port=%u} tls_alias=%s\",\n                  NULLSTR(server->name), server->port, NULLSTR(tls_alias));\n    else\n        VIR_DEBUG(\"server={unix socket=%s} tls_alias=%s\",\n                  NULLSTR(server->socket), NULLSTR(tls_alias));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerStart(mon, server, tls_alias);\n}"
  },
  {
    "function_name": "qemuMonitorGetSEVCapabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3832-3839",
    "snippet": "int\nqemuMonitorGetSEVCapabilities(qemuMonitorPtr mon,\n                              virSEVCapability **capabilities)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetSEVCapabilities(mon, capabilities);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetSEVCapabilities",
          "args": [
            "mon",
            "capabilities"
          ],
          "line": 3838
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetSEVCapabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "7049-7128",
          "snippet": "int\nqemuMonitorJSONGetSEVCapabilities(qemuMonitorPtr mon,\n                                  virSEVCapability **capabilities)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr caps;\n    const char *pdh = NULL;\n    const char *cert_chain = NULL;\n    unsigned int cbitpos;\n    unsigned int reduced_phys_bits;\n    g_autoptr(virSEVCapability) capability = NULL;\n\n    *capabilities = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-sev-capabilities\",\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    /* QEMU has only compiled-in support of SEV */\n    if (qemuMonitorJSONHasError(reply, \"GenericError\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    caps = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (virJSONValueObjectGetNumberUint(caps, \"cbitpos\", &cbitpos) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-sev-capabilities reply was missing\"\n                         \" 'cbitpos' field\"));\n        goto cleanup;\n    }\n\n    if (virJSONValueObjectGetNumberUint(caps, \"reduced-phys-bits\",\n                                        &reduced_phys_bits) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-sev-capabilities reply was missing\"\n                         \" 'reduced-phys-bits' field\"));\n        goto cleanup;\n    }\n\n    if (!(pdh = virJSONValueObjectGetString(caps, \"pdh\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-sev-capabilities reply was missing\"\n                         \" 'pdh' field\"));\n        goto cleanup;\n    }\n\n    if (!(cert_chain = virJSONValueObjectGetString(caps, \"cert-chain\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-sev-capabilities reply was missing\"\n                         \" 'cert-chain' field\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC(capability) < 0)\n        goto cleanup;\n\n    capability->pdh = g_strdup(pdh);\n\n    capability->cert_chain = g_strdup(cert_chain);\n\n    capability->cbitpos = cbitpos;\n    capability->reduced_phys_bits = reduced_phys_bits;\n    *capabilities = g_steal_pointer(&capability);\n    ret = 1;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONGetSEVCapabilities(qemuMonitorPtr mon,\n                                  virSEVCapability **capabilities)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr caps;\n    const char *pdh = NULL;\n    const char *cert_chain = NULL;\n    unsigned int cbitpos;\n    unsigned int reduced_phys_bits;\n    g_autoptr(virSEVCapability) capability = NULL;\n\n    *capabilities = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-sev-capabilities\",\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    /* QEMU has only compiled-in support of SEV */\n    if (qemuMonitorJSONHasError(reply, \"GenericError\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    caps = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (virJSONValueObjectGetNumberUint(caps, \"cbitpos\", &cbitpos) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-sev-capabilities reply was missing\"\n                         \" 'cbitpos' field\"));\n        goto cleanup;\n    }\n\n    if (virJSONValueObjectGetNumberUint(caps, \"reduced-phys-bits\",\n                                        &reduced_phys_bits) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-sev-capabilities reply was missing\"\n                         \" 'reduced-phys-bits' field\"));\n        goto cleanup;\n    }\n\n    if (!(pdh = virJSONValueObjectGetString(caps, \"pdh\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-sev-capabilities reply was missing\"\n                         \" 'pdh' field\"));\n        goto cleanup;\n    }\n\n    if (!(cert_chain = virJSONValueObjectGetString(caps, \"cert-chain\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-sev-capabilities reply was missing\"\n                         \" 'cert-chain' field\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC(capability) < 0)\n        goto cleanup;\n\n    capability->pdh = g_strdup(pdh);\n\n    capability->cert_chain = g_strdup(cert_chain);\n\n    capability->cbitpos = cbitpos;\n    capability->reduced_phys_bits = reduced_phys_bits;\n    *capabilities = g_steal_pointer(&capability);\n    ret = 1;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetSEVCapabilities(qemuMonitorPtr mon,\n                              virSEVCapability **capabilities)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetSEVCapabilities(mon, capabilities);\n}"
  },
  {
    "function_name": "qemuMonitorGetGICCapabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3822-3829",
    "snippet": "int\nqemuMonitorGetGICCapabilities(qemuMonitorPtr mon,\n                              virGICCapability **capabilities)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetGICCapabilities(mon, capabilities);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetGICCapabilities",
          "args": [
            "mon",
            "capabilities"
          ],
          "line": 3828
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetGICCapabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "6941-7032",
          "snippet": "int\nqemuMonitorJSONGetGICCapabilities(qemuMonitorPtr mon,\n                                  virGICCapability **capabilities)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr caps;\n    virGICCapability *list = NULL;\n    size_t i;\n    size_t n;\n\n    *capabilities = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-gic-capabilities\",\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    /* If the 'query-gic-capabilities' QMP command was not available\n     * we simply successfully return zero capabilities.\n     * This is the case for QEMU <2.6 and all non-ARM architectures */\n    if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    caps = virJSONValueObjectGetArray(reply, \"return\");\n    n = virJSONValueArraySize(caps);\n\n    /* If the returned array was empty we have to return successfully */\n    if (n == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(list, n) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr cap = virJSONValueArrayGet(caps, i);\n        int version;\n        bool kernel;\n        bool emulated;\n\n        if (!cap || virJSONValueGetType(cap) != VIR_JSON_TYPE_OBJECT) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing entry in GIC capabilities list\"));\n            goto cleanup;\n        }\n\n        if (virJSONValueObjectGetNumberInt(cap, \"version\", &version) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing GIC version\"));\n            goto cleanup;\n        }\n\n        if (virJSONValueObjectGetBoolean(cap, \"kernel\", &kernel) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing in-kernel GIC information\"));\n            goto cleanup;\n        }\n\n        if (virJSONValueObjectGetBoolean(cap, \"emulated\", &emulated) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing emulated GIC information\"));\n            goto cleanup;\n        }\n\n        list[i].version = version;\n        if (kernel)\n            list[i].implementation |= VIR_GIC_IMPLEMENTATION_KERNEL;\n        if (emulated)\n            list[i].implementation |= VIR_GIC_IMPLEMENTATION_EMULATED;\n    }\n\n    ret = n;\n    *capabilities = list;\n    list = NULL;\n\n cleanup:\n    VIR_FREE(list);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONGetGICCapabilities(qemuMonitorPtr mon,\n                                  virGICCapability **capabilities)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr caps;\n    virGICCapability *list = NULL;\n    size_t i;\n    size_t n;\n\n    *capabilities = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-gic-capabilities\",\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    /* If the 'query-gic-capabilities' QMP command was not available\n     * we simply successfully return zero capabilities.\n     * This is the case for QEMU <2.6 and all non-ARM architectures */\n    if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    caps = virJSONValueObjectGetArray(reply, \"return\");\n    n = virJSONValueArraySize(caps);\n\n    /* If the returned array was empty we have to return successfully */\n    if (n == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(list, n) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr cap = virJSONValueArrayGet(caps, i);\n        int version;\n        bool kernel;\n        bool emulated;\n\n        if (!cap || virJSONValueGetType(cap) != VIR_JSON_TYPE_OBJECT) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing entry in GIC capabilities list\"));\n            goto cleanup;\n        }\n\n        if (virJSONValueObjectGetNumberInt(cap, \"version\", &version) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing GIC version\"));\n            goto cleanup;\n        }\n\n        if (virJSONValueObjectGetBoolean(cap, \"kernel\", &kernel) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing in-kernel GIC information\"));\n            goto cleanup;\n        }\n\n        if (virJSONValueObjectGetBoolean(cap, \"emulated\", &emulated) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing emulated GIC information\"));\n            goto cleanup;\n        }\n\n        list[i].version = version;\n        if (kernel)\n            list[i].implementation |= VIR_GIC_IMPLEMENTATION_KERNEL;\n        if (emulated)\n            list[i].implementation |= VIR_GIC_IMPLEMENTATION_EMULATED;\n    }\n\n    ret = n;\n    *capabilities = list;\n    list = NULL;\n\n cleanup:\n    VIR_FREE(list);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetGICCapabilities(qemuMonitorPtr mon,\n                              virGICCapability **capabilities)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetGICCapabilities(mon, capabilities);\n}"
  },
  {
    "function_name": "qemuMonitorSetMigrationCapabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3801-3812",
    "snippet": "int\nqemuMonitorSetMigrationCapabilities(qemuMonitorPtr mon,\n                                    virJSONValuePtr caps)\n{\n    QEMU_CHECK_MONITOR_GOTO(mon, error);\n\n    return qemuMonitorJSONSetMigrationCapabilities(mon, caps);\n\n error:\n    virJSONValueFree(caps);\n    return -1;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueFree",
          "args": [
            "caps"
          ],
          "line": 3810
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "391-423",
          "snippet": "void\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvoid\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONSetMigrationCapabilities",
          "args": [
            "mon",
            "caps"
          ],
          "line": 3807
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSetMigrationCapabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "6897-6923",
          "snippet": "int\nqemuMonitorJSONSetMigrationCapabilities(qemuMonitorPtr mon,\n                                        virJSONValuePtr caps)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"migrate-set-capabilities\",\n                                     \"a:capabilities\", &caps,\n                                     NULL);\n    if (!cmd)\n        goto cleanup;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(caps);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONSetMigrationCapabilities(qemuMonitorPtr mon,\n                                        virJSONValuePtr caps)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"migrate-set-capabilities\",\n                                     \"a:capabilities\", &caps,\n                                     NULL);\n    if (!cmd)\n        goto cleanup;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(caps);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR_GOTO",
          "args": [
            "mon",
            "error"
          ],
          "line": 3805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSetMigrationCapabilities(qemuMonitorPtr mon,\n                                    virJSONValuePtr caps)\n{\n    QEMU_CHECK_MONITOR_GOTO(mon, error);\n\n    return qemuMonitorJSONSetMigrationCapabilities(mon, caps);\n\n error:\n    virJSONValueFree(caps);\n    return -1;\n}"
  },
  {
    "function_name": "qemuMonitorGetMigrationCapabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3781-3788",
    "snippet": "int\nqemuMonitorGetMigrationCapabilities(qemuMonitorPtr mon,\n                                    char ***capabilities)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetMigrationCapabilities(mon, capabilities);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetMigrationCapabilities",
          "args": [
            "mon",
            "capabilities"
          ],
          "line": 3787
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetMigrationCapabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "6831-6894",
          "snippet": "int\nqemuMonitorJSONGetMigrationCapabilities(qemuMonitorPtr mon,\n                                        char ***capabilities)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr caps;\n    char **list = NULL;\n    size_t i;\n    size_t n;\n\n    *capabilities = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-migrate-capabilities\",\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    caps = virJSONValueObjectGetArray(reply, \"return\");\n    n = virJSONValueArraySize(caps);\n\n    if (VIR_ALLOC_N(list, n + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr cap = virJSONValueArrayGet(caps, i);\n        const char *name;\n\n        if (!cap || virJSONValueGetType(cap) != VIR_JSON_TYPE_OBJECT) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing entry in migration capabilities list\"));\n            goto cleanup;\n        }\n\n        if (!(name = virJSONValueObjectGetString(cap, \"capability\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing migration capability name\"));\n            goto cleanup;\n        }\n\n        list[i] = g_strdup(name);\n    }\n\n    ret = n;\n    *capabilities = list;\n    list = NULL;\n\n cleanup:\n    virStringListFree(list);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONGetMigrationCapabilities(qemuMonitorPtr mon,\n                                        char ***capabilities)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr caps;\n    char **list = NULL;\n    size_t i;\n    size_t n;\n\n    *capabilities = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-migrate-capabilities\",\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    caps = virJSONValueObjectGetArray(reply, \"return\");\n    n = virJSONValueArraySize(caps);\n\n    if (VIR_ALLOC_N(list, n + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr cap = virJSONValueArrayGet(caps, i);\n        const char *name;\n\n        if (!cap || virJSONValueGetType(cap) != VIR_JSON_TYPE_OBJECT) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing entry in migration capabilities list\"));\n            goto cleanup;\n        }\n\n        if (!(name = virJSONValueObjectGetString(cap, \"capability\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing migration capability name\"));\n            goto cleanup;\n        }\n\n        list[i] = g_strdup(name);\n    }\n\n    ret = n;\n    *capabilities = list;\n    list = NULL;\n\n cleanup:\n    virStringListFree(list);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetMigrationCapabilities(qemuMonitorPtr mon,\n                                    char ***capabilities)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetMigrationCapabilities(mon, capabilities);\n}"
  },
  {
    "function_name": "qemuMonitorGetTargetArch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3772-3778",
    "snippet": "char *\nqemuMonitorGetTargetArch(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    return qemuMonitorJSONGetTargetArch(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetTargetArch",
          "args": [
            "mon"
          ],
          "line": 3777
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetTargetArch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "6796-6828",
          "snippet": "char *\nqemuMonitorJSONGetTargetArch(qemuMonitorPtr mon)\n{\n    char *ret = NULL;\n    const char *arch;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-target\", NULL)))\n        return NULL;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (!(arch = virJSONValueObjectGetString(data, \"arch\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-target reply was missing arch data\"));\n        goto cleanup;\n    }\n\n    ret = g_strdup(arch);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nchar *\nqemuMonitorJSONGetTargetArch(qemuMonitorPtr mon)\n{\n    char *ret = NULL;\n    const char *arch;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-target\", NULL)))\n        return NULL;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (!(arch = virJSONValueObjectGetString(data, \"arch\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-target reply was missing arch data\"));\n        goto cleanup;\n    }\n\n    ret = g_strdup(arch);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR_NULL",
          "args": [
            "mon"
          ],
          "line": 3775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nchar *\nqemuMonitorGetTargetArch(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    return qemuMonitorJSONGetTargetArch(mon);\n}"
  },
  {
    "function_name": "qemuMonitorGetObjectProps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3759-3769",
    "snippet": "int\nqemuMonitorGetObjectProps(qemuMonitorPtr mon,\n                          const char *object,\n                          char ***props)\n{\n    VIR_DEBUG(\"object=%s props=%p\", object, props);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetObjectProps(mon, object, props);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetObjectProps",
          "args": [
            "mon",
            "object",
            "props"
          ],
          "line": 3768
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetObjectProps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "6764-6793",
          "snippet": "int\nqemuMonitorJSONGetObjectProps(qemuMonitorPtr mon,\n                              const char *object,\n                              char ***props)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    *props = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"qom-list-properties\",\n                                           \"s:typename\", object,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"DeviceNotFound\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    ret = qemuMonitorJSONParsePropsList(cmd, reply, NULL, props);\n cleanup:\n    virJSONValueFree(reply);\n    virJSONValueFree(cmd);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONGetObjectProps(qemuMonitorPtr mon,\n                              const char *object,\n                              char ***props)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    *props = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"qom-list-properties\",\n                                           \"s:typename\", object,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"DeviceNotFound\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    ret = qemuMonitorJSONParsePropsList(cmd, reply, NULL, props);\n cleanup:\n    virJSONValueFree(reply);\n    virJSONValueFree(cmd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"object=%s props=%p\"",
            "object",
            "props"
          ],
          "line": 3764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetObjectProps(qemuMonitorPtr mon,\n                          const char *object,\n                          char ***props)\n{\n    VIR_DEBUG(\"object=%s props=%p\", object, props);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetObjectProps(mon, object, props);\n}"
  },
  {
    "function_name": "qemuMonitorGetDeviceProps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3746-3756",
    "snippet": "int\nqemuMonitorGetDeviceProps(qemuMonitorPtr mon,\n                          const char *device,\n                          char ***props)\n{\n    VIR_DEBUG(\"device=%s props=%p\", device, props);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetDeviceProps(mon, device, props);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetDeviceProps",
          "args": [
            "mon",
            "device",
            "props"
          ],
          "line": 3755
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetDeviceProps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "6733-6761",
          "snippet": "int qemuMonitorJSONGetDeviceProps(qemuMonitorPtr mon,\n                                  const char *device,\n                                  char ***props)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    *props = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"device-list-properties\",\n                                           \"s:typename\", device,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"DeviceNotFound\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    ret = qemuMonitorJSONParsePropsList(cmd, reply, NULL, props);\n cleanup:\n    virJSONValueFree(reply);\n    virJSONValueFree(cmd);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONGetDeviceProps(qemuMonitorPtr mon,\n                                  const char *device,\n                                  char ***props)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    *props = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"device-list-properties\",\n                                           \"s:typename\", device,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"DeviceNotFound\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    ret = qemuMonitorJSONParsePropsList(cmd, reply, NULL, props);\n cleanup:\n    virJSONValueFree(reply);\n    virJSONValueFree(cmd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"device=%s props=%p\"",
            "device",
            "props"
          ],
          "line": 3751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetDeviceProps(qemuMonitorPtr mon,\n                          const char *device,\n                          char ***props)\n{\n    VIR_DEBUG(\"device=%s props=%p\", device, props);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetDeviceProps(mon, device, props);\n}"
  },
  {
    "function_name": "qemuMonitorGetObjectTypes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3734-3743",
    "snippet": "int\nqemuMonitorGetObjectTypes(qemuMonitorPtr mon,\n                          char ***types)\n{\n    VIR_DEBUG(\"types=%p\", types);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetObjectTypes(mon, types);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetObjectTypes",
          "args": [
            "mon",
            "types"
          ],
          "line": 3742
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetObjectTypes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "6351-6402",
          "snippet": "int qemuMonitorJSONGetObjectTypes(qemuMonitorPtr mon,\n                                  char ***types)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    char **typelist = NULL;\n    size_t n = 0;\n    size_t i;\n\n    *types = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"qom-list-types\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n    n = virJSONValueArraySize(data);\n\n    /* null-terminated list */\n    if (VIR_ALLOC_N(typelist, n + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(data, i);\n        const char *tmp;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"qom-list-types reply data was missing 'name'\"));\n            goto cleanup;\n        }\n\n        typelist[i] = g_strdup(tmp);\n    }\n\n    ret = n;\n    *types = typelist;\n    typelist = NULL;\n\n cleanup:\n    virStringListFree(typelist);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint qemuMonitorJSONGetObjectTypes(qemuMonitorPtr mon,\n                                  char ***types)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    char **typelist = NULL;\n    size_t n = 0;\n    size_t i;\n\n    *types = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"qom-list-types\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n    n = virJSONValueArraySize(data);\n\n    /* null-terminated list */\n    if (VIR_ALLOC_N(typelist, n + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(data, i);\n        const char *tmp;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"qom-list-types reply data was missing 'name'\"));\n            goto cleanup;\n        }\n\n        typelist[i] = g_strdup(tmp);\n    }\n\n    ret = n;\n    *types = typelist;\n    typelist = NULL;\n\n cleanup:\n    virStringListFree(typelist);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"types=%p\"",
            "types"
          ],
          "line": 3738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetObjectTypes(qemuMonitorPtr mon,\n                          char ***types)\n{\n    VIR_DEBUG(\"types=%p\", types);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetObjectTypes(mon, types);\n}"
  },
  {
    "function_name": "qemuMonitorGetKVMState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3721-3731",
    "snippet": "int\nqemuMonitorGetKVMState(qemuMonitorPtr mon,\n                       bool *enabled,\n                       bool *present)\n{\n    VIR_DEBUG(\"enabled=%p present=%p\", enabled, present);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetKVMState(mon, enabled, present);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetKVMState",
          "args": [
            "mon",
            "enabled",
            "present"
          ],
          "line": 3730
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetKVMState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "6307-6348",
          "snippet": "int qemuMonitorJSONGetKVMState(qemuMonitorPtr mon,\n                               bool *enabled,\n                               bool *present)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data = NULL;\n\n    /* Safe defaults */\n    *enabled = *present = false;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-kvm\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (virJSONValueObjectGetBoolean(data, \"enabled\", enabled) < 0 ||\n        virJSONValueObjectGetBoolean(data, \"present\", present) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-kvm replied unexpected data\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint qemuMonitorJSONGetKVMState(qemuMonitorPtr mon,\n                               bool *enabled,\n                               bool *present)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data = NULL;\n\n    /* Safe defaults */\n    *enabled = *present = false;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-kvm\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (virJSONValueObjectGetBoolean(data, \"enabled\", enabled) < 0 ||\n        virJSONValueObjectGetBoolean(data, \"present\", present) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-kvm replied unexpected data\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"enabled=%p present=%p\"",
            "enabled",
            "present"
          ],
          "line": 3726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetKVMState(qemuMonitorPtr mon,\n                       bool *enabled,\n                       bool *present)\n{\n    VIR_DEBUG(\"enabled=%p present=%p\", enabled, present);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetKVMState(mon, enabled, present);\n}"
  },
  {
    "function_name": "qemuMonitorGetCommandLineOptionParameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3706-3718",
    "snippet": "int\nqemuMonitorGetCommandLineOptionParameters(qemuMonitorPtr mon,\n                                          const char *option,\n                                          char ***params,\n                                          bool *found)\n{\n    VIR_DEBUG(\"option=%s params=%p\", option, params);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCommandLineOptionParameters(mon, option,\n                                                         params, found);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetCommandLineOptionParameters",
          "args": [
            "mon",
            "option",
            "params",
            "found"
          ],
          "line": 3716
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetCommandLineOptionParameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "6186-6304",
          "snippet": "int\nqemuMonitorJSONGetCommandLineOptionParameters(qemuMonitorPtr mon,\n                                              const char *option,\n                                              char ***params,\n                                              bool *found)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data = NULL;\n    virJSONValuePtr array = NULL;\n    char **paramlist = NULL;\n    size_t n = 0;\n    size_t i;\n\n    *params = NULL;\n    if (found)\n        *found = false;\n\n    /* query-command-line-options has fixed output for a given qemu\n     * binary; but since callers want to query parameters for one\n     * option at a time, we cache the option list from qemu.  */\n    if (!(array = qemuMonitorGetOptions(mon))) {\n        if (!(cmd = qemuMonitorJSONMakeCommand(\"query-command-line-options\",\n                                               NULL)))\n            return -1;\n\n        if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n            goto cleanup;\n\n        if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n            ret = 0;\n            goto cleanup;\n        }\n\n        if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n            goto cleanup;\n\n        if (virJSONValueObjectRemoveKey(reply, \"return\", &array) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-command-line-options reply was missing \"\n                             \"return data\"));\n            goto cleanup;\n        }\n\n        if (!virJSONValueIsArray(array)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed query-command-line-options array\"));\n            goto cleanup;\n        }\n\n        qemuMonitorSetOptions(mon, array);\n    }\n\n    for (i = 0; i < virJSONValueArraySize(array); i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(array, i);\n        const char *tmp;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"option\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-command-line-options reply data was \"\n                             \"missing 'option'\"));\n            goto cleanup;\n        }\n        if (STREQ(tmp, option)) {\n            data = virJSONValueObjectGet(child, \"parameters\");\n            break;\n        }\n    }\n\n    if (!data) {\n        /* Option not found; return 0 parameters rather than an error.  */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (found)\n        *found = true;\n\n    if (!virJSONValueIsArray(data)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed query-command-line-options parameters array\"));\n        goto cleanup;\n    }\n    n = virJSONValueArraySize(data);\n\n    /* null-terminated list */\n    if (VIR_ALLOC_N(paramlist, n + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(data, i);\n        const char *tmp;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-command-line-options parameter data was \"\n                             \"missing 'name'\"));\n            goto cleanup;\n        }\n\n        paramlist[i] = g_strdup(tmp);\n    }\n\n    ret = n;\n    *params = paramlist;\n    paramlist = NULL;\n\n cleanup:\n    /* If we failed before getting the JSON array of options, we (try)\n     * to cache an empty array to speed up the next failure.  */\n    if (!qemuMonitorGetOptions(mon))\n        qemuMonitorSetOptions(mon, virJSONValueNewArray());\n\n    virStringListFree(paramlist);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint\nqemuMonitorJSONGetCommandLineOptionParameters(qemuMonitorPtr mon,\n                                              const char *option,\n                                              char ***params,\n                                              bool *found)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data = NULL;\n    virJSONValuePtr array = NULL;\n    char **paramlist = NULL;\n    size_t n = 0;\n    size_t i;\n\n    *params = NULL;\n    if (found)\n        *found = false;\n\n    /* query-command-line-options has fixed output for a given qemu\n     * binary; but since callers want to query parameters for one\n     * option at a time, we cache the option list from qemu.  */\n    if (!(array = qemuMonitorGetOptions(mon))) {\n        if (!(cmd = qemuMonitorJSONMakeCommand(\"query-command-line-options\",\n                                               NULL)))\n            return -1;\n\n        if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n            goto cleanup;\n\n        if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n            ret = 0;\n            goto cleanup;\n        }\n\n        if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n            goto cleanup;\n\n        if (virJSONValueObjectRemoveKey(reply, \"return\", &array) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-command-line-options reply was missing \"\n                             \"return data\"));\n            goto cleanup;\n        }\n\n        if (!virJSONValueIsArray(array)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed query-command-line-options array\"));\n            goto cleanup;\n        }\n\n        qemuMonitorSetOptions(mon, array);\n    }\n\n    for (i = 0; i < virJSONValueArraySize(array); i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(array, i);\n        const char *tmp;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"option\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-command-line-options reply data was \"\n                             \"missing 'option'\"));\n            goto cleanup;\n        }\n        if (STREQ(tmp, option)) {\n            data = virJSONValueObjectGet(child, \"parameters\");\n            break;\n        }\n    }\n\n    if (!data) {\n        /* Option not found; return 0 parameters rather than an error.  */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (found)\n        *found = true;\n\n    if (!virJSONValueIsArray(data)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed query-command-line-options parameters array\"));\n        goto cleanup;\n    }\n    n = virJSONValueArraySize(data);\n\n    /* null-terminated list */\n    if (VIR_ALLOC_N(paramlist, n + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(data, i);\n        const char *tmp;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-command-line-options parameter data was \"\n                             \"missing 'name'\"));\n            goto cleanup;\n        }\n\n        paramlist[i] = g_strdup(tmp);\n    }\n\n    ret = n;\n    *params = paramlist;\n    paramlist = NULL;\n\n cleanup:\n    /* If we failed before getting the JSON array of options, we (try)\n     * to cache an empty array to speed up the next failure.  */\n    if (!qemuMonitorGetOptions(mon))\n        qemuMonitorSetOptions(mon, virJSONValueNewArray());\n\n    virStringListFree(paramlist);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"option=%s params=%p\"",
            "option",
            "params"
          ],
          "line": 3712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetCommandLineOptionParameters(qemuMonitorPtr mon,\n                                          const char *option,\n                                          char ***params,\n                                          bool *found)\n{\n    VIR_DEBUG(\"option=%s params=%p\", option, params);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCommandLineOptionParameters(mon, option,\n                                                         params, found);\n}"
  },
  {
    "function_name": "qemuMonitorGetEvents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3692-3701",
    "snippet": "int\nqemuMonitorGetEvents(qemuMonitorPtr mon,\n                     char ***events)\n{\n    VIR_DEBUG(\"events=%p\", events);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetEvents(mon, events);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetEvents",
          "args": [
            "mon",
            "events"
          ],
          "line": 3700
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetEvents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "6127-6183",
          "snippet": "int qemuMonitorJSONGetEvents(qemuMonitorPtr mon,\n                             char ***events)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    char **eventlist = NULL;\n    size_t n = 0;\n    size_t i;\n\n    *events = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-events\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n    n = virJSONValueArraySize(data);\n\n    /* null-terminated list */\n    if (VIR_ALLOC_N(eventlist, n + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(data, i);\n        const char *tmp;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-events reply data was missing 'name'\"));\n            goto cleanup;\n        }\n\n        eventlist[i] = g_strdup(tmp);\n    }\n\n    ret = n;\n    *events = eventlist;\n    eventlist = NULL;\n\n cleanup:\n    virStringListFree(eventlist);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint qemuMonitorJSONGetEvents(qemuMonitorPtr mon,\n                             char ***events)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    char **eventlist = NULL;\n    size_t n = 0;\n    size_t i;\n\n    *events = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-events\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n    n = virJSONValueArraySize(data);\n\n    /* null-terminated list */\n    if (VIR_ALLOC_N(eventlist, n + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(data, i);\n        const char *tmp;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-events reply data was missing 'name'\"));\n            goto cleanup;\n        }\n\n        eventlist[i] = g_strdup(tmp);\n    }\n\n    ret = n;\n    *events = eventlist;\n    eventlist = NULL;\n\n cleanup:\n    virStringListFree(eventlist);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"events=%p\"",
            "events"
          ],
          "line": 3696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetEvents(qemuMonitorPtr mon,\n                     char ***events)\n{\n    VIR_DEBUG(\"events=%p\", events);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetEvents(mon, events);\n}"
  },
  {
    "function_name": "qemuMonitorGetCommands",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3680-3689",
    "snippet": "int\nqemuMonitorGetCommands(qemuMonitorPtr mon,\n                       char ***commands)\n{\n    VIR_DEBUG(\"commands=%p\", commands);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCommands(mon, commands);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetCommands",
          "args": [
            "mon",
            "commands"
          ],
          "line": 3688
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetCommands",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "6072-6124",
          "snippet": "int qemuMonitorJSONGetCommands(qemuMonitorPtr mon,\n                               char ***commands)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    char **commandlist = NULL;\n    size_t n = 0;\n    size_t i;\n\n    *commands = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-commands\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n    n = virJSONValueArraySize(data);\n\n    /* null-terminated list */\n    if (VIR_ALLOC_N(commandlist, n + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(data, i);\n        const char *tmp;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-commands reply data was missing 'name'\"));\n            goto cleanup;\n        }\n\n        commandlist[i] = g_strdup(tmp);\n    }\n\n    ret = n;\n    *commands = commandlist;\n    commandlist = NULL;\n\n\n cleanup:\n    virStringListFree(commandlist);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint qemuMonitorJSONGetCommands(qemuMonitorPtr mon,\n                               char ***commands)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    char **commandlist = NULL;\n    size_t n = 0;\n    size_t i;\n\n    *commands = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-commands\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n    n = virJSONValueArraySize(data);\n\n    /* null-terminated list */\n    if (VIR_ALLOC_N(commandlist, n + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(data, i);\n        const char *tmp;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-commands reply data was missing 'name'\"));\n            goto cleanup;\n        }\n\n        commandlist[i] = g_strdup(tmp);\n    }\n\n    ret = n;\n    *commands = commandlist;\n    commandlist = NULL;\n\n\n cleanup:\n    virStringListFree(commandlist);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"commands=%p\"",
            "commands"
          ],
          "line": 3684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetCommands(qemuMonitorPtr mon,\n                       char ***commands)\n{\n    VIR_DEBUG(\"commands=%p\", commands);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCommands(mon, commands);\n}"
  },
  {
    "function_name": "qemuMonitorCPUModelInfoCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3632-3677",
    "snippet": "qemuMonitorCPUModelInfoPtr\nqemuMonitorCPUModelInfoCopy(const qemuMonitorCPUModelInfo *orig)\n{\n    qemuMonitorCPUModelInfoPtr copy;\n    size_t i;\n\n    if (VIR_ALLOC(copy) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(copy->props, orig->nprops) < 0)\n        goto error;\n\n    copy->name = g_strdup(orig->name);\n\n    copy->migratability = orig->migratability;\n    copy->nprops = orig->nprops;\n\n    for (i = 0; i < orig->nprops; i++) {\n        copy->props[i].name = g_strdup(orig->props[i].name);\n\n        copy->props[i].migratable = orig->props[i].migratable;\n        copy->props[i].type = orig->props[i].type;\n        switch (orig->props[i].type) {\n        case QEMU_MONITOR_CPU_PROPERTY_BOOLEAN:\n            copy->props[i].value.boolean = orig->props[i].value.boolean;\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_STRING:\n            copy->props[i].value.string = g_strdup(orig->props[i].value.string);\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_NUMBER:\n            copy->props[i].value.number = orig->props[i].value.number;\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_LAST:\n            break;\n        }\n    }\n\n    return copy;\n\n error:\n    qemuMonitorCPUModelInfoFree(copy);\n    return NULL;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorCPUModelInfoFree",
          "args": [
            "copy"
          ],
          "line": 3675
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCPUModelInfoFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3612-3629",
          "snippet": "void\nqemuMonitorCPUModelInfoFree(qemuMonitorCPUModelInfoPtr model_info)\n{\n    size_t i;\n\n    if (!model_info)\n        return;\n\n    for (i = 0; i < model_info->nprops; i++) {\n        VIR_FREE(model_info->props[i].name);\n        if (model_info->props[i].type == QEMU_MONITOR_CPU_PROPERTY_STRING)\n            VIR_FREE(model_info->props[i].value.string);\n    }\n\n    VIR_FREE(model_info->props);\n    VIR_FREE(model_info->name);\n    VIR_FREE(model_info);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorCPUModelInfoFree(qemuMonitorCPUModelInfoPtr model_info)\n{\n    size_t i;\n\n    if (!model_info)\n        return;\n\n    for (i = 0; i < model_info->nprops; i++) {\n        VIR_FREE(model_info->props[i].name);\n        if (model_info->props[i].type == QEMU_MONITOR_CPU_PROPERTY_STRING)\n            VIR_FREE(model_info->props[i].value.string);\n    }\n\n    VIR_FREE(model_info->props);\n    VIR_FREE(model_info->name);\n    VIR_FREE(model_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "orig->props[i].value.string"
          ],
          "line": 3660
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "copy->props",
            "orig->nprops"
          ],
          "line": 3641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "copy"
          ],
          "line": 3638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nqemuMonitorCPUModelInfoPtr\nqemuMonitorCPUModelInfoCopy(const qemuMonitorCPUModelInfo *orig)\n{\n    qemuMonitorCPUModelInfoPtr copy;\n    size_t i;\n\n    if (VIR_ALLOC(copy) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(copy->props, orig->nprops) < 0)\n        goto error;\n\n    copy->name = g_strdup(orig->name);\n\n    copy->migratability = orig->migratability;\n    copy->nprops = orig->nprops;\n\n    for (i = 0; i < orig->nprops; i++) {\n        copy->props[i].name = g_strdup(orig->props[i].name);\n\n        copy->props[i].migratable = orig->props[i].migratable;\n        copy->props[i].type = orig->props[i].type;\n        switch (orig->props[i].type) {\n        case QEMU_MONITOR_CPU_PROPERTY_BOOLEAN:\n            copy->props[i].value.boolean = orig->props[i].value.boolean;\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_STRING:\n            copy->props[i].value.string = g_strdup(orig->props[i].value.string);\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_NUMBER:\n            copy->props[i].value.number = orig->props[i].value.number;\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_LAST:\n            break;\n        }\n    }\n\n    return copy;\n\n error:\n    qemuMonitorCPUModelInfoFree(copy);\n    return NULL;\n}"
  },
  {
    "function_name": "qemuMonitorCPUModelInfoFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3612-3629",
    "snippet": "void\nqemuMonitorCPUModelInfoFree(qemuMonitorCPUModelInfoPtr model_info)\n{\n    size_t i;\n\n    if (!model_info)\n        return;\n\n    for (i = 0; i < model_info->nprops; i++) {\n        VIR_FREE(model_info->props[i].name);\n        if (model_info->props[i].type == QEMU_MONITOR_CPU_PROPERTY_STRING)\n            VIR_FREE(model_info->props[i].value.string);\n    }\n\n    VIR_FREE(model_info->props);\n    VIR_FREE(model_info->name);\n    VIR_FREE(model_info);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "model_info"
          ],
          "line": 3628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "model_info->name"
          ],
          "line": 3627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "model_info->props"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "model_info->props[i].value.string"
          ],
          "line": 3623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "model_info->props[i].name"
          ],
          "line": 3621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorCPUModelInfoFree(qemuMonitorCPUModelInfoPtr model_info)\n{\n    size_t i;\n\n    if (!model_info)\n        return;\n\n    for (i = 0; i < model_info->nprops; i++) {\n        VIR_FREE(model_info->props[i].name);\n        if (model_info->props[i].type == QEMU_MONITOR_CPU_PROPERTY_STRING)\n            VIR_FREE(model_info->props[i].value.string);\n    }\n\n    VIR_FREE(model_info->props);\n    VIR_FREE(model_info->name);\n    VIR_FREE(model_info);\n}"
  },
  {
    "function_name": "qemuMonitorGetCPUModelComparison",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3598-3609",
    "snippet": "int\nqemuMonitorGetCPUModelComparison(qemuMonitorPtr mon,\n                                 virCPUDefPtr cpu_a,\n                                 virCPUDefPtr cpu_b,\n                                 char **result)\n{\n    VIR_DEBUG(\"cpu_a=%p cpu_b=%p\", cpu_a, cpu_b);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCPUModelComparison(mon, cpu_a, cpu_b, result);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetCPUModelComparison",
          "args": [
            "mon",
            "cpu_a",
            "cpu_b",
            "result"
          ],
          "line": 3608
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetCPUModelComparison",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "6029-6069",
          "snippet": "int\nqemuMonitorJSONGetCPUModelComparison(qemuMonitorPtr mon,\n                                     virCPUDefPtr cpu_a,\n                                     virCPUDefPtr cpu_b,\n                                     char **result)\n{\n    g_autoptr(virJSONValue) model_a = NULL;\n    g_autoptr(virJSONValue) model_b = NULL;\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n    const char *data_result;\n    virJSONValuePtr data;\n\n    if (!(model_a = qemuMonitorJSONMakeCPUModel(cpu_a, true)) ||\n        !(model_b = qemuMonitorJSONMakeCPUModel(cpu_b, true)))\n        return -1;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-cpu-model-comparison\",\n                                           \"a:modela\", &model_a,\n                                           \"a:modelb\", &model_b,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        return -1;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (!(data_result = virJSONValueObjectGetString(data, \"result\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-cpu-model-comparison reply data was missing \"\n                         \"'result'\"));\n        return -1;\n    }\n\n    *result = g_strdup(data_result);\n    return 0;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint\nqemuMonitorJSONGetCPUModelComparison(qemuMonitorPtr mon,\n                                     virCPUDefPtr cpu_a,\n                                     virCPUDefPtr cpu_b,\n                                     char **result)\n{\n    g_autoptr(virJSONValue) model_a = NULL;\n    g_autoptr(virJSONValue) model_b = NULL;\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n    const char *data_result;\n    virJSONValuePtr data;\n\n    if (!(model_a = qemuMonitorJSONMakeCPUModel(cpu_a, true)) ||\n        !(model_b = qemuMonitorJSONMakeCPUModel(cpu_b, true)))\n        return -1;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-cpu-model-comparison\",\n                                           \"a:modela\", &model_a,\n                                           \"a:modelb\", &model_b,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        return -1;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (!(data_result = virJSONValueObjectGetString(data, \"result\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-cpu-model-comparison reply data was missing \"\n                         \"'result'\"));\n        return -1;\n    }\n\n    *result = g_strdup(data_result);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cpu_a=%p cpu_b=%p\"",
            "cpu_a",
            "cpu_b"
          ],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetCPUModelComparison(qemuMonitorPtr mon,\n                                 virCPUDefPtr cpu_a,\n                                 virCPUDefPtr cpu_b,\n                                 char **result)\n{\n    VIR_DEBUG(\"cpu_a=%p cpu_b=%p\", cpu_a, cpu_b);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCPUModelComparison(mon, cpu_a, cpu_b, result);\n}"
  },
  {
    "function_name": "qemuMonitorGetCPUModelBaseline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3584-3595",
    "snippet": "int\nqemuMonitorGetCPUModelBaseline(qemuMonitorPtr mon,\n                               virCPUDefPtr cpu_a,\n                               virCPUDefPtr cpu_b,\n                               qemuMonitorCPUModelInfoPtr *baseline)\n{\n    VIR_DEBUG(\"cpu_a=%p cpu_b=%p\", cpu_a, cpu_b);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCPUModelBaseline(mon, cpu_a, cpu_b, baseline);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetCPUModelBaseline",
          "args": [
            "mon",
            "cpu_a",
            "cpu_b",
            "baseline"
          ],
          "line": 3594
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetCPUModelBaseline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "5987-6026",
          "snippet": "int\nqemuMonitorJSONGetCPUModelBaseline(qemuMonitorPtr mon,\n                                   virCPUDefPtr cpu_a,\n                                   virCPUDefPtr cpu_b,\n                                   qemuMonitorCPUModelInfoPtr *baseline)\n{\n    g_autoptr(virJSONValue) model_a = NULL;\n    g_autoptr(virJSONValue) model_b = NULL;\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n    virJSONValuePtr data;\n    virJSONValuePtr cpu_model;\n    virJSONValuePtr cpu_props = NULL;\n    const char *cpu_name = \"\";\n\n    if (!(model_a = qemuMonitorJSONMakeCPUModel(cpu_a, true)) ||\n        !(model_b = qemuMonitorJSONMakeCPUModel(cpu_b, true)))\n        return -1;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-cpu-model-baseline\",\n                                           \"a:modela\", &model_a,\n                                           \"a:modelb\", &model_b,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        return -1;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (qemuMonitorJSONParseCPUModelData(data, \"query-cpu-model-baseline\",\n                                         false, &cpu_model, &cpu_props,\n                                         &cpu_name) < 0)\n        return -1;\n\n    return qemuMonitorJSONParseCPUModel(cpu_name, cpu_props, baseline);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint\nqemuMonitorJSONGetCPUModelBaseline(qemuMonitorPtr mon,\n                                   virCPUDefPtr cpu_a,\n                                   virCPUDefPtr cpu_b,\n                                   qemuMonitorCPUModelInfoPtr *baseline)\n{\n    g_autoptr(virJSONValue) model_a = NULL;\n    g_autoptr(virJSONValue) model_b = NULL;\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n    virJSONValuePtr data;\n    virJSONValuePtr cpu_model;\n    virJSONValuePtr cpu_props = NULL;\n    const char *cpu_name = \"\";\n\n    if (!(model_a = qemuMonitorJSONMakeCPUModel(cpu_a, true)) ||\n        !(model_b = qemuMonitorJSONMakeCPUModel(cpu_b, true)))\n        return -1;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-cpu-model-baseline\",\n                                           \"a:modela\", &model_a,\n                                           \"a:modelb\", &model_b,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        return -1;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (qemuMonitorJSONParseCPUModelData(data, \"query-cpu-model-baseline\",\n                                         false, &cpu_model, &cpu_props,\n                                         &cpu_name) < 0)\n        return -1;\n\n    return qemuMonitorJSONParseCPUModel(cpu_name, cpu_props, baseline);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cpu_a=%p cpu_b=%p\"",
            "cpu_a",
            "cpu_b"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetCPUModelBaseline(qemuMonitorPtr mon,\n                               virCPUDefPtr cpu_a,\n                               virCPUDefPtr cpu_b,\n                               qemuMonitorCPUModelInfoPtr *baseline)\n{\n    VIR_DEBUG(\"cpu_a=%p cpu_b=%p\", cpu_a, cpu_b);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCPUModelBaseline(mon, cpu_a, cpu_b, baseline);\n}"
  },
  {
    "function_name": "qemuMonitorGetCPUModelExpansion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3566-3581",
    "snippet": "int\nqemuMonitorGetCPUModelExpansion(qemuMonitorPtr mon,\n                                qemuMonitorCPUModelExpansionType type,\n                                virCPUDefPtr cpu,\n                                bool migratable,\n                                bool fail_no_props,\n                                qemuMonitorCPUModelInfoPtr *model_info)\n{\n    VIR_DEBUG(\"type=%d cpu=%p migratable=%d\", type, cpu, migratable);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCPUModelExpansion(mon, type, cpu,\n                                               migratable, fail_no_props,\n                                               model_info);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetCPUModelExpansion",
          "args": [
            "mon",
            "type",
            "cpu",
            "migratable",
            "fail_no_props",
            "model_info"
          ],
          "line": 3578
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetCPUModelExpansion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "5910-5984",
          "snippet": "int\nqemuMonitorJSONGetCPUModelExpansion(qemuMonitorPtr mon,\n                                    qemuMonitorCPUModelExpansionType type,\n                                    virCPUDefPtr cpu,\n                                    bool migratable,\n                                    bool fail_no_props,\n                                    qemuMonitorCPUModelInfoPtr *model_info)\n{\n    g_autoptr(virJSONValue) model = NULL;\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n    virJSONValuePtr data;\n    virJSONValuePtr cpu_model;\n    virJSONValuePtr cpu_props = NULL;\n    const char *cpu_name = \"\";\n    const char *typeStr = \"\";\n\n    *model_info = NULL;\n\n    if (!(model = qemuMonitorJSONMakeCPUModel(cpu, migratable)))\n        return -1;\n\n retry:\n    switch (type) {\n    case QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC:\n    case QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC_FULL:\n        typeStr = \"static\";\n        break;\n\n    case QEMU_MONITOR_CPU_MODEL_EXPANSION_FULL:\n        typeStr = \"full\";\n        break;\n    }\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-cpu-model-expansion\",\n                                           \"s:type\", typeStr,\n                                           \"a:model\", &model,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    /* Even though query-cpu-model-expansion is advertised by query-commands it\n     * may just return GenericError if it is not implemented for the requested\n     * guest architecture or it is not supported in the host environment.\n     */\n    if (qemuMonitorJSONHasError(reply, \"GenericError\"))\n        return 0;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        return -1;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (qemuMonitorJSONParseCPUModelData(data, \"query-cpu-model-expansion\",\n                                         fail_no_props, &cpu_model, &cpu_props,\n                                         &cpu_name) < 0)\n        return -1;\n\n    /* QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC_FULL requests \"full\" expansion\n     * on the result of the initial \"static\" expansion.\n     */\n    if (type == QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC_FULL) {\n        if (!(model = virJSONValueCopy(cpu_model)))\n            return -1;\n\n        virJSONValueFree(cmd);\n        virJSONValueFree(reply);\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_FULL;\n        goto retry;\n    }\n\n    return qemuMonitorJSONParseCPUModel(cpu_name, cpu_props, model_info);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint\nqemuMonitorJSONGetCPUModelExpansion(qemuMonitorPtr mon,\n                                    qemuMonitorCPUModelExpansionType type,\n                                    virCPUDefPtr cpu,\n                                    bool migratable,\n                                    bool fail_no_props,\n                                    qemuMonitorCPUModelInfoPtr *model_info)\n{\n    g_autoptr(virJSONValue) model = NULL;\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n    virJSONValuePtr data;\n    virJSONValuePtr cpu_model;\n    virJSONValuePtr cpu_props = NULL;\n    const char *cpu_name = \"\";\n    const char *typeStr = \"\";\n\n    *model_info = NULL;\n\n    if (!(model = qemuMonitorJSONMakeCPUModel(cpu, migratable)))\n        return -1;\n\n retry:\n    switch (type) {\n    case QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC:\n    case QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC_FULL:\n        typeStr = \"static\";\n        break;\n\n    case QEMU_MONITOR_CPU_MODEL_EXPANSION_FULL:\n        typeStr = \"full\";\n        break;\n    }\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-cpu-model-expansion\",\n                                           \"s:type\", typeStr,\n                                           \"a:model\", &model,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    /* Even though query-cpu-model-expansion is advertised by query-commands it\n     * may just return GenericError if it is not implemented for the requested\n     * guest architecture or it is not supported in the host environment.\n     */\n    if (qemuMonitorJSONHasError(reply, \"GenericError\"))\n        return 0;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        return -1;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (qemuMonitorJSONParseCPUModelData(data, \"query-cpu-model-expansion\",\n                                         fail_no_props, &cpu_model, &cpu_props,\n                                         &cpu_name) < 0)\n        return -1;\n\n    /* QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC_FULL requests \"full\" expansion\n     * on the result of the initial \"static\" expansion.\n     */\n    if (type == QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC_FULL) {\n        if (!(model = virJSONValueCopy(cpu_model)))\n            return -1;\n\n        virJSONValueFree(cmd);\n        virJSONValueFree(reply);\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_FULL;\n        goto retry;\n    }\n\n    return qemuMonitorJSONParseCPUModel(cpu_name, cpu_props, model_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"type=%d cpu=%p migratable=%d\"",
            "type",
            "cpu",
            "migratable"
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetCPUModelExpansion(qemuMonitorPtr mon,\n                                qemuMonitorCPUModelExpansionType type,\n                                virCPUDefPtr cpu,\n                                bool migratable,\n                                bool fail_no_props,\n                                qemuMonitorCPUModelInfoPtr *model_info)\n{\n    VIR_DEBUG(\"type=%d cpu=%p migratable=%d\", type, cpu, migratable);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCPUModelExpansion(mon, type, cpu,\n                                               migratable, fail_no_props,\n                                               model_info);\n}"
  },
  {
    "function_name": "qemuMonitorCPUDefsCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3542-3563",
    "snippet": "qemuMonitorCPUDefsPtr\nqemuMonitorCPUDefsCopy(qemuMonitorCPUDefsPtr src)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n    size_t i;\n\n    if (!src)\n        return NULL;\n\n    defs = qemuMonitorCPUDefsNew(src->ncpus);\n    for (i = 0; i < src->ncpus; i++) {\n        qemuMonitorCPUDefInfoPtr cpuDst = defs->cpus + i;\n        qemuMonitorCPUDefInfoPtr cpuSrc = src->cpus + i;\n\n        cpuDst->usable = cpuSrc->usable;\n        cpuDst->name = g_strdup(cpuSrc->name);\n        cpuDst->type = g_strdup(cpuSrc->type);\n        cpuDst->blockers = g_strdupv(cpuSrc->blockers);\n    }\n\n    return g_steal_pointer(&defs);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&defs"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdupv",
          "args": [
            "cpuSrc->blockers"
          ],
          "line": 3559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "cpuSrc->type"
          ],
          "line": 3558
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorCPUDefsNew",
          "args": [
            "src->ncpus"
          ],
          "line": 3551
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCPUDefsNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3529-3539",
          "snippet": "qemuMonitorCPUDefsPtr\nqemuMonitorCPUDefsNew(size_t count)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n\n    defs = g_new0(qemuMonitorCPUDefs, 1);\n    defs->cpus = g_new0(qemuMonitorCPUDefInfo, count);\n    defs->ncpus = count;\n\n    return g_steal_pointer(&defs);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nqemuMonitorCPUDefsPtr\nqemuMonitorCPUDefsNew(size_t count)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n\n    defs = g_new0(qemuMonitorCPUDefs, 1);\n    defs->cpus = g_new0(qemuMonitorCPUDefInfo, count);\n    defs->ncpus = count;\n\n    return g_steal_pointer(&defs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nqemuMonitorCPUDefsPtr\nqemuMonitorCPUDefsCopy(qemuMonitorCPUDefsPtr src)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n    size_t i;\n\n    if (!src)\n        return NULL;\n\n    defs = qemuMonitorCPUDefsNew(src->ncpus);\n    for (i = 0; i < src->ncpus; i++) {\n        qemuMonitorCPUDefInfoPtr cpuDst = defs->cpus + i;\n        qemuMonitorCPUDefInfoPtr cpuSrc = src->cpus + i;\n\n        cpuDst->usable = cpuSrc->usable;\n        cpuDst->name = g_strdup(cpuSrc->name);\n        cpuDst->type = g_strdup(cpuSrc->type);\n        cpuDst->blockers = g_strdupv(cpuSrc->blockers);\n    }\n\n    return g_steal_pointer(&defs);\n}"
  },
  {
    "function_name": "qemuMonitorCPUDefsNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3529-3539",
    "snippet": "qemuMonitorCPUDefsPtr\nqemuMonitorCPUDefsNew(size_t count)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n\n    defs = g_new0(qemuMonitorCPUDefs, 1);\n    defs->cpus = g_new0(qemuMonitorCPUDefInfo, count);\n    defs->ncpus = count;\n\n    return g_steal_pointer(&defs);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&defs"
          ],
          "line": 3538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "qemuMonitorCPUDefInfo",
            "count"
          ],
          "line": 3535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "qemuMonitorCPUDefs",
            "1"
          ],
          "line": 3534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nqemuMonitorCPUDefsPtr\nqemuMonitorCPUDefsNew(size_t count)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n\n    defs = g_new0(qemuMonitorCPUDefs, 1);\n    defs->cpus = g_new0(qemuMonitorCPUDefInfo, count);\n    defs->ncpus = count;\n\n    return g_steal_pointer(&defs);\n}"
  },
  {
    "function_name": "qemuMonitorCPUDefsFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3510-3526",
    "snippet": "void\nqemuMonitorCPUDefsFree(qemuMonitorCPUDefsPtr defs)\n{\n    size_t i;\n\n    if (!defs)\n        return;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        g_strfreev(defs->cpus[i].blockers);\n        g_free(defs->cpus[i].name);\n        g_free(defs->cpus[i].type);\n    }\n\n    g_free(defs->cpus);\n    g_free(defs);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "defs"
          ],
          "line": 3525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "defs->cpus"
          ],
          "line": 3524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "defs->cpus[i].type"
          ],
          "line": 3521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "defs->cpus[i].name"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strfreev",
          "args": [
            "defs->cpus[i].blockers"
          ],
          "line": 3519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorCPUDefsFree(qemuMonitorCPUDefsPtr defs)\n{\n    size_t i;\n\n    if (!defs)\n        return;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        g_strfreev(defs->cpus[i].blockers);\n        g_free(defs->cpus[i].name);\n        g_free(defs->cpus[i].type);\n    }\n\n    g_free(defs->cpus);\n    g_free(defs);\n}"
  },
  {
    "function_name": "qemuMonitorGetCPUDefinitions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3498-3507",
    "snippet": "int\nqemuMonitorGetCPUDefinitions(qemuMonitorPtr mon,\n                             qemuMonitorCPUDefsPtr *cpuDefs)\n{\n    VIR_DEBUG(\"cpuDefs=%p\", cpuDefs);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCPUDefinitions(mon, cpuDefs);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetCPUDefinitions",
          "args": [
            "mon",
            "cpuDefs"
          ],
          "line": 3506
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetCPUDefinitions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "5657-5750",
          "snippet": "int\nqemuMonitorJSONGetCPUDefinitions(qemuMonitorPtr mon,\n                                 qemuMonitorCPUDefsPtr *cpuDefs)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n    virJSONValuePtr data;\n    size_t ncpus;\n    size_t i;\n\n    *cpuDefs = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-cpu-definitions\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    /* Urgh, some QEMU architectures have the query-cpu-definitions\n     * command, but return 'GenericError' with string \"Not supported\",\n     * instead of simply omitting the command entirely :-(\n     */\n    if (qemuMonitorJSONHasError(reply, \"GenericError\"))\n        return 0;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        return -1;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n    ncpus = virJSONValueArraySize(data);\n\n    if (!(defs = qemuMonitorCPUDefsNew(ncpus)))\n        return -1;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(data, i);\n        const char *tmp;\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + i;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-cpu-definitions reply data was missing 'name'\"));\n            return -1;\n        }\n\n        cpu->name = g_strdup(tmp);\n\n        if ((tmp = virJSONValueObjectGetString(child, \"typename\")) && *tmp)\n            cpu->type = g_strdup(tmp);\n\n        if (virJSONValueObjectHasKey(child, \"unavailable-features\")) {\n            virJSONValuePtr blockers;\n            size_t j;\n            size_t len;\n\n            blockers = virJSONValueObjectGetArray(child,\n                                                  \"unavailable-features\");\n            if (!blockers) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"unavailable-features in query-cpu-definitions \"\n                                 \"reply data was not an array\"));\n                return -1;\n            }\n\n            len = virJSONValueArraySize(blockers);\n\n            if (len == 0) {\n                cpu->usable = VIR_DOMCAPS_CPU_USABLE_YES;\n                continue;\n            }\n\n            cpu->usable = VIR_DOMCAPS_CPU_USABLE_NO;\n            if (VIR_ALLOC_N(cpu->blockers, len + 1) < 0)\n                return -1;\n\n            for (j = 0; j < len; j++) {\n                virJSONValuePtr blocker = virJSONValueArrayGet(blockers, j);\n\n                if (virJSONValueGetType(blocker) != VIR_JSON_TYPE_STRING) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"unexpected value in unavailable-features \"\n                                     \"array\"));\n                    return -1;\n                }\n\n                cpu->blockers[j] = g_strdup(virJSONValueGetString(blocker));\n            }\n        }\n    }\n\n    *cpuDefs = g_steal_pointer(&defs);\n    return 0;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint\nqemuMonitorJSONGetCPUDefinitions(qemuMonitorPtr mon,\n                                 qemuMonitorCPUDefsPtr *cpuDefs)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n    virJSONValuePtr data;\n    size_t ncpus;\n    size_t i;\n\n    *cpuDefs = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-cpu-definitions\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    /* Urgh, some QEMU architectures have the query-cpu-definitions\n     * command, but return 'GenericError' with string \"Not supported\",\n     * instead of simply omitting the command entirely :-(\n     */\n    if (qemuMonitorJSONHasError(reply, \"GenericError\"))\n        return 0;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        return -1;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n    ncpus = virJSONValueArraySize(data);\n\n    if (!(defs = qemuMonitorCPUDefsNew(ncpus)))\n        return -1;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(data, i);\n        const char *tmp;\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + i;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-cpu-definitions reply data was missing 'name'\"));\n            return -1;\n        }\n\n        cpu->name = g_strdup(tmp);\n\n        if ((tmp = virJSONValueObjectGetString(child, \"typename\")) && *tmp)\n            cpu->type = g_strdup(tmp);\n\n        if (virJSONValueObjectHasKey(child, \"unavailable-features\")) {\n            virJSONValuePtr blockers;\n            size_t j;\n            size_t len;\n\n            blockers = virJSONValueObjectGetArray(child,\n                                                  \"unavailable-features\");\n            if (!blockers) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"unavailable-features in query-cpu-definitions \"\n                                 \"reply data was not an array\"));\n                return -1;\n            }\n\n            len = virJSONValueArraySize(blockers);\n\n            if (len == 0) {\n                cpu->usable = VIR_DOMCAPS_CPU_USABLE_YES;\n                continue;\n            }\n\n            cpu->usable = VIR_DOMCAPS_CPU_USABLE_NO;\n            if (VIR_ALLOC_N(cpu->blockers, len + 1) < 0)\n                return -1;\n\n            for (j = 0; j < len; j++) {\n                virJSONValuePtr blocker = virJSONValueArrayGet(blockers, j);\n\n                if (virJSONValueGetType(blocker) != VIR_JSON_TYPE_STRING) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"unexpected value in unavailable-features \"\n                                     \"array\"));\n                    return -1;\n                }\n\n                cpu->blockers[j] = g_strdup(virJSONValueGetString(blocker));\n            }\n        }\n    }\n\n    *cpuDefs = g_steal_pointer(&defs);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cpuDefs=%p\"",
            "cpuDefs"
          ],
          "line": 3502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetCPUDefinitions(qemuMonitorPtr mon,\n                             qemuMonitorCPUDefsPtr *cpuDefs)\n{\n    VIR_DEBUG(\"cpuDefs=%p\", cpuDefs);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCPUDefinitions(mon, cpuDefs);\n}"
  },
  {
    "function_name": "qemuMonitorMachineInfoFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3486-3495",
    "snippet": "void\nqemuMonitorMachineInfoFree(qemuMonitorMachineInfoPtr machine)\n{\n    if (!machine)\n        return;\n    VIR_FREE(machine->name);\n    VIR_FREE(machine->alias);\n    VIR_FREE(machine->defaultCPU);\n    VIR_FREE(machine);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machine"
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machine->defaultCPU"
          ],
          "line": 3493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machine->alias"
          ],
          "line": 3492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machine->name"
          ],
          "line": 3491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorMachineInfoFree(qemuMonitorMachineInfoPtr machine)\n{\n    if (!machine)\n        return;\n    VIR_FREE(machine->name);\n    VIR_FREE(machine->alias);\n    VIR_FREE(machine->defaultCPU);\n    VIR_FREE(machine);\n}"
  },
  {
    "function_name": "qemuMonitorGetMachines",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3474-3483",
    "snippet": "int\nqemuMonitorGetMachines(qemuMonitorPtr mon,\n                       qemuMonitorMachineInfoPtr **machines)\n{\n    VIR_DEBUG(\"machines=%p\", machines);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetMachines(mon, machines);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetMachines",
          "args": [
            "mon",
            "machines"
          ],
          "line": 3482
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetMachines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "5557-5654",
          "snippet": "int qemuMonitorJSONGetMachines(qemuMonitorPtr mon,\n                               qemuMonitorMachineInfoPtr **machines)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    qemuMonitorMachineInfoPtr *infolist = NULL;\n    size_t n = 0;\n    size_t i;\n\n    *machines = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-machines\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n    n = virJSONValueArraySize(data);\n\n    /* null-terminated list */\n    if (VIR_ALLOC_N(infolist, n + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(data, i);\n        const char *tmp;\n        qemuMonitorMachineInfoPtr info;\n\n        if (VIR_ALLOC(info) < 0)\n            goto cleanup;\n\n        infolist[i] = info;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-machines reply data was missing 'name'\"));\n            goto cleanup;\n        }\n\n        info->name = g_strdup(tmp);\n\n        if (virJSONValueObjectHasKey(child, \"is-default\") &&\n            virJSONValueObjectGetBoolean(child, \"is-default\", &info->isDefault) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-machines reply has malformed 'is-default' data\"));\n            goto cleanup;\n        }\n\n        if (virJSONValueObjectHasKey(child, \"alias\")) {\n            if (!(tmp = virJSONValueObjectGetString(child, \"alias\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"query-machines reply has malformed 'alias' data\"));\n                goto cleanup;\n            }\n            info->alias = g_strdup(tmp);\n        }\n        if (virJSONValueObjectHasKey(child, \"cpu-max\") &&\n            virJSONValueObjectGetNumberUint(child, \"cpu-max\", &info->maxCpus) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-machines reply has malformed 'cpu-max' data\"));\n            goto cleanup;\n        }\n\n        ignore_value(virJSONValueObjectGetBoolean(child, \"hotpluggable-cpus\",\n                                                  &info->hotplugCpus));\n\n        if (virJSONValueObjectHasKey(child, \"default-cpu-type\")) {\n            if (!(tmp = virJSONValueObjectGetString(child, \"default-cpu-type\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"query-machines reply has malformed \"\n                                 \"'default-cpu-type' data\"));\n                goto cleanup;\n            }\n\n            info->defaultCPU = g_strdup(tmp);\n        }\n    }\n\n    ret = n;\n    *machines = infolist;\n    infolist = NULL;\n\n cleanup:\n    if (infolist) {\n        for (i = 0; i < n; i++)\n            qemuMonitorMachineInfoFree(infolist[i]);\n        VIR_FREE(infolist);\n    }\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint qemuMonitorJSONGetMachines(qemuMonitorPtr mon,\n                               qemuMonitorMachineInfoPtr **machines)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    qemuMonitorMachineInfoPtr *infolist = NULL;\n    size_t n = 0;\n    size_t i;\n\n    *machines = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-machines\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n    n = virJSONValueArraySize(data);\n\n    /* null-terminated list */\n    if (VIR_ALLOC_N(infolist, n + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(data, i);\n        const char *tmp;\n        qemuMonitorMachineInfoPtr info;\n\n        if (VIR_ALLOC(info) < 0)\n            goto cleanup;\n\n        infolist[i] = info;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-machines reply data was missing 'name'\"));\n            goto cleanup;\n        }\n\n        info->name = g_strdup(tmp);\n\n        if (virJSONValueObjectHasKey(child, \"is-default\") &&\n            virJSONValueObjectGetBoolean(child, \"is-default\", &info->isDefault) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-machines reply has malformed 'is-default' data\"));\n            goto cleanup;\n        }\n\n        if (virJSONValueObjectHasKey(child, \"alias\")) {\n            if (!(tmp = virJSONValueObjectGetString(child, \"alias\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"query-machines reply has malformed 'alias' data\"));\n                goto cleanup;\n            }\n            info->alias = g_strdup(tmp);\n        }\n        if (virJSONValueObjectHasKey(child, \"cpu-max\") &&\n            virJSONValueObjectGetNumberUint(child, \"cpu-max\", &info->maxCpus) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-machines reply has malformed 'cpu-max' data\"));\n            goto cleanup;\n        }\n\n        ignore_value(virJSONValueObjectGetBoolean(child, \"hotpluggable-cpus\",\n                                                  &info->hotplugCpus));\n\n        if (virJSONValueObjectHasKey(child, \"default-cpu-type\")) {\n            if (!(tmp = virJSONValueObjectGetString(child, \"default-cpu-type\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"query-machines reply has malformed \"\n                                 \"'default-cpu-type' data\"));\n                goto cleanup;\n            }\n\n            info->defaultCPU = g_strdup(tmp);\n        }\n    }\n\n    ret = n;\n    *machines = infolist;\n    infolist = NULL;\n\n cleanup:\n    if (infolist) {\n        for (i = 0; i < n; i++)\n            qemuMonitorMachineInfoFree(infolist[i]);\n        VIR_FREE(infolist);\n    }\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"machines=%p\"",
            "machines"
          ],
          "line": 3478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetMachines(qemuMonitorPtr mon,\n                       qemuMonitorMachineInfoPtr **machines)\n{\n    VIR_DEBUG(\"machines=%p\", machines);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetMachines(mon, machines);\n}"
  },
  {
    "function_name": "qemuMonitorGetVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3458-3471",
    "snippet": "int\nqemuMonitorGetVersion(qemuMonitorPtr mon,\n                      int *major,\n                      int *minor,\n                      int *micro,\n                      char **package)\n{\n    VIR_DEBUG(\"major=%p minor=%p micro=%p package=%p\",\n              major, minor, micro, package);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetVersion(mon, major, minor, micro, package);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetVersion",
          "args": [
            "mon",
            "major",
            "minor",
            "micro",
            "package"
          ],
          "line": 3470
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "5489-5554",
          "snippet": "int qemuMonitorJSONGetVersion(qemuMonitorPtr mon,\n                              int *major,\n                              int *minor,\n                              int *micro,\n                              char **package)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    virJSONValuePtr qemu;\n\n    *major = *minor = *micro = 0;\n    if (package)\n        *package = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-version\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (!(qemu = virJSONValueObjectGetObject(data, \"qemu\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-version reply was missing 'qemu' data\"));\n        goto cleanup;\n    }\n\n    if (virJSONValueObjectGetNumberInt(qemu, \"major\", major) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-version reply was missing 'major' version\"));\n        goto cleanup;\n    }\n    if (virJSONValueObjectGetNumberInt(qemu, \"minor\", minor) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-version reply was missing 'minor' version\"));\n        goto cleanup;\n    }\n    if (virJSONValueObjectGetNumberInt(qemu, \"micro\", micro) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-version reply was missing 'micro' version\"));\n        goto cleanup;\n    }\n\n    if (package) {\n        const char *tmp;\n        if (!(tmp = virJSONValueObjectGetString(data, \"package\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-version reply was missing 'package' version\"));\n            goto cleanup;\n        }\n        *package = g_strdup(tmp);\n    }\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint qemuMonitorJSONGetVersion(qemuMonitorPtr mon,\n                              int *major,\n                              int *minor,\n                              int *micro,\n                              char **package)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    virJSONValuePtr qemu;\n\n    *major = *minor = *micro = 0;\n    if (package)\n        *package = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-version\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (!(qemu = virJSONValueObjectGetObject(data, \"qemu\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-version reply was missing 'qemu' data\"));\n        goto cleanup;\n    }\n\n    if (virJSONValueObjectGetNumberInt(qemu, \"major\", major) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-version reply was missing 'major' version\"));\n        goto cleanup;\n    }\n    if (virJSONValueObjectGetNumberInt(qemu, \"minor\", minor) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-version reply was missing 'minor' version\"));\n        goto cleanup;\n    }\n    if (virJSONValueObjectGetNumberInt(qemu, \"micro\", micro) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-version reply was missing 'micro' version\"));\n        goto cleanup;\n    }\n\n    if (package) {\n        const char *tmp;\n        if (!(tmp = virJSONValueObjectGetString(data, \"package\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-version reply was missing 'package' version\"));\n            goto cleanup;\n        }\n        *package = g_strdup(tmp);\n    }\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"major=%p minor=%p micro=%p package=%p\"",
            "major",
            "minor",
            "micro",
            "package"
          ],
          "line": 3465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetVersion(qemuMonitorPtr mon,\n                      int *major,\n                      int *minor,\n                      int *micro,\n                      char **package)\n{\n    VIR_DEBUG(\"major=%p minor=%p micro=%p package=%p\",\n              major, minor, micro, package);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetVersion(mon, major, minor, micro, package);\n}"
  },
  {
    "function_name": "qemuMonitorSystemWakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3449-3455",
    "snippet": "int\nqemuMonitorSystemWakeup(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSystemWakeup(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSystemWakeup",
          "args": [
            "mon"
          ],
          "line": 3454
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSystemWakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "5466-5487",
          "snippet": "int qemuMonitorJSONSystemWakeup(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"system_wakeup\", NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONSystemWakeup(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"system_wakeup\", NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSystemWakeup(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSystemWakeup(mon);\n}"
  },
  {
    "function_name": "qemuMonitorOpenGraphics",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3422-3446",
    "snippet": "int\nqemuMonitorOpenGraphics(qemuMonitorPtr mon,\n                        const char *protocol,\n                        int fd,\n                        const char *fdname,\n                        bool skipauth)\n{\n    VIR_DEBUG(\"protocol=%s fd=%d fdname=%s skipauth=%d\",\n              protocol, fd, NULLSTR(fdname), skipauth);\n    int ret;\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (qemuMonitorSendFileHandle(mon, fdname, fd) < 0)\n        return -1;\n\n    ret = qemuMonitorJSONOpenGraphics(mon, protocol, fdname, skipauth);\n\n    if (ret < 0) {\n        if (qemuMonitorCloseFileHandle(mon, fdname) < 0)\n            VIR_WARN(\"failed to close device handle '%s'\", fdname);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"failed to close device handle '%s'\"",
            "fdname"
          ],
          "line": 3442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorCloseFileHandle",
          "args": [
            "mon",
            "fdname"
          ],
          "line": 3441
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCloseFileHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2626-2644",
          "snippet": "int\nqemuMonitorCloseFileHandle(qemuMonitorPtr mon,\n                           const char *fdname)\n{\n    int ret = -1;\n    virErrorPtr error;\n\n    VIR_DEBUG(\"fdname=%s\", fdname);\n\n    virErrorPreserveLast(&error);\n\n    QEMU_CHECK_MONITOR_GOTO(mon, cleanup);\n\n    ret = qemuMonitorJSONCloseFileHandle(mon, fdname);\n\n cleanup:\n    virErrorRestore(&error);\n    return ret;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorCloseFileHandle(qemuMonitorPtr mon,\n                           const char *fdname)\n{\n    int ret = -1;\n    virErrorPtr error;\n\n    VIR_DEBUG(\"fdname=%s\", fdname);\n\n    virErrorPreserveLast(&error);\n\n    QEMU_CHECK_MONITOR_GOTO(mon, cleanup);\n\n    ret = qemuMonitorJSONCloseFileHandle(mon, fdname);\n\n cleanup:\n    virErrorRestore(&error);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONOpenGraphics",
          "args": [
            "mon",
            "protocol",
            "fdname",
            "skipauth"
          ],
          "line": 3438
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONOpenGraphics",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "5223-5251",
          "snippet": "int qemuMonitorJSONOpenGraphics(qemuMonitorPtr mon,\n                                const char *protocol,\n                                const char *fdname,\n                                bool skipauth)\n{\n    int ret = -1;\n    virJSONValuePtr cmd, reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"add_client\",\n                                     \"s:protocol\", protocol,\n                                     \"s:fdname\", fdname,\n                                     \"b:skipauth\", skipauth,\n                                     NULL);\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONOpenGraphics(qemuMonitorPtr mon,\n                                const char *protocol,\n                                const char *fdname,\n                                bool skipauth)\n{\n    int ret = -1;\n    virJSONValuePtr cmd, reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"add_client\",\n                                     \"s:protocol\", protocol,\n                                     \"s:fdname\", fdname,\n                                     \"b:skipauth\", skipauth,\n                                     NULL);\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorSendFileHandle",
          "args": [
            "mon",
            "fdname",
            "fd"
          ],
          "line": 3435
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorSendFileHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2607-2623",
          "snippet": "int\nqemuMonitorSendFileHandle(qemuMonitorPtr mon,\n                          const char *fdname,\n                          int fd)\n{\n    VIR_DEBUG(\"fdname=%s fd=%d\", fdname, fd);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (fd < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"fd must be valid\"));\n        return -1;\n    }\n\n    return qemuMonitorJSONSendFileHandle(mon, fdname, fd);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSendFileHandle(qemuMonitorPtr mon,\n                          const char *fdname,\n                          int fd)\n{\n    VIR_DEBUG(\"fdname=%s fd=%d\", fdname, fd);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (fd < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"fd must be valid\"));\n        return -1;\n    }\n\n    return qemuMonitorJSONSendFileHandle(mon, fdname, fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"protocol=%s fd=%d fdname=%s skipauth=%d\"",
            "protocol",
            "fd",
            "NULLSTR(fdname)",
            "skipauth"
          ],
          "line": 3429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "fdname"
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorOpenGraphics(qemuMonitorPtr mon,\n                        const char *protocol,\n                        int fd,\n                        const char *fdname,\n                        bool skipauth)\n{\n    VIR_DEBUG(\"protocol=%s fd=%d fdname=%s skipauth=%d\",\n              protocol, fd, NULLSTR(fdname), skipauth);\n    int ret;\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (qemuMonitorSendFileHandle(mon, fdname, fd) < 0)\n        return -1;\n\n    ret = qemuMonitorJSONOpenGraphics(mon, protocol, fdname, skipauth);\n\n    if (ret < 0) {\n        if (qemuMonitorCloseFileHandle(mon, fdname) < 0)\n            VIR_WARN(\"failed to close device handle '%s'\", fdname);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorVMStatusToPausedReason",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3367-3419",
    "snippet": "int\nqemuMonitorVMStatusToPausedReason(const char *status)\n{\n    int st;\n\n    if (!status)\n        return VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    if ((st = qemuMonitorVMStatusTypeFromString(status)) < 0) {\n        VIR_WARN(\"QEMU reported unknown VM status: '%s'\", status);\n        return VIR_DOMAIN_PAUSED_UNKNOWN;\n    }\n\n    switch ((qemuMonitorVMStatus) st) {\n    case QEMU_MONITOR_VM_STATUS_DEBUG:\n    case QEMU_MONITOR_VM_STATUS_INTERNAL_ERROR:\n    case QEMU_MONITOR_VM_STATUS_RESTORE_VM:\n        return VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    case QEMU_MONITOR_VM_STATUS_INMIGRATE:\n    case QEMU_MONITOR_VM_STATUS_POSTMIGRATE:\n    case QEMU_MONITOR_VM_STATUS_FINISH_MIGRATE:\n        return VIR_DOMAIN_PAUSED_MIGRATION;\n\n    case QEMU_MONITOR_VM_STATUS_IO_ERROR:\n        return VIR_DOMAIN_PAUSED_IOERROR;\n\n    case QEMU_MONITOR_VM_STATUS_PAUSED:\n    case QEMU_MONITOR_VM_STATUS_PRELAUNCH:\n        return VIR_DOMAIN_PAUSED_USER;\n\n    case QEMU_MONITOR_VM_STATUS_RUNNING:\n        VIR_WARN(\"QEMU reports the guest is paused but status is 'running'\");\n        return VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    case QEMU_MONITOR_VM_STATUS_SAVE_VM:\n        return VIR_DOMAIN_PAUSED_SAVE;\n\n    case QEMU_MONITOR_VM_STATUS_SHUTDOWN:\n        return VIR_DOMAIN_PAUSED_SHUTTING_DOWN;\n\n    case QEMU_MONITOR_VM_STATUS_WATCHDOG:\n        return VIR_DOMAIN_PAUSED_WATCHDOG;\n\n    case QEMU_MONITOR_VM_STATUS_GUEST_PANICKED:\n        return VIR_DOMAIN_PAUSED_CRASHED;\n\n    /* unreachable from this point on */\n    case QEMU_MONITOR_VM_STATUS_LAST:\n        ;\n    }\n    return VIR_DOMAIN_PAUSED_UNKNOWN;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"QEMU reports the guest is paused but status is 'running'\""
          ],
          "line": 3399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"QEMU reported unknown VM status: '%s'\"",
            "status"
          ],
          "line": 3376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorVMStatusTypeFromString",
          "args": [
            "status"
          ],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorVMStatusToPausedReason(const char *status)\n{\n    int st;\n\n    if (!status)\n        return VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    if ((st = qemuMonitorVMStatusTypeFromString(status)) < 0) {\n        VIR_WARN(\"QEMU reported unknown VM status: '%s'\", status);\n        return VIR_DOMAIN_PAUSED_UNKNOWN;\n    }\n\n    switch ((qemuMonitorVMStatus) st) {\n    case QEMU_MONITOR_VM_STATUS_DEBUG:\n    case QEMU_MONITOR_VM_STATUS_INTERNAL_ERROR:\n    case QEMU_MONITOR_VM_STATUS_RESTORE_VM:\n        return VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    case QEMU_MONITOR_VM_STATUS_INMIGRATE:\n    case QEMU_MONITOR_VM_STATUS_POSTMIGRATE:\n    case QEMU_MONITOR_VM_STATUS_FINISH_MIGRATE:\n        return VIR_DOMAIN_PAUSED_MIGRATION;\n\n    case QEMU_MONITOR_VM_STATUS_IO_ERROR:\n        return VIR_DOMAIN_PAUSED_IOERROR;\n\n    case QEMU_MONITOR_VM_STATUS_PAUSED:\n    case QEMU_MONITOR_VM_STATUS_PRELAUNCH:\n        return VIR_DOMAIN_PAUSED_USER;\n\n    case QEMU_MONITOR_VM_STATUS_RUNNING:\n        VIR_WARN(\"QEMU reports the guest is paused but status is 'running'\");\n        return VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    case QEMU_MONITOR_VM_STATUS_SAVE_VM:\n        return VIR_DOMAIN_PAUSED_SAVE;\n\n    case QEMU_MONITOR_VM_STATUS_SHUTDOWN:\n        return VIR_DOMAIN_PAUSED_SHUTTING_DOWN;\n\n    case QEMU_MONITOR_VM_STATUS_WATCHDOG:\n        return VIR_DOMAIN_PAUSED_WATCHDOG;\n\n    case QEMU_MONITOR_VM_STATUS_GUEST_PANICKED:\n        return VIR_DOMAIN_PAUSED_CRASHED;\n\n    /* unreachable from this point on */\n    case QEMU_MONITOR_VM_STATUS_LAST:\n        ;\n    }\n    return VIR_DOMAIN_PAUSED_UNKNOWN;\n}"
  },
  {
    "function_name": "qemuMonitorGetBlockIoThrottle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3352-3364",
    "snippet": "int\nqemuMonitorGetBlockIoThrottle(qemuMonitorPtr mon,\n                              const char *drivealias,\n                              const char *qdevid,\n                              virDomainBlockIoTuneInfoPtr reply)\n{\n    VIR_DEBUG(\"drivealias=%s, qdevid=%s, reply=%p\",\n              NULLSTR(drivealias), NULLSTR(qdevid), reply);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetBlockIoThrottle(mon, drivealias, qdevid, reply);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetBlockIoThrottle",
          "args": [
            "mon",
            "drivealias",
            "qdevid",
            "reply"
          ],
          "line": 3363
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetBlockIoThrottle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "5450-5464",
          "snippet": "int qemuMonitorJSONGetBlockIoThrottle(qemuMonitorPtr mon,\n                                      const char *drivealias,\n                                      const char *qdevid,\n                                      virDomainBlockIoTuneInfoPtr reply)\n{\n    int ret = -1;\n    virJSONValuePtr devices = NULL;\n\n    if (!(devices = qemuMonitorJSONQueryBlock(mon)))\n        return -1;\n\n    ret = qemuMonitorJSONBlockIoThrottleInfo(devices, drivealias, qdevid, reply);\n    virJSONValueFree(devices);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONGetBlockIoThrottle(qemuMonitorPtr mon,\n                                      const char *drivealias,\n                                      const char *qdevid,\n                                      virDomainBlockIoTuneInfoPtr reply)\n{\n    int ret = -1;\n    virJSONValuePtr devices = NULL;\n\n    if (!(devices = qemuMonitorJSONQueryBlock(mon)))\n        return -1;\n\n    ret = qemuMonitorJSONBlockIoThrottleInfo(devices, drivealias, qdevid, reply);\n    virJSONValueFree(devices);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"drivealias=%s, qdevid=%s, reply=%p\"",
            "NULLSTR(drivealias)",
            "NULLSTR(qdevid)",
            "reply"
          ],
          "line": 3358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "qdevid"
          ],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "drivealias"
          ],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetBlockIoThrottle(qemuMonitorPtr mon,\n                              const char *drivealias,\n                              const char *qdevid,\n                              virDomainBlockIoTuneInfoPtr reply)\n{\n    VIR_DEBUG(\"drivealias=%s, qdevid=%s, reply=%p\",\n              NULLSTR(drivealias), NULLSTR(qdevid), reply);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetBlockIoThrottle(mon, drivealias, qdevid, reply);\n}"
  },
  {
    "function_name": "qemuMonitorSetBlockIoThrottle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3331-3349",
    "snippet": "int\nqemuMonitorSetBlockIoThrottle(qemuMonitorPtr mon,\n                              const char *drivealias,\n                              const char *qomid,\n                              virDomainBlockIoTuneInfoPtr info,\n                              bool supportMaxOptions,\n                              bool supportGroupNameOption,\n                              bool supportMaxLengthOptions)\n{\n    VIR_DEBUG(\"drivealias=%s, qomid=%s, info=%p\",\n              NULLSTR(drivealias), NULLSTR(qomid), info);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetBlockIoThrottle(mon, drivealias, qomid, info,\n                                             supportMaxOptions,\n                                             supportGroupNameOption,\n                                             supportMaxLengthOptions);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSetBlockIoThrottle",
          "args": [
            "mon",
            "drivealias",
            "qomid",
            "info",
            "supportMaxOptions",
            "supportGroupNameOption",
            "supportMaxLengthOptions"
          ],
          "line": 3345
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSetBlockIoThrottle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "5351-5448",
          "snippet": "int qemuMonitorJSONSetBlockIoThrottle(qemuMonitorPtr mon,\n                                      const char *drivealias,\n                                      const char *qomid,\n                                      virDomainBlockIoTuneInfoPtr info,\n                                      bool supportMaxOptions,\n                                      bool supportGroupNameOption,\n                                      bool supportMaxLengthOptions)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr result = NULL;\n    virJSONValuePtr args = NULL;\n    const char *errdev = drivealias;\n\n    if (!errdev)\n        errdev = qomid;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"block_set_io_throttle\", NULL)))\n        return -1;\n\n    if (virJSONValueObjectCreate(&args,\n                                 \"S:device\", drivealias,\n                                 \"S:id\", qomid,\n                                 \"U:bps\", info->total_bytes_sec,\n                                 \"U:bps_rd\", info->read_bytes_sec,\n                                 \"U:bps_wr\", info->write_bytes_sec,\n                                 \"U:iops\", info->total_iops_sec,\n                                 \"U:iops_rd\", info->read_iops_sec,\n                                 \"U:iops_wr\", info->write_iops_sec,\n                                 NULL) < 0)\n        goto cleanup;\n\n    if (supportMaxOptions &&\n        virJSONValueObjectAdd(args,\n                              \"U:bps_max\", info->total_bytes_sec_max,\n                              \"U:bps_rd_max\", info->read_bytes_sec_max,\n                              \"U:bps_wr_max\", info->write_bytes_sec_max,\n                              \"U:iops_max\", info->total_iops_sec_max,\n                              \"U:iops_rd_max\", info->read_iops_sec_max,\n                              \"U:iops_wr_max\", info->write_iops_sec_max,\n                              \"U:iops_size\", info->size_iops_sec,\n                              NULL) < 0)\n        goto cleanup;\n\n    if (supportGroupNameOption &&\n        virJSONValueObjectAdd(args,\n                              \"S:group\", info->group_name,\n                              NULL) < 0)\n        goto cleanup;\n\n    if (supportMaxLengthOptions &&\n        virJSONValueObjectAdd(args,\n                              \"P:bps_max_length\",\n                              info->total_bytes_sec_max_length,\n                              \"P:bps_rd_max_length\",\n                              info->read_bytes_sec_max_length,\n                              \"P:bps_wr_max_length\",\n                              info->write_bytes_sec_max_length,\n                              \"P:iops_max_length\",\n                              info->total_iops_sec_max_length,\n                              \"P:iops_rd_max_length\",\n                              info->read_iops_sec_max_length,\n                              \"P:iops_wr_max_length\",\n                              info->write_iops_sec_max_length,\n                              NULL) < 0)\n        goto cleanup;\n\n    if (virJSONValueObjectAppend(cmd, \"arguments\", args) < 0)\n        goto cleanup;\n    args = NULL; /* obj owns reference to args now */\n\n    if (qemuMonitorJSONCommand(mon, cmd, &result) < 0)\n        goto cleanup;\n\n    if (virJSONValueObjectHasKey(result, \"error\")) {\n        if (qemuMonitorJSONHasError(result, \"DeviceNotActive\")) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"No active operation on device: %s\"), errdev);\n        } else if (qemuMonitorJSONHasError(result, \"NotSupported\")) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"Operation is not supported for device: %s\"), errdev);\n        } else {\n            virJSONValuePtr error = virJSONValueObjectGet(result, \"error\");\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to execute '%s', unexpected error: '%s'\"),\n                           qemuMonitorJSONCommandName(cmd),\n                           qemuMonitorJSONStringifyError(error));\n        }\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(result);\n    virJSONValueFree(args);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONSetBlockIoThrottle(qemuMonitorPtr mon,\n                                      const char *drivealias,\n                                      const char *qomid,\n                                      virDomainBlockIoTuneInfoPtr info,\n                                      bool supportMaxOptions,\n                                      bool supportGroupNameOption,\n                                      bool supportMaxLengthOptions)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr result = NULL;\n    virJSONValuePtr args = NULL;\n    const char *errdev = drivealias;\n\n    if (!errdev)\n        errdev = qomid;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"block_set_io_throttle\", NULL)))\n        return -1;\n\n    if (virJSONValueObjectCreate(&args,\n                                 \"S:device\", drivealias,\n                                 \"S:id\", qomid,\n                                 \"U:bps\", info->total_bytes_sec,\n                                 \"U:bps_rd\", info->read_bytes_sec,\n                                 \"U:bps_wr\", info->write_bytes_sec,\n                                 \"U:iops\", info->total_iops_sec,\n                                 \"U:iops_rd\", info->read_iops_sec,\n                                 \"U:iops_wr\", info->write_iops_sec,\n                                 NULL) < 0)\n        goto cleanup;\n\n    if (supportMaxOptions &&\n        virJSONValueObjectAdd(args,\n                              \"U:bps_max\", info->total_bytes_sec_max,\n                              \"U:bps_rd_max\", info->read_bytes_sec_max,\n                              \"U:bps_wr_max\", info->write_bytes_sec_max,\n                              \"U:iops_max\", info->total_iops_sec_max,\n                              \"U:iops_rd_max\", info->read_iops_sec_max,\n                              \"U:iops_wr_max\", info->write_iops_sec_max,\n                              \"U:iops_size\", info->size_iops_sec,\n                              NULL) < 0)\n        goto cleanup;\n\n    if (supportGroupNameOption &&\n        virJSONValueObjectAdd(args,\n                              \"S:group\", info->group_name,\n                              NULL) < 0)\n        goto cleanup;\n\n    if (supportMaxLengthOptions &&\n        virJSONValueObjectAdd(args,\n                              \"P:bps_max_length\",\n                              info->total_bytes_sec_max_length,\n                              \"P:bps_rd_max_length\",\n                              info->read_bytes_sec_max_length,\n                              \"P:bps_wr_max_length\",\n                              info->write_bytes_sec_max_length,\n                              \"P:iops_max_length\",\n                              info->total_iops_sec_max_length,\n                              \"P:iops_rd_max_length\",\n                              info->read_iops_sec_max_length,\n                              \"P:iops_wr_max_length\",\n                              info->write_iops_sec_max_length,\n                              NULL) < 0)\n        goto cleanup;\n\n    if (virJSONValueObjectAppend(cmd, \"arguments\", args) < 0)\n        goto cleanup;\n    args = NULL; /* obj owns reference to args now */\n\n    if (qemuMonitorJSONCommand(mon, cmd, &result) < 0)\n        goto cleanup;\n\n    if (virJSONValueObjectHasKey(result, \"error\")) {\n        if (qemuMonitorJSONHasError(result, \"DeviceNotActive\")) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"No active operation on device: %s\"), errdev);\n        } else if (qemuMonitorJSONHasError(result, \"NotSupported\")) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"Operation is not supported for device: %s\"), errdev);\n        } else {\n            virJSONValuePtr error = virJSONValueObjectGet(result, \"error\");\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to execute '%s', unexpected error: '%s'\"),\n                           qemuMonitorJSONCommandName(cmd),\n                           qemuMonitorJSONStringifyError(error));\n        }\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(result);\n    virJSONValueFree(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"drivealias=%s, qomid=%s, info=%p\"",
            "NULLSTR(drivealias)",
            "NULLSTR(qomid)",
            "info"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "qomid"
          ],
          "line": 3341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "drivealias"
          ],
          "line": 3341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSetBlockIoThrottle(qemuMonitorPtr mon,\n                              const char *drivealias,\n                              const char *qomid,\n                              virDomainBlockIoTuneInfoPtr info,\n                              bool supportMaxOptions,\n                              bool supportGroupNameOption,\n                              bool supportMaxLengthOptions)\n{\n    VIR_DEBUG(\"drivealias=%s, qomid=%s, info=%p\",\n              NULLSTR(drivealias), NULLSTR(qomid), info);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetBlockIoThrottle(mon, drivealias, qomid, info,\n                                             supportMaxOptions,\n                                             supportGroupNameOption,\n                                             supportMaxLengthOptions);\n}"
  },
  {
    "function_name": "qemuMonitorJobComplete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3319-3328",
    "snippet": "int\nqemuMonitorJobComplete(qemuMonitorPtr mon,\n                       const char *jobname)\n{\n    VIR_DEBUG(\"jobname=%s\", jobname);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONJobComplete(mon, jobname);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONJobComplete",
          "args": [
            "mon",
            "jobname"
          ],
          "line": 3327
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONJobComplete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "5201-5220",
          "snippet": "int\nqemuMonitorJSONJobComplete(qemuMonitorPtr mon,\n                           const char *jobname)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"job-complete\",\n                                           \"s:id\", jobname,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONBlockJobError(cmd, reply, jobname) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONJobComplete(qemuMonitorPtr mon,\n                           const char *jobname)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"job-complete\",\n                                           \"s:id\", jobname,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONBlockJobError(cmd, reply, jobname) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"jobname=%s\"",
            "jobname"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJobComplete(qemuMonitorPtr mon,\n                       const char *jobname)\n{\n    VIR_DEBUG(\"jobname=%s\", jobname);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONJobComplete(mon, jobname);\n}"
  },
  {
    "function_name": "qemuMonitorJobCancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3306-3316",
    "snippet": "int\nqemuMonitorJobCancel(qemuMonitorPtr mon,\n                     const char *jobname,\n                     bool quiet)\n{\n    VIR_DEBUG(\"jobname='%s' quiet=%d\", jobname, quiet);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONJobCancel(mon, jobname, quiet);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONJobCancel",
          "args": [
            "mon",
            "jobname",
            "quiet"
          ],
          "line": 3315
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONJobCancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "5173-5198",
          "snippet": "int\nqemuMonitorJSONJobCancel(qemuMonitorPtr mon,\n                         const char *jobname,\n                         bool quiet)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"job-cancel\",\n                                           \"s:id\", jobname,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (quiet) {\n        if (virJSONValueObjectHasKey(reply, \"error\") != 0)\n            return -1;\n    } else {\n        if (qemuMonitorJSONBlockJobError(cmd, reply, jobname) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONJobCancel(qemuMonitorPtr mon,\n                         const char *jobname,\n                         bool quiet)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"job-cancel\",\n                                           \"s:id\", jobname,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (quiet) {\n        if (virJSONValueObjectHasKey(reply, \"error\") != 0)\n            return -1;\n    } else {\n        if (qemuMonitorJSONBlockJobError(cmd, reply, jobname) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"jobname='%s' quiet=%d\"",
            "jobname",
            "quiet"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJobCancel(qemuMonitorPtr mon,\n                     const char *jobname,\n                     bool quiet)\n{\n    VIR_DEBUG(\"jobname='%s' quiet=%d\", jobname, quiet);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONJobCancel(mon, jobname, quiet);\n}"
  },
  {
    "function_name": "qemuMonitorJobDismiss",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3294-3303",
    "snippet": "int\nqemuMonitorJobDismiss(qemuMonitorPtr mon,\n                      const char *jobname)\n{\n    VIR_DEBUG(\"jobname=%s\", jobname);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONJobDismiss(mon, jobname);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONJobDismiss",
          "args": [
            "mon",
            "jobname"
          ],
          "line": 3302
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONJobDismiss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "5151-5170",
          "snippet": "int\nqemuMonitorJSONJobDismiss(qemuMonitorPtr mon,\n                          const char *jobname)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"job-dismiss\",\n                                           \"s:id\", jobname,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONBlockJobError(cmd, reply, jobname) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONJobDismiss(qemuMonitorPtr mon,\n                          const char *jobname)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"job-dismiss\",\n                                           \"s:id\", jobname,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONBlockJobError(cmd, reply, jobname) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"jobname=%s\"",
            "jobname"
          ],
          "line": 3298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJobDismiss(qemuMonitorPtr mon,\n                      const char *jobname)\n{\n    VIR_DEBUG(\"jobname=%s\", jobname);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONJobDismiss(mon, jobname);\n}"
  },
  {
    "function_name": "qemuMonitorGetBlockJobInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3270-3291",
    "snippet": "int\nqemuMonitorGetBlockJobInfo(qemuMonitorPtr mon,\n                           const char *alias,\n                           qemuMonitorBlockJobInfoPtr info)\n{\n    virHashTablePtr all;\n    qemuMonitorBlockJobInfoPtr data;\n    int ret = 0;\n\n    VIR_DEBUG(\"alias=%s, info=%p\", alias, info);\n\n    if (!(all = qemuMonitorGetAllBlockJobInfo(mon, true)))\n        return -1;\n\n    if ((data = virHashLookup(all, alias))) {\n        *info = *data;\n        ret = 1;\n    }\n\n    virHashFree(all);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "all"
          ],
          "line": 3289
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "all",
            "alias"
          ],
          "line": 3284
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetAllBlockJobInfo",
          "args": [
            "mon",
            "true"
          ],
          "line": 3281
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetAllBlockJobInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3256-3262",
          "snippet": "virHashTablePtr\nqemuMonitorGetAllBlockJobInfo(qemuMonitorPtr mon,\n                              bool rawjobname)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n    return qemuMonitorJSONGetAllBlockJobInfo(mon, rawjobname);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirHashTablePtr\nqemuMonitorGetAllBlockJobInfo(qemuMonitorPtr mon,\n                              bool rawjobname)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n    return qemuMonitorJSONGetAllBlockJobInfo(mon, rawjobname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"alias=%s, info=%p\"",
            "alias",
            "info"
          ],
          "line": 3279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetBlockJobInfo(qemuMonitorPtr mon,\n                           const char *alias,\n                           qemuMonitorBlockJobInfoPtr info)\n{\n    virHashTablePtr all;\n    qemuMonitorBlockJobInfoPtr data;\n    int ret = 0;\n\n    VIR_DEBUG(\"alias=%s, info=%p\", alias, info);\n\n    if (!(all = qemuMonitorGetAllBlockJobInfo(mon, true)))\n        return -1;\n\n    if ((data = virHashLookup(all, alias))) {\n        *info = *data;\n        ret = 1;\n    }\n\n    virHashFree(all);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorGetAllBlockJobInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3256-3262",
    "snippet": "virHashTablePtr\nqemuMonitorGetAllBlockJobInfo(qemuMonitorPtr mon,\n                              bool rawjobname)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n    return qemuMonitorJSONGetAllBlockJobInfo(mon, rawjobname);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetAllBlockJobInfo",
          "args": [
            "mon",
            "rawjobname"
          ],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetAllBlockJobInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4948-4995",
          "snippet": "virHashTablePtr\nqemuMonitorJSONGetAllBlockJobInfo(qemuMonitorPtr mon,\n                                  bool rawjobname)\n{\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    size_t nr_results;\n    size_t i;\n    virHashTablePtr blockJobs = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"query-block-jobs\", NULL);\n    if (!cmd)\n        return NULL;\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if ((data = virJSONValueObjectGetArray(reply, \"return\")) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"reply was missing return data\"));\n        goto cleanup;\n    }\n\n    nr_results = virJSONValueArraySize(data);\n    if (!(blockJobs = virHashCreate(nr_results, virHashValueFree)))\n        goto cleanup;\n\n    for (i = 0; i < nr_results; i++) {\n        virJSONValuePtr entry = virJSONValueArrayGet(data, i);\n        if (!entry) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing array element\"));\n            goto error;\n        }\n        if (qemuMonitorJSONParseBlockJobInfo(blockJobs, entry, rawjobname) < 0)\n            goto error;\n    }\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return blockJobs;\n\n error:\n    virHashFree(blockJobs);\n    blockJobs = NULL;\n    goto cleanup;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nvirHashTablePtr\nqemuMonitorJSONGetAllBlockJobInfo(qemuMonitorPtr mon,\n                                  bool rawjobname)\n{\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    size_t nr_results;\n    size_t i;\n    virHashTablePtr blockJobs = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"query-block-jobs\", NULL);\n    if (!cmd)\n        return NULL;\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if ((data = virJSONValueObjectGetArray(reply, \"return\")) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"reply was missing return data\"));\n        goto cleanup;\n    }\n\n    nr_results = virJSONValueArraySize(data);\n    if (!(blockJobs = virHashCreate(nr_results, virHashValueFree)))\n        goto cleanup;\n\n    for (i = 0; i < nr_results; i++) {\n        virJSONValuePtr entry = virJSONValueArrayGet(data, i);\n        if (!entry) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing array element\"));\n            goto error;\n        }\n        if (qemuMonitorJSONParseBlockJobInfo(blockJobs, entry, rawjobname) < 0)\n            goto error;\n    }\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return blockJobs;\n\n error:\n    virHashFree(blockJobs);\n    blockJobs = NULL;\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR_NULL",
          "args": [
            "mon"
          ],
          "line": 3260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirHashTablePtr\nqemuMonitorGetAllBlockJobInfo(qemuMonitorPtr mon,\n                              bool rawjobname)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n    return qemuMonitorJSONGetAllBlockJobInfo(mon, rawjobname);\n}"
  },
  {
    "function_name": "qemuMonitorBlockJobSetSpeed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3243-3253",
    "snippet": "int\nqemuMonitorBlockJobSetSpeed(qemuMonitorPtr mon,\n                            const char *jobname,\n                            unsigned long long bandwidth)\n{\n    VIR_DEBUG(\"jobname=%s, bandwidth=%lluB\", jobname, bandwidth);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockJobSetSpeed(mon, jobname, bandwidth);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONBlockJobSetSpeed",
          "args": [
            "mon",
            "jobname",
            "bandwidth"
          ],
          "line": 3252
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONBlockJobSetSpeed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "5093-5120",
          "snippet": "int\nqemuMonitorJSONBlockJobSetSpeed(qemuMonitorPtr mon,\n                                const char *jobname,\n                                unsigned long long speed)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"block-job-set-speed\",\n                                           \"s:device\", jobname,\n                                           \"J:speed\", speed,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONBlockJobError(cmd, reply, jobname) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONBlockJobSetSpeed(qemuMonitorPtr mon,\n                                const char *jobname,\n                                unsigned long long speed)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"block-job-set-speed\",\n                                           \"s:device\", jobname,\n                                           \"J:speed\", speed,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONBlockJobError(cmd, reply, jobname) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"jobname=%s, bandwidth=%lluB\"",
            "jobname",
            "bandwidth"
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockJobSetSpeed(qemuMonitorPtr mon,\n                            const char *jobname,\n                            unsigned long long bandwidth)\n{\n    VIR_DEBUG(\"jobname=%s, bandwidth=%lluB\", jobname, bandwidth);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockJobSetSpeed(mon, jobname, bandwidth);\n}"
  },
  {
    "function_name": "qemuMonitorBlockJobCancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3231-3240",
    "snippet": "int\nqemuMonitorBlockJobCancel(qemuMonitorPtr mon,\n                          const char *jobname)\n{\n    VIR_DEBUG(\"jobname=%s\", jobname);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockJobCancel(mon, jobname);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONBlockJobCancel",
          "args": [
            "mon",
            "jobname"
          ],
          "line": 3239
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONBlockJobCancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "5065-5090",
          "snippet": "int\nqemuMonitorJSONBlockJobCancel(qemuMonitorPtr mon,\n                              const char *jobname)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"block-job-cancel\",\n                                           \"s:device\", jobname,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONBlockJobError(cmd, reply, jobname) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONBlockJobCancel(qemuMonitorPtr mon,\n                              const char *jobname)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"block-job-cancel\",\n                                           \"s:device\", jobname,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONBlockJobError(cmd, reply, jobname) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"jobname=%s\"",
            "jobname"
          ],
          "line": 3235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockJobCancel(qemuMonitorPtr mon,\n                          const char *jobname)\n{\n    VIR_DEBUG(\"jobname=%s\", jobname);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockJobCancel(mon, jobname);\n}"
  },
  {
    "function_name": "qemuMonitorBlockStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3203-3228",
    "snippet": "int\nqemuMonitorBlockStream(qemuMonitorPtr mon,\n                       const char *device,\n                       const char *jobname,\n                       bool persistjob,\n                       const char *base,\n                       const char *baseNode,\n                       const char *backingName,\n                       unsigned long long bandwidth)\n{\n    VIR_DEBUG(\"device=%s, jobname=%s, persistjob=%d, base=%s, baseNode=%s, \"\n              \"backingName=%s, bandwidth=%lluB\",\n              device, NULLSTR(jobname), persistjob, NULLSTR(base),\n              NULLSTR(baseNode), NULLSTR(backingName), bandwidth);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (base && baseNode) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"'base' and 'baseNode' can't be used together\"));\n        return -1;\n    }\n\n    return qemuMonitorJSONBlockStream(mon, device, jobname, persistjob, base,\n                                      baseNode, backingName, bandwidth);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONBlockStream",
          "args": [
            "mon",
            "device",
            "jobname",
            "persistjob",
            "base",
            "baseNode",
            "backingName",
            "bandwidth"
          ],
          "line": 3226
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONBlockStream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "5017-5062",
          "snippet": "int\nqemuMonitorJSONBlockStream(qemuMonitorPtr mon,\n                           const char *device,\n                           const char *jobname,\n                           bool persistjob,\n                           const char *base,\n                           const char *baseNode,\n                           const char *backingName,\n                           unsigned long long speed)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virTristateBool autofinalize = VIR_TRISTATE_BOOL_ABSENT;\n    virTristateBool autodismiss = VIR_TRISTATE_BOOL_ABSENT;\n\n    if (persistjob) {\n        autofinalize = VIR_TRISTATE_BOOL_YES;\n        autodismiss = VIR_TRISTATE_BOOL_NO;\n    }\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"block-stream\",\n                                           \"s:device\", device,\n                                           \"S:job-id\", jobname,\n                                           \"Y:speed\", speed,\n                                           \"S:base\", base,\n                                           \"S:base-node\", baseNode,\n                                           \"S:backing-file\", backingName,\n                                           \"T:auto-finalize\", autofinalize,\n                                           \"T:auto-dismiss\", autodismiss,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONBlockStream(qemuMonitorPtr mon,\n                           const char *device,\n                           const char *jobname,\n                           bool persistjob,\n                           const char *base,\n                           const char *baseNode,\n                           const char *backingName,\n                           unsigned long long speed)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virTristateBool autofinalize = VIR_TRISTATE_BOOL_ABSENT;\n    virTristateBool autodismiss = VIR_TRISTATE_BOOL_ABSENT;\n\n    if (persistjob) {\n        autofinalize = VIR_TRISTATE_BOOL_YES;\n        autodismiss = VIR_TRISTATE_BOOL_NO;\n    }\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"block-stream\",\n                                           \"s:device\", device,\n                                           \"S:job-id\", jobname,\n                                           \"Y:speed\", speed,\n                                           \"S:base\", base,\n                                           \"S:base-node\", baseNode,\n                                           \"S:backing-file\", backingName,\n                                           \"T:auto-finalize\", autofinalize,\n                                           \"T:auto-dismiss\", autodismiss,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"'base' and 'baseNode' can't be used together\")"
          ],
          "line": 3221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"'base' and 'baseNode' can't be used together\""
          ],
          "line": 3222
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"device=%s, jobname=%s, persistjob=%d, base=%s, baseNode=%s, \"\n              \"backingName=%s, bandwidth=%lluB\"",
            "device",
            "NULLSTR(jobname)",
            "persistjob",
            "NULLSTR(base)",
            "NULLSTR(baseNode)",
            "NULLSTR(backingName)",
            "bandwidth"
          ],
          "line": 3213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "backingName"
          ],
          "line": 3216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "baseNode"
          ],
          "line": 3216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "base"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "jobname"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockStream(qemuMonitorPtr mon,\n                       const char *device,\n                       const char *jobname,\n                       bool persistjob,\n                       const char *base,\n                       const char *baseNode,\n                       const char *backingName,\n                       unsigned long long bandwidth)\n{\n    VIR_DEBUG(\"device=%s, jobname=%s, persistjob=%d, base=%s, baseNode=%s, \"\n              \"backingName=%s, bandwidth=%lluB\",\n              device, NULLSTR(jobname), persistjob, NULLSTR(base),\n              NULLSTR(baseNode), NULLSTR(backingName), bandwidth);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (base && baseNode) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"'base' and 'baseNode' can't be used together\"));\n        return -1;\n    }\n\n    return qemuMonitorJSONBlockStream(mon, device, jobname, persistjob, base,\n                                      baseNode, backingName, bandwidth);\n}"
  },
  {
    "function_name": "qemuMonitorScreendump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3188-3199",
    "snippet": "int\nqemuMonitorScreendump(qemuMonitorPtr mon,\n                      const char *device,\n                      unsigned int head,\n                      const char *file)\n{\n    VIR_DEBUG(\"file=%s\", file);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONScreendump(mon, device, head, file);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONScreendump",
          "args": [
            "mon",
            "device",
            "head",
            "file"
          ],
          "line": 3198
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONScreendump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4849-4877",
          "snippet": "int qemuMonitorJSONScreendump(qemuMonitorPtr mon,\n                              const char *device,\n                              unsigned int head,\n                              const char *file)\n{\n    int ret = -1;\n    virJSONValuePtr cmd, reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"screendump\",\n                                     \"s:filename\", file,\n                                     \"S:device\", device,\n                                     \"p:head\", head,\n                                     NULL);\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONScreendump(qemuMonitorPtr mon,\n                              const char *device,\n                              unsigned int head,\n                              const char *file)\n{\n    int ret = -1;\n    virJSONValuePtr cmd, reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"screendump\",\n                                     \"s:filename\", file,\n                                     \"S:device\", device,\n                                     \"p:head\", head,\n                                     NULL);\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"file=%s\"",
            "file"
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorScreendump(qemuMonitorPtr mon,\n                      const char *device,\n                      unsigned int head,\n                      const char *file)\n{\n    VIR_DEBUG(\"file=%s\", file);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONScreendump(mon, device, head, file);\n}"
  },
  {
    "function_name": "qemuMonitorSendKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3174-3185",
    "snippet": "int\nqemuMonitorSendKey(qemuMonitorPtr mon,\n                   unsigned int holdtime,\n                   unsigned int *keycodes,\n                   unsigned int nkeycodes)\n{\n    VIR_DEBUG(\"holdtime=%u, nkeycodes=%u\", holdtime, nkeycodes);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSendKey(mon, holdtime, keycodes, nkeycodes);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSendKey",
          "args": [
            "mon",
            "holdtime",
            "keycodes",
            "nkeycodes"
          ],
          "line": 3184
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSendKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4787-4847",
          "snippet": "int qemuMonitorJSONSendKey(qemuMonitorPtr mon,\n                           unsigned int holdtime,\n                           unsigned int *keycodes,\n                           unsigned int nkeycodes)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr keys = NULL;\n    virJSONValuePtr key = NULL;\n    size_t i;\n\n    /* create the key data array */\n    keys = virJSONValueNewArray();\n\n    for (i = 0; i < nkeycodes; i++) {\n        if (keycodes[i] > 0xffff) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"keycode %zu is invalid: 0x%X\"), i, keycodes[i]);\n            goto cleanup;\n        }\n\n        /* create single key object */\n        key = virJSONValueNewObject();\n\n        /* Union KeyValue has two types, use the generic one */\n        if (virJSONValueObjectAppendString(key, \"type\", \"number\") < 0)\n            goto cleanup;\n\n        /* with the keycode */\n        if (virJSONValueObjectAppendNumberInt(key, \"data\", keycodes[i]) < 0)\n            goto cleanup;\n\n        if (virJSONValueArrayAppend(keys, key) < 0)\n            goto cleanup;\n\n        key = NULL;\n\n    }\n\n    cmd = qemuMonitorJSONMakeCommand(\"send-key\",\n                                     \"a:keys\", &keys,\n                                     \"p:hold-time\", holdtime,\n                                     NULL);\n    if (!cmd)\n        goto cleanup;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    virJSONValueFree(keys);\n    virJSONValueFree(key);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint qemuMonitorJSONSendKey(qemuMonitorPtr mon,\n                           unsigned int holdtime,\n                           unsigned int *keycodes,\n                           unsigned int nkeycodes)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr keys = NULL;\n    virJSONValuePtr key = NULL;\n    size_t i;\n\n    /* create the key data array */\n    keys = virJSONValueNewArray();\n\n    for (i = 0; i < nkeycodes; i++) {\n        if (keycodes[i] > 0xffff) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"keycode %zu is invalid: 0x%X\"), i, keycodes[i]);\n            goto cleanup;\n        }\n\n        /* create single key object */\n        key = virJSONValueNewObject();\n\n        /* Union KeyValue has two types, use the generic one */\n        if (virJSONValueObjectAppendString(key, \"type\", \"number\") < 0)\n            goto cleanup;\n\n        /* with the keycode */\n        if (virJSONValueObjectAppendNumberInt(key, \"data\", keycodes[i]) < 0)\n            goto cleanup;\n\n        if (virJSONValueArrayAppend(keys, key) < 0)\n            goto cleanup;\n\n        key = NULL;\n\n    }\n\n    cmd = qemuMonitorJSONMakeCommand(\"send-key\",\n                                     \"a:keys\", &keys,\n                                     \"p:hold-time\", holdtime,\n                                     NULL);\n    if (!cmd)\n        goto cleanup;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    virJSONValueFree(keys);\n    virJSONValueFree(key);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"holdtime=%u, nkeycodes=%u\"",
            "holdtime",
            "nkeycodes"
          ],
          "line": 3180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSendKey(qemuMonitorPtr mon,\n                   unsigned int holdtime,\n                   unsigned int *keycodes,\n                   unsigned int nkeycodes)\n{\n    VIR_DEBUG(\"holdtime=%u, nkeycodes=%u\", holdtime, nkeycodes);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSendKey(mon, holdtime, keycodes, nkeycodes);\n}"
  },
  {
    "function_name": "qemuMonitorInjectNMI",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3165-3171",
    "snippet": "int\nqemuMonitorInjectNMI(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONInjectNMI(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONInjectNMI",
          "args": [
            "mon"
          ],
          "line": 3170
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONInjectNMI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4764-4785",
          "snippet": "int qemuMonitorJSONInjectNMI(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"inject-nmi\", NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONInjectNMI(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"inject-nmi\", NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorInjectNMI(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONInjectNMI(mon);\n}"
  },
  {
    "function_name": "qemuMonitorArbitraryCommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3148-3162",
    "snippet": "int\nqemuMonitorArbitraryCommand(qemuMonitorPtr mon,\n                            const char *cmd,\n                            char **reply,\n                            bool hmp)\n{\n    VIR_DEBUG(\"cmd=%s, reply=%p, hmp=%d\", cmd, reply, hmp);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (hmp)\n        return qemuMonitorJSONHumanCommand(mon, cmd, reply);\n    else\n        return qemuMonitorJSONArbitraryCommand(mon, cmd, reply);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONArbitraryCommand",
          "args": [
            "mon",
            "cmd",
            "reply"
          ],
          "line": 3161
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONArbitraryCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4739-4762",
          "snippet": "int qemuMonitorJSONArbitraryCommand(qemuMonitorPtr mon,\n                                    const char *cmd_str,\n                                    char **reply_str)\n{\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    int ret = -1;\n\n    if (!(cmd = virJSONValueFromString(cmd_str)))\n        goto cleanup;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (!(*reply_str = virJSONValueToString(reply, false)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONArbitraryCommand(qemuMonitorPtr mon,\n                                    const char *cmd_str,\n                                    char **reply_str)\n{\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    int ret = -1;\n\n    if (!(cmd = virJSONValueFromString(cmd_str)))\n        goto cleanup;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (!(*reply_str = virJSONValueToString(reply, false)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONHumanCommand",
          "args": [
            "mon",
            "cmd",
            "reply"
          ],
          "line": 3159
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONHumanCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "1567-1609",
          "snippet": "int\nqemuMonitorJSONHumanCommand(qemuMonitorPtr mon,\n                            const char *cmd_str,\n                            char **reply_str)\n{\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr obj;\n    int ret = -1;\n\n    cmd = qemuMonitorJSONMakeCommand(\"human-monitor-command\",\n                                     \"s:command-line\", cmd_str,\n                                     NULL);\n\n    if (!cmd || qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Human monitor command is not available to run %s\"),\n                       cmd_str);\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckError(cmd, reply))\n        goto cleanup;\n\n    obj = virJSONValueObjectGet(reply, \"return\");\n\n    if (reply_str) {\n        const char *data;\n\n        data = virJSONValueGetString(obj);\n        *reply_str = g_strdup(NULLSTR_EMPTY(data));\n    }\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint\nqemuMonitorJSONHumanCommand(qemuMonitorPtr mon,\n                            const char *cmd_str,\n                            char **reply_str)\n{\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr obj;\n    int ret = -1;\n\n    cmd = qemuMonitorJSONMakeCommand(\"human-monitor-command\",\n                                     \"s:command-line\", cmd_str,\n                                     NULL);\n\n    if (!cmd || qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Human monitor command is not available to run %s\"),\n                       cmd_str);\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckError(cmd, reply))\n        goto cleanup;\n\n    obj = virJSONValueObjectGet(reply, \"return\");\n\n    if (reply_str) {\n        const char *data;\n\n        data = virJSONValueGetString(obj);\n        *reply_str = g_strdup(NULLSTR_EMPTY(data));\n    }\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cmd=%s, reply=%p, hmp=%d\"",
            "cmd",
            "reply",
            "hmp"
          ],
          "line": 3154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorArbitraryCommand(qemuMonitorPtr mon,\n                            const char *cmd,\n                            char **reply,\n                            bool hmp)\n{\n    VIR_DEBUG(\"cmd=%s, reply=%p, hmp=%d\", cmd, reply, hmp);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (hmp)\n        return qemuMonitorJSONHumanCommand(mon, cmd, reply);\n    else\n        return qemuMonitorJSONArbitraryCommand(mon, cmd, reply);\n}"
  },
  {
    "function_name": "qemuMonitorDrivePivot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3136-3145",
    "snippet": "int\nqemuMonitorDrivePivot(qemuMonitorPtr mon,\n                      const char *jobname)\n{\n    VIR_DEBUG(\"jobname=%s\", jobname);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONDrivePivot(mon, jobname);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONDrivePivot",
          "args": [
            "mon",
            "jobname"
          ],
          "line": 3144
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONDrivePivot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "5123-5148",
          "snippet": "int\nqemuMonitorJSONDrivePivot(qemuMonitorPtr mon,\n                          const char *jobname)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"block-job-complete\",\n                                     \"s:device\", jobname,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONBlockJobError(cmd, reply, jobname) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONDrivePivot(qemuMonitorPtr mon,\n                          const char *jobname)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"block-job-complete\",\n                                     \"s:device\", jobname,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONBlockJobError(cmd, reply, jobname) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"jobname=%s\"",
            "jobname"
          ],
          "line": 3140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorDrivePivot(qemuMonitorPtr mon,\n                      const char *jobname)\n{\n    VIR_DEBUG(\"jobname=%s\", jobname);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONDrivePivot(mon, jobname);\n}"
  },
  {
    "function_name": "qemuMonitorDiskNameLookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3123-3132",
    "snippet": "char *\nqemuMonitorDiskNameLookup(qemuMonitorPtr mon,\n                          const char *device,\n                          virStorageSourcePtr top,\n                          virStorageSourcePtr target)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    return qemuMonitorJSONDiskNameLookup(mon, device, top, target);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONDiskNameLookup",
          "args": [
            "mon",
            "device",
            "top",
            "target"
          ],
          "line": 3131
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONDiskNameLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4692-4736",
          "snippet": "char *\nqemuMonitorJSONDiskNameLookup(qemuMonitorPtr mon,\n                              const char *device,\n                              virStorageSourcePtr top,\n                              virStorageSourcePtr target)\n{\n    char *ret = NULL;\n    virJSONValuePtr devices;\n    size_t i;\n\n    if (!(devices = qemuMonitorJSONQueryBlock(mon)))\n        return NULL;\n\n    for (i = 0; i < virJSONValueArraySize(devices); i++) {\n        virJSONValuePtr dev;\n        virJSONValuePtr inserted;\n        virJSONValuePtr image;\n        const char *thisdev;\n\n        if (!(dev = qemuMonitorJSONGetBlockDev(devices, i)))\n            goto cleanup;\n\n        if (!(thisdev = qemuMonitorJSONGetBlockDevDevice(dev)))\n            goto cleanup;\n\n        if (STREQ(thisdev, device)) {\n            if ((inserted = virJSONValueObjectGetObject(dev, \"inserted\")) &&\n                (image = virJSONValueObjectGetObject(inserted, \"image\"))) {\n                ret = qemuMonitorJSONDiskNameLookupOne(image, top, target);\n            }\n            break;\n        }\n    }\n    /* Guarantee an error when returning NULL, but don't override a\n     * more specific error if one was already generated.  */\n    if (!ret && virGetLastErrorCode() == VIR_ERR_OK)\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to find backing name for device %s\"),\n                       device);\n\n cleanup:\n    virJSONValueFree(devices);\n\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nchar *\nqemuMonitorJSONDiskNameLookup(qemuMonitorPtr mon,\n                              const char *device,\n                              virStorageSourcePtr top,\n                              virStorageSourcePtr target)\n{\n    char *ret = NULL;\n    virJSONValuePtr devices;\n    size_t i;\n\n    if (!(devices = qemuMonitorJSONQueryBlock(mon)))\n        return NULL;\n\n    for (i = 0; i < virJSONValueArraySize(devices); i++) {\n        virJSONValuePtr dev;\n        virJSONValuePtr inserted;\n        virJSONValuePtr image;\n        const char *thisdev;\n\n        if (!(dev = qemuMonitorJSONGetBlockDev(devices, i)))\n            goto cleanup;\n\n        if (!(thisdev = qemuMonitorJSONGetBlockDevDevice(dev)))\n            goto cleanup;\n\n        if (STREQ(thisdev, device)) {\n            if ((inserted = virJSONValueObjectGetObject(dev, \"inserted\")) &&\n                (image = virJSONValueObjectGetObject(inserted, \"image\"))) {\n                ret = qemuMonitorJSONDiskNameLookupOne(image, top, target);\n            }\n            break;\n        }\n    }\n    /* Guarantee an error when returning NULL, but don't override a\n     * more specific error if one was already generated.  */\n    if (!ret && virGetLastErrorCode() == VIR_ERR_OK)\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to find backing name for device %s\"),\n                       device);\n\n cleanup:\n    virJSONValueFree(devices);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR_NULL",
          "args": [
            "mon"
          ],
          "line": 3129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nchar *\nqemuMonitorDiskNameLookup(qemuMonitorPtr mon,\n                          const char *device,\n                          virStorageSourcePtr top,\n                          virStorageSourcePtr target)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    return qemuMonitorJSONDiskNameLookup(mon, device, top, target);\n}"
  },
  {
    "function_name": "qemuMonitorSupportsActiveCommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3111-3118",
    "snippet": "bool\nqemuMonitorSupportsActiveCommit(qemuMonitorPtr mon)\n{\n    if (!mon)\n        return false;\n\n    return qemuMonitorJSONSupportsActiveCommit(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSupportsActiveCommit",
          "args": [
            "mon"
          ],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSupportsActiveCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4574-4602",
          "snippet": "bool\nqemuMonitorJSONSupportsActiveCommit(qemuMonitorPtr mon)\n{\n    bool ret = false;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"block-commit\", \"s:device\",\n                                           \"bogus\", NULL)))\n        return false;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"DeviceNotFound\")) {\n        VIR_DEBUG(\"block-commit supports active commit\");\n        ret = true;\n        goto cleanup;\n    }\n\n    /* This is a false negative for qemu 2.0; but probably not\n     * worth the additional complexity to worry about it */\n    VIR_DEBUG(\"block-commit requires 'top' parameter, \"\n              \"assuming it lacks active commit\");\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nbool\nqemuMonitorJSONSupportsActiveCommit(qemuMonitorPtr mon)\n{\n    bool ret = false;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"block-commit\", \"s:device\",\n                                           \"bogus\", NULL)))\n        return false;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"DeviceNotFound\")) {\n        VIR_DEBUG(\"block-commit supports active commit\");\n        ret = true;\n        goto cleanup;\n    }\n\n    /* This is a false negative for qemu 2.0; but probably not\n     * worth the additional complexity to worry about it */\n    VIR_DEBUG(\"block-commit requires 'top' parameter, \"\n              \"assuming it lacks active commit\");\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nbool\nqemuMonitorSupportsActiveCommit(qemuMonitorPtr mon)\n{\n    if (!mon)\n        return false;\n\n    return qemuMonitorJSONSupportsActiveCommit(mon);\n}"
  },
  {
    "function_name": "qemuMonitorBlockCommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3085-3107",
    "snippet": "int\nqemuMonitorBlockCommit(qemuMonitorPtr mon,\n                       const char *device,\n                       const char *jobname,\n                       bool persistjob,\n                       const char *top,\n                       const char *topNode,\n                       const char *base,\n                       const char *baseNode,\n                       const char *backingName,\n                       unsigned long long bandwidth)\n{\n    VIR_DEBUG(\"device=%s, jobname=%s, persistjob=%d, top=%s, topNode=%s, \"\n              \"base=%s, baseNode=%s, backingName=%s, bandwidth=%llu\",\n              device, NULLSTR(jobname), persistjob, NULLSTR(top), NULLSTR(topNode),\n              NULLSTR(base), NULLSTR(baseNode), NULLSTR(backingName), bandwidth);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockCommit(mon, device, jobname, persistjob, top,\n                                      topNode, base, baseNode, backingName,\n                                      bandwidth);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONBlockCommit",
          "args": [
            "mon",
            "device",
            "jobname",
            "persistjob",
            "top",
            "topNode",
            "base",
            "baseNode",
            "backingName",
            "bandwidth"
          ],
          "line": 3104
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONBlockCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4607-4656",
          "snippet": "int\nqemuMonitorJSONBlockCommit(qemuMonitorPtr mon,\n                           const char *device,\n                           const char *jobname,\n                           bool persistjob,\n                           const char *top,\n                           const char *topNode,\n                           const char *base,\n                           const char *baseNode,\n                           const char *backingName,\n                           unsigned long long speed)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virTristateBool autofinalize = VIR_TRISTATE_BOOL_ABSENT;\n    virTristateBool autodismiss = VIR_TRISTATE_BOOL_ABSENT;\n\n    if (persistjob) {\n        autofinalize = VIR_TRISTATE_BOOL_YES;\n        autodismiss = VIR_TRISTATE_BOOL_NO;\n    }\n\n    cmd = qemuMonitorJSONMakeCommand(\"block-commit\",\n                                     \"s:device\", device,\n                                     \"S:job-id\", jobname,\n                                     \"Y:speed\", speed,\n                                     \"S:top\", top,\n                                     \"S:top-node\", topNode,\n                                     \"S:base\", base,\n                                     \"S:base-node\", baseNode,\n                                     \"S:backing-file\", backingName,\n                                     \"T:auto-finalize\", autofinalize,\n                                     \"T:auto-dismiss\", autodismiss,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONBlockCommit(qemuMonitorPtr mon,\n                           const char *device,\n                           const char *jobname,\n                           bool persistjob,\n                           const char *top,\n                           const char *topNode,\n                           const char *base,\n                           const char *baseNode,\n                           const char *backingName,\n                           unsigned long long speed)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virTristateBool autofinalize = VIR_TRISTATE_BOOL_ABSENT;\n    virTristateBool autodismiss = VIR_TRISTATE_BOOL_ABSENT;\n\n    if (persistjob) {\n        autofinalize = VIR_TRISTATE_BOOL_YES;\n        autodismiss = VIR_TRISTATE_BOOL_NO;\n    }\n\n    cmd = qemuMonitorJSONMakeCommand(\"block-commit\",\n                                     \"s:device\", device,\n                                     \"S:job-id\", jobname,\n                                     \"Y:speed\", speed,\n                                     \"S:top\", top,\n                                     \"S:top-node\", topNode,\n                                     \"S:base\", base,\n                                     \"S:base-node\", baseNode,\n                                     \"S:backing-file\", backingName,\n                                     \"T:auto-finalize\", autofinalize,\n                                     \"T:auto-dismiss\", autodismiss,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"device=%s, jobname=%s, persistjob=%d, top=%s, topNode=%s, \"\n              \"base=%s, baseNode=%s, backingName=%s, bandwidth=%llu\"",
            "device",
            "NULLSTR(jobname)",
            "persistjob",
            "NULLSTR(top)",
            "NULLSTR(topNode)",
            "NULLSTR(base)",
            "NULLSTR(baseNode)",
            "NULLSTR(backingName)",
            "bandwidth"
          ],
          "line": 3097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "backingName"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "baseNode"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "base"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "topNode"
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "top"
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "jobname"
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockCommit(qemuMonitorPtr mon,\n                       const char *device,\n                       const char *jobname,\n                       bool persistjob,\n                       const char *top,\n                       const char *topNode,\n                       const char *base,\n                       const char *baseNode,\n                       const char *backingName,\n                       unsigned long long bandwidth)\n{\n    VIR_DEBUG(\"device=%s, jobname=%s, persistjob=%d, top=%s, topNode=%s, \"\n              \"base=%s, baseNode=%s, backingName=%s, bandwidth=%llu\",\n              device, NULLSTR(jobname), persistjob, NULLSTR(top), NULLSTR(topNode),\n              NULLSTR(base), NULLSTR(baseNode), NULLSTR(backingName), bandwidth);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockCommit(mon, device, jobname, persistjob, top,\n                                      topNode, base, baseNode, backingName,\n                                      bandwidth);\n}"
  },
  {
    "function_name": "qemuMonitorTransaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3073-3081",
    "snippet": "int\nqemuMonitorTransaction(qemuMonitorPtr mon, virJSONValuePtr *actions)\n{\n    VIR_DEBUG(\"actions=%p\", *actions);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONTransaction(mon, actions);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONTransaction",
          "args": [
            "mon",
            "actions"
          ],
          "line": 3080
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4545-4569",
          "snippet": "int\nqemuMonitorJSONTransaction(qemuMonitorPtr mon, virJSONValuePtr *actions)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"transaction\",\n                                     \"a:actions\", actions,\n                                     NULL);\n    if (!cmd)\n        goto cleanup;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONTransaction(qemuMonitorPtr mon, virJSONValuePtr *actions)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"transaction\",\n                                     \"a:actions\", actions,\n                                     NULL);\n    if (!cmd)\n        goto cleanup;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"actions=%p\"",
            "*actions"
          ],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransaction(qemuMonitorPtr mon, virJSONValuePtr *actions)\n{\n    VIR_DEBUG(\"actions=%p\", *actions);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONTransaction(mon, actions);\n}"
  },
  {
    "function_name": "qemuMonitorBlockdevMirror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3049-3069",
    "snippet": "int\nqemuMonitorBlockdevMirror(qemuMonitorPtr mon,\n                          const char *jobname,\n                          bool persistjob,\n                          const char *device,\n                          const char *target,\n                          unsigned long long bandwidth,\n                          unsigned int granularity,\n                          unsigned long long buf_size,\n                          bool shallow)\n{\n    VIR_DEBUG(\"jobname=%s, persistjob=%d, device=%s, target=%s, bandwidth=%lld, \"\n              \"granularity=%#x, buf_size=%lld, shallow=%d\",\n              NULLSTR(jobname), persistjob, device, target, bandwidth, granularity,\n              buf_size, shallow);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevMirror(mon, jobname, persistjob, device, target,\n                                         bandwidth, granularity, buf_size, shallow);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONBlockdevMirror",
          "args": [
            "mon",
            "jobname",
            "persistjob",
            "device",
            "target",
            "bandwidth",
            "granularity",
            "buf_size",
            "shallow"
          ],
          "line": 3067
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONBlockdevMirror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4503-4542",
          "snippet": "int\nqemuMonitorJSONBlockdevMirror(qemuMonitorPtr mon,\n                              const char *jobname,\n                              bool persistjob,\n                              const char *device,\n                              const char *target,\n                              unsigned long long speed,\n                              unsigned int granularity,\n                              unsigned long long buf_size,\n                              bool shallow)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n    virTristateBool autofinalize = VIR_TRISTATE_BOOL_ABSENT;\n    virTristateBool autodismiss = VIR_TRISTATE_BOOL_ABSENT;\n\n    if (persistjob) {\n        autofinalize = VIR_TRISTATE_BOOL_YES;\n        autodismiss = VIR_TRISTATE_BOOL_NO;\n    }\n\n    cmd = qemuMonitorJSONMakeCommand(\"blockdev-mirror\",\n                                     \"S:job-id\", jobname,\n                                     \"s:device\", device,\n                                     \"s:target\", target,\n                                     \"Y:speed\", speed,\n                                     \"z:granularity\", granularity,\n                                     \"P:buf-size\", buf_size,\n                                     \"s:sync\", shallow ? \"top\" : \"full\",\n                                     \"T:auto-finalize\", autofinalize,\n                                     \"T:auto-dismiss\", autodismiss,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    return qemuMonitorJSONCheckError(cmd, reply);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONBlockdevMirror(qemuMonitorPtr mon,\n                              const char *jobname,\n                              bool persistjob,\n                              const char *device,\n                              const char *target,\n                              unsigned long long speed,\n                              unsigned int granularity,\n                              unsigned long long buf_size,\n                              bool shallow)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n    virTristateBool autofinalize = VIR_TRISTATE_BOOL_ABSENT;\n    virTristateBool autodismiss = VIR_TRISTATE_BOOL_ABSENT;\n\n    if (persistjob) {\n        autofinalize = VIR_TRISTATE_BOOL_YES;\n        autodismiss = VIR_TRISTATE_BOOL_NO;\n    }\n\n    cmd = qemuMonitorJSONMakeCommand(\"blockdev-mirror\",\n                                     \"S:job-id\", jobname,\n                                     \"s:device\", device,\n                                     \"s:target\", target,\n                                     \"Y:speed\", speed,\n                                     \"z:granularity\", granularity,\n                                     \"P:buf-size\", buf_size,\n                                     \"s:sync\", shallow ? \"top\" : \"full\",\n                                     \"T:auto-finalize\", autofinalize,\n                                     \"T:auto-dismiss\", autodismiss,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    return qemuMonitorJSONCheckError(cmd, reply);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"jobname=%s, persistjob=%d, device=%s, target=%s, bandwidth=%lld, \"\n              \"granularity=%#x, buf_size=%lld, shallow=%d\"",
            "NULLSTR(jobname)",
            "persistjob",
            "device",
            "target",
            "bandwidth",
            "granularity",
            "buf_size",
            "shallow"
          ],
          "line": 3060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "jobname"
          ],
          "line": 3062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockdevMirror(qemuMonitorPtr mon,\n                          const char *jobname,\n                          bool persistjob,\n                          const char *device,\n                          const char *target,\n                          unsigned long long bandwidth,\n                          unsigned int granularity,\n                          unsigned long long buf_size,\n                          bool shallow)\n{\n    VIR_DEBUG(\"jobname=%s, persistjob=%d, device=%s, target=%s, bandwidth=%lld, \"\n              \"granularity=%#x, buf_size=%lld, shallow=%d\",\n              NULLSTR(jobname), persistjob, device, target, bandwidth, granularity,\n              buf_size, shallow);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevMirror(mon, jobname, persistjob, device, target,\n                                         bandwidth, granularity, buf_size, shallow);\n}"
  },
  {
    "function_name": "qemuMonitorDriveMirror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3029-3046",
    "snippet": "int\nqemuMonitorDriveMirror(qemuMonitorPtr mon,\n                       const char *device, const char *file,\n                       const char *format, unsigned long long bandwidth,\n                       unsigned int granularity, unsigned long long buf_size,\n                       bool shallow,\n                       bool reuse)\n{\n    VIR_DEBUG(\"device=%s, file=%s, format=%s, bandwidth=%lld, \"\n              \"granularity=%#x, buf_size=%lld, shallow=%d, reuse=%d\",\n              device, file, NULLSTR(format), bandwidth, granularity,\n              buf_size, shallow, reuse);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONDriveMirror(mon, device, file, format, bandwidth,\n                                      granularity, buf_size, shallow, reuse);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONDriveMirror",
          "args": [
            "mon",
            "device",
            "file",
            "format",
            "bandwidth",
            "granularity",
            "buf_size",
            "shallow",
            "reuse"
          ],
          "line": 3044
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONDriveMirror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4471-4500",
          "snippet": "int\nqemuMonitorJSONDriveMirror(qemuMonitorPtr mon,\n                           const char *device, const char *file,\n                           const char *format, unsigned long long speed,\n                           unsigned int granularity,\n                           unsigned long long buf_size,\n                           bool shallow,\n                           bool reuse)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"drive-mirror\",\n                                     \"s:device\", device,\n                                     \"s:target\", file,\n                                     \"Y:speed\", speed,\n                                     \"z:granularity\", granularity,\n                                     \"P:buf-size\", buf_size,\n                                     \"s:sync\", shallow ? \"top\" : \"full\",\n                                     \"s:mode\", reuse ? \"existing\" : \"absolute-paths\",\n                                     \"S:format\", format,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    return qemuMonitorJSONCheckError(cmd, reply);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONDriveMirror(qemuMonitorPtr mon,\n                           const char *device, const char *file,\n                           const char *format, unsigned long long speed,\n                           unsigned int granularity,\n                           unsigned long long buf_size,\n                           bool shallow,\n                           bool reuse)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"drive-mirror\",\n                                     \"s:device\", device,\n                                     \"s:target\", file,\n                                     \"Y:speed\", speed,\n                                     \"z:granularity\", granularity,\n                                     \"P:buf-size\", buf_size,\n                                     \"s:sync\", shallow ? \"top\" : \"full\",\n                                     \"s:mode\", reuse ? \"existing\" : \"absolute-paths\",\n                                     \"S:format\", format,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    return qemuMonitorJSONCheckError(cmd, reply);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"device=%s, file=%s, format=%s, bandwidth=%lld, \"\n              \"granularity=%#x, buf_size=%lld, shallow=%d, reuse=%d\"",
            "device",
            "file",
            "NULLSTR(format)",
            "bandwidth",
            "granularity",
            "buf_size",
            "shallow",
            "reuse"
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "format"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorDriveMirror(qemuMonitorPtr mon,\n                       const char *device, const char *file,\n                       const char *format, unsigned long long bandwidth,\n                       unsigned int granularity, unsigned long long buf_size,\n                       bool shallow,\n                       bool reuse)\n{\n    VIR_DEBUG(\"device=%s, file=%s, format=%s, bandwidth=%lld, \"\n              \"granularity=%#x, buf_size=%lld, shallow=%d, reuse=%d\",\n              device, file, NULLSTR(format), bandwidth, granularity,\n              buf_size, shallow, reuse);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONDriveMirror(mon, device, file, format, bandwidth,\n                                      granularity, buf_size, shallow, reuse);\n}"
  },
  {
    "function_name": "qemuMonitorDeleteSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3016-3025",
    "snippet": "int\nqemuMonitorDeleteSnapshot(qemuMonitorPtr mon, const char *name)\n{\n    VIR_DEBUG(\"name=%s\", name);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    /* there won't ever be a direct QMP replacement for this function */\n    return qemuMonitorTextDeleteSnapshot(mon, name);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorTextDeleteSnapshot",
          "args": [
            "mon",
            "name"
          ],
          "line": 3024
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTextDeleteSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_text.c",
          "lines": "202-233",
          "snippet": "int qemuMonitorTextDeleteSnapshot(qemuMonitorPtr mon, const char *name)\n{\n    char *cmd = NULL;\n    char *reply = NULL;\n    int ret = -1;\n\n    cmd = g_strdup_printf(\"delvm \\\"%s\\\"\", name);\n    if (qemuMonitorJSONHumanCommand(mon, cmd, &reply))\n        goto cleanup;\n\n    if (strstr(reply, \"No block device supports snapshots\")) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"this domain does not have a device to delete snapshots\"));\n        goto cleanup;\n    } else if (strstr(reply, \"Snapshots not supported on device\")) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\", reply);\n        goto cleanup;\n    } else if (strstr(reply, \"Error: \") ||\n               (strstr(reply, \"Error\") &&\n                strstr(reply, \"while deleting snapshot\"))) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Failed to delete snapshot: %s\"), reply);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(cmd);\n    VIR_FREE(reply);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include <config.h>\n\nint qemuMonitorTextDeleteSnapshot(qemuMonitorPtr mon, const char *name)\n{\n    char *cmd = NULL;\n    char *reply = NULL;\n    int ret = -1;\n\n    cmd = g_strdup_printf(\"delvm \\\"%s\\\"\", name);\n    if (qemuMonitorJSONHumanCommand(mon, cmd, &reply))\n        goto cleanup;\n\n    if (strstr(reply, \"No block device supports snapshots\")) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"this domain does not have a device to delete snapshots\"));\n        goto cleanup;\n    } else if (strstr(reply, \"Snapshots not supported on device\")) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\", reply);\n        goto cleanup;\n    } else if (strstr(reply, \"Error: \") ||\n               (strstr(reply, \"Error\") &&\n                strstr(reply, \"while deleting snapshot\"))) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Failed to delete snapshot: %s\"), reply);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(cmd);\n    VIR_FREE(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"name=%s\"",
            "name"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorDeleteSnapshot(qemuMonitorPtr mon, const char *name)\n{\n    VIR_DEBUG(\"name=%s\", name);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    /* there won't ever be a direct QMP replacement for this function */\n    return qemuMonitorTextDeleteSnapshot(mon, name);\n}"
  },
  {
    "function_name": "qemuMonitorLoadSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "3004-3013",
    "snippet": "int\nqemuMonitorLoadSnapshot(qemuMonitorPtr mon, const char *name)\n{\n    VIR_DEBUG(\"name=%s\", name);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    /* there won't ever be a direct QMP replacement for this function */\n    return qemuMonitorTextLoadSnapshot(mon, name);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorTextLoadSnapshot",
          "args": [
            "mon",
            "name"
          ],
          "line": 3012
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTextLoadSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_text.c",
          "lines": "160-200",
          "snippet": "int qemuMonitorTextLoadSnapshot(qemuMonitorPtr mon, const char *name)\n{\n    char *cmd = NULL;\n    char *reply = NULL;\n    int ret = -1;\n\n    cmd = g_strdup_printf(\"loadvm \\\"%s\\\"\", name);\n\n    if (qemuMonitorJSONHumanCommand(mon, cmd, &reply))\n        goto cleanup;\n\n    if (strstr(reply, \"No block device supports snapshots\")) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"this domain does not have a device to load snapshots\"));\n        goto cleanup;\n    } else if (strstr(reply, \"Could not find snapshot\")) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"the snapshot '%s' does not exist, and was not loaded\"),\n                       name);\n        goto cleanup;\n    } else if (strstr(reply, \"Snapshots not supported on device\")) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Failed to load snapshot: %s\"), reply);\n        goto cleanup;\n    } else if (strstr(reply, \"Could not open VM state file\") ||\n               strstr(reply, \"Error: \") ||\n               (strstr(reply, \"Error\") &&\n                (strstr(reply, \"while loading VM state\") ||\n                 strstr(reply, \"while activating snapshot on\")))) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Failed to load snapshot: %s\"), reply);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(cmd);\n    VIR_FREE(reply);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include <config.h>\n\nint qemuMonitorTextLoadSnapshot(qemuMonitorPtr mon, const char *name)\n{\n    char *cmd = NULL;\n    char *reply = NULL;\n    int ret = -1;\n\n    cmd = g_strdup_printf(\"loadvm \\\"%s\\\"\", name);\n\n    if (qemuMonitorJSONHumanCommand(mon, cmd, &reply))\n        goto cleanup;\n\n    if (strstr(reply, \"No block device supports snapshots\")) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"this domain does not have a device to load snapshots\"));\n        goto cleanup;\n    } else if (strstr(reply, \"Could not find snapshot\")) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"the snapshot '%s' does not exist, and was not loaded\"),\n                       name);\n        goto cleanup;\n    } else if (strstr(reply, \"Snapshots not supported on device\")) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Failed to load snapshot: %s\"), reply);\n        goto cleanup;\n    } else if (strstr(reply, \"Could not open VM state file\") ||\n               strstr(reply, \"Error: \") ||\n               (strstr(reply, \"Error\") &&\n                (strstr(reply, \"while loading VM state\") ||\n                 strstr(reply, \"while activating snapshot on\")))) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Failed to load snapshot: %s\"), reply);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(cmd);\n    VIR_FREE(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 3009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"name=%s\"",
            "name"
          ],
          "line": 3007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorLoadSnapshot(qemuMonitorPtr mon, const char *name)\n{\n    VIR_DEBUG(\"name=%s\", name);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    /* there won't ever be a direct QMP replacement for this function */\n    return qemuMonitorTextLoadSnapshot(mon, name);\n}"
  },
  {
    "function_name": "qemuMonitorCreateSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2993-3002",
    "snippet": "int\nqemuMonitorCreateSnapshot(qemuMonitorPtr mon, const char *name)\n{\n    VIR_DEBUG(\"name=%s\", name);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    /* there won't ever be a direct QMP replacement for this function */\n    return qemuMonitorTextCreateSnapshot(mon, name);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorTextCreateSnapshot",
          "args": [
            "mon",
            "name"
          ],
          "line": 3001
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTextCreateSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_text.c",
          "lines": "131-158",
          "snippet": "int\nqemuMonitorTextCreateSnapshot(qemuMonitorPtr mon,\n                              const char *name)\n{\n    g_autofree char *cmd = NULL;\n    g_autofree char *reply = NULL;\n\n    cmd = g_strdup_printf(\"savevm \\\"%s\\\"\", name);\n\n    if (qemuMonitorJSONHumanCommand(mon, cmd, &reply))\n        return -1;\n\n    if (strstr(reply, \"Error while creating snapshot\") ||\n        strstr(reply, \"Could not open VM state file\") ||\n        strstr(reply, \"State blocked by non-migratable device\") ||\n        strstr(reply, \"Error: \") ||\n        (strstr(reply, \"Error\") && strstr(reply, \"while writing VM\"))) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Failed to take snapshot: %s\"), reply);\n        return -1;\n    } else if (strstr(reply, \"No block device can accept snapshots\")) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"this domain does not have a device to take snapshots\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include <config.h>\n\nint\nqemuMonitorTextCreateSnapshot(qemuMonitorPtr mon,\n                              const char *name)\n{\n    g_autofree char *cmd = NULL;\n    g_autofree char *reply = NULL;\n\n    cmd = g_strdup_printf(\"savevm \\\"%s\\\"\", name);\n\n    if (qemuMonitorJSONHumanCommand(mon, cmd, &reply))\n        return -1;\n\n    if (strstr(reply, \"Error while creating snapshot\") ||\n        strstr(reply, \"Could not open VM state file\") ||\n        strstr(reply, \"State blocked by non-migratable device\") ||\n        strstr(reply, \"Error: \") ||\n        (strstr(reply, \"Error\") && strstr(reply, \"while writing VM\"))) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Failed to take snapshot: %s\"), reply);\n        return -1;\n    } else if (strstr(reply, \"No block device can accept snapshots\")) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"this domain does not have a device to take snapshots\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"name=%s\"",
            "name"
          ],
          "line": 2996
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorCreateSnapshot(qemuMonitorPtr mon, const char *name)\n{\n    VIR_DEBUG(\"name=%s\", name);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    /* there won't ever be a direct QMP replacement for this function */\n    return qemuMonitorTextCreateSnapshot(mon, name);\n}"
  },
  {
    "function_name": "qemuMonitorAddDrive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2980-2990",
    "snippet": "int\nqemuMonitorAddDrive(qemuMonitorPtr mon,\n                    const char *drivestr)\n{\n    VIR_DEBUG(\"drive=%s\", drivestr);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    /* there won't ever be a direct QMP replacement for this function */\n    return qemuMonitorTextAddDrive(mon, drivestr);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorTextAddDrive",
          "args": [
            "mon",
            "drivestr"
          ],
          "line": 2989
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTextAddDrive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_text.c",
          "lines": "36-91",
          "snippet": "int qemuMonitorTextAddDrive(qemuMonitorPtr mon,\n                            const char *drivestr)\n{\n    char *cmd = NULL;\n    char *reply = NULL;\n    int ret = -1;\n\n    /* 'dummy' here is just a placeholder since there is no PCI\n     * address required when attaching drives to a controller */\n    cmd = g_strdup_printf(\"drive_add dummy %s\", drivestr);\n\n    if (qemuMonitorJSONHumanCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (strstr(reply, \"unknown command:\")) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"drive hotplug is not supported\"));\n        goto cleanup;\n    }\n\n    if (strstr(reply, \"could not open disk image\")) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"open disk image file failed\"));\n        goto cleanup;\n    }\n\n    if (strstr(reply, \"Could not open\")) {\n        size_t len = strlen(reply);\n        if (reply[len - 1] == '\\n')\n            reply[len - 1] = '\\0';\n\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       reply);\n        goto cleanup;\n    }\n\n    if (strstr(reply, \"Image is not in\")) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Incorrect disk format\"));\n        goto cleanup;\n    }\n\n    if (strstr(reply, \"IOMMU\") ||\n        strstr(reply, \"VFIO\")) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       reply);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(cmd);\n    VIR_FREE(reply);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include <config.h>\n\nint qemuMonitorTextAddDrive(qemuMonitorPtr mon,\n                            const char *drivestr)\n{\n    char *cmd = NULL;\n    char *reply = NULL;\n    int ret = -1;\n\n    /* 'dummy' here is just a placeholder since there is no PCI\n     * address required when attaching drives to a controller */\n    cmd = g_strdup_printf(\"drive_add dummy %s\", drivestr);\n\n    if (qemuMonitorJSONHumanCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (strstr(reply, \"unknown command:\")) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"drive hotplug is not supported\"));\n        goto cleanup;\n    }\n\n    if (strstr(reply, \"could not open disk image\")) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"open disk image file failed\"));\n        goto cleanup;\n    }\n\n    if (strstr(reply, \"Could not open\")) {\n        size_t len = strlen(reply);\n        if (reply[len - 1] == '\\n')\n            reply[len - 1] = '\\0';\n\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       reply);\n        goto cleanup;\n    }\n\n    if (strstr(reply, \"Image is not in\")) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Incorrect disk format\"));\n        goto cleanup;\n    }\n\n    if (strstr(reply, \"IOMMU\") ||\n        strstr(reply, \"VFIO\")) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       reply);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(cmd);\n    VIR_FREE(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"drive=%s\"",
            "drivestr"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorAddDrive(qemuMonitorPtr mon,\n                    const char *drivestr)\n{\n    VIR_DEBUG(\"drive=%s\", drivestr);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    /* there won't ever be a direct QMP replacement for this function */\n    return qemuMonitorTextAddDrive(mon, drivestr);\n}"
  },
  {
    "function_name": "qemuMonitorDelObject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2967-2977",
    "snippet": "int\nqemuMonitorDelObject(qemuMonitorPtr mon,\n                     const char *objalias,\n                     bool report_error)\n{\n    VIR_DEBUG(\"objalias=%s\", objalias);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONDelObject(mon, objalias, report_error);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONDelObject",
          "args": [
            "mon",
            "objalias",
            "report_error"
          ],
          "line": 2976
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONDelObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4449-4467",
          "snippet": "int\nqemuMonitorJSONDelObject(qemuMonitorPtr mon,\n                         const char *objalias,\n                         bool report_error)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"object-del\", \"s:id\", objalias, NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckErrorFull(cmd, reply, report_error) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONDelObject(qemuMonitorPtr mon,\n                         const char *objalias,\n                         bool report_error)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"object-del\", \"s:id\", objalias, NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckErrorFull(cmd, reply, report_error) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"objalias=%s\"",
            "objalias"
          ],
          "line": 2972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorDelObject(qemuMonitorPtr mon,\n                     const char *objalias,\n                     bool report_error)\n{\n    VIR_DEBUG(\"objalias=%s\", objalias);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONDelObject(mon, objalias, report_error);\n}"
  },
  {
    "function_name": "qemuMonitorAddObject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2920-2964",
    "snippet": "int\nqemuMonitorAddObject(qemuMonitorPtr mon,\n                     virJSONValuePtr *props,\n                     char **alias)\n{\n    const char *type = NULL;\n    const char *id = NULL;\n    char *tmp = NULL;\n    int ret = -1;\n\n    if (!*props) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"object props can't be NULL\"));\n        goto cleanup;\n    }\n\n    type = virJSONValueObjectGetString(*props, \"qom-type\");\n    id = virJSONValueObjectGetString(*props, \"id\");\n\n    VIR_DEBUG(\"type=%s id=%s\", NULLSTR(type), NULLSTR(id));\n\n    QEMU_CHECK_MONITOR_GOTO(mon, cleanup);\n\n    if (!id || !type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing alias or qom-type for qemu object '%s'\"),\n                       NULLSTR(type));\n        goto cleanup;\n    }\n\n    if (alias)\n        tmp = g_strdup(id);\n\n    ret = qemuMonitorJSONAddObject(mon, *props);\n    *props = NULL;\n\n    if (alias)\n        *alias = g_steal_pointer(&tmp);\n\n cleanup:\n    VIR_FREE(tmp);\n    virJSONValueFree(*props);\n    *props = NULL;\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueFree",
          "args": [
            "*props"
          ],
          "line": 2961
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "391-423",
          "snippet": "void\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvoid\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 2960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&tmp"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONAddObject",
          "args": [
            "mon",
            "*props"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONAddObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4429-4446",
          "snippet": "int\nqemuMonitorJSONAddObject(qemuMonitorPtr mon,\n                         virJSONValuePtr props)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommandInternal(\"object-add\", props)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONAddObject(qemuMonitorPtr mon,\n                         virJSONValuePtr props)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommandInternal(\"object-add\", props)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "id"
          ],
          "line": 2951
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing alias or qom-type for qemu object '%s'\")",
            "NULLSTR(type)"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "type"
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing alias or qom-type for qemu object '%s'\""
          ],
          "line": 2945
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR_GOTO",
          "args": [
            "mon",
            "cleanup"
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"type=%s id=%s\"",
            "NULLSTR(type)",
            "NULLSTR(id)"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "id"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "type"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "*props",
            "\"id\""
          ],
          "line": 2937
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"object props can't be NULL\")"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorAddObject(qemuMonitorPtr mon,\n                     virJSONValuePtr *props,\n                     char **alias)\n{\n    const char *type = NULL;\n    const char *id = NULL;\n    char *tmp = NULL;\n    int ret = -1;\n\n    if (!*props) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"object props can't be NULL\"));\n        goto cleanup;\n    }\n\n    type = virJSONValueObjectGetString(*props, \"qom-type\");\n    id = virJSONValueObjectGetString(*props, \"id\");\n\n    VIR_DEBUG(\"type=%s id=%s\", NULLSTR(type), NULLSTR(id));\n\n    QEMU_CHECK_MONITOR_GOTO(mon, cleanup);\n\n    if (!id || !type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing alias or qom-type for qemu object '%s'\"),\n                       NULLSTR(type));\n        goto cleanup;\n    }\n\n    if (alias)\n        tmp = g_strdup(id);\n\n    ret = qemuMonitorJSONAddObject(mon, *props);\n    *props = NULL;\n\n    if (alias)\n        *alias = g_steal_pointer(&tmp);\n\n cleanup:\n    VIR_FREE(tmp);\n    virJSONValueFree(*props);\n    *props = NULL;\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorCreateObjectProps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2880-2906",
    "snippet": "int\nqemuMonitorCreateObjectProps(virJSONValuePtr *propsret,\n                             const char *type,\n                             const char *alias,\n                             ...)\n{\n    virJSONValuePtr props = NULL;\n    int ret = -1;\n    va_list args;\n\n    *propsret = NULL;\n\n    va_start(args, alias);\n\n    if (virJSONValueObjectCreateVArgs(&props, args) < 0)\n        goto cleanup;\n\n    if (!(*propsret = qemuMonitorCreateObjectPropsWrap(type, alias, &props)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(props);\n    va_end(args);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 2904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueFree",
          "args": [
            "props"
          ],
          "line": 2903
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "391-423",
          "snippet": "void\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvoid\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorCreateObjectPropsWrap",
          "args": [
            "type",
            "alias",
            "&props"
          ],
          "line": 2897
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCreateObjectPropsWrap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2854-2867",
          "snippet": "virJSONValuePtr\nqemuMonitorCreateObjectPropsWrap(const char *type,\n                                 const char *alias,\n                                 virJSONValuePtr *props)\n{\n    virJSONValuePtr ret;\n\n    ignore_value(virJSONValueObjectCreate(&ret,\n                                          \"s:qom-type\", type,\n                                          \"s:id\", alias,\n                                          \"A:props\", props,\n                                          NULL));\n    return ret;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirJSONValuePtr\nqemuMonitorCreateObjectPropsWrap(const char *type,\n                                 const char *alias,\n                                 virJSONValuePtr *props)\n{\n    virJSONValuePtr ret;\n\n    ignore_value(virJSONValueObjectCreate(&ret,\n                                          \"s:qom-type\", type,\n                                          \"s:id\", alias,\n                                          \"A:props\", props,\n                                          NULL));\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectCreateVArgs",
          "args": [
            "&props",
            "args"
          ],
          "line": 2894
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectCreateVArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "359-374",
          "snippet": "int\nvirJSONValueObjectCreateVArgs(virJSONValuePtr *obj,\n                              va_list args)\n{\n    int ret;\n\n    *obj = virJSONValueNewObject();\n\n    /* free the object on error, or if no value objects were added */\n    if ((ret = virJSONValueObjectAddVArgs(*obj, args)) <= 0) {\n        virJSONValueFree(*obj);\n        *obj = NULL;\n    }\n\n    return ret;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectCreateVArgs(virJSONValuePtr *obj,\n                              va_list args)\n{\n    int ret;\n\n    *obj = virJSONValueNewObject();\n\n    /* free the object on error, or if no value objects were added */\n    if ((ret = virJSONValueObjectAddVArgs(*obj, args)) <= 0) {\n        virJSONValueFree(*obj);\n        *obj = NULL;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "alias"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorCreateObjectProps(virJSONValuePtr *propsret,\n                             const char *type,\n                             const char *alias,\n                             ...)\n{\n    virJSONValuePtr props = NULL;\n    int ret = -1;\n    va_list args;\n\n    *propsret = NULL;\n\n    va_start(args, alias);\n\n    if (virJSONValueObjectCreateVArgs(&props, args) < 0)\n        goto cleanup;\n\n    if (!(*propsret = qemuMonitorCreateObjectPropsWrap(type, alias, &props)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(props);\n    va_end(args);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorCreateObjectPropsWrap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2854-2867",
    "snippet": "virJSONValuePtr\nqemuMonitorCreateObjectPropsWrap(const char *type,\n                                 const char *alias,\n                                 virJSONValuePtr *props)\n{\n    virJSONValuePtr ret;\n\n    ignore_value(virJSONValueObjectCreate(&ret,\n                                          \"s:qom-type\", type,\n                                          \"s:id\", alias,\n                                          \"A:props\", props,\n                                          NULL));\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virJSONValueObjectCreate(&ret,\n                                          \"s:qom-type\", type,\n                                          \"s:id\", alias,\n                                          \"A:props\", props,\n                                          NULL)"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectCreate",
          "args": [
            "&ret",
            "\"s:qom-type\"",
            "type",
            "\"s:id\"",
            "alias",
            "\"A:props\"",
            "props",
            "NULL"
          ],
          "line": 2861
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "377-388",
          "snippet": "int\nvirJSONValueObjectCreate(virJSONValuePtr *obj, ...)\n{\n    va_list args;\n    int ret;\n\n    va_start(args, obj);\n    ret = virJSONValueObjectCreateVArgs(obj, args);\n    va_end(args);\n\n    return ret;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectCreate(virJSONValuePtr *obj, ...)\n{\n    va_list args;\n    int ret;\n\n    va_start(args, obj);\n    ret = virJSONValueObjectCreateVArgs(obj, args);\n    va_end(args);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirJSONValuePtr\nqemuMonitorCreateObjectPropsWrap(const char *type,\n                                 const char *alias,\n                                 virJSONValuePtr *props)\n{\n    virJSONValuePtr ret;\n\n    ignore_value(virJSONValueObjectCreate(&ret,\n                                          \"s:qom-type\", type,\n                                          \"s:id\", alias,\n                                          \"A:props\", props,\n                                          NULL));\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorAddDeviceArgs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2844-2851",
    "snippet": "int\nqemuMonitorAddDeviceArgs(qemuMonitorPtr mon,\n                         virJSONValuePtr args)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONAddDeviceArgs(mon, args);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONAddDeviceArgs",
          "args": [
            "mon",
            "args"
          ],
          "line": 2850
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONAddDeviceArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4386-4413",
          "snippet": "int\nqemuMonitorJSONAddDeviceArgs(qemuMonitorPtr mon,\n                             virJSONValuePtr args)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"device_add\", NULL)))\n        goto cleanup;\n\n    if (virJSONValueObjectAppend(cmd, \"arguments\", args) < 0)\n        goto cleanup;\n    args = NULL; /* obj owns reference to args now */\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(args);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONAddDeviceArgs(qemuMonitorPtr mon,\n                             virJSONValuePtr args)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"device_add\", NULL)))\n        goto cleanup;\n\n    if (virJSONValueObjectAppend(cmd, \"arguments\", args) < 0)\n        goto cleanup;\n    args = NULL; /* obj owns reference to args now */\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(args);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorAddDeviceArgs(qemuMonitorPtr mon,\n                         virJSONValuePtr args)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONAddDeviceArgs(mon, args);\n}"
  },
  {
    "function_name": "qemuMonitorAddDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2828-2833",
    "snippet": "int\nqemuMonitorAddDevice(qemuMonitorPtr mon,\n                     const char *devicestr)\n{\n    return qemuMonitorAddDeviceWithFd(mon, devicestr, -1, NULL);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorAddDeviceWithFd",
          "args": [
            "mon",
            "devicestr",
            "-1",
            "NULL"
          ],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorAddDeviceWithFd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2803-2825",
          "snippet": "int\nqemuMonitorAddDeviceWithFd(qemuMonitorPtr mon,\n                           const char *devicestr,\n                           int fd,\n                           const char *fdname)\n{\n    VIR_DEBUG(\"device=%s fd=%d fdname=%s\", devicestr, fd, NULLSTR(fdname));\n    int ret;\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (fd >= 0 && qemuMonitorSendFileHandle(mon, fdname, fd) < 0)\n        return -1;\n\n    ret = qemuMonitorJSONAddDevice(mon, devicestr);\n\n    if (ret < 0 && fd >= 0) {\n        if (qemuMonitorCloseFileHandle(mon, fdname) < 0)\n            VIR_WARN(\"failed to close device handle '%s'\", fdname);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorAddDeviceWithFd(qemuMonitorPtr mon,\n                           const char *devicestr,\n                           int fd,\n                           const char *fdname)\n{\n    VIR_DEBUG(\"device=%s fd=%d fdname=%s\", devicestr, fd, NULLSTR(fdname));\n    int ret;\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (fd >= 0 && qemuMonitorSendFileHandle(mon, fdname, fd) < 0)\n        return -1;\n\n    ret = qemuMonitorJSONAddDevice(mon, devicestr);\n\n    if (ret < 0 && fd >= 0) {\n        if (qemuMonitorCloseFileHandle(mon, fdname) < 0)\n            VIR_WARN(\"failed to close device handle '%s'\", fdname);\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorAddDevice(qemuMonitorPtr mon,\n                     const char *devicestr)\n{\n    return qemuMonitorAddDeviceWithFd(mon, devicestr, -1, NULL);\n}"
  },
  {
    "function_name": "qemuMonitorAddDeviceWithFd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2803-2825",
    "snippet": "int\nqemuMonitorAddDeviceWithFd(qemuMonitorPtr mon,\n                           const char *devicestr,\n                           int fd,\n                           const char *fdname)\n{\n    VIR_DEBUG(\"device=%s fd=%d fdname=%s\", devicestr, fd, NULLSTR(fdname));\n    int ret;\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (fd >= 0 && qemuMonitorSendFileHandle(mon, fdname, fd) < 0)\n        return -1;\n\n    ret = qemuMonitorJSONAddDevice(mon, devicestr);\n\n    if (ret < 0 && fd >= 0) {\n        if (qemuMonitorCloseFileHandle(mon, fdname) < 0)\n            VIR_WARN(\"failed to close device handle '%s'\", fdname);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"failed to close device handle '%s'\"",
            "fdname"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorCloseFileHandle",
          "args": [
            "mon",
            "fdname"
          ],
          "line": 2820
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCloseFileHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2626-2644",
          "snippet": "int\nqemuMonitorCloseFileHandle(qemuMonitorPtr mon,\n                           const char *fdname)\n{\n    int ret = -1;\n    virErrorPtr error;\n\n    VIR_DEBUG(\"fdname=%s\", fdname);\n\n    virErrorPreserveLast(&error);\n\n    QEMU_CHECK_MONITOR_GOTO(mon, cleanup);\n\n    ret = qemuMonitorJSONCloseFileHandle(mon, fdname);\n\n cleanup:\n    virErrorRestore(&error);\n    return ret;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorCloseFileHandle(qemuMonitorPtr mon,\n                           const char *fdname)\n{\n    int ret = -1;\n    virErrorPtr error;\n\n    VIR_DEBUG(\"fdname=%s\", fdname);\n\n    virErrorPreserveLast(&error);\n\n    QEMU_CHECK_MONITOR_GOTO(mon, cleanup);\n\n    ret = qemuMonitorJSONCloseFileHandle(mon, fdname);\n\n cleanup:\n    virErrorRestore(&error);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONAddDevice",
          "args": [
            "mon",
            "devicestr"
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONAddDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4416-4426",
          "snippet": "int\nqemuMonitorJSONAddDevice(qemuMonitorPtr mon,\n                         const char *devicestr)\n{\n    virJSONValuePtr args;\n\n    if (!(args = qemuMonitorJSONKeywordStringToJSON(devicestr, \"driver\")))\n        return -1;\n\n    return qemuMonitorJSONAddDeviceArgs(mon, args);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONAddDevice(qemuMonitorPtr mon,\n                         const char *devicestr)\n{\n    virJSONValuePtr args;\n\n    if (!(args = qemuMonitorJSONKeywordStringToJSON(devicestr, \"driver\")))\n        return -1;\n\n    return qemuMonitorJSONAddDeviceArgs(mon, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorSendFileHandle",
          "args": [
            "mon",
            "fdname",
            "fd"
          ],
          "line": 2814
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorSendFileHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2607-2623",
          "snippet": "int\nqemuMonitorSendFileHandle(qemuMonitorPtr mon,\n                          const char *fdname,\n                          int fd)\n{\n    VIR_DEBUG(\"fdname=%s fd=%d\", fdname, fd);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (fd < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"fd must be valid\"));\n        return -1;\n    }\n\n    return qemuMonitorJSONSendFileHandle(mon, fdname, fd);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSendFileHandle(qemuMonitorPtr mon,\n                          const char *fdname,\n                          int fd)\n{\n    VIR_DEBUG(\"fdname=%s fd=%d\", fdname, fd);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (fd < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"fd must be valid\"));\n        return -1;\n    }\n\n    return qemuMonitorJSONSendFileHandle(mon, fdname, fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"device=%s fd=%d fdname=%s\"",
            "devicestr",
            "fd",
            "NULLSTR(fdname)"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "fdname"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorAddDeviceWithFd(qemuMonitorPtr mon,\n                           const char *devicestr,\n                           int fd,\n                           const char *fdname)\n{\n    VIR_DEBUG(\"device=%s fd=%d fdname=%s\", devicestr, fd, NULLSTR(fdname));\n    int ret;\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (fd >= 0 && qemuMonitorSendFileHandle(mon, fdname, fd) < 0)\n        return -1;\n\n    ret = qemuMonitorJSONAddDevice(mon, devicestr);\n\n    if (ret < 0 && fd >= 0) {\n        if (qemuMonitorCloseFileHandle(mon, fdname) < 0)\n            VIR_WARN(\"failed to close device handle '%s'\", fdname);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorDelDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2791-2800",
    "snippet": "int\nqemuMonitorDelDevice(qemuMonitorPtr mon,\n                     const char *devalias)\n{\n    VIR_DEBUG(\"devalias=%s\", devalias);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONDelDevice(mon, devalias);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONDelDevice",
          "args": [
            "mon",
            "devalias"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONDelDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4354-4383",
          "snippet": "int qemuMonitorJSONDelDevice(qemuMonitorPtr mon,\n                             const char *devalias)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"device_del\",\n                                     \"s:id\", devalias,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"DeviceNotFound\")) {\n        ret = -2;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONDelDevice(qemuMonitorPtr mon,\n                             const char *devalias)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"device_del\",\n                                     \"s:id\", devalias,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"DeviceNotFound\")) {\n        ret = -2;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"devalias=%s\"",
            "devalias"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorDelDevice(qemuMonitorPtr mon,\n                     const char *devalias)\n{\n    VIR_DEBUG(\"devalias=%s\", devalias);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONDelDevice(mon, devalias);\n}"
  },
  {
    "function_name": "qemuMonitorDriveDel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2768-2778",
    "snippet": "int\nqemuMonitorDriveDel(qemuMonitorPtr mon,\n                    const char *drivestr)\n{\n    VIR_DEBUG(\"drivestr=%s\", drivestr);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    /* there won't be a direct replacement for drive_del in QMP */\n    return qemuMonitorTextDriveDel(mon, drivestr);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorTextDriveDel",
          "args": [
            "mon",
            "drivestr"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTextDriveDel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_text.c",
          "lines": "94-129",
          "snippet": "int qemuMonitorTextDriveDel(qemuMonitorPtr mon,\n                            const char *drivestr)\n{\n    char *cmd = NULL;\n    char *reply = NULL;\n    int ret = -1;\n\n    cmd = g_strdup_printf(\"drive_del %s\", drivestr);\n\n    if (qemuMonitorJSONHumanCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (strstr(reply, \"unknown command:\")) {\n        VIR_ERROR(_(\"deleting drive is not supported.  \"\n                    \"This may leak data if disk is reassigned\"));\n        ret = 1;\n        goto cleanup;\n\n    /* (qemu) drive_del wark\n     * Device 'wark' not found */\n    } else if (strstr(reply, \"Device '\") && strstr(reply, \"not found\")) {\n        /* NB: device not found errors mean the drive was auto-deleted and we\n         * ignore the error */\n    } else if (STRNEQ(reply, \"\")) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"deleting %s drive failed: %s\"), drivestr, reply);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(cmd);\n    VIR_FREE(reply);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include <config.h>\n\nint qemuMonitorTextDriveDel(qemuMonitorPtr mon,\n                            const char *drivestr)\n{\n    char *cmd = NULL;\n    char *reply = NULL;\n    int ret = -1;\n\n    cmd = g_strdup_printf(\"drive_del %s\", drivestr);\n\n    if (qemuMonitorJSONHumanCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (strstr(reply, \"unknown command:\")) {\n        VIR_ERROR(_(\"deleting drive is not supported.  \"\n                    \"This may leak data if disk is reassigned\"));\n        ret = 1;\n        goto cleanup;\n\n    /* (qemu) drive_del wark\n     * Device 'wark' not found */\n    } else if (strstr(reply, \"Device '\") && strstr(reply, \"not found\")) {\n        /* NB: device not found errors mean the drive was auto-deleted and we\n         * ignore the error */\n    } else if (STRNEQ(reply, \"\")) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"deleting %s drive failed: %s\"), drivestr, reply);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(cmd);\n    VIR_FREE(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"drivestr=%s\"",
            "drivestr"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorDriveDel(qemuMonitorPtr mon,\n                    const char *drivestr)\n{\n    VIR_DEBUG(\"drivestr=%s\", drivestr);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    /* there won't be a direct replacement for drive_del in QMP */\n    return qemuMonitorTextDriveDel(mon, drivestr);\n}"
  },
  {
    "function_name": "qemuMonitorGetChardevInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2732-2758",
    "snippet": "int\nqemuMonitorGetChardevInfo(qemuMonitorPtr mon,\n                          virHashTablePtr *retinfo)\n{\n    int ret;\n    virHashTablePtr info = NULL;\n\n    VIR_DEBUG(\"retinfo=%p\", retinfo);\n\n    QEMU_CHECK_MONITOR_GOTO(mon, error);\n\n    if (!(info = virHashCreate(10, qemuMonitorChardevInfoFree)))\n        goto error;\n\n    ret = qemuMonitorJSONGetChardevInfo(mon, info);\n\n    if (ret < 0)\n        goto error;\n\n    *retinfo = info;\n    return 0;\n\n error:\n    virHashFree(info);\n    *retinfo = NULL;\n    return -1;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "info"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetChardevInfo",
          "args": [
            "mon",
            "info"
          ],
          "line": 2746
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetChardevInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4327-4351",
          "snippet": "int\nqemuMonitorJSONGetChardevInfo(qemuMonitorPtr mon,\n                              virHashTablePtr info)\n\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"query-chardev\",\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorJSONExtractChardevInfo(reply, info);\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONGetChardevInfo(qemuMonitorPtr mon,\n                              virHashTablePtr info)\n\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"query-chardev\",\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorJSONExtractChardevInfo(reply, info);\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "10",
            "qemuMonitorChardevInfoFree"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR_GOTO",
          "args": [
            "mon",
            "error"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"retinfo=%p\"",
            "retinfo"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetChardevInfo(qemuMonitorPtr mon,\n                          virHashTablePtr *retinfo)\n{\n    int ret;\n    virHashTablePtr info = NULL;\n\n    VIR_DEBUG(\"retinfo=%p\", retinfo);\n\n    QEMU_CHECK_MONITOR_GOTO(mon, error);\n\n    if (!(info = virHashCreate(10, qemuMonitorChardevInfoFree)))\n        goto error;\n\n    ret = qemuMonitorJSONGetChardevInfo(mon, info);\n\n    if (ret < 0)\n        goto error;\n\n    *retinfo = info;\n    return 0;\n\n error:\n    virHashFree(info);\n    *retinfo = NULL;\n    return -1;\n}"
  },
  {
    "function_name": "qemuMonitorChardevInfoFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2722-2729",
    "snippet": "void\nqemuMonitorChardevInfoFree(void *data)\n{\n    qemuMonitorChardevInfoPtr info = data;\n\n    VIR_FREE(info->ptyPath);\n    VIR_FREE(info);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "info"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "info->ptyPath"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorChardevInfoFree(void *data)\n{\n    qemuMonitorChardevInfoPtr info = data;\n\n    VIR_FREE(info->ptyPath);\n    VIR_FREE(info);\n}"
  },
  {
    "function_name": "qemuMonitorQueryRxFilter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2710-2719",
    "snippet": "int\nqemuMonitorQueryRxFilter(qemuMonitorPtr mon, const char *alias,\n                         virNetDevRxFilterPtr *filter)\n{\n    VIR_DEBUG(\"alias=%s filter=%p\", alias, filter);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONQueryRxFilter(mon, alias, filter);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONQueryRxFilter",
          "args": [
            "mon",
            "alias",
            "filter"
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONQueryRxFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4214-4245",
          "snippet": "int\nqemuMonitorJSONQueryRxFilter(qemuMonitorPtr mon, const char *alias,\n                             virNetDevRxFilterPtr *filter)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"query-rx-filter\",\n                                                     \"s:name\", alias,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n\n    if (!cmd)\n        goto cleanup;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONQueryRxFilterParse(reply, filter) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        virNetDevRxFilterFree(*filter);\n        *filter = NULL;\n    }\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONQueryRxFilter(qemuMonitorPtr mon, const char *alias,\n                             virNetDevRxFilterPtr *filter)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"query-rx-filter\",\n                                                     \"s:name\", alias,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n\n    if (!cmd)\n        goto cleanup;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONQueryRxFilterParse(reply, filter) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        virNetDevRxFilterFree(*filter);\n        *filter = NULL;\n    }\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"alias=%s filter=%p\"",
            "alias",
            "filter"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorQueryRxFilter(qemuMonitorPtr mon, const char *alias,\n                         virNetDevRxFilterPtr *filter)\n{\n    VIR_DEBUG(\"alias=%s filter=%p\", alias, filter);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONQueryRxFilter(mon, alias, filter);\n}"
  },
  {
    "function_name": "qemuMonitorRemoveNetdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2698-2707",
    "snippet": "int\nqemuMonitorRemoveNetdev(qemuMonitorPtr mon,\n                        const char *alias)\n{\n    VIR_DEBUG(\"alias=%s\", alias);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONRemoveNetdev(mon, alias);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONRemoveNetdev",
          "args": [
            "mon",
            "alias"
          ],
          "line": 2706
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONRemoveNetdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "4014-4036",
          "snippet": "int qemuMonitorJSONRemoveNetdev(qemuMonitorPtr mon,\n                                const char *alias)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"netdev_del\",\n                                                     \"s:id\", alias,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONRemoveNetdev(qemuMonitorPtr mon,\n                                const char *alias)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"netdev_del\",\n                                                     \"s:id\", alias,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"alias=%s\"",
            "alias"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorRemoveNetdev(qemuMonitorPtr mon,\n                        const char *alias)\n{\n    VIR_DEBUG(\"alias=%s\", alias);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONRemoveNetdev(mon, alias);\n}"
  },
  {
    "function_name": "qemuMonitorAddNetdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2647-2695",
    "snippet": "int\nqemuMonitorAddNetdev(qemuMonitorPtr mon,\n                     const char *netdevstr,\n                     int *tapfd, char **tapfdName, int tapfdSize,\n                     int *vhostfd, char **vhostfdName, int vhostfdSize,\n                     int slirpfd, char *slirpfdName)\n{\n    int ret = -1;\n    size_t i = 0, j = 0;\n\n    VIR_DEBUG(\"netdevstr=%s tapfd=%p tapfdName=%p tapfdSize=%d\"\n              \"vhostfd=%p vhostfdName=%p vhostfdSize=%d\"\n              \"slirpfd=%d slirpfdName=%s\",\n              netdevstr, tapfd, tapfdName, tapfdSize,\n              vhostfd, vhostfdName, vhostfdSize, slirpfd, slirpfdName);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    for (i = 0; i < tapfdSize; i++) {\n        if (qemuMonitorSendFileHandle(mon, tapfdName[i], tapfd[i]) < 0)\n            goto cleanup;\n    }\n    for (j = 0; j < vhostfdSize; j++) {\n        if (qemuMonitorSendFileHandle(mon, vhostfdName[j], vhostfd[j]) < 0)\n            goto cleanup;\n    }\n\n    if (slirpfd > 0 &&\n        qemuMonitorSendFileHandle(mon, slirpfdName, slirpfd) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorJSONAddNetdev(mon, netdevstr);\n\n cleanup:\n    if (ret < 0) {\n        while (i--) {\n            if (qemuMonitorCloseFileHandle(mon, tapfdName[i]) < 0)\n                VIR_WARN(\"failed to close device handle '%s'\", tapfdName[i]);\n        }\n        while (j--) {\n            if (qemuMonitorCloseFileHandle(mon, vhostfdName[j]) < 0)\n                VIR_WARN(\"failed to close device handle '%s'\", vhostfdName[j]);\n        }\n        if (qemuMonitorCloseFileHandle(mon, slirpfdName) < 0)\n            VIR_WARN(\"failed to close device handle '%s'\", slirpfdName);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"failed to close device handle '%s'\"",
            "slirpfdName"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorCloseFileHandle",
          "args": [
            "mon",
            "slirpfdName"
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCloseFileHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2626-2644",
          "snippet": "int\nqemuMonitorCloseFileHandle(qemuMonitorPtr mon,\n                           const char *fdname)\n{\n    int ret = -1;\n    virErrorPtr error;\n\n    VIR_DEBUG(\"fdname=%s\", fdname);\n\n    virErrorPreserveLast(&error);\n\n    QEMU_CHECK_MONITOR_GOTO(mon, cleanup);\n\n    ret = qemuMonitorJSONCloseFileHandle(mon, fdname);\n\n cleanup:\n    virErrorRestore(&error);\n    return ret;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorCloseFileHandle(qemuMonitorPtr mon,\n                           const char *fdname)\n{\n    int ret = -1;\n    virErrorPtr error;\n\n    VIR_DEBUG(\"fdname=%s\", fdname);\n\n    virErrorPreserveLast(&error);\n\n    QEMU_CHECK_MONITOR_GOTO(mon, cleanup);\n\n    ret = qemuMonitorJSONCloseFileHandle(mon, fdname);\n\n cleanup:\n    virErrorRestore(&error);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"failed to close device handle '%s'\"",
            "vhostfdName[j]"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"failed to close device handle '%s'\"",
            "tapfdName[i]"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONAddNetdev",
          "args": [
            "mon",
            "netdevstr"
          ],
          "line": 2678
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONAddNetdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3979-4011",
          "snippet": "int qemuMonitorJSONAddNetdev(qemuMonitorPtr mon,\n                             const char *netdevstr)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr args = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"netdev_add\", NULL);\n    if (!cmd)\n        return -1;\n\n    args = qemuMonitorJSONKeywordStringToJSON(netdevstr, \"type\");\n    if (!args)\n        goto cleanup;\n\n    if (virJSONValueObjectAppend(cmd, \"arguments\", args) < 0)\n        goto cleanup;\n    args = NULL; /* obj owns reference to args now */\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(args);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONAddNetdev(qemuMonitorPtr mon,\n                             const char *netdevstr)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr args = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"netdev_add\", NULL);\n    if (!cmd)\n        return -1;\n\n    args = qemuMonitorJSONKeywordStringToJSON(netdevstr, \"type\");\n    if (!args)\n        goto cleanup;\n\n    if (virJSONValueObjectAppend(cmd, \"arguments\", args) < 0)\n        goto cleanup;\n    args = NULL; /* obj owns reference to args now */\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(args);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorSendFileHandle",
          "args": [
            "mon",
            "slirpfdName",
            "slirpfd"
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorSendFileHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2607-2623",
          "snippet": "int\nqemuMonitorSendFileHandle(qemuMonitorPtr mon,\n                          const char *fdname,\n                          int fd)\n{\n    VIR_DEBUG(\"fdname=%s fd=%d\", fdname, fd);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (fd < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"fd must be valid\"));\n        return -1;\n    }\n\n    return qemuMonitorJSONSendFileHandle(mon, fdname, fd);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSendFileHandle(qemuMonitorPtr mon,\n                          const char *fdname,\n                          int fd)\n{\n    VIR_DEBUG(\"fdname=%s fd=%d\", fdname, fd);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (fd < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"fd must be valid\"));\n        return -1;\n    }\n\n    return qemuMonitorJSONSendFileHandle(mon, fdname, fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"netdevstr=%s tapfd=%p tapfdName=%p tapfdSize=%d\"\n              \"vhostfd=%p vhostfdName=%p vhostfdSize=%d\"\n              \"slirpfd=%d slirpfdName=%s\"",
            "netdevstr",
            "tapfd",
            "tapfdName",
            "tapfdSize",
            "vhostfd",
            "vhostfdName",
            "vhostfdSize",
            "slirpfd",
            "slirpfdName"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorAddNetdev(qemuMonitorPtr mon,\n                     const char *netdevstr,\n                     int *tapfd, char **tapfdName, int tapfdSize,\n                     int *vhostfd, char **vhostfdName, int vhostfdSize,\n                     int slirpfd, char *slirpfdName)\n{\n    int ret = -1;\n    size_t i = 0, j = 0;\n\n    VIR_DEBUG(\"netdevstr=%s tapfd=%p tapfdName=%p tapfdSize=%d\"\n              \"vhostfd=%p vhostfdName=%p vhostfdSize=%d\"\n              \"slirpfd=%d slirpfdName=%s\",\n              netdevstr, tapfd, tapfdName, tapfdSize,\n              vhostfd, vhostfdName, vhostfdSize, slirpfd, slirpfdName);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    for (i = 0; i < tapfdSize; i++) {\n        if (qemuMonitorSendFileHandle(mon, tapfdName[i], tapfd[i]) < 0)\n            goto cleanup;\n    }\n    for (j = 0; j < vhostfdSize; j++) {\n        if (qemuMonitorSendFileHandle(mon, vhostfdName[j], vhostfd[j]) < 0)\n            goto cleanup;\n    }\n\n    if (slirpfd > 0 &&\n        qemuMonitorSendFileHandle(mon, slirpfdName, slirpfd) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorJSONAddNetdev(mon, netdevstr);\n\n cleanup:\n    if (ret < 0) {\n        while (i--) {\n            if (qemuMonitorCloseFileHandle(mon, tapfdName[i]) < 0)\n                VIR_WARN(\"failed to close device handle '%s'\", tapfdName[i]);\n        }\n        while (j--) {\n            if (qemuMonitorCloseFileHandle(mon, vhostfdName[j]) < 0)\n                VIR_WARN(\"failed to close device handle '%s'\", vhostfdName[j]);\n        }\n        if (qemuMonitorCloseFileHandle(mon, slirpfdName) < 0)\n            VIR_WARN(\"failed to close device handle '%s'\", slirpfdName);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorCloseFileHandle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2626-2644",
    "snippet": "int\nqemuMonitorCloseFileHandle(qemuMonitorPtr mon,\n                           const char *fdname)\n{\n    int ret = -1;\n    virErrorPtr error;\n\n    VIR_DEBUG(\"fdname=%s\", fdname);\n\n    virErrorPreserveLast(&error);\n\n    QEMU_CHECK_MONITOR_GOTO(mon, cleanup);\n\n    ret = qemuMonitorJSONCloseFileHandle(mon, fdname);\n\n cleanup:\n    virErrorRestore(&error);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&error"
          ],
          "line": 2642
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONCloseFileHandle",
          "args": [
            "mon",
            "fdname"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONCloseFileHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3954-3976",
          "snippet": "int qemuMonitorJSONCloseFileHandle(qemuMonitorPtr mon,\n                                   const char *fdname)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"closefd\",\n                                                     \"s:fdname\", fdname,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONCloseFileHandle(qemuMonitorPtr mon,\n                                   const char *fdname)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"closefd\",\n                                                     \"s:fdname\", fdname,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR_GOTO",
          "args": [
            "mon",
            "cleanup"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&error"
          ],
          "line": 2635
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"fdname=%s\"",
            "fdname"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorCloseFileHandle(qemuMonitorPtr mon,\n                           const char *fdname)\n{\n    int ret = -1;\n    virErrorPtr error;\n\n    VIR_DEBUG(\"fdname=%s\", fdname);\n\n    virErrorPreserveLast(&error);\n\n    QEMU_CHECK_MONITOR_GOTO(mon, cleanup);\n\n    ret = qemuMonitorJSONCloseFileHandle(mon, fdname);\n\n cleanup:\n    virErrorRestore(&error);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorSendFileHandle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2607-2623",
    "snippet": "int\nqemuMonitorSendFileHandle(qemuMonitorPtr mon,\n                          const char *fdname,\n                          int fd)\n{\n    VIR_DEBUG(\"fdname=%s fd=%d\", fdname, fd);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (fd < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"fd must be valid\"));\n        return -1;\n    }\n\n    return qemuMonitorJSONSendFileHandle(mon, fdname, fd);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSendFileHandle",
          "args": [
            "mon",
            "fdname",
            "fd"
          ],
          "line": 2622
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSendFileHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3928-3951",
          "snippet": "int qemuMonitorJSONSendFileHandle(qemuMonitorPtr mon,\n                                  const char *fdname,\n                                  int fd)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"getfd\",\n                                                     \"s:fdname\", fdname,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommandWithFd(mon, cmd, fd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONSendFileHandle(qemuMonitorPtr mon,\n                                  const char *fdname,\n                                  int fd)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"getfd\",\n                                                     \"s:fdname\", fdname,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommandWithFd(mon, cmd, fd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"fd must be valid\")"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"fd must be valid\""
          ],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"fdname=%s fd=%d\"",
            "fdname",
            "fd"
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSendFileHandle(qemuMonitorPtr mon,\n                          const char *fdname,\n                          int fd)\n{\n    VIR_DEBUG(\"fdname=%s fd=%d\", fdname, fd);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (fd < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"fd must be valid\"));\n        return -1;\n    }\n\n    return qemuMonitorJSONSendFileHandle(mon, fdname, fd);\n}"
  },
  {
    "function_name": "qemuMonitorGraphicsRelocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2585-2604",
    "snippet": "int\nqemuMonitorGraphicsRelocate(qemuMonitorPtr mon,\n                            int type,\n                            const char *hostname,\n                            int port,\n                            int tlsPort,\n                            const char *tlsSubject)\n{\n    VIR_DEBUG(\"type=%d hostname=%s port=%d tlsPort=%d tlsSubject=%s\",\n              type, hostname, port, tlsPort, NULLSTR(tlsSubject));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGraphicsRelocate(mon,\n                                           type,\n                                           hostname,\n                                           port,\n                                           tlsPort,\n                                           tlsSubject);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGraphicsRelocate",
          "args": [
            "mon",
            "type",
            "hostname",
            "port",
            "tlsPort",
            "tlsSubject"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGraphicsRelocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3894-3925",
          "snippet": "int qemuMonitorJSONGraphicsRelocate(qemuMonitorPtr mon,\n                                    int type,\n                                    const char *hostname,\n                                    int port,\n                                    int tlsPort,\n                                    const char *tlsSubject)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"client_migrate_info\",\n                                                     \"s:protocol\",\n                                                     (type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE ? \"spice\" : \"vnc\"),\n                                                     \"s:hostname\", hostname,\n                                                     \"i:port\", port,\n                                                     \"i:tls-port\", tlsPort,\n                                                     \"S:cert-subject\", tlsSubject,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONGraphicsRelocate(qemuMonitorPtr mon,\n                                    int type,\n                                    const char *hostname,\n                                    int port,\n                                    int tlsPort,\n                                    const char *tlsSubject)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"client_migrate_info\",\n                                                     \"s:protocol\",\n                                                     (type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE ? \"spice\" : \"vnc\"),\n                                                     \"s:hostname\", hostname,\n                                                     \"i:port\", port,\n                                                     \"i:tls-port\", tlsPort,\n                                                     \"S:cert-subject\", tlsSubject,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"type=%d hostname=%s port=%d tlsPort=%d tlsSubject=%s\"",
            "type",
            "hostname",
            "port",
            "tlsPort",
            "NULLSTR(tlsSubject)"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "tlsSubject"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGraphicsRelocate(qemuMonitorPtr mon,\n                            int type,\n                            const char *hostname,\n                            int port,\n                            int tlsPort,\n                            const char *tlsSubject)\n{\n    VIR_DEBUG(\"type=%d hostname=%s port=%d tlsPort=%d tlsSubject=%s\",\n              type, hostname, port, tlsPort, NULLSTR(tlsSubject));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGraphicsRelocate(mon,\n                                           type,\n                                           hostname,\n                                           port,\n                                           tlsPort,\n                                           tlsSubject);\n}"
  },
  {
    "function_name": "qemuMonitorDumpToFd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2560-2582",
    "snippet": "int\nqemuMonitorDumpToFd(qemuMonitorPtr mon,\n                    int fd,\n                    const char *dumpformat,\n                    bool detach)\n{\n    int ret;\n    VIR_DEBUG(\"fd=%d dumpformat=%s\", fd, dumpformat);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (qemuMonitorSendFileHandle(mon, \"dump\", fd) < 0)\n        return -1;\n\n    ret = qemuMonitorJSONDump(mon, \"fd:dump\", dumpformat, detach);\n\n    if (ret < 0) {\n        if (qemuMonitorCloseFileHandle(mon, \"dump\") < 0)\n            VIR_WARN(\"failed to close dumping handle\");\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"failed to close dumping handle\""
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorCloseFileHandle",
          "args": [
            "mon",
            "\"dump\""
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCloseFileHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2626-2644",
          "snippet": "int\nqemuMonitorCloseFileHandle(qemuMonitorPtr mon,\n                           const char *fdname)\n{\n    int ret = -1;\n    virErrorPtr error;\n\n    VIR_DEBUG(\"fdname=%s\", fdname);\n\n    virErrorPreserveLast(&error);\n\n    QEMU_CHECK_MONITOR_GOTO(mon, cleanup);\n\n    ret = qemuMonitorJSONCloseFileHandle(mon, fdname);\n\n cleanup:\n    virErrorRestore(&error);\n    return ret;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorCloseFileHandle(qemuMonitorPtr mon,\n                           const char *fdname)\n{\n    int ret = -1;\n    virErrorPtr error;\n\n    VIR_DEBUG(\"fdname=%s\", fdname);\n\n    virErrorPreserveLast(&error);\n\n    QEMU_CHECK_MONITOR_GOTO(mon, cleanup);\n\n    ret = qemuMonitorJSONCloseFileHandle(mon, fdname);\n\n cleanup:\n    virErrorRestore(&error);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONDump",
          "args": [
            "mon",
            "\"fd:dump\"",
            "dumpformat",
            "detach"
          ],
          "line": 2574
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONDump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3862-3892",
          "snippet": "int\nqemuMonitorJSONDump(qemuMonitorPtr mon,\n                    const char *protocol,\n                    const char *dumpformat,\n                    bool detach)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"dump-guest-memory\",\n                                     \"b:paging\", false,\n                                     \"s:protocol\", protocol,\n                                     \"S:format\", dumpformat,\n                                     \"B:detach\", detach,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONDump(qemuMonitorPtr mon,\n                    const char *protocol,\n                    const char *dumpformat,\n                    bool detach)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"dump-guest-memory\",\n                                     \"b:paging\", false,\n                                     \"s:protocol\", protocol,\n                                     \"S:format\", dumpformat,\n                                     \"B:detach\", detach,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorSendFileHandle",
          "args": [
            "mon",
            "\"dump\"",
            "fd"
          ],
          "line": 2571
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorSendFileHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2607-2623",
          "snippet": "int\nqemuMonitorSendFileHandle(qemuMonitorPtr mon,\n                          const char *fdname,\n                          int fd)\n{\n    VIR_DEBUG(\"fdname=%s fd=%d\", fdname, fd);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (fd < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"fd must be valid\"));\n        return -1;\n    }\n\n    return qemuMonitorJSONSendFileHandle(mon, fdname, fd);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSendFileHandle(qemuMonitorPtr mon,\n                          const char *fdname,\n                          int fd)\n{\n    VIR_DEBUG(\"fdname=%s fd=%d\", fdname, fd);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (fd < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"fd must be valid\"));\n        return -1;\n    }\n\n    return qemuMonitorJSONSendFileHandle(mon, fdname, fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"fd=%d dumpformat=%s\"",
            "fd",
            "dumpformat"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorDumpToFd(qemuMonitorPtr mon,\n                    int fd,\n                    const char *dumpformat,\n                    bool detach)\n{\n    int ret;\n    VIR_DEBUG(\"fd=%d dumpformat=%s\", fd, dumpformat);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (qemuMonitorSendFileHandle(mon, \"dump\", fd) < 0)\n        return -1;\n\n    ret = qemuMonitorJSONDump(mon, \"fd:dump\", dumpformat, detach);\n\n    if (ret < 0) {\n        if (qemuMonitorCloseFileHandle(mon, \"dump\") < 0)\n            VIR_WARN(\"failed to close dumping handle\");\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorGetDumpGuestMemoryCapability",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2548-2557",
    "snippet": "int\nqemuMonitorGetDumpGuestMemoryCapability(qemuMonitorPtr mon,\n                                        const char *capability)\n{\n    VIR_DEBUG(\"capability=%s\", capability);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetDumpGuestMemoryCapability(mon, capability);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetDumpGuestMemoryCapability",
          "args": [
            "mon",
            "capability"
          ],
          "line": 2556
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetDumpGuestMemoryCapability",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3806-3860",
          "snippet": "int\nqemuMonitorJSONGetDumpGuestMemoryCapability(qemuMonitorPtr mon,\n                                            const char *capability)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr caps;\n    virJSONValuePtr formats;\n    size_t i;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-dump-guest-memory-capability\",\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    caps = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (!(formats = virJSONValueObjectGetArray(caps, \"formats\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing supported dump formats\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(formats); i++) {\n        virJSONValuePtr dumpformat = virJSONValueArrayGet(formats, i);\n\n        if (!dumpformat || virJSONValueGetType(dumpformat) != VIR_JSON_TYPE_STRING) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing entry in supported dump formats\"));\n            goto cleanup;\n        }\n\n        if (STREQ(virJSONValueGetString(dumpformat), capability)) {\n            ret = 1;\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONGetDumpGuestMemoryCapability(qemuMonitorPtr mon,\n                                            const char *capability)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr caps;\n    virJSONValuePtr formats;\n    size_t i;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-dump-guest-memory-capability\",\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    caps = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (!(formats = virJSONValueObjectGetArray(caps, \"formats\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing supported dump formats\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(formats); i++) {\n        virJSONValuePtr dumpformat = virJSONValueArrayGet(formats, i);\n\n        if (!dumpformat || virJSONValueGetType(dumpformat) != VIR_JSON_TYPE_STRING) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing entry in supported dump formats\"));\n            goto cleanup;\n        }\n\n        if (STREQ(virJSONValueGetString(dumpformat), capability)) {\n            ret = 1;\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"capability=%s\"",
            "capability"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetDumpGuestMemoryCapability(qemuMonitorPtr mon,\n                                        const char *capability)\n{\n    VIR_DEBUG(\"capability=%s\", capability);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetDumpGuestMemoryCapability(mon, capability);\n}"
  },
  {
    "function_name": "qemuMonitorQueryDump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2535-2542",
    "snippet": "int\nqemuMonitorQueryDump(qemuMonitorPtr mon,\n                     qemuMonitorDumpStatsPtr stats)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONQueryDump(mon, stats);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONQueryDump",
          "args": [
            "mon",
            "stats"
          ],
          "line": 2541
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONQueryDump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3777-3803",
          "snippet": "int\nqemuMonitorJSONQueryDump(qemuMonitorPtr mon,\n                         qemuMonitorDumpStatsPtr stats)\n{\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"query-dump\", NULL);\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr result = NULL;\n    int ret = -1;\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    result = virJSONValueObjectGetObject(reply, \"return\");\n\n    ret = qemuMonitorJSONExtractDumpStats(result, stats);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONQueryDump(qemuMonitorPtr mon,\n                         qemuMonitorDumpStatsPtr stats)\n{\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"query-dump\", NULL);\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr result = NULL;\n    int ret = -1;\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    result = virJSONValueObjectGetObject(reply, \"return\");\n\n    ret = qemuMonitorJSONExtractDumpStats(result, stats);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorQueryDump(qemuMonitorPtr mon,\n                     qemuMonitorDumpStatsPtr stats)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONQueryDump(mon, stats);\n}"
  },
  {
    "function_name": "qemuMonitorMigrateCancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2526-2532",
    "snippet": "int\nqemuMonitorMigrateCancel(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateCancel(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONMigrateCancel",
          "args": [
            "mon"
          ],
          "line": 2531
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONMigrateCancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3746-3765",
          "snippet": "int qemuMonitorJSONMigrateCancel(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"migrate_cancel\", NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONMigrateCancel(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"migrate_cancel\", NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorMigrateCancel(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateCancel(mon);\n}"
  },
  {
    "function_name": "qemuMonitorMigrateToHost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2502-2523",
    "snippet": "int\nqemuMonitorMigrateToHost(qemuMonitorPtr mon,\n                         unsigned int flags,\n                         const char *protocol,\n                         const char *hostname,\n                         int port)\n{\n    int ret;\n    char *uri = NULL;\n    VIR_DEBUG(\"hostname=%s port=%d flags=0x%x\", hostname, port, flags);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (strchr(hostname, ':')) {\n        uri = g_strdup_printf(\"%s:[%s]:%d\", protocol, hostname, port);\n    } else uri = g_strdup_printf(\"%s:%s:%d\", protocol, hostname, port);\n\n    ret = qemuMonitorJSONMigrate(mon, flags, uri);\n\n    VIR_FREE(uri);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uri"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONMigrate",
          "args": [
            "mon",
            "flags",
            "uri"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONMigrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3716-3744",
          "snippet": "int qemuMonitorJSONMigrate(qemuMonitorPtr mon,\n                           unsigned int flags,\n                           const char *uri)\n{\n    int ret = -1;\n    virJSONValuePtr cmd =\n      qemuMonitorJSONMakeCommand(\"migrate\",\n                                 \"b:detach\", flags & QEMU_MONITOR_MIGRATE_BACKGROUND ? 1 : 0,\n                                 \"b:blk\", flags & QEMU_MONITOR_MIGRATE_NON_SHARED_DISK ? 1 : 0,\n                                 \"b:inc\", flags & QEMU_MONITOR_MIGRATE_NON_SHARED_INC ? 1 : 0,\n                                 \"s:uri\", uri,\n                                 NULL);\n    virJSONValuePtr reply = NULL;\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONMigrate(qemuMonitorPtr mon,\n                           unsigned int flags,\n                           const char *uri)\n{\n    int ret = -1;\n    virJSONValuePtr cmd =\n      qemuMonitorJSONMakeCommand(\"migrate\",\n                                 \"b:detach\", flags & QEMU_MONITOR_MIGRATE_BACKGROUND ? 1 : 0,\n                                 \"b:blk\", flags & QEMU_MONITOR_MIGRATE_NON_SHARED_DISK ? 1 : 0,\n                                 \"b:inc\", flags & QEMU_MONITOR_MIGRATE_NON_SHARED_INC ? 1 : 0,\n                                 \"s:uri\", uri,\n                                 NULL);\n    virJSONValuePtr reply = NULL;\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s:%s:%d\"",
            "protocol",
            "hostname",
            "port"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "hostname",
            "':'"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"hostname=%s port=%d flags=0x%x\"",
            "hostname",
            "port",
            "flags"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorMigrateToHost(qemuMonitorPtr mon,\n                         unsigned int flags,\n                         const char *protocol,\n                         const char *hostname,\n                         int port)\n{\n    int ret;\n    char *uri = NULL;\n    VIR_DEBUG(\"hostname=%s port=%d flags=0x%x\", hostname, port, flags);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (strchr(hostname, ':')) {\n        uri = g_strdup_printf(\"%s:[%s]:%d\", protocol, hostname, port);\n    } else uri = g_strdup_printf(\"%s:%s:%d\", protocol, hostname, port);\n\n    ret = qemuMonitorJSONMigrate(mon, flags, uri);\n\n    VIR_FREE(uri);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorMigrateToFd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2478-2499",
    "snippet": "int\nqemuMonitorMigrateToFd(qemuMonitorPtr mon,\n                       unsigned int flags,\n                       int fd)\n{\n    int ret;\n    VIR_DEBUG(\"fd=%d flags=0x%x\", fd, flags);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (qemuMonitorSendFileHandle(mon, \"migrate\", fd) < 0)\n        return -1;\n\n    ret = qemuMonitorJSONMigrate(mon, flags, \"fd:migrate\");\n\n    if (ret < 0) {\n        if (qemuMonitorCloseFileHandle(mon, \"migrate\") < 0)\n            VIR_WARN(\"failed to close migration handle\");\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"failed to close migration handle\""
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorCloseFileHandle",
          "args": [
            "mon",
            "\"migrate\""
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCloseFileHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2626-2644",
          "snippet": "int\nqemuMonitorCloseFileHandle(qemuMonitorPtr mon,\n                           const char *fdname)\n{\n    int ret = -1;\n    virErrorPtr error;\n\n    VIR_DEBUG(\"fdname=%s\", fdname);\n\n    virErrorPreserveLast(&error);\n\n    QEMU_CHECK_MONITOR_GOTO(mon, cleanup);\n\n    ret = qemuMonitorJSONCloseFileHandle(mon, fdname);\n\n cleanup:\n    virErrorRestore(&error);\n    return ret;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorCloseFileHandle(qemuMonitorPtr mon,\n                           const char *fdname)\n{\n    int ret = -1;\n    virErrorPtr error;\n\n    VIR_DEBUG(\"fdname=%s\", fdname);\n\n    virErrorPreserveLast(&error);\n\n    QEMU_CHECK_MONITOR_GOTO(mon, cleanup);\n\n    ret = qemuMonitorJSONCloseFileHandle(mon, fdname);\n\n cleanup:\n    virErrorRestore(&error);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONMigrate",
          "args": [
            "mon",
            "flags",
            "\"fd:migrate\""
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONMigrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3716-3744",
          "snippet": "int qemuMonitorJSONMigrate(qemuMonitorPtr mon,\n                           unsigned int flags,\n                           const char *uri)\n{\n    int ret = -1;\n    virJSONValuePtr cmd =\n      qemuMonitorJSONMakeCommand(\"migrate\",\n                                 \"b:detach\", flags & QEMU_MONITOR_MIGRATE_BACKGROUND ? 1 : 0,\n                                 \"b:blk\", flags & QEMU_MONITOR_MIGRATE_NON_SHARED_DISK ? 1 : 0,\n                                 \"b:inc\", flags & QEMU_MONITOR_MIGRATE_NON_SHARED_INC ? 1 : 0,\n                                 \"s:uri\", uri,\n                                 NULL);\n    virJSONValuePtr reply = NULL;\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONMigrate(qemuMonitorPtr mon,\n                           unsigned int flags,\n                           const char *uri)\n{\n    int ret = -1;\n    virJSONValuePtr cmd =\n      qemuMonitorJSONMakeCommand(\"migrate\",\n                                 \"b:detach\", flags & QEMU_MONITOR_MIGRATE_BACKGROUND ? 1 : 0,\n                                 \"b:blk\", flags & QEMU_MONITOR_MIGRATE_NON_SHARED_DISK ? 1 : 0,\n                                 \"b:inc\", flags & QEMU_MONITOR_MIGRATE_NON_SHARED_INC ? 1 : 0,\n                                 \"s:uri\", uri,\n                                 NULL);\n    virJSONValuePtr reply = NULL;\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorSendFileHandle",
          "args": [
            "mon",
            "\"migrate\"",
            "fd"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorSendFileHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2607-2623",
          "snippet": "int\nqemuMonitorSendFileHandle(qemuMonitorPtr mon,\n                          const char *fdname,\n                          int fd)\n{\n    VIR_DEBUG(\"fdname=%s fd=%d\", fdname, fd);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (fd < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"fd must be valid\"));\n        return -1;\n    }\n\n    return qemuMonitorJSONSendFileHandle(mon, fdname, fd);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSendFileHandle(qemuMonitorPtr mon,\n                          const char *fdname,\n                          int fd)\n{\n    VIR_DEBUG(\"fdname=%s fd=%d\", fdname, fd);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (fd < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"fd must be valid\"));\n        return -1;\n    }\n\n    return qemuMonitorJSONSendFileHandle(mon, fdname, fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"fd=%d flags=0x%x\"",
            "fd",
            "flags"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorMigrateToFd(qemuMonitorPtr mon,\n                       unsigned int flags,\n                       int fd)\n{\n    int ret;\n    VIR_DEBUG(\"fd=%d flags=0x%x\", fd, flags);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (qemuMonitorSendFileHandle(mon, \"migrate\", fd) < 0)\n        return -1;\n\n    ret = qemuMonitorJSONMigrate(mon, flags, \"fd:migrate\");\n\n    if (ret < 0) {\n        if (qemuMonitorCloseFileHandle(mon, \"migrate\") < 0)\n            VIR_WARN(\"failed to close migration handle\");\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorGetMigrationStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2464-2475",
    "snippet": "int\nqemuMonitorGetMigrationStats(qemuMonitorPtr mon,\n                             qemuMonitorMigrationStatsPtr stats,\n                             char **error)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    if (error)\n        *error = NULL;\n\n    return qemuMonitorJSONGetMigrationStats(mon, stats, error);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetMigrationStats",
          "args": [
            "mon",
            "stats",
            "error"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetMigrationStats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3683-3713",
          "snippet": "int qemuMonitorJSONGetMigrationStats(qemuMonitorPtr mon,\n                                     qemuMonitorMigrationStatsPtr stats,\n                                     char **error)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"query-migrate\",\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n\n    memset(stats, 0, sizeof(*stats));\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONGetMigrationStatsReply(reply, stats, error) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    if (ret < 0)\n        memset(stats, 0, sizeof(*stats));\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONGetMigrationStats(qemuMonitorPtr mon,\n                                     qemuMonitorMigrationStatsPtr stats,\n                                     char **error)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"query-migrate\",\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n\n    memset(stats, 0, sizeof(*stats));\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONGetMigrationStatsReply(reply, stats, error) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    if (ret < 0)\n        memset(stats, 0, sizeof(*stats));\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetMigrationStats(qemuMonitorPtr mon,\n                             qemuMonitorMigrationStatsPtr stats,\n                             char **error)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    if (error)\n        *error = NULL;\n\n    return qemuMonitorJSONGetMigrationStats(mon, stats, error);\n}"
  },
  {
    "function_name": "qemuMonitorSetMigrationParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2450-2461",
    "snippet": "int\nqemuMonitorSetMigrationParams(qemuMonitorPtr mon,\n                              virJSONValuePtr params)\n{\n    QEMU_CHECK_MONITOR_GOTO(mon, error);\n\n    return qemuMonitorJSONSetMigrationParams(mon, params);\n\n error:\n    virJSONValueFree(params);\n    return -1;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueFree",
          "args": [
            "params"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "391-423",
          "snippet": "void\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvoid\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONSetMigrationParams",
          "args": [
            "mon",
            "params"
          ],
          "line": 2456
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSetMigrationParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3451-3468",
          "snippet": "int\nqemuMonitorJSONSetMigrationParams(qemuMonitorPtr mon,\n                                  virJSONValuePtr params)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommandInternal(\"migrate-set-parameters\", params)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONSetMigrationParams(qemuMonitorPtr mon,\n                                  virJSONValuePtr params)\n{\n    g_autoptr(virJSONValue) cmd = NULL;\n    g_autoptr(virJSONValue) reply = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommandInternal(\"migrate-set-parameters\", params)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        return -1;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR_GOTO",
          "args": [
            "mon",
            "error"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSetMigrationParams(qemuMonitorPtr mon,\n                              virJSONValuePtr params)\n{\n    QEMU_CHECK_MONITOR_GOTO(mon, error);\n\n    return qemuMonitorJSONSetMigrationParams(mon, params);\n\n error:\n    virJSONValueFree(params);\n    return -1;\n}"
  },
  {
    "function_name": "qemuMonitorGetMigrationParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2430-2437",
    "snippet": "int\nqemuMonitorGetMigrationParams(qemuMonitorPtr mon,\n                              virJSONValuePtr *params)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetMigrationParams(mon, params);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetMigrationParams",
          "args": [
            "mon",
            "params"
          ],
          "line": 2436
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetMigrationParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3418-3449",
          "snippet": "int\nqemuMonitorJSONGetMigrationParams(qemuMonitorPtr mon,\n                                  virJSONValuePtr *params)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n\n    *params = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-migrate-parameters\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    *params = virJSONValueObjectStealObject(reply, \"return\");\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONGetMigrationParams(qemuMonitorPtr mon,\n                                  virJSONValuePtr *params)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n\n    *params = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-migrate-parameters\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    *params = virJSONValueObjectStealObject(reply, \"return\");\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetMigrationParams(qemuMonitorPtr mon,\n                              virJSONValuePtr *params)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetMigrationParams(mon, params);\n}"
  },
  {
    "function_name": "qemuMonitorSetMigrationCacheSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2407-2416",
    "snippet": "int\nqemuMonitorSetMigrationCacheSize(qemuMonitorPtr mon,\n                                 unsigned long long cacheSize)\n{\n    VIR_DEBUG(\"cacheSize=%llu\", cacheSize);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetMigrationCacheSize(mon, cacheSize);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSetMigrationCacheSize",
          "args": [
            "mon",
            "cacheSize"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSetMigrationCacheSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3390-3415",
          "snippet": "int\nqemuMonitorJSONSetMigrationCacheSize(qemuMonitorPtr mon,\n                                     unsigned long long cacheSize)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"migrate-set-cache-size\",\n                                     \"U:value\", cacheSize,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONSetMigrationCacheSize(qemuMonitorPtr mon,\n                                     unsigned long long cacheSize)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"migrate-set-cache-size\",\n                                     \"U:value\", cacheSize,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cacheSize=%llu\"",
            "cacheSize"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSetMigrationCacheSize(qemuMonitorPtr mon,\n                                 unsigned long long cacheSize)\n{\n    VIR_DEBUG(\"cacheSize=%llu\", cacheSize);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetMigrationCacheSize(mon, cacheSize);\n}"
  },
  {
    "function_name": "qemuMonitorGetMigrationCacheSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2395-2404",
    "snippet": "int\nqemuMonitorGetMigrationCacheSize(qemuMonitorPtr mon,\n                                 unsigned long long *cacheSize)\n{\n    VIR_DEBUG(\"cacheSize=%p\", cacheSize);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetMigrationCacheSize(mon, cacheSize);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetMigrationCacheSize",
          "args": [
            "mon",
            "cacheSize"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetMigrationCacheSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3356-3387",
          "snippet": "int\nqemuMonitorJSONGetMigrationCacheSize(qemuMonitorPtr mon,\n                                     unsigned long long *cacheSize)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    *cacheSize = 0;\n\n    cmd = qemuMonitorJSONMakeCommand(\"query-migrate-cache-size\", NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_NUMBER) < 0)\n        goto cleanup;\n\n    if (virJSONValueObjectGetNumberUlong(reply, \"return\", cacheSize) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid cache size in query-migrate-cache-size reply\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONGetMigrationCacheSize(qemuMonitorPtr mon,\n                                     unsigned long long *cacheSize)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    *cacheSize = 0;\n\n    cmd = qemuMonitorJSONMakeCommand(\"query-migrate-cache-size\", NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_NUMBER) < 0)\n        goto cleanup;\n\n    if (virJSONValueObjectGetNumberUlong(reply, \"return\", cacheSize) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid cache size in query-migrate-cache-size reply\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cacheSize=%p\"",
            "cacheSize"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetMigrationCacheSize(qemuMonitorPtr mon,\n                                 unsigned long long *cacheSize)\n{\n    VIR_DEBUG(\"cacheSize=%p\", cacheSize);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetMigrationCacheSize(mon, cacheSize);\n}"
  },
  {
    "function_name": "qemuMonitorSetMigrationDowntime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2383-2392",
    "snippet": "int\nqemuMonitorSetMigrationDowntime(qemuMonitorPtr mon,\n                                unsigned long long downtime)\n{\n    VIR_DEBUG(\"downtime=%llu\", downtime);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetMigrationDowntime(mon, downtime);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSetMigrationDowntime",
          "args": [
            "mon",
            "downtime"
          ],
          "line": 2391
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSetMigrationDowntime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3329-3353",
          "snippet": "int qemuMonitorJSONSetMigrationDowntime(qemuMonitorPtr mon,\n                                        unsigned long long downtime)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"migrate_set_downtime\",\n                                     \"d:value\", downtime / 1000.0,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONSetMigrationDowntime(qemuMonitorPtr mon,\n                                        unsigned long long downtime)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"migrate_set_downtime\",\n                                     \"d:value\", downtime / 1000.0,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"downtime=%llu\"",
            "downtime"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSetMigrationDowntime(qemuMonitorPtr mon,\n                                unsigned long long downtime)\n{\n    VIR_DEBUG(\"downtime=%llu\", downtime);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetMigrationDowntime(mon, downtime);\n}"
  },
  {
    "function_name": "qemuMonitorSetMigrationSpeed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2364-2380",
    "snippet": "int\nqemuMonitorSetMigrationSpeed(qemuMonitorPtr mon,\n                             unsigned long bandwidth)\n{\n    VIR_DEBUG(\"bandwidth=%lu\", bandwidth);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (bandwidth > QEMU_DOMAIN_MIG_BANDWIDTH_MAX) {\n        virReportError(VIR_ERR_OVERFLOW,\n                       _(\"bandwidth must be less than %llu\"),\n                       QEMU_DOMAIN_MIG_BANDWIDTH_MAX + 1ULL);\n        return -1;\n    }\n\n    return qemuMonitorJSONSetMigrationSpeed(mon, bandwidth);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSetMigrationSpeed",
          "args": [
            "mon",
            "bandwidth"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSetMigrationSpeed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3303-3326",
          "snippet": "int qemuMonitorJSONSetMigrationSpeed(qemuMonitorPtr mon,\n                                     unsigned long bandwidth)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    cmd = qemuMonitorJSONMakeCommand(\"migrate_set_speed\",\n                                     \"U:value\", bandwidth * 1024ULL * 1024ULL,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONSetMigrationSpeed(qemuMonitorPtr mon,\n                                     unsigned long bandwidth)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    cmd = qemuMonitorJSONMakeCommand(\"migrate_set_speed\",\n                                     \"U:value\", bandwidth * 1024ULL * 1024ULL,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OVERFLOW",
            "_(\"bandwidth must be less than %llu\")",
            "QEMU_DOMAIN_MIG_BANDWIDTH_MAX + 1ULL"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"bandwidth must be less than %llu\""
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"bandwidth=%lu\"",
            "bandwidth"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSetMigrationSpeed(qemuMonitorPtr mon,\n                             unsigned long bandwidth)\n{\n    VIR_DEBUG(\"bandwidth=%lu\", bandwidth);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (bandwidth > QEMU_DOMAIN_MIG_BANDWIDTH_MAX) {\n        virReportError(VIR_ERR_OVERFLOW,\n                       _(\"bandwidth must be less than %llu\"),\n                       QEMU_DOMAIN_MIG_BANDWIDTH_MAX + 1ULL);\n        return -1;\n    }\n\n    return qemuMonitorJSONSetMigrationSpeed(mon, bandwidth);\n}"
  },
  {
    "function_name": "qemuMonitorSavePhysicalMemory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2350-2361",
    "snippet": "int\nqemuMonitorSavePhysicalMemory(qemuMonitorPtr mon,\n                              unsigned long long offset,\n                              unsigned long long length,\n                              const char *path)\n{\n    VIR_DEBUG(\"offset=%llu length=%llu path=%s\", offset, length, path);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSavePhysicalMemory(mon, offset, length, path);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSavePhysicalMemory",
          "args": [
            "mon",
            "offset",
            "length",
            "path"
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSavePhysicalMemory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3294-3300",
          "snippet": "int qemuMonitorJSONSavePhysicalMemory(qemuMonitorPtr mon,\n                                      unsigned long long offset,\n                                      unsigned long long length,\n                                      const char *path)\n{\n    return qemuMonitorJSONSaveMemory(mon, \"pmemsave\", offset, length, path);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONSavePhysicalMemory(qemuMonitorPtr mon,\n                                      unsigned long long offset,\n                                      unsigned long long length,\n                                      const char *path)\n{\n    return qemuMonitorJSONSaveMemory(mon, \"pmemsave\", offset, length, path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"offset=%llu length=%llu path=%s\"",
            "offset",
            "length",
            "path"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSavePhysicalMemory(qemuMonitorPtr mon,\n                              unsigned long long offset,\n                              unsigned long long length,\n                              const char *path)\n{\n    VIR_DEBUG(\"offset=%llu length=%llu path=%s\", offset, length, path);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSavePhysicalMemory(mon, offset, length, path);\n}"
  },
  {
    "function_name": "qemuMonitorSaveVirtualMemory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2336-2347",
    "snippet": "int\nqemuMonitorSaveVirtualMemory(qemuMonitorPtr mon,\n                             unsigned long long offset,\n                             unsigned long long length,\n                             const char *path)\n{\n    VIR_DEBUG(\"offset=%llu length=%llu path=%s\", offset, length, path);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSaveVirtualMemory(mon, offset, length, path);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSaveVirtualMemory",
          "args": [
            "mon",
            "offset",
            "length",
            "path"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSaveVirtualMemory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3286-3292",
          "snippet": "int qemuMonitorJSONSaveVirtualMemory(qemuMonitorPtr mon,\n                                     unsigned long long offset,\n                                     unsigned long long length,\n                                     const char *path)\n{\n    return qemuMonitorJSONSaveMemory(mon, \"memsave\", offset, length, path);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONSaveVirtualMemory(qemuMonitorPtr mon,\n                                     unsigned long long offset,\n                                     unsigned long long length,\n                                     const char *path)\n{\n    return qemuMonitorJSONSaveMemory(mon, \"memsave\", offset, length, path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"offset=%llu length=%llu path=%s\"",
            "offset",
            "length",
            "path"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSaveVirtualMemory(qemuMonitorPtr mon,\n                             unsigned long long offset,\n                             unsigned long long length,\n                             const char *path)\n{\n    VIR_DEBUG(\"offset=%llu length=%llu path=%s\", offset, length, path);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSaveVirtualMemory(mon, offset, length, path);\n}"
  },
  {
    "function_name": "qemuMonitorChangeMedia",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2322-2333",
    "snippet": "int\nqemuMonitorChangeMedia(qemuMonitorPtr mon,\n                       const char *dev_name,\n                       const char *newmedia,\n                       const char *format)\n{\n    VIR_DEBUG(\"dev_name=%s newmedia=%s format=%s\", dev_name, newmedia, format);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONChangeMedia(mon, dev_name, newmedia, format);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONChangeMedia",
          "args": [
            "mon",
            "dev_name",
            "newmedia",
            "format"
          ],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONChangeMedia",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3224-3253",
          "snippet": "int qemuMonitorJSONChangeMedia(qemuMonitorPtr mon,\n                               const char *dev_name,\n                               const char *newmedia,\n                               const char *format)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"change\",\n                                     \"s:device\", dev_name,\n                                     \"s:target\", newmedia,\n                                     \"S:arg\", format,\n                                     NULL);\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONChangeMedia(qemuMonitorPtr mon,\n                               const char *dev_name,\n                               const char *newmedia,\n                               const char *format)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"change\",\n                                     \"s:device\", dev_name,\n                                     \"s:target\", newmedia,\n                                     \"S:arg\", format,\n                                     NULL);\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"dev_name=%s newmedia=%s format=%s\"",
            "dev_name",
            "newmedia",
            "format"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorChangeMedia(qemuMonitorPtr mon,\n                       const char *dev_name,\n                       const char *newmedia,\n                       const char *format)\n{\n    VIR_DEBUG(\"dev_name=%s newmedia=%s format=%s\", dev_name, newmedia, format);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONChangeMedia(mon, dev_name, newmedia, format);\n}"
  },
  {
    "function_name": "qemuMonitorEjectMedia",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2309-2319",
    "snippet": "int\nqemuMonitorEjectMedia(qemuMonitorPtr mon,\n                      const char *dev_name,\n                      bool force)\n{\n    VIR_DEBUG(\"dev_name=%s force=%d\", dev_name, force);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONEjectMedia(mon, dev_name, force);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONEjectMedia",
          "args": [
            "mon",
            "dev_name",
            "force"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONEjectMedia",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3197-3221",
          "snippet": "int qemuMonitorJSONEjectMedia(qemuMonitorPtr mon,\n                              const char *dev_name,\n                              bool force)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"eject\",\n                                                     \"s:device\", dev_name,\n                                                     \"b:force\", force ? 1 : 0,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONEjectMedia(qemuMonitorPtr mon,\n                              const char *dev_name,\n                              bool force)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"eject\",\n                                                     \"s:device\", dev_name,\n                                                     \"b:force\", force ? 1 : 0,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"dev_name=%s force=%d\"",
            "dev_name",
            "force"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEjectMedia(qemuMonitorPtr mon,\n                      const char *dev_name,\n                      bool force)\n{\n    VIR_DEBUG(\"dev_name=%s force=%d\", dev_name, force);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONEjectMedia(mon, dev_name, force);\n}"
  },
  {
    "function_name": "qemuMonitorSetCPU",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2298-2306",
    "snippet": "int\nqemuMonitorSetCPU(qemuMonitorPtr mon, int cpu, bool online)\n{\n    VIR_DEBUG(\"cpu=%d online=%d\", cpu, online);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetCPU(mon, cpu, online);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSetCPU",
          "args": [
            "mon",
            "cpu",
            "online"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSetCPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3159-3187",
          "snippet": "int qemuMonitorJSONSetCPU(qemuMonitorPtr mon,\n                          int cpu, bool online)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n\n    if (online) {\n        cmd = qemuMonitorJSONMakeCommand(\"cpu-add\",\n                                         \"i:id\", cpu,\n                                         NULL);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"vCPU unplug is not supported by this QEMU\"));\n        goto cleanup;\n    }\n    if (!cmd)\n        goto cleanup;\n\n    if ((ret = qemuMonitorJSONCommand(mon, cmd, &reply)) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorJSONCheckError(cmd, reply);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONSetCPU(qemuMonitorPtr mon,\n                          int cpu, bool online)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n\n    if (online) {\n        cmd = qemuMonitorJSONMakeCommand(\"cpu-add\",\n                                         \"i:id\", cpu,\n                                         NULL);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"vCPU unplug is not supported by this QEMU\"));\n        goto cleanup;\n    }\n    if (!cmd)\n        goto cleanup;\n\n    if ((ret = qemuMonitorJSONCommand(mon, cmd, &reply)) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorJSONCheckError(cmd, reply);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cpu=%d online=%d\"",
            "cpu",
            "online"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSetCPU(qemuMonitorPtr mon, int cpu, bool online)\n{\n    VIR_DEBUG(\"cpu=%d online=%d\", cpu, online);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetCPU(mon, cpu, online);\n}"
  },
  {
    "function_name": "qemuMonitorSetBalloon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2283-2292",
    "snippet": "int\nqemuMonitorSetBalloon(qemuMonitorPtr mon,\n                      unsigned long long newmem)\n{\n    VIR_DEBUG(\"newmem=%llu\", newmem);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetBalloon(mon, newmem);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSetBalloon",
          "args": [
            "mon",
            "newmem"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSetBalloon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3124-3156",
          "snippet": "int\nqemuMonitorJSONSetBalloon(qemuMonitorPtr mon,\n                          unsigned long long newmem)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"balloon\",\n                                                     \"U:value\", newmem * 1024,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    /* See if balloon soft-failed */\n    if (qemuMonitorJSONHasError(reply, \"DeviceNotActive\") ||\n        qemuMonitorJSONHasError(reply, \"KVMMissingCap\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* See if any other fatal error occurred */\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    /* Real success */\n    ret = 1;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONSetBalloon(qemuMonitorPtr mon,\n                          unsigned long long newmem)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"balloon\",\n                                                     \"U:value\", newmem * 1024,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    /* See if balloon soft-failed */\n    if (qemuMonitorJSONHasError(reply, \"DeviceNotActive\") ||\n        qemuMonitorJSONHasError(reply, \"KVMMissingCap\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* See if any other fatal error occurred */\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    /* Real success */\n    ret = 1;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"newmem=%llu\"",
            "newmem"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSetBalloon(qemuMonitorPtr mon,\n                      unsigned long long newmem)\n{\n    VIR_DEBUG(\"newmem=%llu\", newmem);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetBalloon(mon, newmem);\n}"
  },
  {
    "function_name": "qemuMonitorExpirePassword",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2258-2276",
    "snippet": "int\nqemuMonitorExpirePassword(qemuMonitorPtr mon,\n                          int type,\n                          const char *expire_time)\n{\n    const char *protocol = qemuMonitorTypeToProtocol(type);\n\n    if (!protocol)\n        return -1;\n\n    VIR_DEBUG(\"protocol=%s, expire_time=%s\", protocol, expire_time);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (!expire_time)\n        expire_time = \"now\";\n\n    return qemuMonitorJSONExpirePassword(mon, protocol, expire_time);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONExpirePassword",
          "args": [
            "mon",
            "protocol",
            "expire_time"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONExpirePassword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3097-3121",
          "snippet": "int qemuMonitorJSONExpirePassword(qemuMonitorPtr mon,\n                                  const char *protocol,\n                                  const char *expire_time)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"expire_password\",\n                                                     \"s:protocol\", protocol,\n                                                     \"s:time\", expire_time,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONExpirePassword(qemuMonitorPtr mon,\n                                  const char *protocol,\n                                  const char *expire_time)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"expire_password\",\n                                                     \"s:protocol\", protocol,\n                                                     \"s:time\", expire_time,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"protocol=%s, expire_time=%s\"",
            "protocol",
            "expire_time"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorTypeToProtocol",
          "args": [
            "type"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTypeToProtocol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2215-2229",
          "snippet": "static const char *\nqemuMonitorTypeToProtocol(int type)\n{\n    switch (type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        return \"vnc\";\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        return \"spice\";\n    default:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported protocol type %s\"),\n                       virDomainGraphicsTypeToString(type));\n        return NULL;\n    }\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic const char *\nqemuMonitorTypeToProtocol(int type)\n{\n    switch (type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        return \"vnc\";\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        return \"spice\";\n    default:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported protocol type %s\"),\n                       virDomainGraphicsTypeToString(type));\n        return NULL;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorExpirePassword(qemuMonitorPtr mon,\n                          int type,\n                          const char *expire_time)\n{\n    const char *protocol = qemuMonitorTypeToProtocol(type);\n\n    if (!protocol)\n        return -1;\n\n    VIR_DEBUG(\"protocol=%s, expire_time=%s\", protocol, expire_time);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (!expire_time)\n        expire_time = \"now\";\n\n    return qemuMonitorJSONExpirePassword(mon, protocol, expire_time);\n}"
  },
  {
    "function_name": "qemuMonitorSetPassword",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2232-2255",
    "snippet": "int\nqemuMonitorSetPassword(qemuMonitorPtr mon,\n                       int type,\n                       const char *password,\n                       const char *action_if_connected)\n{\n    const char *protocol = qemuMonitorTypeToProtocol(type);\n\n    if (!protocol)\n        return -1;\n\n    VIR_DEBUG(\"protocol=%s, password=%p, action_if_connected=%s\",\n              protocol, password, action_if_connected);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (!password)\n        password = \"\";\n\n    if (!action_if_connected)\n        action_if_connected = \"keep\";\n\n    return qemuMonitorJSONSetPassword(mon, protocol, password, action_if_connected);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSetPassword",
          "args": [
            "mon",
            "protocol",
            "password",
            "action_if_connected"
          ],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSetPassword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3069-3095",
          "snippet": "int qemuMonitorJSONSetPassword(qemuMonitorPtr mon,\n                               const char *protocol,\n                               const char *password,\n                               const char *action_if_connected)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"set_password\",\n                                                     \"s:protocol\", protocol,\n                                                     \"s:password\", password,\n                                                     \"s:connected\", action_if_connected,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONSetPassword(qemuMonitorPtr mon,\n                               const char *protocol,\n                               const char *password,\n                               const char *action_if_connected)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"set_password\",\n                                                     \"s:protocol\", protocol,\n                                                     \"s:password\", password,\n                                                     \"s:connected\", action_if_connected,\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"protocol=%s, password=%p, action_if_connected=%s\"",
            "protocol",
            "password",
            "action_if_connected"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorTypeToProtocol",
          "args": [
            "type"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTypeToProtocol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2215-2229",
          "snippet": "static const char *\nqemuMonitorTypeToProtocol(int type)\n{\n    switch (type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        return \"vnc\";\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        return \"spice\";\n    default:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported protocol type %s\"),\n                       virDomainGraphicsTypeToString(type));\n        return NULL;\n    }\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic const char *\nqemuMonitorTypeToProtocol(int type)\n{\n    switch (type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        return \"vnc\";\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        return \"spice\";\n    default:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported protocol type %s\"),\n                       virDomainGraphicsTypeToString(type));\n        return NULL;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSetPassword(qemuMonitorPtr mon,\n                       int type,\n                       const char *password,\n                       const char *action_if_connected)\n{\n    const char *protocol = qemuMonitorTypeToProtocol(type);\n\n    if (!protocol)\n        return -1;\n\n    VIR_DEBUG(\"protocol=%s, password=%p, action_if_connected=%s\",\n              protocol, password, action_if_connected);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (!password)\n        password = \"\";\n\n    if (!action_if_connected)\n        action_if_connected = \"keep\";\n\n    return qemuMonitorJSONSetPassword(mon, protocol, password, action_if_connected);\n}"
  },
  {
    "function_name": "qemuMonitorTypeToProtocol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2215-2229",
    "snippet": "static const char *\nqemuMonitorTypeToProtocol(int type)\n{\n    switch (type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        return \"vnc\";\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        return \"spice\";\n    default:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported protocol type %s\"),\n                       virDomainGraphicsTypeToString(type));\n        return NULL;\n    }\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"unsupported protocol type %s\")",
            "virDomainGraphicsTypeToString(type)"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsTypeToString",
          "args": [
            "type"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported protocol type %s\""
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic const char *\nqemuMonitorTypeToProtocol(int type)\n{\n    switch (type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        return \"vnc\";\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        return \"spice\";\n    default:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported protocol type %s\"),\n                       virDomainGraphicsTypeToString(type));\n        return NULL;\n    }\n}"
  },
  {
    "function_name": "qemuMonitorBlockResize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2194-2212",
    "snippet": "int\nqemuMonitorBlockResize(qemuMonitorPtr mon,\n                       const char *device,\n                       const char *nodename,\n                       unsigned long long size)\n{\n    VIR_DEBUG(\"device=%s nodename=%s size=%llu\",\n              NULLSTR(device), NULLSTR(nodename), size);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if ((!device && !nodename) || (device && nodename)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"exactly one of 'device' and 'nodename' need to be specified\"));\n        return -1;\n    }\n\n    return qemuMonitorJSONBlockResize(mon, device, nodename, size);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONBlockResize",
          "args": [
            "mon",
            "device",
            "nodename",
            "size"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONBlockResize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3038-3066",
          "snippet": "int qemuMonitorJSONBlockResize(qemuMonitorPtr mon,\n                               const char *device,\n                               const char *nodename,\n                               unsigned long long size)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"block_resize\",\n                                     \"S:device\", device,\n                                     \"S:node-name\", nodename,\n                                     \"U:size\", size,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONBlockResize(qemuMonitorPtr mon,\n                               const char *device,\n                               const char *nodename,\n                               unsigned long long size)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n\n    cmd = qemuMonitorJSONMakeCommand(\"block_resize\",\n                                     \"S:device\", device,\n                                     \"S:node-name\", nodename,\n                                     \"U:size\", size,\n                                     NULL);\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"exactly one of 'device' and 'nodename' need to be specified\")"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"exactly one of 'device' and 'nodename' need to be specified\""
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"device=%s nodename=%s size=%llu\"",
            "NULLSTR(device)",
            "NULLSTR(nodename)",
            "size"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "nodename"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "device"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockResize(qemuMonitorPtr mon,\n                       const char *device,\n                       const char *nodename,\n                       unsigned long long size)\n{\n    VIR_DEBUG(\"device=%s nodename=%s size=%llu\",\n              NULLSTR(device), NULLSTR(nodename), size);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if ((!device && !nodename) || (device && nodename)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"exactly one of 'device' and 'nodename' need to be specified\"));\n        return -1;\n    }\n\n    return qemuMonitorJSONBlockResize(mon, device, nodename, size);\n}"
  },
  {
    "function_name": "qemuMonitorBlockGetNamedNodeData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2183-2191",
    "snippet": "virHashTablePtr\nqemuMonitorBlockGetNamedNodeData(qemuMonitorPtr mon,\n                                 bool supports_flat)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n    VIR_DEBUG(\"supports_flat=%d\", supports_flat);\n\n    return qemuMonitorJSONBlockGetNamedNodeData(mon, supports_flat);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONBlockGetNamedNodeData",
          "args": [
            "mon",
            "supports_flat"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONBlockGetNamedNodeData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "3025-3035",
          "snippet": "virHashTablePtr\nqemuMonitorJSONBlockGetNamedNodeData(qemuMonitorPtr mon,\n                                     bool supports_flat)\n{\n    g_autoptr(virJSONValue) nodes = NULL;\n\n    if (!(nodes = qemuMonitorJSONQueryNamedBlockNodes(mon, supports_flat)))\n        return NULL;\n\n    return qemuMonitorJSONBlockGetNamedNodeDataJSON(nodes);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirHashTablePtr\nqemuMonitorJSONBlockGetNamedNodeData(qemuMonitorPtr mon,\n                                     bool supports_flat)\n{\n    g_autoptr(virJSONValue) nodes = NULL;\n\n    if (!(nodes = qemuMonitorJSONQueryNamedBlockNodes(mon, supports_flat)))\n        return NULL;\n\n    return qemuMonitorJSONBlockGetNamedNodeDataJSON(nodes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"supports_flat=%d\"",
            "supports_flat"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR_NULL",
          "args": [
            "mon"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirHashTablePtr\nqemuMonitorBlockGetNamedNodeData(qemuMonitorPtr mon,\n                                 bool supports_flat)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n    VIR_DEBUG(\"supports_flat=%d\", supports_flat);\n\n    return qemuMonitorJSONBlockGetNamedNodeData(mon, supports_flat);\n}"
  },
  {
    "function_name": "qemuMonitorBlockStatsUpdateCapacityBlockdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2162-2171",
    "snippet": "int\nqemuMonitorBlockStatsUpdateCapacityBlockdev(qemuMonitorPtr mon,\n                                            virHashTablePtr stats)\n{\n    VIR_DEBUG(\"stats=%p\", stats);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockStatsUpdateCapacityBlockdev(mon, stats);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONBlockStatsUpdateCapacityBlockdev",
          "args": [
            "mon",
            "stats"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONBlockStatsUpdateCapacityBlockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "2867-2887",
          "snippet": "int\nqemuMonitorJSONBlockStatsUpdateCapacityBlockdev(qemuMonitorPtr mon,\n                                                virHashTablePtr stats)\n{\n    virJSONValuePtr nodes;\n    int ret = -1;\n\n    if (!(nodes = qemuMonitorJSONQueryNamedBlockNodes(mon, false)))\n        return -1;\n\n    if (virJSONValueArrayForeachSteal(nodes,\n                                      qemuMonitorJSONBlockStatsUpdateCapacityBlockdevWorker,\n                                      stats) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(nodes);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONBlockStatsUpdateCapacityBlockdev(qemuMonitorPtr mon,\n                                                virHashTablePtr stats)\n{\n    virJSONValuePtr nodes;\n    int ret = -1;\n\n    if (!(nodes = qemuMonitorJSONQueryNamedBlockNodes(mon, false)))\n        return -1;\n\n    if (virJSONValueArrayForeachSteal(nodes,\n                                      qemuMonitorJSONBlockStatsUpdateCapacityBlockdevWorker,\n                                      stats) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(nodes);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"stats=%p\"",
            "stats"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockStatsUpdateCapacityBlockdev(qemuMonitorPtr mon,\n                                            virHashTablePtr stats)\n{\n    VIR_DEBUG(\"stats=%p\", stats);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockStatsUpdateCapacityBlockdev(mon, stats);\n}"
  },
  {
    "function_name": "qemuMonitorBlockStatsUpdateCapacity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2149-2159",
    "snippet": "int\nqemuMonitorBlockStatsUpdateCapacity(qemuMonitorPtr mon,\n                                    virHashTablePtr stats,\n                                    bool backingChain)\n{\n    VIR_DEBUG(\"stats=%p, backing=%d\", stats, backingChain);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockStatsUpdateCapacity(mon, stats, backingChain);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONBlockStatsUpdateCapacity",
          "args": [
            "mon",
            "stats",
            "backingChain"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONBlockStatsUpdateCapacityBlockdevWorker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "2839-2864",
          "snippet": "static int\nqemuMonitorJSONBlockStatsUpdateCapacityBlockdevWorker(size_t pos G_GNUC_UNUSED,\n                                                      virJSONValuePtr val,\n                                                      void *opaque)\n{\n    virHashTablePtr stats = opaque;\n    virJSONValuePtr image;\n    const char *nodename;\n    qemuBlockStatsPtr entry;\n\n    if (!(nodename = virJSONValueObjectGetString(val, \"node-name\")) ||\n        !(image = virJSONValueObjectGetObject(val, \"image\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-named-block-nodes entry was not in expected format\"));\n        return -1;\n    }\n\n    if (qemuMonitorJSONBlockStatsUpdateCapacityData(image, nodename, stats, &entry) < 0)\n        return -1;\n\n    if (entry)\n        ignore_value(virJSONValueObjectGetNumberUlong(val, \"write_threshold\",\n                                                      &entry->write_threshold));\n\n    return 1; /* we don't want to steal the value from the JSON array */\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic int\nqemuMonitorJSONBlockStatsUpdateCapacityBlockdevWorker(size_t pos G_GNUC_UNUSED,\n                                                      virJSONValuePtr val,\n                                                      void *opaque)\n{\n    virHashTablePtr stats = opaque;\n    virJSONValuePtr image;\n    const char *nodename;\n    qemuBlockStatsPtr entry;\n\n    if (!(nodename = virJSONValueObjectGetString(val, \"node-name\")) ||\n        !(image = virJSONValueObjectGetObject(val, \"image\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-named-block-nodes entry was not in expected format\"));\n        return -1;\n    }\n\n    if (qemuMonitorJSONBlockStatsUpdateCapacityData(image, nodename, stats, &entry) < 0)\n        return -1;\n\n    if (entry)\n        ignore_value(virJSONValueObjectGetNumberUlong(val, \"write_threshold\",\n                                                      &entry->write_threshold));\n\n    return 1; /* we don't want to steal the value from the JSON array */\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"stats=%p, backing=%d\"",
            "stats",
            "backingChain"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockStatsUpdateCapacity(qemuMonitorPtr mon,\n                                    virHashTablePtr stats,\n                                    bool backingChain)\n{\n    VIR_DEBUG(\"stats=%p, backing=%d\", stats, backingChain);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockStatsUpdateCapacity(mon, stats, backingChain);\n}"
  },
  {
    "function_name": "qemuMonitorGetAllBlockStatsInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2120-2145",
    "snippet": "int\nqemuMonitorGetAllBlockStatsInfo(qemuMonitorPtr mon,\n                                virHashTablePtr *ret_stats,\n                                bool backingChain)\n{\n    int ret = -1;\n    VIR_DEBUG(\"ret_stats=%p, backing=%d\", ret_stats, backingChain);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (!(*ret_stats = virHashCreate(10, virHashValueFree)))\n        goto error;\n\n    ret = qemuMonitorJSONGetAllBlockStatsInfo(mon, *ret_stats,\n                                              backingChain);\n\n    if (ret < 0)\n        goto error;\n\n    return ret;\n\n error:\n    virHashFree(*ret_stats);\n    *ret_stats = NULL;\n    return -1;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "*ret_stats"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetAllBlockStatsInfo",
          "args": [
            "mon",
            "*ret_stats",
            "backingChain"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetAllBlockStatsInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "2682-2727",
          "snippet": "int\nqemuMonitorJSONGetAllBlockStatsInfo(qemuMonitorPtr mon,\n                                    virHashTablePtr hash,\n                                    bool backingChain)\n{\n    int nstats = 0;\n    int rc;\n    size_t i;\n    g_autoptr(virJSONValue) devices = NULL;\n\n    if (!(devices = qemuMonitorJSONQueryBlockstats(mon)))\n        return -1;\n\n    for (i = 0; i < virJSONValueArraySize(devices); i++) {\n        virJSONValuePtr dev = virJSONValueArrayGet(devices, i);\n        const char *dev_name;\n\n        if (!dev || virJSONValueGetType(dev) != VIR_JSON_TYPE_OBJECT) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"blockstats device entry was not \"\n                             \"in expected format\"));\n            return -1;\n        }\n\n        if (!(dev_name = virJSONValueObjectGetString(dev, \"device\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"blockstats device entry was not \"\n                             \"in expected format\"));\n            return -1;\n        }\n\n        if (*dev_name == '\\0')\n            dev_name = NULL;\n\n        rc = qemuMonitorJSONGetOneBlockStatsInfo(dev, dev_name, 0, hash,\n                                                 backingChain);\n\n        if (rc < 0)\n            return -1;\n\n        if (rc > nstats)\n            nstats = rc;\n    }\n\n    return nstats;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONGetAllBlockStatsInfo(qemuMonitorPtr mon,\n                                    virHashTablePtr hash,\n                                    bool backingChain)\n{\n    int nstats = 0;\n    int rc;\n    size_t i;\n    g_autoptr(virJSONValue) devices = NULL;\n\n    if (!(devices = qemuMonitorJSONQueryBlockstats(mon)))\n        return -1;\n\n    for (i = 0; i < virJSONValueArraySize(devices); i++) {\n        virJSONValuePtr dev = virJSONValueArrayGet(devices, i);\n        const char *dev_name;\n\n        if (!dev || virJSONValueGetType(dev) != VIR_JSON_TYPE_OBJECT) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"blockstats device entry was not \"\n                             \"in expected format\"));\n            return -1;\n        }\n\n        if (!(dev_name = virJSONValueObjectGetString(dev, \"device\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"blockstats device entry was not \"\n                             \"in expected format\"));\n            return -1;\n        }\n\n        if (*dev_name == '\\0')\n            dev_name = NULL;\n\n        rc = qemuMonitorJSONGetOneBlockStatsInfo(dev, dev_name, 0, hash,\n                                                 backingChain);\n\n        if (rc < 0)\n            return -1;\n\n        if (rc > nstats)\n            nstats = rc;\n    }\n\n    return nstats;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "10",
            "virHashValueFree"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"ret_stats=%p, backing=%d\"",
            "ret_stats",
            "backingChain"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetAllBlockStatsInfo(qemuMonitorPtr mon,\n                                virHashTablePtr *ret_stats,\n                                bool backingChain)\n{\n    int ret = -1;\n    VIR_DEBUG(\"ret_stats=%p, backing=%d\", ret_stats, backingChain);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (!(*ret_stats = virHashCreate(10, virHashValueFree)))\n        goto error;\n\n    ret = qemuMonitorJSONGetAllBlockStatsInfo(mon, *ret_stats,\n                                              backingChain);\n\n    if (ret < 0)\n        goto error;\n\n    return ret;\n\n error:\n    virHashFree(*ret_stats);\n    *ret_stats = NULL;\n    return -1;\n}"
  },
  {
    "function_name": "qemuMonitorQueryBlockstats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2099-2105",
    "snippet": "virJSONValuePtr\nqemuMonitorQueryBlockstats(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    return qemuMonitorJSONQueryBlockstats(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONQueryBlockstats",
          "args": [
            "mon"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONQueryBlockstats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "2657-2679",
          "snippet": "virJSONValuePtr\nqemuMonitorJSONQueryBlockstats(qemuMonitorPtr mon)\n{\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr ret = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-blockstats\", NULL)))\n        return NULL;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    ret = virJSONValueObjectStealArray(reply, \"return\");\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirJSONValuePtr\nqemuMonitorJSONQueryBlockstats(qemuMonitorPtr mon)\n{\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr ret = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-blockstats\", NULL)))\n        return NULL;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    ret = virJSONValueObjectStealArray(reply, \"return\");\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR_NULL",
          "args": [
            "mon"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirJSONValuePtr\nqemuMonitorQueryBlockstats(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    return qemuMonitorJSONQueryBlockstats(mon);\n}"
  },
  {
    "function_name": "qemuMonitorGetBlockInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2071-2090",
    "snippet": "virHashTablePtr\nqemuMonitorGetBlockInfo(qemuMonitorPtr mon)\n{\n    int ret;\n    virHashTablePtr table;\n\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    if (!(table = virHashCreate(32, qemuDomainDiskInfoFree)))\n        return NULL;\n\n    ret = qemuMonitorJSONGetBlockInfo(mon, table);\n\n    if (ret < 0) {\n        virHashFree(table);\n        return NULL;\n    }\n\n    return table;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "table"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetBlockInfo",
          "args": [
            "mon",
            "table"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetBlockInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "2456-2531",
          "snippet": "int qemuMonitorJSONGetBlockInfo(qemuMonitorPtr mon,\n                                virHashTablePtr table)\n{\n    int ret = -1;\n    size_t i;\n\n    virJSONValuePtr devices;\n\n    if (!(devices = qemuMonitorJSONQueryBlock(mon)))\n        return -1;\n\n    for (i = 0; i < virJSONValueArraySize(devices); i++) {\n        virJSONValuePtr dev;\n        virJSONValuePtr image;\n        struct qemuDomainDiskInfo info = { false };\n        const char *thisdev;\n        const char *status;\n        const char *qdev;\n\n        if (!(dev = qemuMonitorJSONGetBlockDev(devices, i)))\n            goto cleanup;\n\n        if (!(thisdev = qemuMonitorJSONGetBlockDevDevice(dev)))\n            goto cleanup;\n\n        thisdev = qemuAliasDiskDriveSkipPrefix(thisdev);\n        qdev = virJSONValueObjectGetString(dev, \"qdev\");\n\n        if (*thisdev == '\\0')\n            thisdev = NULL;\n\n        if (!qdev && !thisdev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-block device entry was not in expected format\"));\n            goto cleanup;\n        }\n\n        if (virJSONValueObjectGetBoolean(dev, \"removable\", &info.removable) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"cannot read %s value\"),\n                           \"removable\");\n            goto cleanup;\n        }\n\n        /* 'tray_open' is present only if the device has a tray */\n        if (virJSONValueObjectGetBoolean(dev, \"tray_open\", &info.tray_open) == 0)\n            info.tray = true;\n\n        /* presence of 'inserted' notifies that a medium is in the device */\n        if ((image = virJSONValueObjectGetObject(dev, \"inserted\"))) {\n            info.nodename = (char *) virJSONValueObjectGetString(image, \"node-name\");\n        } else {\n            info.empty = true;\n        }\n\n        /* Missing io-status indicates no error */\n        if ((status = virJSONValueObjectGetString(dev, \"io-status\"))) {\n            info.io_status = qemuMonitorBlockIOStatusToError(status);\n            if (info.io_status < 0)\n                goto cleanup;\n        }\n\n        if (thisdev &&\n            qemuMonitorJSONBlockInfoAdd(table, &info, thisdev) < 0)\n            goto cleanup;\n\n        if (qdev && STRNEQ_NULLABLE(thisdev, qdev) &&\n            qemuMonitorJSONBlockInfoAdd(table, &info, qdev) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(devices);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONGetBlockInfo(qemuMonitorPtr mon,\n                                virHashTablePtr table)\n{\n    int ret = -1;\n    size_t i;\n\n    virJSONValuePtr devices;\n\n    if (!(devices = qemuMonitorJSONQueryBlock(mon)))\n        return -1;\n\n    for (i = 0; i < virJSONValueArraySize(devices); i++) {\n        virJSONValuePtr dev;\n        virJSONValuePtr image;\n        struct qemuDomainDiskInfo info = { false };\n        const char *thisdev;\n        const char *status;\n        const char *qdev;\n\n        if (!(dev = qemuMonitorJSONGetBlockDev(devices, i)))\n            goto cleanup;\n\n        if (!(thisdev = qemuMonitorJSONGetBlockDevDevice(dev)))\n            goto cleanup;\n\n        thisdev = qemuAliasDiskDriveSkipPrefix(thisdev);\n        qdev = virJSONValueObjectGetString(dev, \"qdev\");\n\n        if (*thisdev == '\\0')\n            thisdev = NULL;\n\n        if (!qdev && !thisdev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"query-block device entry was not in expected format\"));\n            goto cleanup;\n        }\n\n        if (virJSONValueObjectGetBoolean(dev, \"removable\", &info.removable) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"cannot read %s value\"),\n                           \"removable\");\n            goto cleanup;\n        }\n\n        /* 'tray_open' is present only if the device has a tray */\n        if (virJSONValueObjectGetBoolean(dev, \"tray_open\", &info.tray_open) == 0)\n            info.tray = true;\n\n        /* presence of 'inserted' notifies that a medium is in the device */\n        if ((image = virJSONValueObjectGetObject(dev, \"inserted\"))) {\n            info.nodename = (char *) virJSONValueObjectGetString(image, \"node-name\");\n        } else {\n            info.empty = true;\n        }\n\n        /* Missing io-status indicates no error */\n        if ((status = virJSONValueObjectGetString(dev, \"io-status\"))) {\n            info.io_status = qemuMonitorBlockIOStatusToError(status);\n            if (info.io_status < 0)\n                goto cleanup;\n        }\n\n        if (thisdev &&\n            qemuMonitorJSONBlockInfoAdd(table, &info, thisdev) < 0)\n            goto cleanup;\n\n        if (qdev && STRNEQ_NULLABLE(thisdev, qdev) &&\n            qemuMonitorJSONBlockInfoAdd(table, &info, qdev) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(devices);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "32",
            "qemuDomainDiskInfoFree"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR_NULL",
          "args": [
            "mon"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirHashTablePtr\nqemuMonitorGetBlockInfo(qemuMonitorPtr mon)\n{\n    int ret;\n    virHashTablePtr table;\n\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    if (!(table = virHashCreate(32, qemuDomainDiskInfoFree)))\n        return NULL;\n\n    ret = qemuMonitorJSONGetBlockInfo(mon, table);\n\n    if (ret < 0) {\n        virHashFree(table);\n        return NULL;\n    }\n\n    return table;\n}"
  },
  {
    "function_name": "qemuDomainDiskInfoFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2061-2068",
    "snippet": "static void\nqemuDomainDiskInfoFree(void *value)\n{\n    struct qemuDomainDiskInfo *info = value;\n\n    VIR_FREE(info->nodename);\n    VIR_FREE(info);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "info"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "info->nodename"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void\nqemuDomainDiskInfoFree(void *value)\n{\n    struct qemuDomainDiskInfo *info = value;\n\n    VIR_FREE(info->nodename);\n    VIR_FREE(info);\n}"
  },
  {
    "function_name": "qemuMonitorBlockIOStatusToError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2034-2058",
    "snippet": "int\nqemuMonitorBlockIOStatusToError(const char *status)\n{\n    int st = qemuMonitorBlockIOStatusTypeFromString(status);\n\n    if (st < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown block IO status: %s\"), status);\n        return -1;\n    }\n\n    switch ((qemuMonitorBlockIOStatus) st) {\n    case QEMU_MONITOR_BLOCK_IO_STATUS_OK:\n        return VIR_DOMAIN_DISK_ERROR_NONE;\n    case QEMU_MONITOR_BLOCK_IO_STATUS_FAILED:\n        return VIR_DOMAIN_DISK_ERROR_UNSPEC;\n    case QEMU_MONITOR_BLOCK_IO_STATUS_NOSPACE:\n        return VIR_DOMAIN_DISK_ERROR_NO_SPACE;\n\n    /* unreachable */\n    case QEMU_MONITOR_BLOCK_IO_STATUS_LAST:\n        break;\n    }\n    return -1;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown block IO status: %s\")",
            "status"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown block IO status: %s\""
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorBlockIOStatusTypeFromString",
          "args": [
            "status"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockIOStatusToError(const char *status)\n{\n    int st = qemuMonitorBlockIOStatusTypeFromString(status);\n\n    if (st < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown block IO status: %s\"), status);\n        return -1;\n    }\n\n    switch ((qemuMonitorBlockIOStatus) st) {\n    case QEMU_MONITOR_BLOCK_IO_STATUS_OK:\n        return VIR_DOMAIN_DISK_ERROR_NONE;\n    case QEMU_MONITOR_BLOCK_IO_STATUS_FAILED:\n        return VIR_DOMAIN_DISK_ERROR_UNSPEC;\n    case QEMU_MONITOR_BLOCK_IO_STATUS_NOSPACE:\n        return VIR_DOMAIN_DISK_ERROR_NO_SPACE;\n\n    /* unreachable */\n    case QEMU_MONITOR_BLOCK_IO_STATUS_LAST:\n        break;\n    }\n    return -1;\n}"
  },
  {
    "function_name": "qemuMonitorSetMemoryStatsPeriod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "2002-2031",
    "snippet": "int\nqemuMonitorSetMemoryStatsPeriod(qemuMonitorPtr mon,\n                                virDomainMemballoonDefPtr balloon,\n                                int period)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p period=%d\", mon, period);\n\n    if (!mon)\n        return -1;\n\n    if (period < 0)\n        return -1;\n\n    qemuMonitorInitBalloonObjectPath(mon, balloon);\n    if (mon->balloonpath) {\n        ret = qemuMonitorJSONSetMemoryStatsPeriod(mon, mon->balloonpath,\n                                                  period);\n\n        /*\n         * Most of the calls to this function are supposed to be\n         * non-fatal and the only one that should be fatal wants its\n         * own error message.  More details for debugging will be in\n         * the log file.\n         */\n        if (ret < 0)\n            virResetLastError();\n    }\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONSetMemoryStatsPeriod",
          "args": [
            "mon",
            "mon->balloonpath",
            "period"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSetMemoryStatsPeriod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "2344-2361",
          "snippet": "int\nqemuMonitorJSONSetMemoryStatsPeriod(qemuMonitorPtr mon,\n                                    char *balloonpath,\n                                    int period)\n{\n    qemuMonitorJSONObjectProperty prop;\n\n    /* Set to the value in memballoon (could enable or disable) */\n    memset(&prop, 0, sizeof(qemuMonitorJSONObjectProperty));\n    prop.type = QEMU_MONITOR_OBJECT_PROPERTY_INT;\n    prop.val.iv = period;\n    if (qemuMonitorJSONSetObjectProperty(mon, balloonpath,\n                                         \"guest-stats-polling-interval\",\n                                         &prop) < 0) {\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONSetMemoryStatsPeriod(qemuMonitorPtr mon,\n                                    char *balloonpath,\n                                    int period)\n{\n    qemuMonitorJSONObjectProperty prop;\n\n    /* Set to the value in memballoon (could enable or disable) */\n    memset(&prop, 0, sizeof(qemuMonitorJSONObjectProperty));\n    prop.type = QEMU_MONITOR_OBJECT_PROPERTY_INT;\n    prop.val.iv = period;\n    if (qemuMonitorJSONSetObjectProperty(mon, balloonpath,\n                                         \"guest-stats-polling-interval\",\n                                         &prop) < 0) {\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorInitBalloonObjectPath",
          "args": [
            "mon",
            "balloon"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorInitBalloonObjectPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "998-1055",
          "snippet": "static void\nqemuMonitorInitBalloonObjectPath(qemuMonitorPtr mon,\n                                 virDomainMemballoonDefPtr balloon)\n{\n    ssize_t i, nprops = 0;\n    char *path = NULL;\n    const char *name;\n    qemuMonitorJSONListPathPtr *bprops = NULL;\n\n    if (mon->balloonpath) {\n        return;\n    } else if (mon->ballooninit) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot determine balloon device path\"));\n        return;\n    }\n    mon->ballooninit = true;\n\n    switch (balloon->info.type) {\n    case VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI:\n        name = \"virtio-balloon-pci\";\n        break;\n    case VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW:\n        name = \"virtio-balloon-ccw\";\n        break;\n    default:\n        return;\n    }\n\n    if (qemuMonitorJSONFindLinkPath(mon, name, balloon->info.alias, &path) < 0)\n        return;\n\n    nprops = qemuMonitorJSONGetObjectListPaths(mon, path, &bprops);\n    if (nprops < 0)\n        goto cleanup;\n\n    for (i = 0; i < nprops; i++) {\n        if (STREQ(bprops[i]->name, \"guest-stats-polling-interval\")) {\n            VIR_DEBUG(\"Found Balloon Object Path %s\", path);\n            mon->balloonpath = path;\n            path = NULL;\n            goto cleanup;\n        }\n    }\n\n\n    /* If we get here, we found the path, but not the property */\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Property 'guest-stats-polling-interval' \"\n                     \"not found on memory balloon driver.\"));\n\n cleanup:\n    for (i = 0; i < nprops; i++)\n        qemuMonitorJSONListPathFree(bprops[i]);\n    VIR_FREE(bprops);\n    VIR_FREE(path);\n    return;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void\nqemuMonitorInitBalloonObjectPath(qemuMonitorPtr mon,\n                                 virDomainMemballoonDefPtr balloon)\n{\n    ssize_t i, nprops = 0;\n    char *path = NULL;\n    const char *name;\n    qemuMonitorJSONListPathPtr *bprops = NULL;\n\n    if (mon->balloonpath) {\n        return;\n    } else if (mon->ballooninit) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot determine balloon device path\"));\n        return;\n    }\n    mon->ballooninit = true;\n\n    switch (balloon->info.type) {\n    case VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI:\n        name = \"virtio-balloon-pci\";\n        break;\n    case VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW:\n        name = \"virtio-balloon-ccw\";\n        break;\n    default:\n        return;\n    }\n\n    if (qemuMonitorJSONFindLinkPath(mon, name, balloon->info.alias, &path) < 0)\n        return;\n\n    nprops = qemuMonitorJSONGetObjectListPaths(mon, path, &bprops);\n    if (nprops < 0)\n        goto cleanup;\n\n    for (i = 0; i < nprops; i++) {\n        if (STREQ(bprops[i]->name, \"guest-stats-polling-interval\")) {\n            VIR_DEBUG(\"Found Balloon Object Path %s\", path);\n            mon->balloonpath = path;\n            path = NULL;\n            goto cleanup;\n        }\n    }\n\n\n    /* If we get here, we found the path, but not the property */\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Property 'guest-stats-polling-interval' \"\n                     \"not found on memory balloon driver.\"));\n\n cleanup:\n    for (i = 0; i < nprops; i++)\n        qemuMonitorJSONListPathFree(bprops[i]);\n    VIR_FREE(bprops);\n    VIR_FREE(path);\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p period=%d\"",
            "mon",
            "period"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSetMemoryStatsPeriod(qemuMonitorPtr mon,\n                                virDomainMemballoonDefPtr balloon,\n                                int period)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p period=%d\", mon, period);\n\n    if (!mon)\n        return -1;\n\n    if (period < 0)\n        return -1;\n\n    qemuMonitorInitBalloonObjectPath(mon, balloon);\n    if (mon->balloonpath) {\n        ret = qemuMonitorJSONSetMemoryStatsPeriod(mon, mon->balloonpath,\n                                                  period);\n\n        /*\n         * Most of the calls to this function are supposed to be\n         * non-fatal and the only one that should be fatal wants its\n         * own error message.  More details for debugging will be in\n         * the log file.\n         */\n        if (ret < 0)\n            virResetLastError();\n    }\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorGetMemoryStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1979-1992",
    "snippet": "int\nqemuMonitorGetMemoryStats(qemuMonitorPtr mon,\n                          virDomainMemballoonDefPtr balloon,\n                          virDomainMemoryStatPtr stats,\n                          unsigned int nr_stats)\n{\n    VIR_DEBUG(\"stats=%p nstats=%u\", stats, nr_stats);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    qemuMonitorInitBalloonObjectPath(mon, balloon);\n    return qemuMonitorJSONGetMemoryStats(mon, mon->balloonpath,\n                                         stats, nr_stats);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetMemoryStats",
          "args": [
            "mon",
            "mon->balloonpath",
            "stats",
            "nr_stats"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetMemoryStats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "2254-2336",
          "snippet": "int qemuMonitorJSONGetMemoryStats(qemuMonitorPtr mon,\n                                  char *balloonpath,\n                                  virDomainMemoryStatPtr stats,\n                                  unsigned int nr_stats)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    virJSONValuePtr statsdata;\n    unsigned long long mem;\n    int got = 0;\n\n    ret = qemuMonitorJSONGetBalloonInfo(mon, &mem);\n    if (ret == 1 && (got < nr_stats)) {\n        stats[got].tag = VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON;\n        stats[got].val = mem;\n        got++;\n    }\n\n    if (!balloonpath)\n        goto cleanup;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"qom-get\",\n                                           \"s:path\", balloonpath,\n                                           \"s:property\", \"guest-stats\",\n                                           NULL)))\n        goto cleanup;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if ((data = virJSONValueObjectGetObject(reply, \"error\"))) {\n        const char *klass = virJSONValueObjectGetString(data, \"class\");\n        const char *desc = virJSONValueObjectGetString(data, \"desc\");\n\n        if (STREQ_NULLABLE(klass, \"GenericError\") &&\n            STREQ_NULLABLE(desc, \"guest hasn't updated any stats yet\")) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"the guest hasn't updated any stats yet\"));\n            goto cleanup;\n        }\n    }\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (!(statsdata = virJSONValueObjectGet(data, \"stats\"))) {\n        VIR_DEBUG(\"data does not include 'stats'\");\n        goto cleanup;\n    }\n\n    GET_BALLOON_STATS(statsdata, \"stat-swap-in\",\n                      VIR_DOMAIN_MEMORY_STAT_SWAP_IN, 1024);\n    GET_BALLOON_STATS(statsdata, \"stat-swap-out\",\n                      VIR_DOMAIN_MEMORY_STAT_SWAP_OUT, 1024);\n    GET_BALLOON_STATS(statsdata, \"stat-major-faults\",\n                      VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT, 1);\n    GET_BALLOON_STATS(statsdata, \"stat-minor-faults\",\n                      VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT, 1);\n    GET_BALLOON_STATS(statsdata, \"stat-free-memory\",\n                      VIR_DOMAIN_MEMORY_STAT_UNUSED, 1024);\n    GET_BALLOON_STATS(statsdata, \"stat-total-memory\",\n                      VIR_DOMAIN_MEMORY_STAT_AVAILABLE, 1024);\n    GET_BALLOON_STATS(statsdata, \"stat-available-memory\",\n                      VIR_DOMAIN_MEMORY_STAT_USABLE, 1024);\n    GET_BALLOON_STATS(data, \"last-update\",\n                      VIR_DOMAIN_MEMORY_STAT_LAST_UPDATE, 1);\n    GET_BALLOON_STATS(statsdata, \"stat-disk-caches\",\n                      VIR_DOMAIN_MEMORY_STAT_DISK_CACHES, 1024);\n    GET_BALLOON_STATS(statsdata, \"stat-htlb-pgalloc\",\n                      VIR_DOMAIN_MEMORY_STAT_HUGETLB_PGALLOC, 1);\n    GET_BALLOON_STATS(statsdata, \"stat-htlb-pgfail\",\n                      VIR_DOMAIN_MEMORY_STAT_HUGETLB_PGFAIL, 1);\n\n    ret = got;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint qemuMonitorJSONGetMemoryStats(qemuMonitorPtr mon,\n                                  char *balloonpath,\n                                  virDomainMemoryStatPtr stats,\n                                  unsigned int nr_stats)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = NULL;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    virJSONValuePtr statsdata;\n    unsigned long long mem;\n    int got = 0;\n\n    ret = qemuMonitorJSONGetBalloonInfo(mon, &mem);\n    if (ret == 1 && (got < nr_stats)) {\n        stats[got].tag = VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON;\n        stats[got].val = mem;\n        got++;\n    }\n\n    if (!balloonpath)\n        goto cleanup;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"qom-get\",\n                                           \"s:path\", balloonpath,\n                                           \"s:property\", \"guest-stats\",\n                                           NULL)))\n        goto cleanup;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if ((data = virJSONValueObjectGetObject(reply, \"error\"))) {\n        const char *klass = virJSONValueObjectGetString(data, \"class\");\n        const char *desc = virJSONValueObjectGetString(data, \"desc\");\n\n        if (STREQ_NULLABLE(klass, \"GenericError\") &&\n            STREQ_NULLABLE(desc, \"guest hasn't updated any stats yet\")) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"the guest hasn't updated any stats yet\"));\n            goto cleanup;\n        }\n    }\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (!(statsdata = virJSONValueObjectGet(data, \"stats\"))) {\n        VIR_DEBUG(\"data does not include 'stats'\");\n        goto cleanup;\n    }\n\n    GET_BALLOON_STATS(statsdata, \"stat-swap-in\",\n                      VIR_DOMAIN_MEMORY_STAT_SWAP_IN, 1024);\n    GET_BALLOON_STATS(statsdata, \"stat-swap-out\",\n                      VIR_DOMAIN_MEMORY_STAT_SWAP_OUT, 1024);\n    GET_BALLOON_STATS(statsdata, \"stat-major-faults\",\n                      VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT, 1);\n    GET_BALLOON_STATS(statsdata, \"stat-minor-faults\",\n                      VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT, 1);\n    GET_BALLOON_STATS(statsdata, \"stat-free-memory\",\n                      VIR_DOMAIN_MEMORY_STAT_UNUSED, 1024);\n    GET_BALLOON_STATS(statsdata, \"stat-total-memory\",\n                      VIR_DOMAIN_MEMORY_STAT_AVAILABLE, 1024);\n    GET_BALLOON_STATS(statsdata, \"stat-available-memory\",\n                      VIR_DOMAIN_MEMORY_STAT_USABLE, 1024);\n    GET_BALLOON_STATS(data, \"last-update\",\n                      VIR_DOMAIN_MEMORY_STAT_LAST_UPDATE, 1);\n    GET_BALLOON_STATS(statsdata, \"stat-disk-caches\",\n                      VIR_DOMAIN_MEMORY_STAT_DISK_CACHES, 1024);\n    GET_BALLOON_STATS(statsdata, \"stat-htlb-pgalloc\",\n                      VIR_DOMAIN_MEMORY_STAT_HUGETLB_PGALLOC, 1);\n    GET_BALLOON_STATS(statsdata, \"stat-htlb-pgfail\",\n                      VIR_DOMAIN_MEMORY_STAT_HUGETLB_PGFAIL, 1);\n\n    ret = got;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorInitBalloonObjectPath",
          "args": [
            "mon",
            "balloon"
          ],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorInitBalloonObjectPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "998-1055",
          "snippet": "static void\nqemuMonitorInitBalloonObjectPath(qemuMonitorPtr mon,\n                                 virDomainMemballoonDefPtr balloon)\n{\n    ssize_t i, nprops = 0;\n    char *path = NULL;\n    const char *name;\n    qemuMonitorJSONListPathPtr *bprops = NULL;\n\n    if (mon->balloonpath) {\n        return;\n    } else if (mon->ballooninit) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot determine balloon device path\"));\n        return;\n    }\n    mon->ballooninit = true;\n\n    switch (balloon->info.type) {\n    case VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI:\n        name = \"virtio-balloon-pci\";\n        break;\n    case VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW:\n        name = \"virtio-balloon-ccw\";\n        break;\n    default:\n        return;\n    }\n\n    if (qemuMonitorJSONFindLinkPath(mon, name, balloon->info.alias, &path) < 0)\n        return;\n\n    nprops = qemuMonitorJSONGetObjectListPaths(mon, path, &bprops);\n    if (nprops < 0)\n        goto cleanup;\n\n    for (i = 0; i < nprops; i++) {\n        if (STREQ(bprops[i]->name, \"guest-stats-polling-interval\")) {\n            VIR_DEBUG(\"Found Balloon Object Path %s\", path);\n            mon->balloonpath = path;\n            path = NULL;\n            goto cleanup;\n        }\n    }\n\n\n    /* If we get here, we found the path, but not the property */\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Property 'guest-stats-polling-interval' \"\n                     \"not found on memory balloon driver.\"));\n\n cleanup:\n    for (i = 0; i < nprops; i++)\n        qemuMonitorJSONListPathFree(bprops[i]);\n    VIR_FREE(bprops);\n    VIR_FREE(path);\n    return;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void\nqemuMonitorInitBalloonObjectPath(qemuMonitorPtr mon,\n                                 virDomainMemballoonDefPtr balloon)\n{\n    ssize_t i, nprops = 0;\n    char *path = NULL;\n    const char *name;\n    qemuMonitorJSONListPathPtr *bprops = NULL;\n\n    if (mon->balloonpath) {\n        return;\n    } else if (mon->ballooninit) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot determine balloon device path\"));\n        return;\n    }\n    mon->ballooninit = true;\n\n    switch (balloon->info.type) {\n    case VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI:\n        name = \"virtio-balloon-pci\";\n        break;\n    case VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW:\n        name = \"virtio-balloon-ccw\";\n        break;\n    default:\n        return;\n    }\n\n    if (qemuMonitorJSONFindLinkPath(mon, name, balloon->info.alias, &path) < 0)\n        return;\n\n    nprops = qemuMonitorJSONGetObjectListPaths(mon, path, &bprops);\n    if (nprops < 0)\n        goto cleanup;\n\n    for (i = 0; i < nprops; i++) {\n        if (STREQ(bprops[i]->name, \"guest-stats-polling-interval\")) {\n            VIR_DEBUG(\"Found Balloon Object Path %s\", path);\n            mon->balloonpath = path;\n            path = NULL;\n            goto cleanup;\n        }\n    }\n\n\n    /* If we get here, we found the path, but not the property */\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Property 'guest-stats-polling-interval' \"\n                     \"not found on memory balloon driver.\"));\n\n cleanup:\n    for (i = 0; i < nprops; i++)\n        qemuMonitorJSONListPathFree(bprops[i]);\n    VIR_FREE(bprops);\n    VIR_FREE(path);\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"stats=%p nstats=%u\"",
            "stats",
            "nr_stats"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetMemoryStats(qemuMonitorPtr mon,\n                          virDomainMemballoonDefPtr balloon,\n                          virDomainMemoryStatPtr stats,\n                          unsigned int nr_stats)\n{\n    VIR_DEBUG(\"stats=%p nstats=%u\", stats, nr_stats);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    qemuMonitorInitBalloonObjectPath(mon, balloon);\n    return qemuMonitorJSONGetMemoryStats(mon, mon->balloonpath,\n                                         stats, nr_stats);\n}"
  },
  {
    "function_name": "qemuMonitorGetBalloonInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1969-1976",
    "snippet": "int\nqemuMonitorGetBalloonInfo(qemuMonitorPtr mon,\n                          unsigned long long *currmem)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetBalloonInfo(mon, currmem);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetBalloonInfo",
          "args": [
            "mon",
            "currmem"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetBalloonInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "2170-2214",
          "snippet": "int\nqemuMonitorJSONGetBalloonInfo(qemuMonitorPtr mon,\n                              unsigned long long *currmem)\n{\n    int ret = -1;\n    virJSONValuePtr data;\n    unsigned long long mem;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"query-balloon\",\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n\n    *currmem = 0;\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    /* See if balloon soft-failed */\n    if (qemuMonitorJSONHasError(reply, \"DeviceNotActive\") ||\n        qemuMonitorJSONHasError(reply, \"KVMMissingCap\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* See if any other fatal error occurred */\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (virJSONValueObjectGetNumberUlong(data, \"actual\", &mem) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"info balloon reply was missing balloon data\"));\n        goto cleanup;\n    }\n\n    *currmem = (mem/1024);\n    ret = 1;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint\nqemuMonitorJSONGetBalloonInfo(qemuMonitorPtr mon,\n                              unsigned long long *currmem)\n{\n    int ret = -1;\n    virJSONValuePtr data;\n    unsigned long long mem;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"query-balloon\",\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n\n    *currmem = 0;\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    /* See if balloon soft-failed */\n    if (qemuMonitorJSONHasError(reply, \"DeviceNotActive\") ||\n        qemuMonitorJSONHasError(reply, \"KVMMissingCap\")) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* See if any other fatal error occurred */\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (virJSONValueObjectGetNumberUlong(data, \"actual\", &mem) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"info balloon reply was missing balloon data\"));\n        goto cleanup;\n    }\n\n    *currmem = (mem/1024);\n    ret = 1;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetBalloonInfo(qemuMonitorPtr mon,\n                          unsigned long long *currmem)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetBalloonInfo(mon, currmem);\n}"
  },
  {
    "function_name": "qemuMonitorGetVirtType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1955-1962",
    "snippet": "int\nqemuMonitorGetVirtType(qemuMonitorPtr mon,\n                       virDomainVirtType *virtType)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetVirtType(mon, virtType);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetVirtType",
          "args": [
            "mon",
            "virtType"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetVirtType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "2018-2055",
          "snippet": "int qemuMonitorJSONGetVirtType(qemuMonitorPtr mon,\n                               virDomainVirtType *virtType)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"query-kvm\",\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    bool val = false;\n\n    *virtType = VIR_DOMAIN_VIRT_QEMU;\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (virJSONValueObjectGetBoolean(data, \"enabled\", &val) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"info kvm reply missing 'enabled' field\"));\n        goto cleanup;\n    }\n\n    if (val)\n        *virtType = VIR_DOMAIN_VIRT_KVM;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint qemuMonitorJSONGetVirtType(qemuMonitorPtr mon,\n                               virDomainVirtType *virtType)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"query-kvm\",\n                                                     NULL);\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    bool val = false;\n\n    *virtType = VIR_DOMAIN_VIRT_QEMU;\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (virJSONValueObjectGetBoolean(data, \"enabled\", &val) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"info kvm reply missing 'enabled' field\"));\n        goto cleanup;\n    }\n\n    if (val)\n        *virtType = VIR_DOMAIN_VIRT_KVM;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetVirtType(qemuMonitorPtr mon,\n                       virDomainVirtType *virtType)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetVirtType(mon, virtType);\n}"
  },
  {
    "function_name": "qemuMonitorSetLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1942-1952",
    "snippet": "int\nqemuMonitorSetLink(qemuMonitorPtr mon,\n                   const char *name,\n                   virDomainNetInterfaceLinkState state)\n{\n    VIR_DEBUG(\"name=%s, state=%u\", name, state);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetLink(mon, name, state);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSetLink",
          "args": [
            "mon",
            "name",
            "state"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSetLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "1763-1788",
          "snippet": "int qemuMonitorJSONSetLink(qemuMonitorPtr mon,\n                           const char *name,\n                           virDomainNetInterfaceLinkState state)\n{\n    int ret = -1;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"set_link\",\n                                                     \"s:name\", name,\n                                                     \"b:up\", state != VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN,\n                                                     NULL);\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONSetLink(qemuMonitorPtr mon,\n                           const char *name,\n                           virDomainNetInterfaceLinkState state)\n{\n    int ret = -1;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"set_link\",\n                                                     \"s:name\", name,\n                                                     \"b:up\", state != VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN,\n                                                     NULL);\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"name=%s, state=%u\"",
            "name",
            "state"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSetLink(qemuMonitorPtr mon,\n                   const char *name,\n                   virDomainNetInterfaceLinkState state)\n{\n    VIR_DEBUG(\"name=%s, state=%u\", name, state);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetLink(mon, name, state);\n}"
  },
  {
    "function_name": "qemuMonitorGetCpuHalted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1909-1939",
    "snippet": "virBitmapPtr\nqemuMonitorGetCpuHalted(qemuMonitorPtr mon,\n                        size_t maxvcpus,\n                        bool fast)\n{\n    struct qemuMonitorQueryCpusEntry *cpuentries = NULL;\n    size_t ncpuentries = 0;\n    size_t i;\n    int rc;\n    virBitmapPtr ret = NULL;\n\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    rc = qemuMonitorJSONQueryCPUs(mon, &cpuentries, &ncpuentries, false,\n                                  fast);\n\n    if (rc < 0)\n        goto cleanup;\n\n    if (!(ret = virBitmapNew(maxvcpus)))\n        goto cleanup;\n\n    for (i = 0; i < ncpuentries; i++) {\n        if (cpuentries[i].halted)\n            ignore_value(virBitmapSetBit(ret, cpuentries[i].qemu_id));\n    }\n\n cleanup:\n    qemuMonitorQueryCpusFree(cpuentries, ncpuentries);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorQueryCpusFree",
          "args": [
            "cpuentries",
            "ncpuentries"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorQueryCpusFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "1646-1659",
          "snippet": "void\nqemuMonitorQueryCpusFree(struct qemuMonitorQueryCpusEntry *entries,\n                         size_t nentries)\n{\n    size_t i;\n\n    if (!entries)\n        return;\n\n    for (i = 0; i < nentries; i++)\n        VIR_FREE(entries[i].qom_path);\n\n    VIR_FREE(entries);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorQueryCpusFree(struct qemuMonitorQueryCpusEntry *entries,\n                         size_t nentries)\n{\n    size_t i;\n\n    if (!entries)\n        return;\n\n    for (i = 0; i < nentries; i++)\n        VIR_FREE(entries[i].qom_path);\n\n    VIR_FREE(entries);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(ret, cpuentries[i].qemu_id)"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "ret",
            "cpuentries[i].qemu_id"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "maxvcpus"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONQueryCPUs",
          "args": [
            "mon",
            "&cpuentries",
            "&ncpuentries",
            "false",
            "fast"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONQueryCPUs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "1978-2015",
          "snippet": "int\nqemuMonitorJSONQueryCPUs(qemuMonitorPtr mon,\n                         struct qemuMonitorQueryCpusEntry **entries,\n                         size_t *nentries,\n                         bool force,\n                         bool fast)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n\n    if (fast)\n        cmd = qemuMonitorJSONMakeCommand(\"query-cpus-fast\", NULL);\n    else\n        cmd = qemuMonitorJSONMakeCommand(\"query-cpus\", NULL);\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (force && qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    if (!(data = virJSONValueObjectGetArray(reply, \"return\"))) {\n        ret = -2;\n        goto cleanup;\n    }\n\n    ret = qemuMonitorJSONExtractCPUInfo(data, entries, nentries, fast);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint\nqemuMonitorJSONQueryCPUs(qemuMonitorPtr mon,\n                         struct qemuMonitorQueryCpusEntry **entries,\n                         size_t *nentries,\n                         bool force,\n                         bool fast)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n\n    if (fast)\n        cmd = qemuMonitorJSONMakeCommand(\"query-cpus-fast\", NULL);\n    else\n        cmd = qemuMonitorJSONMakeCommand(\"query-cpus\", NULL);\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (force && qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    if (!(data = virJSONValueObjectGetArray(reply, \"return\"))) {\n        ret = -2;\n        goto cleanup;\n    }\n\n    ret = qemuMonitorJSONExtractCPUInfo(data, entries, nentries, fast);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR_NULL",
          "args": [
            "mon"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirBitmapPtr\nqemuMonitorGetCpuHalted(qemuMonitorPtr mon,\n                        size_t maxvcpus,\n                        bool fast)\n{\n    struct qemuMonitorQueryCpusEntry *cpuentries = NULL;\n    size_t ncpuentries = 0;\n    size_t i;\n    int rc;\n    virBitmapPtr ret = NULL;\n\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    rc = qemuMonitorJSONQueryCPUs(mon, &cpuentries, &ncpuentries, false,\n                                  fast);\n\n    if (rc < 0)\n        goto cleanup;\n\n    if (!(ret = virBitmapNew(maxvcpus)))\n        goto cleanup;\n\n    for (i = 0; i < ncpuentries; i++) {\n        if (cpuentries[i].halted)\n            ignore_value(virBitmapSetBit(ret, cpuentries[i].qemu_id));\n    }\n\n cleanup:\n    qemuMonitorQueryCpusFree(cpuentries, ncpuentries);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorGetCPUInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1843-1900",
    "snippet": "int\nqemuMonitorGetCPUInfo(qemuMonitorPtr mon,\n                      qemuMonitorCPUInfoPtr *vcpus,\n                      size_t maxvcpus,\n                      bool hotplug,\n                      bool fast)\n{\n    struct qemuMonitorQueryHotpluggableCpusEntry *hotplugcpus = NULL;\n    size_t nhotplugcpus = 0;\n    struct qemuMonitorQueryCpusEntry *cpuentries = NULL;\n    size_t ncpuentries = 0;\n    int ret = -1;\n    int rc;\n    qemuMonitorCPUInfoPtr info = NULL;\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (VIR_ALLOC_N(info, maxvcpus) < 0)\n        return -1;\n\n    /* initialize a few non-zero defaults */\n    qemuMonitorCPUInfoClear(info, maxvcpus);\n\n    if (hotplug &&\n        (qemuMonitorJSONGetHotpluggableCPUs(mon, &hotplugcpus, &nhotplugcpus)) < 0)\n        goto cleanup;\n\n    rc = qemuMonitorJSONQueryCPUs(mon, &cpuentries, &ncpuentries, hotplug,\n                                  fast);\n\n    if (rc < 0) {\n        if (!hotplug && rc == -2) {\n            *vcpus = g_steal_pointer(&info);\n            ret = 0;\n        }\n\n        goto cleanup;\n    }\n\n    if (!hotplugcpus ||\n        qemuMonitorGetCPUInfoHotplug(hotplugcpus, nhotplugcpus,\n                                     cpuentries, ncpuentries,\n                                     info, maxvcpus) < 0) {\n        /* Fallback to the legacy algorithm. Hotplug paths will make sure that\n         * the appropriate data is present */\n        qemuMonitorCPUInfoClear(info, maxvcpus);\n        qemuMonitorGetCPUInfoLegacy(cpuentries, ncpuentries, info, maxvcpus);\n    }\n\n    *vcpus = g_steal_pointer(&info);\n    ret = 0;\n\n cleanup:\n    qemuMonitorQueryHotpluggableCpusFree(hotplugcpus, nhotplugcpus);\n    qemuMonitorQueryCpusFree(cpuentries, ncpuentries);\n    qemuMonitorCPUInfoFree(info, maxvcpus);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorCPUInfoFree",
          "args": [
            "info",
            "maxvcpus"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCPUInfoFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "1634-1644",
          "snippet": "void\nqemuMonitorCPUInfoFree(qemuMonitorCPUInfoPtr cpus,\n                       size_t ncpus)\n{\n    if (!cpus)\n        return;\n\n    qemuMonitorCPUInfoClear(cpus, ncpus);\n\n    VIR_FREE(cpus);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorCPUInfoFree(qemuMonitorCPUInfoPtr cpus,\n                       size_t ncpus)\n{\n    if (!cpus)\n        return;\n\n    qemuMonitorCPUInfoClear(cpus, ncpus);\n\n    VIR_FREE(cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorQueryCpusFree",
          "args": [
            "cpuentries",
            "ncpuentries"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorQueryCpusFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "1646-1659",
          "snippet": "void\nqemuMonitorQueryCpusFree(struct qemuMonitorQueryCpusEntry *entries,\n                         size_t nentries)\n{\n    size_t i;\n\n    if (!entries)\n        return;\n\n    for (i = 0; i < nentries; i++)\n        VIR_FREE(entries[i].qom_path);\n\n    VIR_FREE(entries);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorQueryCpusFree(struct qemuMonitorQueryCpusEntry *entries,\n                         size_t nentries)\n{\n    size_t i;\n\n    if (!entries)\n        return;\n\n    for (i = 0; i < nentries; i++)\n        VIR_FREE(entries[i].qom_path);\n\n    VIR_FREE(entries);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorQueryHotpluggableCpusFree",
          "args": [
            "hotplugcpus",
            "nhotplugcpus"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorQueryHotpluggableCpusFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8495-8515",
          "snippet": "void\nqemuMonitorQueryHotpluggableCpusFree(struct qemuMonitorQueryHotpluggableCpusEntry *entries,\n                                     size_t nentries)\n{\n    struct qemuMonitorQueryHotpluggableCpusEntry *entry;\n    size_t i;\n\n    if (!entries)\n        return;\n\n    for (i = 0; i < nentries; i++) {\n        entry = entries + i;\n\n        VIR_FREE(entry->type);\n        VIR_FREE(entry->qom_path);\n        VIR_FREE(entry->alias);\n        virJSONValueFree(entry->props);\n    }\n\n    VIR_FREE(entries);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorQueryHotpluggableCpusFree(struct qemuMonitorQueryHotpluggableCpusEntry *entries,\n                                     size_t nentries)\n{\n    struct qemuMonitorQueryHotpluggableCpusEntry *entry;\n    size_t i;\n\n    if (!entries)\n        return;\n\n    for (i = 0; i < nentries; i++) {\n        entry = entries + i;\n\n        VIR_FREE(entry->type);\n        VIR_FREE(entry->qom_path);\n        VIR_FREE(entry->alias);\n        virJSONValueFree(entry->props);\n    }\n\n    VIR_FREE(entries);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&info"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetCPUInfoLegacy",
          "args": [
            "cpuentries",
            "ncpuentries",
            "info",
            "maxvcpus"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetCPUInfoLegacy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "1665-1684",
          "snippet": "static void\nqemuMonitorGetCPUInfoLegacy(struct qemuMonitorQueryCpusEntry *cpuentries,\n                            size_t ncpuentries,\n                            qemuMonitorCPUInfoPtr vcpus,\n                            size_t maxvcpus)\n{\n    size_t i;\n\n    for (i = 0; i < maxvcpus; i++) {\n        if (i < ncpuentries) {\n            vcpus[i].tid = cpuentries[i].tid;\n            vcpus[i].halted = cpuentries[i].halted;\n            vcpus[i].qemu_id = cpuentries[i].qemu_id;\n        }\n\n        /* for legacy hotplug to work we need to fake the vcpu count added by\n         * enabling a given vcpu */\n        vcpus[i].vcpus = 1;\n    }\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void\nqemuMonitorGetCPUInfoLegacy(struct qemuMonitorQueryCpusEntry *cpuentries,\n                            size_t ncpuentries,\n                            qemuMonitorCPUInfoPtr vcpus,\n                            size_t maxvcpus)\n{\n    size_t i;\n\n    for (i = 0; i < maxvcpus; i++) {\n        if (i < ncpuentries) {\n            vcpus[i].tid = cpuentries[i].tid;\n            vcpus[i].halted = cpuentries[i].halted;\n            vcpus[i].qemu_id = cpuentries[i].qemu_id;\n        }\n\n        /* for legacy hotplug to work we need to fake the vcpu count added by\n         * enabling a given vcpu */\n        vcpus[i].vcpus = 1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorCPUInfoClear",
          "args": [
            "info",
            "maxvcpus"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCPUInfoClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "1608-1631",
          "snippet": "static void\nqemuMonitorCPUInfoClear(qemuMonitorCPUInfoPtr cpus,\n                        size_t ncpus)\n{\n    size_t i;\n\n    for (i = 0; i < ncpus; i++) {\n        cpus[i].id = 0;\n        cpus[i].qemu_id = -1;\n        cpus[i].socket_id = -1;\n        cpus[i].die_id = -1;\n        cpus[i].core_id = -1;\n        cpus[i].thread_id = -1;\n        cpus[i].node_id = -1;\n        cpus[i].vcpus = 0;\n        cpus[i].tid = 0;\n        cpus[i].halted = false;\n\n        VIR_FREE(cpus[i].qom_path);\n        VIR_FREE(cpus[i].alias);\n        VIR_FREE(cpus[i].type);\n        virJSONValueFree(cpus[i].props);\n    }\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void\nqemuMonitorCPUInfoClear(qemuMonitorCPUInfoPtr cpus,\n                        size_t ncpus)\n{\n    size_t i;\n\n    for (i = 0; i < ncpus; i++) {\n        cpus[i].id = 0;\n        cpus[i].qemu_id = -1;\n        cpus[i].socket_id = -1;\n        cpus[i].die_id = -1;\n        cpus[i].core_id = -1;\n        cpus[i].thread_id = -1;\n        cpus[i].node_id = -1;\n        cpus[i].vcpus = 0;\n        cpus[i].tid = 0;\n        cpus[i].halted = false;\n\n        VIR_FREE(cpus[i].qom_path);\n        VIR_FREE(cpus[i].alias);\n        VIR_FREE(cpus[i].type);\n        virJSONValueFree(cpus[i].props);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetCPUInfoHotplug",
          "args": [
            "hotplugcpus",
            "nhotplugcpus",
            "cpuentries",
            "ncpuentries",
            "info",
            "maxvcpus"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetCPUInfoHotplug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "1714-1825",
          "snippet": "static int\nqemuMonitorGetCPUInfoHotplug(struct qemuMonitorQueryHotpluggableCpusEntry *hotplugvcpus,\n                             size_t nhotplugvcpus,\n                             struct qemuMonitorQueryCpusEntry *cpuentries,\n                             size_t ncpuentries,\n                             qemuMonitorCPUInfoPtr vcpus,\n                             size_t maxvcpus)\n{\n    char *tmp;\n    int order = 1;\n    size_t totalvcpus = 0;\n    size_t mastervcpu; /* this iterator is used for iterating hotpluggable entities */\n    size_t slavevcpu; /* this corresponds to subentries of a hotpluggable entry */\n    size_t anyvcpu; /* this iterator is used for any vcpu entry in the result */\n    size_t i;\n    size_t j;\n\n    /* ensure that the total vcpu count reported by query-hotpluggable-cpus equals\n     * to the libvirt maximum cpu count */\n    for (i = 0; i < nhotplugvcpus; i++)\n        totalvcpus += hotplugvcpus[i].vcpus;\n\n    /* trim '/thread...' suffix from the data returned by query-cpus[-fast] */\n    for (i = 0; i < ncpuentries; i++) {\n        if (cpuentries[i].qom_path &&\n            (tmp = strstr(cpuentries[i].qom_path, \"/thread\")))\n            *tmp = '\\0';\n    }\n\n    if (totalvcpus != maxvcpus) {\n        VIR_DEBUG(\"expected '%zu' total vcpus got '%zu'\", maxvcpus, totalvcpus);\n        return -1;\n    }\n\n    /* Note the order in which the hotpluggable entities are inserted by\n     * matching them to the query-cpus[-fast] entries */\n    for (i = 0; i < ncpuentries; i++) {\n        for (j = 0; j < nhotplugvcpus; j++) {\n            if (!cpuentries[i].qom_path ||\n                !hotplugvcpus[j].qom_path ||\n                STRNEQ(cpuentries[i].qom_path, hotplugvcpus[j].qom_path))\n                continue;\n\n            /* add ordering info for hotpluggable entries */\n            if (hotplugvcpus[j].enable_id == 0)\n                hotplugvcpus[j].enable_id = order++;\n\n            break;\n        }\n    }\n\n    /* transfer appropriate data from the hotpluggable list to corresponding\n     * entries. the entries returned by qemu may in fact describe multiple\n     * logical vcpus in the guest */\n    mastervcpu = 0;\n    for (i = 0; i < nhotplugvcpus; i++) {\n        vcpus[mastervcpu].online = !!hotplugvcpus[i].qom_path;\n        vcpus[mastervcpu].hotpluggable = !!hotplugvcpus[i].alias ||\n                                         !vcpus[mastervcpu].online;\n        vcpus[mastervcpu].socket_id = hotplugvcpus[i].socket_id;\n        vcpus[mastervcpu].die_id = hotplugvcpus[i].die_id;\n        vcpus[mastervcpu].core_id = hotplugvcpus[i].core_id;\n        vcpus[mastervcpu].thread_id = hotplugvcpus[i].thread_id;\n        vcpus[mastervcpu].node_id = hotplugvcpus[i].node_id;\n        vcpus[mastervcpu].vcpus = hotplugvcpus[i].vcpus;\n        vcpus[mastervcpu].qom_path = g_steal_pointer(&hotplugvcpus[i].qom_path);\n        vcpus[mastervcpu].alias = g_steal_pointer(&hotplugvcpus[i].alias);\n        vcpus[mastervcpu].type = g_steal_pointer(&hotplugvcpus[i].type);\n        vcpus[mastervcpu].props = g_steal_pointer(&hotplugvcpus[i].props);\n        vcpus[mastervcpu].id = hotplugvcpus[i].enable_id;\n\n        /* copy state information to slave vcpus */\n        for (slavevcpu = mastervcpu + 1; slavevcpu < mastervcpu + hotplugvcpus[i].vcpus; slavevcpu++) {\n            vcpus[slavevcpu].online = vcpus[mastervcpu].online;\n            vcpus[slavevcpu].hotpluggable = vcpus[mastervcpu].hotpluggable;\n        }\n\n        /* calculate next master vcpu (hotpluggable unit) entry */\n        mastervcpu += hotplugvcpus[i].vcpus;\n    }\n\n    /* match entries from query cpus to the output array taking into account\n     * multi-vcpu objects */\n    for (j = 0; j < ncpuentries; j++) {\n        /* find the correct entry or beginning of group of entries */\n        for (anyvcpu = 0; anyvcpu < maxvcpus; anyvcpu++) {\n            if (cpuentries[j].qom_path && vcpus[anyvcpu].qom_path &&\n                STREQ(cpuentries[j].qom_path, vcpus[anyvcpu].qom_path))\n                break;\n        }\n\n        if (anyvcpu == maxvcpus) {\n            VIR_DEBUG(\"too many query-cpus[-fast] entries for a given \"\n                      \"query-hotpluggable-cpus entry\");\n            return -1;\n        }\n\n        if (vcpus[anyvcpu].vcpus != 1) {\n            /* find a possibly empty vcpu thread for core granularity systems */\n            for (; anyvcpu < maxvcpus; anyvcpu++) {\n                if (vcpus[anyvcpu].tid == 0)\n                    break;\n            }\n        }\n\n        vcpus[anyvcpu].qemu_id = cpuentries[j].qemu_id;\n        vcpus[anyvcpu].tid = cpuentries[j].tid;\n        vcpus[anyvcpu].halted = cpuentries[j].halted;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic int\nqemuMonitorGetCPUInfoHotplug(struct qemuMonitorQueryHotpluggableCpusEntry *hotplugvcpus,\n                             size_t nhotplugvcpus,\n                             struct qemuMonitorQueryCpusEntry *cpuentries,\n                             size_t ncpuentries,\n                             qemuMonitorCPUInfoPtr vcpus,\n                             size_t maxvcpus)\n{\n    char *tmp;\n    int order = 1;\n    size_t totalvcpus = 0;\n    size_t mastervcpu; /* this iterator is used for iterating hotpluggable entities */\n    size_t slavevcpu; /* this corresponds to subentries of a hotpluggable entry */\n    size_t anyvcpu; /* this iterator is used for any vcpu entry in the result */\n    size_t i;\n    size_t j;\n\n    /* ensure that the total vcpu count reported by query-hotpluggable-cpus equals\n     * to the libvirt maximum cpu count */\n    for (i = 0; i < nhotplugvcpus; i++)\n        totalvcpus += hotplugvcpus[i].vcpus;\n\n    /* trim '/thread...' suffix from the data returned by query-cpus[-fast] */\n    for (i = 0; i < ncpuentries; i++) {\n        if (cpuentries[i].qom_path &&\n            (tmp = strstr(cpuentries[i].qom_path, \"/thread\")))\n            *tmp = '\\0';\n    }\n\n    if (totalvcpus != maxvcpus) {\n        VIR_DEBUG(\"expected '%zu' total vcpus got '%zu'\", maxvcpus, totalvcpus);\n        return -1;\n    }\n\n    /* Note the order in which the hotpluggable entities are inserted by\n     * matching them to the query-cpus[-fast] entries */\n    for (i = 0; i < ncpuentries; i++) {\n        for (j = 0; j < nhotplugvcpus; j++) {\n            if (!cpuentries[i].qom_path ||\n                !hotplugvcpus[j].qom_path ||\n                STRNEQ(cpuentries[i].qom_path, hotplugvcpus[j].qom_path))\n                continue;\n\n            /* add ordering info for hotpluggable entries */\n            if (hotplugvcpus[j].enable_id == 0)\n                hotplugvcpus[j].enable_id = order++;\n\n            break;\n        }\n    }\n\n    /* transfer appropriate data from the hotpluggable list to corresponding\n     * entries. the entries returned by qemu may in fact describe multiple\n     * logical vcpus in the guest */\n    mastervcpu = 0;\n    for (i = 0; i < nhotplugvcpus; i++) {\n        vcpus[mastervcpu].online = !!hotplugvcpus[i].qom_path;\n        vcpus[mastervcpu].hotpluggable = !!hotplugvcpus[i].alias ||\n                                         !vcpus[mastervcpu].online;\n        vcpus[mastervcpu].socket_id = hotplugvcpus[i].socket_id;\n        vcpus[mastervcpu].die_id = hotplugvcpus[i].die_id;\n        vcpus[mastervcpu].core_id = hotplugvcpus[i].core_id;\n        vcpus[mastervcpu].thread_id = hotplugvcpus[i].thread_id;\n        vcpus[mastervcpu].node_id = hotplugvcpus[i].node_id;\n        vcpus[mastervcpu].vcpus = hotplugvcpus[i].vcpus;\n        vcpus[mastervcpu].qom_path = g_steal_pointer(&hotplugvcpus[i].qom_path);\n        vcpus[mastervcpu].alias = g_steal_pointer(&hotplugvcpus[i].alias);\n        vcpus[mastervcpu].type = g_steal_pointer(&hotplugvcpus[i].type);\n        vcpus[mastervcpu].props = g_steal_pointer(&hotplugvcpus[i].props);\n        vcpus[mastervcpu].id = hotplugvcpus[i].enable_id;\n\n        /* copy state information to slave vcpus */\n        for (slavevcpu = mastervcpu + 1; slavevcpu < mastervcpu + hotplugvcpus[i].vcpus; slavevcpu++) {\n            vcpus[slavevcpu].online = vcpus[mastervcpu].online;\n            vcpus[slavevcpu].hotpluggable = vcpus[mastervcpu].hotpluggable;\n        }\n\n        /* calculate next master vcpu (hotpluggable unit) entry */\n        mastervcpu += hotplugvcpus[i].vcpus;\n    }\n\n    /* match entries from query cpus to the output array taking into account\n     * multi-vcpu objects */\n    for (j = 0; j < ncpuentries; j++) {\n        /* find the correct entry or beginning of group of entries */\n        for (anyvcpu = 0; anyvcpu < maxvcpus; anyvcpu++) {\n            if (cpuentries[j].qom_path && vcpus[anyvcpu].qom_path &&\n                STREQ(cpuentries[j].qom_path, vcpus[anyvcpu].qom_path))\n                break;\n        }\n\n        if (anyvcpu == maxvcpus) {\n            VIR_DEBUG(\"too many query-cpus[-fast] entries for a given \"\n                      \"query-hotpluggable-cpus entry\");\n            return -1;\n        }\n\n        if (vcpus[anyvcpu].vcpus != 1) {\n            /* find a possibly empty vcpu thread for core granularity systems */\n            for (; anyvcpu < maxvcpus; anyvcpu++) {\n                if (vcpus[anyvcpu].tid == 0)\n                    break;\n            }\n        }\n\n        vcpus[anyvcpu].qemu_id = cpuentries[j].qemu_id;\n        vcpus[anyvcpu].tid = cpuentries[j].tid;\n        vcpus[anyvcpu].halted = cpuentries[j].halted;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&info"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONQueryCPUs",
          "args": [
            "mon",
            "&cpuentries",
            "&ncpuentries",
            "hotplug",
            "fast"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONQueryCPUs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "1978-2015",
          "snippet": "int\nqemuMonitorJSONQueryCPUs(qemuMonitorPtr mon,\n                         struct qemuMonitorQueryCpusEntry **entries,\n                         size_t *nentries,\n                         bool force,\n                         bool fast)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n\n    if (fast)\n        cmd = qemuMonitorJSONMakeCommand(\"query-cpus-fast\", NULL);\n    else\n        cmd = qemuMonitorJSONMakeCommand(\"query-cpus\", NULL);\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (force && qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    if (!(data = virJSONValueObjectGetArray(reply, \"return\"))) {\n        ret = -2;\n        goto cleanup;\n    }\n\n    ret = qemuMonitorJSONExtractCPUInfo(data, entries, nentries, fast);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint\nqemuMonitorJSONQueryCPUs(qemuMonitorPtr mon,\n                         struct qemuMonitorQueryCpusEntry **entries,\n                         size_t *nentries,\n                         bool force,\n                         bool fast)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n\n    if (fast)\n        cmd = qemuMonitorJSONMakeCommand(\"query-cpus-fast\", NULL);\n    else\n        cmd = qemuMonitorJSONMakeCommand(\"query-cpus\", NULL);\n\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (force && qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    if (!(data = virJSONValueObjectGetArray(reply, \"return\"))) {\n        ret = -2;\n        goto cleanup;\n    }\n\n    ret = qemuMonitorJSONExtractCPUInfo(data, entries, nentries, fast);\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetHotpluggableCPUs",
          "args": [
            "mon",
            "&hotplugcpus",
            "&nhotplugcpus"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetHotpluggableCPUs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8615-8662",
          "snippet": "int\nqemuMonitorJSONGetHotpluggableCPUs(qemuMonitorPtr mon,\n                                   struct qemuMonitorQueryHotpluggableCpusEntry **entries,\n                                   size_t *nentries)\n{\n    struct qemuMonitorQueryHotpluggableCpusEntry *info = NULL;\n    size_t ninfo = 0;\n    int ret = -1;\n    size_t i;\n    virJSONValuePtr data;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr vcpu;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-hotpluggable-cpus\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGet(reply, \"return\");\n    ninfo = virJSONValueArraySize(data);\n\n    if (VIR_ALLOC_N(info, ninfo) < 0)\n        goto cleanup;\n\n    for (i = 0; i < ninfo; i++) {\n        vcpu = virJSONValueArrayGet(data, i);\n\n        if (qemuMonitorJSONProcessHotpluggableCpusReply(vcpu, info + i) < 0)\n            goto cleanup;\n    }\n\n    qsort(info, ninfo, sizeof(*info), qemuMonitorQueryHotpluggableCpusEntrySort);\n\n    *entries = g_steal_pointer(&info);\n    *nentries = ninfo;\n    ret = 0;\n\n cleanup:\n    qemuMonitorQueryHotpluggableCpusFree(info, ninfo);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint\nqemuMonitorJSONGetHotpluggableCPUs(qemuMonitorPtr mon,\n                                   struct qemuMonitorQueryHotpluggableCpusEntry **entries,\n                                   size_t *nentries)\n{\n    struct qemuMonitorQueryHotpluggableCpusEntry *info = NULL;\n    size_t ninfo = 0;\n    int ret = -1;\n    size_t i;\n    virJSONValuePtr data;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr vcpu;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-hotpluggable-cpus\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGet(reply, \"return\");\n    ninfo = virJSONValueArraySize(data);\n\n    if (VIR_ALLOC_N(info, ninfo) < 0)\n        goto cleanup;\n\n    for (i = 0; i < ninfo; i++) {\n        vcpu = virJSONValueArrayGet(data, i);\n\n        if (qemuMonitorJSONProcessHotpluggableCpusReply(vcpu, info + i) < 0)\n            goto cleanup;\n    }\n\n    qsort(info, ninfo, sizeof(*info), qemuMonitorQueryHotpluggableCpusEntrySort);\n\n    *entries = g_steal_pointer(&info);\n    *nentries = ninfo;\n    ret = 0;\n\n cleanup:\n    qemuMonitorQueryHotpluggableCpusFree(info, ninfo);\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "info",
            "maxvcpus"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetCPUInfo(qemuMonitorPtr mon,\n                      qemuMonitorCPUInfoPtr *vcpus,\n                      size_t maxvcpus,\n                      bool hotplug,\n                      bool fast)\n{\n    struct qemuMonitorQueryHotpluggableCpusEntry *hotplugcpus = NULL;\n    size_t nhotplugcpus = 0;\n    struct qemuMonitorQueryCpusEntry *cpuentries = NULL;\n    size_t ncpuentries = 0;\n    int ret = -1;\n    int rc;\n    qemuMonitorCPUInfoPtr info = NULL;\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (VIR_ALLOC_N(info, maxvcpus) < 0)\n        return -1;\n\n    /* initialize a few non-zero defaults */\n    qemuMonitorCPUInfoClear(info, maxvcpus);\n\n    if (hotplug &&\n        (qemuMonitorJSONGetHotpluggableCPUs(mon, &hotplugcpus, &nhotplugcpus)) < 0)\n        goto cleanup;\n\n    rc = qemuMonitorJSONQueryCPUs(mon, &cpuentries, &ncpuentries, hotplug,\n                                  fast);\n\n    if (rc < 0) {\n        if (!hotplug && rc == -2) {\n            *vcpus = g_steal_pointer(&info);\n            ret = 0;\n        }\n\n        goto cleanup;\n    }\n\n    if (!hotplugcpus ||\n        qemuMonitorGetCPUInfoHotplug(hotplugcpus, nhotplugcpus,\n                                     cpuentries, ncpuentries,\n                                     info, maxvcpus) < 0) {\n        /* Fallback to the legacy algorithm. Hotplug paths will make sure that\n         * the appropriate data is present */\n        qemuMonitorCPUInfoClear(info, maxvcpus);\n        qemuMonitorGetCPUInfoLegacy(cpuentries, ncpuentries, info, maxvcpus);\n    }\n\n    *vcpus = g_steal_pointer(&info);\n    ret = 0;\n\n cleanup:\n    qemuMonitorQueryHotpluggableCpusFree(hotplugcpus, nhotplugcpus);\n    qemuMonitorQueryCpusFree(cpuentries, ncpuentries);\n    qemuMonitorCPUInfoFree(info, maxvcpus);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorGetCPUInfoHotplug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1714-1825",
    "snippet": "static int\nqemuMonitorGetCPUInfoHotplug(struct qemuMonitorQueryHotpluggableCpusEntry *hotplugvcpus,\n                             size_t nhotplugvcpus,\n                             struct qemuMonitorQueryCpusEntry *cpuentries,\n                             size_t ncpuentries,\n                             qemuMonitorCPUInfoPtr vcpus,\n                             size_t maxvcpus)\n{\n    char *tmp;\n    int order = 1;\n    size_t totalvcpus = 0;\n    size_t mastervcpu; /* this iterator is used for iterating hotpluggable entities */\n    size_t slavevcpu; /* this corresponds to subentries of a hotpluggable entry */\n    size_t anyvcpu; /* this iterator is used for any vcpu entry in the result */\n    size_t i;\n    size_t j;\n\n    /* ensure that the total vcpu count reported by query-hotpluggable-cpus equals\n     * to the libvirt maximum cpu count */\n    for (i = 0; i < nhotplugvcpus; i++)\n        totalvcpus += hotplugvcpus[i].vcpus;\n\n    /* trim '/thread...' suffix from the data returned by query-cpus[-fast] */\n    for (i = 0; i < ncpuentries; i++) {\n        if (cpuentries[i].qom_path &&\n            (tmp = strstr(cpuentries[i].qom_path, \"/thread\")))\n            *tmp = '\\0';\n    }\n\n    if (totalvcpus != maxvcpus) {\n        VIR_DEBUG(\"expected '%zu' total vcpus got '%zu'\", maxvcpus, totalvcpus);\n        return -1;\n    }\n\n    /* Note the order in which the hotpluggable entities are inserted by\n     * matching them to the query-cpus[-fast] entries */\n    for (i = 0; i < ncpuentries; i++) {\n        for (j = 0; j < nhotplugvcpus; j++) {\n            if (!cpuentries[i].qom_path ||\n                !hotplugvcpus[j].qom_path ||\n                STRNEQ(cpuentries[i].qom_path, hotplugvcpus[j].qom_path))\n                continue;\n\n            /* add ordering info for hotpluggable entries */\n            if (hotplugvcpus[j].enable_id == 0)\n                hotplugvcpus[j].enable_id = order++;\n\n            break;\n        }\n    }\n\n    /* transfer appropriate data from the hotpluggable list to corresponding\n     * entries. the entries returned by qemu may in fact describe multiple\n     * logical vcpus in the guest */\n    mastervcpu = 0;\n    for (i = 0; i < nhotplugvcpus; i++) {\n        vcpus[mastervcpu].online = !!hotplugvcpus[i].qom_path;\n        vcpus[mastervcpu].hotpluggable = !!hotplugvcpus[i].alias ||\n                                         !vcpus[mastervcpu].online;\n        vcpus[mastervcpu].socket_id = hotplugvcpus[i].socket_id;\n        vcpus[mastervcpu].die_id = hotplugvcpus[i].die_id;\n        vcpus[mastervcpu].core_id = hotplugvcpus[i].core_id;\n        vcpus[mastervcpu].thread_id = hotplugvcpus[i].thread_id;\n        vcpus[mastervcpu].node_id = hotplugvcpus[i].node_id;\n        vcpus[mastervcpu].vcpus = hotplugvcpus[i].vcpus;\n        vcpus[mastervcpu].qom_path = g_steal_pointer(&hotplugvcpus[i].qom_path);\n        vcpus[mastervcpu].alias = g_steal_pointer(&hotplugvcpus[i].alias);\n        vcpus[mastervcpu].type = g_steal_pointer(&hotplugvcpus[i].type);\n        vcpus[mastervcpu].props = g_steal_pointer(&hotplugvcpus[i].props);\n        vcpus[mastervcpu].id = hotplugvcpus[i].enable_id;\n\n        /* copy state information to slave vcpus */\n        for (slavevcpu = mastervcpu + 1; slavevcpu < mastervcpu + hotplugvcpus[i].vcpus; slavevcpu++) {\n            vcpus[slavevcpu].online = vcpus[mastervcpu].online;\n            vcpus[slavevcpu].hotpluggable = vcpus[mastervcpu].hotpluggable;\n        }\n\n        /* calculate next master vcpu (hotpluggable unit) entry */\n        mastervcpu += hotplugvcpus[i].vcpus;\n    }\n\n    /* match entries from query cpus to the output array taking into account\n     * multi-vcpu objects */\n    for (j = 0; j < ncpuentries; j++) {\n        /* find the correct entry or beginning of group of entries */\n        for (anyvcpu = 0; anyvcpu < maxvcpus; anyvcpu++) {\n            if (cpuentries[j].qom_path && vcpus[anyvcpu].qom_path &&\n                STREQ(cpuentries[j].qom_path, vcpus[anyvcpu].qom_path))\n                break;\n        }\n\n        if (anyvcpu == maxvcpus) {\n            VIR_DEBUG(\"too many query-cpus[-fast] entries for a given \"\n                      \"query-hotpluggable-cpus entry\");\n            return -1;\n        }\n\n        if (vcpus[anyvcpu].vcpus != 1) {\n            /* find a possibly empty vcpu thread for core granularity systems */\n            for (; anyvcpu < maxvcpus; anyvcpu++) {\n                if (vcpus[anyvcpu].tid == 0)\n                    break;\n            }\n        }\n\n        vcpus[anyvcpu].qemu_id = cpuentries[j].qemu_id;\n        vcpus[anyvcpu].tid = cpuentries[j].tid;\n        vcpus[anyvcpu].halted = cpuentries[j].halted;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"too many query-cpus[-fast] entries for a given \"\n                      \"query-hotpluggable-cpus entry\""
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "cpuentries[j].qom_path",
            "vcpus[anyvcpu].qom_path"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&hotplugvcpus[i].props"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&hotplugvcpus[i].type"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&hotplugvcpus[i].alias"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&hotplugvcpus[i].qom_path"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "cpuentries[i].qom_path",
            "hotplugvcpus[j].qom_path"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"expected '%zu' total vcpus got '%zu'\"",
            "maxvcpus",
            "totalvcpus"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cpuentries[i].qom_path",
            "\"/thread\""
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic int\nqemuMonitorGetCPUInfoHotplug(struct qemuMonitorQueryHotpluggableCpusEntry *hotplugvcpus,\n                             size_t nhotplugvcpus,\n                             struct qemuMonitorQueryCpusEntry *cpuentries,\n                             size_t ncpuentries,\n                             qemuMonitorCPUInfoPtr vcpus,\n                             size_t maxvcpus)\n{\n    char *tmp;\n    int order = 1;\n    size_t totalvcpus = 0;\n    size_t mastervcpu; /* this iterator is used for iterating hotpluggable entities */\n    size_t slavevcpu; /* this corresponds to subentries of a hotpluggable entry */\n    size_t anyvcpu; /* this iterator is used for any vcpu entry in the result */\n    size_t i;\n    size_t j;\n\n    /* ensure that the total vcpu count reported by query-hotpluggable-cpus equals\n     * to the libvirt maximum cpu count */\n    for (i = 0; i < nhotplugvcpus; i++)\n        totalvcpus += hotplugvcpus[i].vcpus;\n\n    /* trim '/thread...' suffix from the data returned by query-cpus[-fast] */\n    for (i = 0; i < ncpuentries; i++) {\n        if (cpuentries[i].qom_path &&\n            (tmp = strstr(cpuentries[i].qom_path, \"/thread\")))\n            *tmp = '\\0';\n    }\n\n    if (totalvcpus != maxvcpus) {\n        VIR_DEBUG(\"expected '%zu' total vcpus got '%zu'\", maxvcpus, totalvcpus);\n        return -1;\n    }\n\n    /* Note the order in which the hotpluggable entities are inserted by\n     * matching them to the query-cpus[-fast] entries */\n    for (i = 0; i < ncpuentries; i++) {\n        for (j = 0; j < nhotplugvcpus; j++) {\n            if (!cpuentries[i].qom_path ||\n                !hotplugvcpus[j].qom_path ||\n                STRNEQ(cpuentries[i].qom_path, hotplugvcpus[j].qom_path))\n                continue;\n\n            /* add ordering info for hotpluggable entries */\n            if (hotplugvcpus[j].enable_id == 0)\n                hotplugvcpus[j].enable_id = order++;\n\n            break;\n        }\n    }\n\n    /* transfer appropriate data from the hotpluggable list to corresponding\n     * entries. the entries returned by qemu may in fact describe multiple\n     * logical vcpus in the guest */\n    mastervcpu = 0;\n    for (i = 0; i < nhotplugvcpus; i++) {\n        vcpus[mastervcpu].online = !!hotplugvcpus[i].qom_path;\n        vcpus[mastervcpu].hotpluggable = !!hotplugvcpus[i].alias ||\n                                         !vcpus[mastervcpu].online;\n        vcpus[mastervcpu].socket_id = hotplugvcpus[i].socket_id;\n        vcpus[mastervcpu].die_id = hotplugvcpus[i].die_id;\n        vcpus[mastervcpu].core_id = hotplugvcpus[i].core_id;\n        vcpus[mastervcpu].thread_id = hotplugvcpus[i].thread_id;\n        vcpus[mastervcpu].node_id = hotplugvcpus[i].node_id;\n        vcpus[mastervcpu].vcpus = hotplugvcpus[i].vcpus;\n        vcpus[mastervcpu].qom_path = g_steal_pointer(&hotplugvcpus[i].qom_path);\n        vcpus[mastervcpu].alias = g_steal_pointer(&hotplugvcpus[i].alias);\n        vcpus[mastervcpu].type = g_steal_pointer(&hotplugvcpus[i].type);\n        vcpus[mastervcpu].props = g_steal_pointer(&hotplugvcpus[i].props);\n        vcpus[mastervcpu].id = hotplugvcpus[i].enable_id;\n\n        /* copy state information to slave vcpus */\n        for (slavevcpu = mastervcpu + 1; slavevcpu < mastervcpu + hotplugvcpus[i].vcpus; slavevcpu++) {\n            vcpus[slavevcpu].online = vcpus[mastervcpu].online;\n            vcpus[slavevcpu].hotpluggable = vcpus[mastervcpu].hotpluggable;\n        }\n\n        /* calculate next master vcpu (hotpluggable unit) entry */\n        mastervcpu += hotplugvcpus[i].vcpus;\n    }\n\n    /* match entries from query cpus to the output array taking into account\n     * multi-vcpu objects */\n    for (j = 0; j < ncpuentries; j++) {\n        /* find the correct entry or beginning of group of entries */\n        for (anyvcpu = 0; anyvcpu < maxvcpus; anyvcpu++) {\n            if (cpuentries[j].qom_path && vcpus[anyvcpu].qom_path &&\n                STREQ(cpuentries[j].qom_path, vcpus[anyvcpu].qom_path))\n                break;\n        }\n\n        if (anyvcpu == maxvcpus) {\n            VIR_DEBUG(\"too many query-cpus[-fast] entries for a given \"\n                      \"query-hotpluggable-cpus entry\");\n            return -1;\n        }\n\n        if (vcpus[anyvcpu].vcpus != 1) {\n            /* find a possibly empty vcpu thread for core granularity systems */\n            for (; anyvcpu < maxvcpus; anyvcpu++) {\n                if (vcpus[anyvcpu].tid == 0)\n                    break;\n            }\n        }\n\n        vcpus[anyvcpu].qemu_id = cpuentries[j].qemu_id;\n        vcpus[anyvcpu].tid = cpuentries[j].tid;\n        vcpus[anyvcpu].halted = cpuentries[j].halted;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMonitorGetCPUInfoLegacy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1665-1684",
    "snippet": "static void\nqemuMonitorGetCPUInfoLegacy(struct qemuMonitorQueryCpusEntry *cpuentries,\n                            size_t ncpuentries,\n                            qemuMonitorCPUInfoPtr vcpus,\n                            size_t maxvcpus)\n{\n    size_t i;\n\n    for (i = 0; i < maxvcpus; i++) {\n        if (i < ncpuentries) {\n            vcpus[i].tid = cpuentries[i].tid;\n            vcpus[i].halted = cpuentries[i].halted;\n            vcpus[i].qemu_id = cpuentries[i].qemu_id;\n        }\n\n        /* for legacy hotplug to work we need to fake the vcpu count added by\n         * enabling a given vcpu */\n        vcpus[i].vcpus = 1;\n    }\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void\nqemuMonitorGetCPUInfoLegacy(struct qemuMonitorQueryCpusEntry *cpuentries,\n                            size_t ncpuentries,\n                            qemuMonitorCPUInfoPtr vcpus,\n                            size_t maxvcpus)\n{\n    size_t i;\n\n    for (i = 0; i < maxvcpus; i++) {\n        if (i < ncpuentries) {\n            vcpus[i].tid = cpuentries[i].tid;\n            vcpus[i].halted = cpuentries[i].halted;\n            vcpus[i].qemu_id = cpuentries[i].qemu_id;\n        }\n\n        /* for legacy hotplug to work we need to fake the vcpu count added by\n         * enabling a given vcpu */\n        vcpus[i].vcpus = 1;\n    }\n}"
  },
  {
    "function_name": "qemuMonitorQueryCpusFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1646-1659",
    "snippet": "void\nqemuMonitorQueryCpusFree(struct qemuMonitorQueryCpusEntry *entries,\n                         size_t nentries)\n{\n    size_t i;\n\n    if (!entries)\n        return;\n\n    for (i = 0; i < nentries; i++)\n        VIR_FREE(entries[i].qom_path);\n\n    VIR_FREE(entries);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "entries"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "entries[i].qom_path"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorQueryCpusFree(struct qemuMonitorQueryCpusEntry *entries,\n                         size_t nentries)\n{\n    size_t i;\n\n    if (!entries)\n        return;\n\n    for (i = 0; i < nentries; i++)\n        VIR_FREE(entries[i].qom_path);\n\n    VIR_FREE(entries);\n}"
  },
  {
    "function_name": "qemuMonitorCPUInfoFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1634-1644",
    "snippet": "void\nqemuMonitorCPUInfoFree(qemuMonitorCPUInfoPtr cpus,\n                       size_t ncpus)\n{\n    if (!cpus)\n        return;\n\n    qemuMonitorCPUInfoClear(cpus, ncpus);\n\n    VIR_FREE(cpus);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpus"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorCPUInfoClear",
          "args": [
            "cpus",
            "ncpus"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCPUInfoClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "1608-1631",
          "snippet": "static void\nqemuMonitorCPUInfoClear(qemuMonitorCPUInfoPtr cpus,\n                        size_t ncpus)\n{\n    size_t i;\n\n    for (i = 0; i < ncpus; i++) {\n        cpus[i].id = 0;\n        cpus[i].qemu_id = -1;\n        cpus[i].socket_id = -1;\n        cpus[i].die_id = -1;\n        cpus[i].core_id = -1;\n        cpus[i].thread_id = -1;\n        cpus[i].node_id = -1;\n        cpus[i].vcpus = 0;\n        cpus[i].tid = 0;\n        cpus[i].halted = false;\n\n        VIR_FREE(cpus[i].qom_path);\n        VIR_FREE(cpus[i].alias);\n        VIR_FREE(cpus[i].type);\n        virJSONValueFree(cpus[i].props);\n    }\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void\nqemuMonitorCPUInfoClear(qemuMonitorCPUInfoPtr cpus,\n                        size_t ncpus)\n{\n    size_t i;\n\n    for (i = 0; i < ncpus; i++) {\n        cpus[i].id = 0;\n        cpus[i].qemu_id = -1;\n        cpus[i].socket_id = -1;\n        cpus[i].die_id = -1;\n        cpus[i].core_id = -1;\n        cpus[i].thread_id = -1;\n        cpus[i].node_id = -1;\n        cpus[i].vcpus = 0;\n        cpus[i].tid = 0;\n        cpus[i].halted = false;\n\n        VIR_FREE(cpus[i].qom_path);\n        VIR_FREE(cpus[i].alias);\n        VIR_FREE(cpus[i].type);\n        virJSONValueFree(cpus[i].props);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorCPUInfoFree(qemuMonitorCPUInfoPtr cpus,\n                       size_t ncpus)\n{\n    if (!cpus)\n        return;\n\n    qemuMonitorCPUInfoClear(cpus, ncpus);\n\n    VIR_FREE(cpus);\n}"
  },
  {
    "function_name": "qemuMonitorCPUInfoClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1608-1631",
    "snippet": "static void\nqemuMonitorCPUInfoClear(qemuMonitorCPUInfoPtr cpus,\n                        size_t ncpus)\n{\n    size_t i;\n\n    for (i = 0; i < ncpus; i++) {\n        cpus[i].id = 0;\n        cpus[i].qemu_id = -1;\n        cpus[i].socket_id = -1;\n        cpus[i].die_id = -1;\n        cpus[i].core_id = -1;\n        cpus[i].thread_id = -1;\n        cpus[i].node_id = -1;\n        cpus[i].vcpus = 0;\n        cpus[i].tid = 0;\n        cpus[i].halted = false;\n\n        VIR_FREE(cpus[i].qom_path);\n        VIR_FREE(cpus[i].alias);\n        VIR_FREE(cpus[i].type);\n        virJSONValueFree(cpus[i].props);\n    }\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueFree",
          "args": [
            "cpus[i].props"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "391-423",
          "snippet": "void\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvoid\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpus[i].type"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpus[i].alias"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpus[i].qom_path"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void\nqemuMonitorCPUInfoClear(qemuMonitorCPUInfoPtr cpus,\n                        size_t ncpus)\n{\n    size_t i;\n\n    for (i = 0; i < ncpus; i++) {\n        cpus[i].id = 0;\n        cpus[i].qemu_id = -1;\n        cpus[i].socket_id = -1;\n        cpus[i].die_id = -1;\n        cpus[i].core_id = -1;\n        cpus[i].thread_id = -1;\n        cpus[i].node_id = -1;\n        cpus[i].vcpus = 0;\n        cpus[i].tid = 0;\n        cpus[i].halted = false;\n\n        VIR_FREE(cpus[i].qom_path);\n        VIR_FREE(cpus[i].alias);\n        VIR_FREE(cpus[i].type);\n        virJSONValueFree(cpus[i].props);\n    }\n}"
  },
  {
    "function_name": "qemuMonitorSystemReset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1599-1605",
    "snippet": "int\nqemuMonitorSystemReset(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSystemReset(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSystemReset",
          "args": [
            "mon"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSystemReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "1790-1809",
          "snippet": "int qemuMonitorJSONSystemReset(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"system_reset\", NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONSystemReset(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"system_reset\", NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSystemReset(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSystemReset(mon);\n}"
  },
  {
    "function_name": "qemuMonitorSystemPowerdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1590-1596",
    "snippet": "int\nqemuMonitorSystemPowerdown(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSystemPowerdown(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSystemPowerdown",
          "args": [
            "mon"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSystemPowerdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "1742-1761",
          "snippet": "int qemuMonitorJSONSystemPowerdown(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"system_powerdown\", NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint qemuMonitorJSONSystemPowerdown(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"system_powerdown\", NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSystemPowerdown(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSystemPowerdown(mon);\n}"
  },
  {
    "function_name": "qemuMonitorGetStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1577-1587",
    "snippet": "int\nqemuMonitorGetStatus(qemuMonitorPtr mon,\n                     bool *running,\n                     virDomainPausedReason *reason)\n{\n    VIR_DEBUG(\"running=%p, reason=%p\", running, reason);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetStatus(mon, running, reason);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetStatus",
          "args": [
            "mon",
            "running",
            "reason"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "1695-1739",
          "snippet": "int\nqemuMonitorJSONGetStatus(qemuMonitorPtr mon,\n                         bool *running,\n                         virDomainPausedReason *reason)\n{\n    int ret = -1;\n    const char *status;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n\n    if (reason)\n        *reason = VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-status\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (virJSONValueObjectGetBoolean(data, \"running\", running) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-status reply was missing running state\"));\n        goto cleanup;\n    }\n\n    if ((status = virJSONValueObjectGetString(data, \"status\"))) {\n        if (!*running && reason)\n            *reason = qemuMonitorVMStatusToPausedReason(status);\n    } else if (!*running) {\n        VIR_DEBUG(\"query-status reply was missing status details\");\n    }\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint\nqemuMonitorJSONGetStatus(qemuMonitorPtr mon,\n                         bool *running,\n                         virDomainPausedReason *reason)\n{\n    int ret = -1;\n    const char *status;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n\n    if (reason)\n        *reason = VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"query-status\", NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_OBJECT) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetObject(reply, \"return\");\n\n    if (virJSONValueObjectGetBoolean(data, \"running\", running) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"query-status reply was missing running state\"));\n        goto cleanup;\n    }\n\n    if ((status = virJSONValueObjectGetString(data, \"status\"))) {\n        if (!*running && reason)\n            *reason = qemuMonitorVMStatusToPausedReason(status);\n    } else if (!*running) {\n        VIR_DEBUG(\"query-status reply was missing status details\");\n    }\n\n    ret = 0;\n\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"running=%p, reason=%p\"",
            "running",
            "reason"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetStatus(qemuMonitorPtr mon,\n                     bool *running,\n                     virDomainPausedReason *reason)\n{\n    VIR_DEBUG(\"running=%p, reason=%p\", running, reason);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetStatus(mon, running, reason);\n}"
  },
  {
    "function_name": "qemuMonitorCheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1569-1574",
    "snippet": "int\nqemuMonitorCheck(qemuMonitorPtr mon)\n{\n    bool running;\n    return qemuMonitorGetStatus(mon, &running, NULL);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorGetStatus",
          "args": [
            "mon",
            "&running",
            "NULL"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "1577-1587",
          "snippet": "int\nqemuMonitorGetStatus(qemuMonitorPtr mon,\n                     bool *running,\n                     virDomainPausedReason *reason)\n{\n    VIR_DEBUG(\"running=%p, reason=%p\", running, reason);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetStatus(mon, running, reason);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetStatus(qemuMonitorPtr mon,\n                     bool *running,\n                     virDomainPausedReason *reason)\n{\n    VIR_DEBUG(\"running=%p, reason=%p\", running, reason);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetStatus(mon, running, reason);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorCheck(qemuMonitorPtr mon)\n{\n    bool running;\n    return qemuMonitorGetStatus(mon, &running, NULL);\n}"
  },
  {
    "function_name": "qemuMonitorStopCPUs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1560-1566",
    "snippet": "int\nqemuMonitorStopCPUs(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONStopCPUs(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONStopCPUs",
          "args": [
            "mon"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONStopCPUs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "1672-1692",
          "snippet": "int\nqemuMonitorJSONStopCPUs(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"stop\", NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONStopCPUs(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"stop\", NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorStopCPUs(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONStopCPUs(mon);\n}"
  },
  {
    "function_name": "qemuMonitorStartCPUs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1551-1557",
    "snippet": "int\nqemuMonitorStartCPUs(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONStartCPUs(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONStartCPUs",
          "args": [
            "mon"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONStartCPUs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "1635-1669",
          "snippet": "int\nqemuMonitorJSONStartCPUs(qemuMonitorPtr mon)\n{\n    int ret;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"cont\", NULL);\n    virJSONValuePtr reply = NULL;\n    size_t i = 0;\n    int timeout = 3;\n    if (!cmd)\n        return -1;\n\n    do {\n        ret = qemuMonitorJSONCommand(mon, cmd, &reply);\n\n        if (ret != 0)\n            break;\n\n        /* If no error, we're done */\n        if ((ret = qemuMonitorJSONCheckError(cmd, reply)) == 0)\n            break;\n\n        /* If error class is not MigrationExpected, we're done.\n         * Otherwise try 'cont' cmd again */\n        if (!qemuMonitorJSONHasError(reply, \"MigrationExpected\"))\n            break;\n\n        virJSONValueFree(reply);\n        reply = NULL;\n        g_usleep(250000);\n    } while (++i <= timeout);\n\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONStartCPUs(qemuMonitorPtr mon)\n{\n    int ret;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"cont\", NULL);\n    virJSONValuePtr reply = NULL;\n    size_t i = 0;\n    int timeout = 3;\n    if (!cmd)\n        return -1;\n\n    do {\n        ret = qemuMonitorJSONCommand(mon, cmd, &reply);\n\n        if (ret != 0)\n            break;\n\n        /* If no error, we're done */\n        if ((ret = qemuMonitorJSONCheckError(cmd, reply)) == 0)\n            break;\n\n        /* If error class is not MigrationExpected, we're done.\n         * Otherwise try 'cont' cmd again */\n        if (!qemuMonitorJSONHasError(reply, \"MigrationExpected\"))\n            break;\n\n        virJSONValueFree(reply);\n        reply = NULL;\n        g_usleep(250000);\n    } while (++i <= timeout);\n\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorStartCPUs(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONStartCPUs(mon);\n}"
  },
  {
    "function_name": "qemuMonitorSetCapabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1542-1548",
    "snippet": "int\nqemuMonitorSetCapabilities(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetCapabilities(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONSetCapabilities",
          "args": [
            "mon"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONSetCapabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "1612-1632",
          "snippet": "int\nqemuMonitorJSONSetCapabilities(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"qmp_capabilities\", NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONSetCapabilities(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"qmp_capabilities\", NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd)\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckError(cmd, reply) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSetCapabilities(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONSetCapabilities(mon);\n}"
  },
  {
    "function_name": "qemuMonitorEmitGuestCrashloaded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1532-1539",
    "snippet": "int\nqemuMonitorEmitGuestCrashloaded(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n    QEMU_MONITOR_CALLBACK(mon, ret, domainGuestCrashloaded, mon->vm);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainGuestCrashloaded",
            "mon->vm"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitGuestCrashloaded(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n    QEMU_MONITOR_CALLBACK(mon, ret, domainGuestCrashloaded, mon->vm);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitRdmaGidStatusChanged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1514-1529",
    "snippet": "int\nqemuMonitorEmitRdmaGidStatusChanged(qemuMonitorPtr mon,\n                                    const char *netdev,\n                                    bool gid_status,\n                                    unsigned long long subnet_prefix,\n                                    unsigned long long interface_id)\n{\n    int ret = -1;\n    VIR_DEBUG(\"netdev=%s, gid_status=%d, subnet_prefix=0x%llx, interface_id=0x%llx\",\n              netdev, gid_status, subnet_prefix, interface_id);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainRdmaGidStatusChanged, mon->vm,\n                          netdev, gid_status, subnet_prefix, interface_id);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainRdmaGidStatusChanged",
            "mon->vm",
            "netdev",
            "gid_status",
            "subnet_prefix",
            "interface_id"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"netdev=%s, gid_status=%d, subnet_prefix=0x%llx, interface_id=0x%llx\"",
            "netdev",
            "gid_status",
            "subnet_prefix",
            "interface_id"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitRdmaGidStatusChanged(qemuMonitorPtr mon,\n                                    const char *netdev,\n                                    bool gid_status,\n                                    unsigned long long subnet_prefix,\n                                    unsigned long long interface_id)\n{\n    int ret = -1;\n    VIR_DEBUG(\"netdev=%s, gid_status=%d, subnet_prefix=0x%llx, interface_id=0x%llx\",\n              netdev, gid_status, subnet_prefix, interface_id);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainRdmaGidStatusChanged, mon->vm,\n                          netdev, gid_status, subnet_prefix, interface_id);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitPRManagerStatusChanged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1499-1511",
    "snippet": "int\nqemuMonitorEmitPRManagerStatusChanged(qemuMonitorPtr mon,\n                                      const char *prManager,\n                                      bool connected)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p, prManager='%s', connected=%d\", mon, prManager, connected);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainPRManagerStatusChanged,\n                          mon->vm, prManager, connected);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainPRManagerStatusChanged",
            "mon->vm",
            "prManager",
            "connected"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p, prManager='%s', connected=%d\"",
            "mon",
            "prManager",
            "connected"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitPRManagerStatusChanged(qemuMonitorPtr mon,\n                                      const char *prManager,\n                                      bool connected)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p, prManager='%s', connected=%d\", mon, prManager, connected);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainPRManagerStatusChanged,\n                          mon->vm, prManager, connected);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitDumpCompleted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1482-1496",
    "snippet": "int\nqemuMonitorEmitDumpCompleted(qemuMonitorPtr mon,\n                             int status,\n                             qemuMonitorDumpStatsPtr stats,\n                             const char *error)\n{\n    int ret = -1;\n\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainDumpCompleted, mon->vm,\n                          status, stats, error);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainDumpCompleted",
            "mon->vm",
            "status",
            "stats",
            "error"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitDumpCompleted(qemuMonitorPtr mon,\n                             int status,\n                             qemuMonitorDumpStatsPtr stats,\n                             const char *error)\n{\n    int ret = -1;\n\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainDumpCompleted, mon->vm,\n                          status, stats, error);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitBlockThreshold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1464-1479",
    "snippet": "int\nqemuMonitorEmitBlockThreshold(qemuMonitorPtr mon,\n                              const char *nodename,\n                              unsigned long long threshold,\n                              unsigned long long excess)\n{\n    int ret = -1;\n\n    VIR_DEBUG(\"mon=%p, node-name='%s', threshold='%llu', excess='%llu'\",\n              mon, nodename, threshold, excess);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainBlockThreshold, mon->vm,\n                          nodename, threshold, excess);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainBlockThreshold",
            "mon->vm",
            "nodename",
            "threshold",
            "excess"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p, node-name='%s', threshold='%llu', excess='%llu'\"",
            "mon",
            "nodename",
            "threshold",
            "excess"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitBlockThreshold(qemuMonitorPtr mon,\n                              const char *nodename,\n                              unsigned long long threshold,\n                              unsigned long long excess)\n{\n    int ret = -1;\n\n    VIR_DEBUG(\"mon=%p, node-name='%s', threshold='%llu', excess='%llu'\",\n              mon, nodename, threshold, excess);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainBlockThreshold, mon->vm,\n                          nodename, threshold, excess);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitAcpiOstInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1445-1461",
    "snippet": "int\nqemuMonitorEmitAcpiOstInfo(qemuMonitorPtr mon,\n                           const char *alias,\n                           const char *slotType,\n                           const char *slot,\n                           unsigned int source,\n                           unsigned int status)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p, alias='%s', slotType='%s', slot='%s', source='%u' status=%u\",\n              mon, NULLSTR(alias), slotType, slot, source, status);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainAcpiOstInfo, mon->vm,\n                          alias, slotType, slot, source, status);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainAcpiOstInfo",
            "mon->vm",
            "alias",
            "slotType",
            "slot",
            "source",
            "status"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p, alias='%s', slotType='%s', slot='%s', source='%u' status=%u\"",
            "mon",
            "NULLSTR(alias)",
            "slotType",
            "slot",
            "source",
            "status"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "alias"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitAcpiOstInfo(qemuMonitorPtr mon,\n                           const char *alias,\n                           const char *slotType,\n                           const char *slot,\n                           unsigned int source,\n                           unsigned int status)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p, alias='%s', slotType='%s', slot='%s', source='%u' status=%u\",\n              mon, NULLSTR(alias), slotType, slot, source, status);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainAcpiOstInfo, mon->vm,\n                          alias, slotType, slot, source, status);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitMigrationPass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1432-1442",
    "snippet": "int\nqemuMonitorEmitMigrationPass(qemuMonitorPtr mon,\n                             int pass)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p, pass=%d\", mon, pass);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainMigrationPass, mon->vm, pass);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainMigrationPass",
            "mon->vm",
            "pass"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p, pass=%d\"",
            "mon",
            "pass"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitMigrationPass(qemuMonitorPtr mon,\n                             int pass)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p, pass=%d\", mon, pass);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainMigrationPass, mon->vm, pass);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitMigrationStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1418-1429",
    "snippet": "int\nqemuMonitorEmitMigrationStatus(qemuMonitorPtr mon,\n                               int status)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p, status=%s\",\n              mon, NULLSTR(qemuMonitorMigrationStatusTypeToString(status)));\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainMigrationStatus, mon->vm, status);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainMigrationStatus",
            "mon->vm",
            "status"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p, status=%s\"",
            "mon",
            "NULLSTR(qemuMonitorMigrationStatusTypeToString(status))"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "qemuMonitorMigrationStatusTypeToString(status)"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorMigrationStatusTypeToString",
          "args": [
            "status"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitMigrationStatus(qemuMonitorPtr mon,\n                               int status)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p, status=%s\",\n              mon, NULLSTR(qemuMonitorMigrationStatusTypeToString(status)));\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainMigrationStatus, mon->vm, status);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitSpiceMigrated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1406-1415",
    "snippet": "int\nqemuMonitorEmitSpiceMigrated(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainSpiceMigrated, mon->vm);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainSpiceMigrated",
            "mon->vm"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitSpiceMigrated(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainSpiceMigrated, mon->vm);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitSerialChange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1392-1403",
    "snippet": "int\nqemuMonitorEmitSerialChange(qemuMonitorPtr mon,\n                            const char *devAlias,\n                            bool connected)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p, devAlias='%s', connected=%d\", mon, devAlias, connected);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainSerialChange, mon->vm, devAlias, connected);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainSerialChange",
            "mon->vm",
            "devAlias",
            "connected"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p, devAlias='%s', connected=%d\"",
            "mon",
            "devAlias",
            "connected"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitSerialChange(qemuMonitorPtr mon,\n                            const char *devAlias,\n                            bool connected)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p, devAlias='%s', connected=%d\", mon, devAlias, connected);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainSerialChange, mon->vm, devAlias, connected);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitNicRxFilterChanged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1379-1389",
    "snippet": "int\nqemuMonitorEmitNicRxFilterChanged(qemuMonitorPtr mon,\n                                  const char *devAlias)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainNicRxFilterChanged, mon->vm, devAlias);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainNicRxFilterChanged",
            "mon->vm",
            "devAlias"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitNicRxFilterChanged(qemuMonitorPtr mon,\n                                  const char *devAlias)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainNicRxFilterChanged, mon->vm, devAlias);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitDeviceDeleted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1366-1376",
    "snippet": "int\nqemuMonitorEmitDeviceDeleted(qemuMonitorPtr mon,\n                             const char *devAlias)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainDeviceDeleted, mon->vm, devAlias);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainDeviceDeleted",
            "mon->vm",
            "devAlias"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitDeviceDeleted(qemuMonitorPtr mon,\n                             const char *devAlias)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainDeviceDeleted, mon->vm, devAlias);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitBalloonChange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1354-1363",
    "snippet": "int\nqemuMonitorEmitBalloonChange(qemuMonitorPtr mon,\n                             unsigned long long actual)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainBalloonChange, mon->vm, actual);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainBalloonChange",
            "mon->vm",
            "actual"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitBalloonChange(qemuMonitorPtr mon,\n                             unsigned long long actual)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainBalloonChange, mon->vm, actual);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitJobStatusChange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1341-1351",
    "snippet": "int\nqemuMonitorEmitJobStatusChange(qemuMonitorPtr mon,\n                               const char *jobname,\n                               qemuMonitorJobStatus status)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, jobStatusChange, mon->vm, jobname, status);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "jobStatusChange",
            "mon->vm",
            "jobname",
            "status"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitJobStatusChange(qemuMonitorPtr mon,\n                               const char *jobname,\n                               qemuMonitorJobStatus status)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, jobStatusChange, mon->vm, jobname, status);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitBlockJob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1325-1338",
    "snippet": "int\nqemuMonitorEmitBlockJob(qemuMonitorPtr mon,\n                        const char *diskAlias,\n                        int type,\n                        int status,\n                        const char *error)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainBlockJob, mon->vm,\n                          diskAlias, type, status, error);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainBlockJob",
            "mon->vm",
            "diskAlias",
            "type",
            "status",
            "error"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitBlockJob(qemuMonitorPtr mon,\n                        const char *diskAlias,\n                        int type,\n                        int status,\n                        const char *error)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainBlockJob, mon->vm,\n                          diskAlias, type, status, error);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitPMSuspendDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1313-1322",
    "snippet": "int\nqemuMonitorEmitPMSuspendDisk(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainPMSuspendDisk, mon->vm);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainPMSuspendDisk",
            "mon->vm"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitPMSuspendDisk(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainPMSuspendDisk, mon->vm);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitPMSuspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1301-1310",
    "snippet": "int\nqemuMonitorEmitPMSuspend(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainPMSuspend, mon->vm);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainPMSuspend",
            "mon->vm"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitPMSuspend(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainPMSuspend, mon->vm);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitPMWakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1289-1298",
    "snippet": "int\nqemuMonitorEmitPMWakeup(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainPMWakeup, mon->vm);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainPMWakeup",
            "mon->vm"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitPMWakeup(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainPMWakeup, mon->vm);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitTrayChange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1273-1286",
    "snippet": "int\nqemuMonitorEmitTrayChange(qemuMonitorPtr mon,\n                          const char *devAlias,\n                          const char *devid,\n                          int reason)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainTrayChange, mon->vm,\n                          devAlias, devid, reason);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainTrayChange",
            "mon->vm",
            "devAlias",
            "devid",
            "reason"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitTrayChange(qemuMonitorPtr mon,\n                          const char *devAlias,\n                          const char *devid,\n                          int reason)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainTrayChange, mon->vm,\n                          devAlias, devid, reason);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitGraphics",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1249-1270",
    "snippet": "int\nqemuMonitorEmitGraphics(qemuMonitorPtr mon,\n                        int phase,\n                        int localFamily,\n                        const char *localNode,\n                        const char *localService,\n                        int remoteFamily,\n                        const char *remoteNode,\n                        const char *remoteService,\n                        const char *authScheme,\n                        const char *x509dname,\n                        const char *saslUsername)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainGraphics, mon->vm, phase,\n                          localFamily, localNode, localService,\n                          remoteFamily, remoteNode, remoteService,\n                          authScheme, x509dname, saslUsername);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainGraphics",
            "mon->vm",
            "phase",
            "localFamily",
            "localNode",
            "localService",
            "remoteFamily",
            "remoteNode",
            "remoteService",
            "authScheme",
            "x509dname",
            "saslUsername"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitGraphics(qemuMonitorPtr mon,\n                        int phase,\n                        int localFamily,\n                        const char *localNode,\n                        const char *localService,\n                        int remoteFamily,\n                        const char *remoteNode,\n                        const char *remoteService,\n                        const char *authScheme,\n                        const char *x509dname,\n                        const char *saslUsername)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainGraphics, mon->vm, phase,\n                          localFamily, localNode, localService,\n                          remoteFamily, remoteNode, remoteService,\n                          authScheme, x509dname, saslUsername);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitIOError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1233-1246",
    "snippet": "int\nqemuMonitorEmitIOError(qemuMonitorPtr mon,\n                       const char *diskAlias,\n                       const char *nodename,\n                       int action,\n                       const char *reason)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainIOError, mon->vm,\n                          diskAlias, nodename, action, reason);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainIOError",
            "mon->vm",
            "diskAlias",
            "nodename",
            "action",
            "reason"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitIOError(qemuMonitorPtr mon,\n                       const char *diskAlias,\n                       const char *nodename,\n                       int action,\n                       const char *reason)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainIOError, mon->vm,\n                          diskAlias, nodename, action, reason);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitWatchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1222-1230",
    "snippet": "int\nqemuMonitorEmitWatchdog(qemuMonitorPtr mon, int action)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainWatchdog, mon->vm, action);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainWatchdog",
            "mon->vm",
            "action"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitWatchdog(qemuMonitorPtr mon, int action)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainWatchdog, mon->vm, action);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitRTCChange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1211-1219",
    "snippet": "int\nqemuMonitorEmitRTCChange(qemuMonitorPtr mon, long long offset)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainRTCChange, mon->vm, offset);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainRTCChange",
            "mon->vm",
            "offset"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitRTCChange(qemuMonitorPtr mon, long long offset)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainRTCChange, mon->vm, offset);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitGuestPanic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1200-1208",
    "snippet": "int\nqemuMonitorEmitGuestPanic(qemuMonitorPtr mon,\n                          qemuMonitorEventPanicInfoPtr info)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n    QEMU_MONITOR_CALLBACK(mon, ret, domainGuestPanic, mon->vm, info);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainGuestPanic",
            "mon->vm",
            "info"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitGuestPanic(qemuMonitorPtr mon,\n                          qemuMonitorEventPanicInfoPtr info)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n    QEMU_MONITOR_CALLBACK(mon, ret, domainGuestPanic, mon->vm, info);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitResume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1189-1197",
    "snippet": "int\nqemuMonitorEmitResume(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainResume, mon->vm);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainResume",
            "mon->vm"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitResume(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainResume, mon->vm);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitStop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1178-1186",
    "snippet": "int\nqemuMonitorEmitStop(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainStop, mon->vm);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainStop",
            "mon->vm"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitStop(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainStop, mon->vm);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitPowerdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1167-1175",
    "snippet": "int\nqemuMonitorEmitPowerdown(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainPowerdown, mon->vm);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainPowerdown",
            "mon->vm"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitPowerdown(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainPowerdown, mon->vm);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitReset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1156-1164",
    "snippet": "int\nqemuMonitorEmitReset(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainReset, mon->vm);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainReset",
            "mon->vm"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitReset(qemuMonitorPtr mon)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p\", mon);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainReset, mon->vm);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitShutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1145-1153",
    "snippet": "int\nqemuMonitorEmitShutdown(qemuMonitorPtr mon, virTristateBool guest)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p guest=%u\", mon, guest);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainShutdown, mon->vm, guest);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainShutdown",
            "mon->vm",
            "guest"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p guest=%u\"",
            "mon",
            "guest"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitShutdown(qemuMonitorPtr mon, virTristateBool guest)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p guest=%u\", mon, guest);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainShutdown, mon->vm, guest);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorEmitEvent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1131-1142",
    "snippet": "int\nqemuMonitorEmitEvent(qemuMonitorPtr mon, const char *event,\n                     long long seconds, unsigned int micros,\n                     const char *details)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p event=%s\", mon, event);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainEvent, mon->vm, event, seconds,\n                          micros, details);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QEMU_MONITOR_CALLBACK",
          "args": [
            "mon",
            "ret",
            "domainEvent",
            "mon->vm",
            "event",
            "seconds",
            "micros",
            "details"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p event=%s\"",
            "mon",
            "event"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorEmitEvent(qemuMonitorPtr mon, const char *event,\n                     long long seconds, unsigned int micros,\n                     const char *details)\n{\n    int ret = -1;\n    VIR_DEBUG(\"mon=%p event=%s\", mon, event);\n\n    QEMU_MONITOR_CALLBACK(mon, ret, domainEvent, mon->vm, event, seconds,\n                          micros, details);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorUpdateVideoVram64Size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1094-1115",
    "snippet": "int\nqemuMonitorUpdateVideoVram64Size(qemuMonitorPtr mon,\n                                 virDomainVideoDefPtr video,\n                                 const char *videoName)\n{\n    int rc = -1;\n    g_autofree char *path = NULL;\n\n    QEMU_CHECK_MONITOR(mon);\n\n    rc = qemuMonitorJSONFindLinkPath(mon, videoName,\n                                     video->info.alias, &path);\n    if (rc < 0) {\n        if (rc == -2)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to find QOM Object path for \"\n                             \"device '%s'\"), videoName);\n        return -1;\n    }\n\n    return qemuMonitorJSONUpdateVideoVram64Size(mon, video, path);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONUpdateVideoVram64Size",
          "args": [
            "mon",
            "video",
            "path"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONUpdateVideoVram64Size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "2134-2167",
          "snippet": "int\nqemuMonitorJSONUpdateVideoVram64Size(qemuMonitorPtr mon,\n                                     virDomainVideoDefPtr video,\n                                     char *path)\n{\n    qemuMonitorJSONObjectProperty prop = {\n        QEMU_MONITOR_OBJECT_PROPERTY_ULONG,\n        {0}\n    };\n\n    switch (video->type) {\n    case VIR_DOMAIN_VIDEO_TYPE_QXL:\n        if (video->vram64 != 0) {\n            if (qemuMonitorJSONGetObjectProperty(mon, path,\n                                                 \"vram64_size_mb\", &prop) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"QOM Object '%s' has no property 'vram64_size_mb'\"),\n                               path);\n                return -1;\n            }\n            video->vram64 = prop.val.ul * 1024;\n        }\n        break;\n    case VIR_DOMAIN_VIDEO_TYPE_VGA:\n    case VIR_DOMAIN_VIDEO_TYPE_VMVGA:\n    case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n    case VIR_DOMAIN_VIDEO_TYPE_XEN:\n    case VIR_DOMAIN_VIDEO_TYPE_VBOX:\n    case VIR_DOMAIN_VIDEO_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONUpdateVideoVram64Size(qemuMonitorPtr mon,\n                                     virDomainVideoDefPtr video,\n                                     char *path)\n{\n    qemuMonitorJSONObjectProperty prop = {\n        QEMU_MONITOR_OBJECT_PROPERTY_ULONG,\n        {0}\n    };\n\n    switch (video->type) {\n    case VIR_DOMAIN_VIDEO_TYPE_QXL:\n        if (video->vram64 != 0) {\n            if (qemuMonitorJSONGetObjectProperty(mon, path,\n                                                 \"vram64_size_mb\", &prop) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"QOM Object '%s' has no property 'vram64_size_mb'\"),\n                               path);\n                return -1;\n            }\n            video->vram64 = prop.val.ul * 1024;\n        }\n        break;\n    case VIR_DOMAIN_VIDEO_TYPE_VGA:\n    case VIR_DOMAIN_VIDEO_TYPE_VMVGA:\n    case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n    case VIR_DOMAIN_VIDEO_TYPE_XEN:\n    case VIR_DOMAIN_VIDEO_TYPE_VBOX:\n    case VIR_DOMAIN_VIDEO_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to find QOM Object path for \"\n                             \"device '%s'\")",
            "videoName"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to find QOM Object path for \"\n                             \"device '%s'\""
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONFindLinkPath",
          "args": [
            "mon",
            "videoName",
            "video->info.alias",
            "&path"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONFindLinkPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8357-8377",
          "snippet": "int\nqemuMonitorJSONFindLinkPath(qemuMonitorPtr mon,\n                            const char *name,\n                            const char *alias,\n                            char **path)\n{\n    char *linkname = NULL;\n    int ret = -1;\n\n    if (alias) {\n        ret = qemuMonitorJSONFindObjectPathByAlias(mon, name, alias, path);\n        if (ret == -1 || ret == 0)\n            return ret;\n    }\n\n    linkname = g_strdup_printf(\"link<%s>\", name);\n\n    ret = qemuMonitorJSONFindObjectPathByName(mon, \"/\", linkname, path);\n    VIR_FREE(linkname);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONFindLinkPath(qemuMonitorPtr mon,\n                            const char *name,\n                            const char *alias,\n                            char **path)\n{\n    char *linkname = NULL;\n    int ret = -1;\n\n    if (alias) {\n        ret = qemuMonitorJSONFindObjectPathByAlias(mon, name, alias, path);\n        if (ret == -1 || ret == 0)\n            return ret;\n    }\n\n    linkname = g_strdup_printf(\"link<%s>\", name);\n\n    ret = qemuMonitorJSONFindObjectPathByName(mon, \"/\", linkname, path);\n    VIR_FREE(linkname);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorUpdateVideoVram64Size(qemuMonitorPtr mon,\n                                 virDomainVideoDefPtr video,\n                                 const char *videoName)\n{\n    int rc = -1;\n    g_autofree char *path = NULL;\n\n    QEMU_CHECK_MONITOR(mon);\n\n    rc = qemuMonitorJSONFindLinkPath(mon, videoName,\n                                     video->info.alias, &path);\n    if (rc < 0) {\n        if (rc == -2)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to find QOM Object path for \"\n                             \"device '%s'\"), videoName);\n        return -1;\n    }\n\n    return qemuMonitorJSONUpdateVideoVram64Size(mon, video, path);\n}"
  },
  {
    "function_name": "qemuMonitorUpdateVideoMemorySize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "1064-1085",
    "snippet": "int\nqemuMonitorUpdateVideoMemorySize(qemuMonitorPtr mon,\n                                 virDomainVideoDefPtr video,\n                                 const char *videoName)\n{\n    int rc = -1;\n    g_autofree char *path = NULL;\n\n    QEMU_CHECK_MONITOR(mon);\n\n    rc = qemuMonitorJSONFindLinkPath(mon, videoName,\n                                     video->info.alias, &path);\n    if (rc < 0) {\n        if (rc == -2)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to find QOM Object path for \"\n                             \"device '%s'\"), videoName);\n        return -1;\n    }\n\n    return qemuMonitorJSONUpdateVideoMemorySize(mon, video, path);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorJSONUpdateVideoMemorySize",
          "args": [
            "mon",
            "video",
            "path"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONUpdateVideoMemorySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "2064-2125",
          "snippet": "int\nqemuMonitorJSONUpdateVideoMemorySize(qemuMonitorPtr mon,\n                                     virDomainVideoDefPtr video,\n                                     char *path)\n{\n    qemuMonitorJSONObjectProperty prop = {\n        QEMU_MONITOR_OBJECT_PROPERTY_ULONG,\n        {0}\n    };\n\n    switch (video->type) {\n    case VIR_DOMAIN_VIDEO_TYPE_VGA:\n        if (qemuMonitorJSONGetObjectProperty(mon, path, \"vgamem_mb\", &prop) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"QOM Object '%s' has no property 'vgamem_mb'\"),\n                           path);\n            return -1;\n        }\n        video->vram = prop.val.ul * 1024;\n        break;\n    case VIR_DOMAIN_VIDEO_TYPE_QXL:\n        if (qemuMonitorJSONGetObjectProperty(mon, path, \"vram_size\", &prop) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"QOM Object '%s' has no property 'vram_size'\"),\n                           path);\n            return -1;\n        }\n        video->vram = prop.val.ul / 1024;\n\n        if (qemuMonitorJSONGetObjectProperty(mon, path, \"ram_size\", &prop) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"QOM Object '%s' has no property 'ram_size'\"),\n                           path);\n            return -1;\n        }\n        video->ram = prop.val.ul / 1024;\n        if (qemuMonitorJSONGetObjectProperty(mon, path, \"vgamem_mb\", &prop) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"QOM Object '%s' has no property 'vgamem_mb'\"),\n                           path);\n            return -1;\n        }\n        video->vgamem = prop.val.ul * 1024;\n        break;\n    case VIR_DOMAIN_VIDEO_TYPE_VMVGA:\n        if (qemuMonitorJSONGetObjectProperty(mon, path, \"vgamem_mb\", &prop) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"QOM Object '%s' has no property 'vgamem_mb'\"),\n                           path);\n            return -1;\n        }\n        video->vram = prop.val.ul * 1024;\n        break;\n    case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n    case VIR_DOMAIN_VIDEO_TYPE_XEN:\n    case VIR_DOMAIN_VIDEO_TYPE_VBOX:\n    case VIR_DOMAIN_VIDEO_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONUpdateVideoMemorySize(qemuMonitorPtr mon,\n                                     virDomainVideoDefPtr video,\n                                     char *path)\n{\n    qemuMonitorJSONObjectProperty prop = {\n        QEMU_MONITOR_OBJECT_PROPERTY_ULONG,\n        {0}\n    };\n\n    switch (video->type) {\n    case VIR_DOMAIN_VIDEO_TYPE_VGA:\n        if (qemuMonitorJSONGetObjectProperty(mon, path, \"vgamem_mb\", &prop) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"QOM Object '%s' has no property 'vgamem_mb'\"),\n                           path);\n            return -1;\n        }\n        video->vram = prop.val.ul * 1024;\n        break;\n    case VIR_DOMAIN_VIDEO_TYPE_QXL:\n        if (qemuMonitorJSONGetObjectProperty(mon, path, \"vram_size\", &prop) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"QOM Object '%s' has no property 'vram_size'\"),\n                           path);\n            return -1;\n        }\n        video->vram = prop.val.ul / 1024;\n\n        if (qemuMonitorJSONGetObjectProperty(mon, path, \"ram_size\", &prop) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"QOM Object '%s' has no property 'ram_size'\"),\n                           path);\n            return -1;\n        }\n        video->ram = prop.val.ul / 1024;\n        if (qemuMonitorJSONGetObjectProperty(mon, path, \"vgamem_mb\", &prop) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"QOM Object '%s' has no property 'vgamem_mb'\"),\n                           path);\n            return -1;\n        }\n        video->vgamem = prop.val.ul * 1024;\n        break;\n    case VIR_DOMAIN_VIDEO_TYPE_VMVGA:\n        if (qemuMonitorJSONGetObjectProperty(mon, path, \"vgamem_mb\", &prop) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"QOM Object '%s' has no property 'vgamem_mb'\"),\n                           path);\n            return -1;\n        }\n        video->vram = prop.val.ul * 1024;\n        break;\n    case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n    case VIR_DOMAIN_VIDEO_TYPE_XEN:\n    case VIR_DOMAIN_VIDEO_TYPE_VBOX:\n    case VIR_DOMAIN_VIDEO_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to find QOM Object path for \"\n                             \"device '%s'\")",
            "videoName"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to find QOM Object path for \"\n                             \"device '%s'\""
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONFindLinkPath",
          "args": [
            "mon",
            "videoName",
            "video->info.alias",
            "&path"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONFindLinkPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8357-8377",
          "snippet": "int\nqemuMonitorJSONFindLinkPath(qemuMonitorPtr mon,\n                            const char *name,\n                            const char *alias,\n                            char **path)\n{\n    char *linkname = NULL;\n    int ret = -1;\n\n    if (alias) {\n        ret = qemuMonitorJSONFindObjectPathByAlias(mon, name, alias, path);\n        if (ret == -1 || ret == 0)\n            return ret;\n    }\n\n    linkname = g_strdup_printf(\"link<%s>\", name);\n\n    ret = qemuMonitorJSONFindObjectPathByName(mon, \"/\", linkname, path);\n    VIR_FREE(linkname);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONFindLinkPath(qemuMonitorPtr mon,\n                            const char *name,\n                            const char *alias,\n                            char **path)\n{\n    char *linkname = NULL;\n    int ret = -1;\n\n    if (alias) {\n        ret = qemuMonitorJSONFindObjectPathByAlias(mon, name, alias, path);\n        if (ret == -1 || ret == 0)\n            return ret;\n    }\n\n    linkname = g_strdup_printf(\"link<%s>\", name);\n\n    ret = qemuMonitorJSONFindObjectPathByName(mon, \"/\", linkname, path);\n    VIR_FREE(linkname);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_CHECK_MONITOR",
          "args": [
            "mon"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorUpdateVideoMemorySize(qemuMonitorPtr mon,\n                                 virDomainVideoDefPtr video,\n                                 const char *videoName)\n{\n    int rc = -1;\n    g_autofree char *path = NULL;\n\n    QEMU_CHECK_MONITOR(mon);\n\n    rc = qemuMonitorJSONFindLinkPath(mon, videoName,\n                                     video->info.alias, &path);\n    if (rc < 0) {\n        if (rc == -2)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to find QOM Object path for \"\n                             \"device '%s'\"), videoName);\n        return -1;\n    }\n\n    return qemuMonitorJSONUpdateVideoMemorySize(mon, video, path);\n}"
  },
  {
    "function_name": "qemuMonitorInitBalloonObjectPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "998-1055",
    "snippet": "static void\nqemuMonitorInitBalloonObjectPath(qemuMonitorPtr mon,\n                                 virDomainMemballoonDefPtr balloon)\n{\n    ssize_t i, nprops = 0;\n    char *path = NULL;\n    const char *name;\n    qemuMonitorJSONListPathPtr *bprops = NULL;\n\n    if (mon->balloonpath) {\n        return;\n    } else if (mon->ballooninit) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot determine balloon device path\"));\n        return;\n    }\n    mon->ballooninit = true;\n\n    switch (balloon->info.type) {\n    case VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI:\n        name = \"virtio-balloon-pci\";\n        break;\n    case VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW:\n        name = \"virtio-balloon-ccw\";\n        break;\n    default:\n        return;\n    }\n\n    if (qemuMonitorJSONFindLinkPath(mon, name, balloon->info.alias, &path) < 0)\n        return;\n\n    nprops = qemuMonitorJSONGetObjectListPaths(mon, path, &bprops);\n    if (nprops < 0)\n        goto cleanup;\n\n    for (i = 0; i < nprops; i++) {\n        if (STREQ(bprops[i]->name, \"guest-stats-polling-interval\")) {\n            VIR_DEBUG(\"Found Balloon Object Path %s\", path);\n            mon->balloonpath = path;\n            path = NULL;\n            goto cleanup;\n        }\n    }\n\n\n    /* If we get here, we found the path, but not the property */\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Property 'guest-stats-polling-interval' \"\n                     \"not found on memory balloon driver.\"));\n\n cleanup:\n    for (i = 0; i < nprops; i++)\n        qemuMonitorJSONListPathFree(bprops[i]);\n    VIR_FREE(bprops);\n    VIR_FREE(path);\n    return;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "bprops"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONListPathFree",
          "args": [
            "bprops[i]"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONListPathFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "6480-6487",
          "snippet": "void qemuMonitorJSONListPathFree(qemuMonitorJSONListPathPtr paths)\n{\n    if (!paths)\n        return;\n    VIR_FREE(paths->name);\n    VIR_FREE(paths->type);\n    VIR_FREE(paths);\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid qemuMonitorJSONListPathFree(qemuMonitorJSONListPathPtr paths)\n{\n    if (!paths)\n        return;\n    VIR_FREE(paths->name);\n    VIR_FREE(paths->type);\n    VIR_FREE(paths);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Property 'guest-stats-polling-interval' \"\n                     \"not found on memory balloon driver.\")"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Property 'guest-stats-polling-interval' \"\n                     \"not found on memory balloon driver.\""
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Found Balloon Object Path %s\"",
            "path"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "bprops[i]->name",
            "\"guest-stats-polling-interval\""
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONGetObjectListPaths",
          "args": [
            "mon",
            "path",
            "&bprops"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONGetObjectListPaths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "6405-6478",
          "snippet": "int qemuMonitorJSONGetObjectListPaths(qemuMonitorPtr mon,\n                                      const char *path,\n                                      qemuMonitorJSONListPathPtr **paths)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    qemuMonitorJSONListPathPtr *pathlist = NULL;\n    size_t n = 0;\n    size_t i;\n\n    *paths = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"qom-list\",\n                                           \"s:path\", path,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n    n = virJSONValueArraySize(data);\n\n    /* null-terminated list */\n    if (VIR_ALLOC_N(pathlist, n + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(data, i);\n        const char *tmp;\n        qemuMonitorJSONListPathPtr info;\n\n        if (VIR_ALLOC(info) < 0)\n            goto cleanup;\n\n        pathlist[i] = info;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"qom-list reply data was missing 'name'\"));\n            goto cleanup;\n        }\n\n        info->name = g_strdup(tmp);\n\n        if (virJSONValueObjectHasKey(child, \"type\")) {\n            if (!(tmp = virJSONValueObjectGetString(child, \"type\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"qom-list reply has malformed 'type' data\"));\n                goto cleanup;\n            }\n            info->type = g_strdup(tmp);\n        }\n    }\n\n    ret = n;\n    *paths = pathlist;\n    pathlist = NULL;\n\n cleanup:\n    if (pathlist) {\n        for (i = 0; i < n; i++)\n            qemuMonitorJSONListPathFree(pathlist[i]);\n        VIR_FREE(pathlist);\n    }\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint qemuMonitorJSONGetObjectListPaths(qemuMonitorPtr mon,\n                                      const char *path,\n                                      qemuMonitorJSONListPathPtr **paths)\n{\n    int ret = -1;\n    virJSONValuePtr cmd;\n    virJSONValuePtr reply = NULL;\n    virJSONValuePtr data;\n    qemuMonitorJSONListPathPtr *pathlist = NULL;\n    size_t n = 0;\n    size_t i;\n\n    *paths = NULL;\n\n    if (!(cmd = qemuMonitorJSONMakeCommand(\"qom-list\",\n                                           \"s:path\", path,\n                                           NULL)))\n        return -1;\n\n    if (qemuMonitorJSONCommand(mon, cmd, &reply) < 0)\n        goto cleanup;\n\n    if (qemuMonitorJSONCheckReply(cmd, reply, VIR_JSON_TYPE_ARRAY) < 0)\n        goto cleanup;\n\n    data = virJSONValueObjectGetArray(reply, \"return\");\n    n = virJSONValueArraySize(data);\n\n    /* null-terminated list */\n    if (VIR_ALLOC_N(pathlist, n + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < n; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(data, i);\n        const char *tmp;\n        qemuMonitorJSONListPathPtr info;\n\n        if (VIR_ALLOC(info) < 0)\n            goto cleanup;\n\n        pathlist[i] = info;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"qom-list reply data was missing 'name'\"));\n            goto cleanup;\n        }\n\n        info->name = g_strdup(tmp);\n\n        if (virJSONValueObjectHasKey(child, \"type\")) {\n            if (!(tmp = virJSONValueObjectGetString(child, \"type\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"qom-list reply has malformed 'type' data\"));\n                goto cleanup;\n            }\n            info->type = g_strdup(tmp);\n        }\n    }\n\n    ret = n;\n    *paths = pathlist;\n    pathlist = NULL;\n\n cleanup:\n    if (pathlist) {\n        for (i = 0; i < n; i++)\n            qemuMonitorJSONListPathFree(pathlist[i]);\n        VIR_FREE(pathlist);\n    }\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONFindLinkPath",
          "args": [
            "mon",
            "name",
            "balloon->info.alias",
            "&path"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONFindLinkPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "8357-8377",
          "snippet": "int\nqemuMonitorJSONFindLinkPath(qemuMonitorPtr mon,\n                            const char *name,\n                            const char *alias,\n                            char **path)\n{\n    char *linkname = NULL;\n    int ret = -1;\n\n    if (alias) {\n        ret = qemuMonitorJSONFindObjectPathByAlias(mon, name, alias, path);\n        if (ret == -1 || ret == 0)\n            return ret;\n    }\n\n    linkname = g_strdup_printf(\"link<%s>\", name);\n\n    ret = qemuMonitorJSONFindObjectPathByName(mon, \"/\", linkname, path);\n    VIR_FREE(linkname);\n    return ret;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJSONFindLinkPath(qemuMonitorPtr mon,\n                            const char *name,\n                            const char *alias,\n                            char **path)\n{\n    char *linkname = NULL;\n    int ret = -1;\n\n    if (alias) {\n        ret = qemuMonitorJSONFindObjectPathByAlias(mon, name, alias, path);\n        if (ret == -1 || ret == 0)\n            return ret;\n    }\n\n    linkname = g_strdup_printf(\"link<%s>\", name);\n\n    ret = qemuMonitorJSONFindObjectPathByName(mon, \"/\", linkname, path);\n    VIR_FREE(linkname);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot determine balloon device path\")"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void\nqemuMonitorInitBalloonObjectPath(qemuMonitorPtr mon,\n                                 virDomainMemballoonDefPtr balloon)\n{\n    ssize_t i, nprops = 0;\n    char *path = NULL;\n    const char *name;\n    qemuMonitorJSONListPathPtr *bprops = NULL;\n\n    if (mon->balloonpath) {\n        return;\n    } else if (mon->ballooninit) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot determine balloon device path\"));\n        return;\n    }\n    mon->ballooninit = true;\n\n    switch (balloon->info.type) {\n    case VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI:\n        name = \"virtio-balloon-pci\";\n        break;\n    case VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW:\n        name = \"virtio-balloon-ccw\";\n        break;\n    default:\n        return;\n    }\n\n    if (qemuMonitorJSONFindLinkPath(mon, name, balloon->info.alias, &path) < 0)\n        return;\n\n    nprops = qemuMonitorJSONGetObjectListPaths(mon, path, &bprops);\n    if (nprops < 0)\n        goto cleanup;\n\n    for (i = 0; i < nprops; i++) {\n        if (STREQ(bprops[i]->name, \"guest-stats-polling-interval\")) {\n            VIR_DEBUG(\"Found Balloon Object Path %s\", path);\n            mon->balloonpath = path;\n            path = NULL;\n            goto cleanup;\n        }\n    }\n\n\n    /* If we get here, we found the path, but not the property */\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Property 'guest-stats-polling-interval' \"\n                     \"not found on memory balloon driver.\"));\n\n cleanup:\n    for (i = 0; i < nprops; i++)\n        qemuMonitorJSONListPathFree(bprops[i]);\n    VIR_FREE(bprops);\n    VIR_FREE(path);\n    return;\n}"
  },
  {
    "function_name": "qemuMonitorSetOptions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "982-986",
    "snippet": "void\nqemuMonitorSetOptions(qemuMonitorPtr mon, virJSONValuePtr options)\n{\n    mon->options = options;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorSetOptions(qemuMonitorPtr mon, virJSONValuePtr options)\n{\n    mon->options = options;\n}"
  },
  {
    "function_name": "qemuMonitorGetOptions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "975-979",
    "snippet": "virJSONValuePtr\nqemuMonitorGetOptions(qemuMonitorPtr mon)\n{\n    return mon->options;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirJSONValuePtr\nqemuMonitorGetOptions(qemuMonitorPtr mon)\n{\n    return mon->options;\n}"
  },
  {
    "function_name": "qemuMonitorLastError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "965-972",
    "snippet": "virErrorPtr\nqemuMonitorLastError(qemuMonitorPtr mon)\n{\n    if (mon->lastError.code == VIR_ERR_OK)\n        return NULL;\n\n    return virErrorCopyNew(&mon->lastError);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virErrorCopyNew",
          "args": [
            "&mon->lastError"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorCopyNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "223-235",
          "snippet": "virErrorPtr\nvirErrorCopyNew(virErrorPtr err)\n{\n    virErrorPtr ret;\n\n    if (VIR_ALLOC_QUIET(ret) < 0)\n        return NULL;\n\n    if (virCopyError(err, ret) < 0)\n        VIR_FREE(ret);\n\n    return ret;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorPtr\nvirErrorCopyNew(virErrorPtr err)\n{\n    virErrorPtr ret;\n\n    if (VIR_ALLOC_QUIET(ret) < 0)\n        return NULL;\n\n    if (virCopyError(err, ret) < 0)\n        VIR_FREE(ret);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirErrorPtr\nqemuMonitorLastError(qemuMonitorPtr mon)\n{\n    if (mon->lastError.code == VIR_ERR_OK)\n        return NULL;\n\n    return virErrorCopyNew(&mon->lastError);\n}"
  },
  {
    "function_name": "qemuMonitorSend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "915-958",
    "snippet": "int\nqemuMonitorSend(qemuMonitorPtr mon,\n                qemuMonitorMessagePtr msg)\n{\n    int ret = -1;\n\n    /* Check whether qemu quit unexpectedly */\n    if (mon->lastError.code != VIR_ERR_OK) {\n        VIR_DEBUG(\"Attempt to send command while error is set %s\",\n                  NULLSTR(mon->lastError.message));\n        virSetError(&mon->lastError);\n        return -1;\n    }\n\n    mon->msg = msg;\n    qemuMonitorUpdateWatch(mon);\n\n    PROBE(QEMU_MONITOR_SEND_MSG,\n          \"mon=%p msg=%s fd=%d\",\n          mon, mon->msg->txBuffer, mon->msg->txFD);\n\n    while (!mon->msg->finished) {\n        if (virCondWait(&mon->notify, &mon->parent.lock) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to wait on monitor condition\"));\n            goto cleanup;\n        }\n    }\n\n    if (mon->lastError.code != VIR_ERR_OK) {\n        VIR_DEBUG(\"Send command resulted in error %s\",\n                  NULLSTR(mon->lastError.message));\n        virSetError(&mon->lastError);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    mon->msg = NULL;\n    qemuMonitorUpdateWatch(mon);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorUpdateWatch",
          "args": [
            "mon"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorUpdateWatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "509-515",
          "snippet": "static void\nqemuMonitorUpdateWatch(qemuMonitorPtr mon)\n{\n    qemuMonitorUnregister(mon);\n    if (mon->socket)\n        qemuMonitorRegister(mon);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void\nqemuMonitorUpdateWatch(qemuMonitorPtr mon)\n{\n    qemuMonitorUnregister(mon);\n    if (mon->socket)\n        qemuMonitorRegister(mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetError",
          "args": [
            "&mon->lastError"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "virSetErrorLogPriorityFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1391-1394",
          "snippet": "void virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;\n\nvoid virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Send command resulted in error %s\"",
            "NULLSTR(mon->lastError.message)"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "mon->lastError.message"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to wait on monitor condition\")"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to wait on monitor condition\""
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondWait",
          "args": [
            "&mon->notify",
            "&mon->parent.lock"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "virCondWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "145-153",
          "snippet": "int virCondWait(virCondPtr c, virMutexPtr m)\n{\n    int ret;\n    if ((ret = pthread_cond_wait(&c->cond, &m->lock)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondWait(virCondPtr c, virMutexPtr m)\n{\n    int ret;\n    if ((ret = pthread_cond_wait(&c->cond, &m->lock)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "QEMU_MONITOR_SEND_MSG",
            "\"mon=%p msg=%s fd=%d\"",
            "mon",
            "mon->msg->txBuffer",
            "mon->msg->txFD"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Attempt to send command while error is set %s\"",
            "NULLSTR(mon->lastError.message)"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "mon->lastError.message"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSend(qemuMonitorPtr mon,\n                qemuMonitorMessagePtr msg)\n{\n    int ret = -1;\n\n    /* Check whether qemu quit unexpectedly */\n    if (mon->lastError.code != VIR_ERR_OK) {\n        VIR_DEBUG(\"Attempt to send command while error is set %s\",\n                  NULLSTR(mon->lastError.message));\n        virSetError(&mon->lastError);\n        return -1;\n    }\n\n    mon->msg = msg;\n    qemuMonitorUpdateWatch(mon);\n\n    PROBE(QEMU_MONITOR_SEND_MSG,\n          \"mon=%p msg=%s fd=%d\",\n          mon, mon->msg->txBuffer, mon->msg->txFD);\n\n    while (!mon->msg->finished) {\n        if (virCondWait(&mon->notify, &mon->parent.lock) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to wait on monitor condition\"));\n            goto cleanup;\n        }\n    }\n\n    if (mon->lastError.code != VIR_ERR_OK) {\n        VIR_DEBUG(\"Send command resulted in error %s\",\n                  NULLSTR(mon->lastError.message));\n        virSetError(&mon->lastError);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    mon->msg = NULL;\n    qemuMonitorUpdateWatch(mon);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorResetCommandID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "908-912",
    "snippet": "void\nqemuMonitorResetCommandID(qemuMonitorPtr mon)\n{\n    mon->nextSerial = 0;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorResetCommandID(qemuMonitorPtr mon)\n{\n    mon->nextSerial = 0;\n}"
  },
  {
    "function_name": "qemuMonitorNextCommandID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "897-904",
    "snippet": "char *\nqemuMonitorNextCommandID(qemuMonitorPtr mon)\n{\n    char *id;\n\n    id = g_strdup_printf(\"libvirt-%d\", ++mon->nextSerial);\n    return id;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"libvirt-%d\"",
            "++mon->nextSerial"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nchar *\nqemuMonitorNextCommandID(qemuMonitorPtr mon)\n{\n    char *id;\n\n    id = g_strdup_printf(\"libvirt-%d\", ++mon->nextSerial);\n    return id;\n}"
  },
  {
    "function_name": "qemuMonitorClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "846-894",
    "snippet": "void\nqemuMonitorClose(qemuMonitorPtr mon)\n{\n    if (!mon)\n        return;\n\n    virObjectLock(mon);\n    PROBE(QEMU_MONITOR_CLOSE,\n          \"mon=%p refs=%d\", mon, mon->parent.parent.u.s.refs);\n\n    qemuMonitorSetDomainLogLocked(mon, NULL, NULL, NULL);\n\n    if (mon->socket) {\n        qemuMonitorUnregister(mon);\n        g_object_unref(mon->socket);\n        mon->socket = NULL;\n        mon->fd = -1;\n    }\n\n    /* In case another thread is waiting for its monitor command to be\n     * processed, we need to wake it up with appropriate error set.\n     */\n    if (mon->msg) {\n        if (mon->lastError.code == VIR_ERR_OK) {\n            virErrorPtr err;\n\n            virErrorPreserveLast(&err);\n\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"QEMU monitor was closed\"));\n            virCopyLastError(&mon->lastError);\n            if (err)\n                virErrorRestore(&err);\n            else\n                virResetLastError();\n        }\n        mon->msg->finished = 1;\n        virCondSignal(&mon->notify);\n    }\n\n    /* Propagate existing monitor error in case the current thread has no\n     * error set.\n     */\n    if (mon->lastError.code != VIR_ERR_OK && virGetLastErrorCode() == VIR_ERR_OK)\n        virSetError(&mon->lastError);\n\n    virObjectUnlock(mon);\n    virObjectUnref(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "mon"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mon"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetError",
          "args": [
            "&mon->lastError"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "virSetErrorLogPriorityFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1391-1394",
          "snippet": "void virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;\n\nvoid virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetLastErrorCode",
          "args": [],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorCode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "280-287",
          "snippet": "int\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondSignal",
          "args": [
            "&mon->notify"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "virCondSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "170-173",
          "snippet": "void virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&err"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCopyLastError",
          "args": [
            "&mon->lastError"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "virCopyLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "370-389",
          "snippet": "int\nvirCopyLastError(virErrorPtr to)\n{\n    virErrorPtr err = virLastErrorObject();\n\n    if (!to)\n        return -1;\n\n    /* We can't guarantee caller has initialized it to zero */\n    memset(to, 0, sizeof(*to));\n    if (err) {\n        virCopyError(err, to);\n    } else {\n        virResetError(to);\n        to->code = VIR_ERR_NO_MEMORY;\n        to->domain = VIR_FROM_NONE;\n        to->level = VIR_ERR_ERROR;\n    }\n    return to->code;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirCopyLastError(virErrorPtr to)\n{\n    virErrorPtr err = virLastErrorObject();\n\n    if (!to)\n        return -1;\n\n    /* We can't guarantee caller has initialized it to zero */\n    memset(to, 0, sizeof(*to));\n    if (err) {\n        virCopyError(err, to);\n    } else {\n        virResetError(to);\n        to->code = VIR_ERR_NO_MEMORY;\n        to->domain = VIR_FROM_NONE;\n        to->level = VIR_ERR_ERROR;\n    }\n    return to->code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"QEMU monitor was closed\")"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"QEMU monitor was closed\""
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&err"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_object_unref",
          "args": [
            "mon->socket"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorUnregister",
          "args": [
            "mon"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorUnregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "836-844",
          "snippet": "void\nqemuMonitorUnregister(qemuMonitorPtr mon)\n{\n    if (mon->watch) {\n        g_source_destroy(mon->watch);\n        g_source_unref(mon->watch);\n        mon->watch = NULL;\n    }\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorUnregister(qemuMonitorPtr mon)\n{\n    if (mon->watch) {\n        g_source_destroy(mon->watch);\n        g_source_unref(mon->watch);\n        mon->watch = NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorSetDomainLogLocked",
          "args": [
            "mon",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorSetDomainLogLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3959-3971",
          "snippet": "void\nqemuMonitorSetDomainLogLocked(qemuMonitorPtr mon,\n                              qemuMonitorReportDomainLogError func,\n                              void *opaque,\n                              virFreeCallback destroy)\n{\n    if (mon->logDestroy && mon->logOpaque)\n        mon->logDestroy(mon->logOpaque);\n\n    mon->logFunc = func;\n    mon->logOpaque = opaque;\n    mon->logDestroy = destroy;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorSetDomainLogLocked(qemuMonitorPtr mon,\n                              qemuMonitorReportDomainLogError func,\n                              void *opaque,\n                              virFreeCallback destroy)\n{\n    if (mon->logDestroy && mon->logOpaque)\n        mon->logDestroy(mon->logOpaque);\n\n    mon->logFunc = func;\n    mon->logOpaque = opaque;\n    mon->logDestroy = destroy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "QEMU_MONITOR_CLOSE",
            "\"mon=%p refs=%d\"",
            "mon",
            "mon->parent.parent.u.s.refs"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mon"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorClose(qemuMonitorPtr mon)\n{\n    if (!mon)\n        return;\n\n    virObjectLock(mon);\n    PROBE(QEMU_MONITOR_CLOSE,\n          \"mon=%p refs=%d\", mon, mon->parent.parent.u.s.refs);\n\n    qemuMonitorSetDomainLogLocked(mon, NULL, NULL, NULL);\n\n    if (mon->socket) {\n        qemuMonitorUnregister(mon);\n        g_object_unref(mon->socket);\n        mon->socket = NULL;\n        mon->fd = -1;\n    }\n\n    /* In case another thread is waiting for its monitor command to be\n     * processed, we need to wake it up with appropriate error set.\n     */\n    if (mon->msg) {\n        if (mon->lastError.code == VIR_ERR_OK) {\n            virErrorPtr err;\n\n            virErrorPreserveLast(&err);\n\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"QEMU monitor was closed\"));\n            virCopyLastError(&mon->lastError);\n            if (err)\n                virErrorRestore(&err);\n            else\n                virResetLastError();\n        }\n        mon->msg->finished = 1;\n        virCondSignal(&mon->notify);\n    }\n\n    /* Propagate existing monitor error in case the current thread has no\n     * error set.\n     */\n    if (mon->lastError.code != VIR_ERR_OK && virGetLastErrorCode() == VIR_ERR_OK)\n        virSetError(&mon->lastError);\n\n    virObjectUnlock(mon);\n    virObjectUnref(mon);\n}"
  },
  {
    "function_name": "qemuMonitorUnregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "836-844",
    "snippet": "void\nqemuMonitorUnregister(qemuMonitorPtr mon)\n{\n    if (mon->watch) {\n        g_source_destroy(mon->watch);\n        g_source_unref(mon->watch);\n        mon->watch = NULL;\n    }\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_source_unref",
          "args": [
            "mon->watch"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_source_destroy",
          "args": [
            "mon->watch"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorUnregister(qemuMonitorPtr mon)\n{\n    if (mon->watch) {\n        g_source_destroy(mon->watch);\n        g_source_unref(mon->watch);\n        mon->watch = NULL;\n    }\n}"
  },
  {
    "function_name": "qemuMonitorRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "808-833",
    "snippet": "void\nqemuMonitorRegister(qemuMonitorPtr mon)\n{\n    GIOCondition cond = 0;\n\n    if (mon->lastError.code == VIR_ERR_OK) {\n        cond |= G_IO_IN;\n\n        if ((mon->msg && mon->msg->txOffset < mon->msg->txLength) &&\n            !mon->waitGreeting)\n            cond |= G_IO_OUT;\n    }\n\n    mon->watch = g_socket_create_source(mon->socket,\n                                        cond,\n                                        NULL);\n\n    virObjectRef(mon);\n    g_source_set_callback(mon->watch,\n                          (GSourceFunc)qemuMonitorIO,\n                          mon,\n                          (GDestroyNotify)virObjectUnref);\n\n    g_source_attach(mon->watch,\n                    mon->context);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_source_attach",
          "args": [
            "mon->watch",
            "mon->context"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_source_set_callback",
          "args": [
            "mon->watch",
            "(GSourceFunc)qemuMonitorIO",
            "mon",
            "(GDestroyNotify)virObjectUnref"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "mon"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_socket_create_source",
          "args": [
            "mon->socket",
            "cond",
            "NULL"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorRegister(qemuMonitorPtr mon)\n{\n    GIOCondition cond = 0;\n\n    if (mon->lastError.code == VIR_ERR_OK) {\n        cond |= G_IO_IN;\n\n        if ((mon->msg && mon->msg->txOffset < mon->msg->txLength) &&\n            !mon->waitGreeting)\n            cond |= G_IO_OUT;\n    }\n\n    mon->watch = g_socket_create_source(mon->socket,\n                                        cond,\n                                        NULL);\n\n    virObjectRef(mon);\n    g_source_set_callback(mon->watch,\n                          (GSourceFunc)qemuMonitorIO,\n                          mon,\n                          (GDestroyNotify)virObjectUnref);\n\n    g_source_attach(mon->watch,\n                    mon->context);\n}"
  },
  {
    "function_name": "qemuMonitorOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "753-798",
    "snippet": "qemuMonitorPtr\nqemuMonitorOpen(virDomainObjPtr vm,\n                virDomainChrSourceDefPtr config,\n                bool retry,\n                unsigned long long timeout,\n                GMainContext *context,\n                qemuMonitorCallbacksPtr cb,\n                void *opaque)\n{\n    int fd = -1;\n    qemuMonitorPtr ret = NULL;\n\n    timeout += QEMU_DEFAULT_MONITOR_WAIT;\n\n    /* Hold an extra reference because we can't allow 'vm' to be\n     * deleted until the monitor gets its own reference. */\n    virObjectRef(vm);\n\n    if (config->type != VIR_DOMAIN_CHR_TYPE_UNIX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to handle monitor type: %s\"),\n                       virDomainChrTypeToString(config->type));\n        goto cleanup;\n    }\n\n    virObjectUnlock(vm);\n    fd = qemuMonitorOpenUnix(config->data.nix.path,\n                             vm->pid, retry, timeout);\n    virObjectLock(vm);\n\n    if (fd < 0)\n        goto cleanup;\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"domain is not running\"));\n        goto cleanup;\n    }\n\n    ret = qemuMonitorOpenInternal(vm, fd, context, cb, opaque);\n cleanup:\n    if (!ret)\n        VIR_FORCE_CLOSE(fd);\n    virObjectUnref(vm);\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define QEMU_DEFAULT_MONITOR_WAIT 30"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "vm"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorOpenInternal",
          "args": [
            "vm",
            "fd",
            "context",
            "cb",
            "opaque"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorOpenInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "658-732",
          "snippet": "static qemuMonitorPtr\nqemuMonitorOpenInternal(virDomainObjPtr vm,\n                        int fd,\n                        GMainContext *context,\n                        qemuMonitorCallbacksPtr cb,\n                        void *opaque)\n{\n    qemuMonitorPtr mon;\n    g_autoptr(GError) gerr = NULL;\n\n    if (!cb->eofNotify) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"EOF notify callback must be supplied\"));\n        return NULL;\n    }\n    if (!cb->errorNotify) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Error notify callback must be supplied\"));\n        return NULL;\n    }\n\n    if (qemuMonitorInitialize() < 0)\n        return NULL;\n\n    if (!(mon = virObjectLockableNew(qemuMonitorClass)))\n        return NULL;\n\n    if (virCondInit(&mon->notify) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot initialize monitor condition\"));\n        goto cleanup;\n    }\n    mon->fd = fd;\n    mon->context = g_main_context_ref(context);\n    mon->vm = virObjectRef(vm);\n    mon->waitGreeting = true;\n    mon->cb = cb;\n    mon->callbackOpaque = opaque;\n\n    if (virSetCloseExec(mon->fd) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Unable to set monitor close-on-exec flag\"));\n        goto cleanup;\n    }\n\n    mon->socket = g_socket_new_from_fd(fd, &gerr);\n    if (!mon->socket) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to create socket object: %s\"),\n                       gerr->message);\n        goto cleanup;\n    }\n\n    virObjectLock(mon);\n    qemuMonitorRegister(mon);\n\n    PROBE(QEMU_MONITOR_NEW,\n          \"mon=%p refs=%d fd=%d\",\n          mon, mon->parent.parent.u.s.refs, mon->fd);\n    virObjectUnlock(mon);\n\n    return mon;\n\n cleanup:\n    /* We don't want the 'destroy' callback invoked during\n     * cleanup from construction failure, because that can\n     * give a double-unref on virDomainObjPtr in the caller,\n     * so kill the callbacks now.\n     */\n    mon->cb = NULL;\n    /* The caller owns 'fd' on failure */\n    mon->fd = -1;\n    qemuMonitorClose(mon);\n    return NULL;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr qemuMonitorClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic virClassPtr qemuMonitorClass;\n\nstatic qemuMonitorPtr\nqemuMonitorOpenInternal(virDomainObjPtr vm,\n                        int fd,\n                        GMainContext *context,\n                        qemuMonitorCallbacksPtr cb,\n                        void *opaque)\n{\n    qemuMonitorPtr mon;\n    g_autoptr(GError) gerr = NULL;\n\n    if (!cb->eofNotify) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"EOF notify callback must be supplied\"));\n        return NULL;\n    }\n    if (!cb->errorNotify) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Error notify callback must be supplied\"));\n        return NULL;\n    }\n\n    if (qemuMonitorInitialize() < 0)\n        return NULL;\n\n    if (!(mon = virObjectLockableNew(qemuMonitorClass)))\n        return NULL;\n\n    if (virCondInit(&mon->notify) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot initialize monitor condition\"));\n        goto cleanup;\n    }\n    mon->fd = fd;\n    mon->context = g_main_context_ref(context);\n    mon->vm = virObjectRef(vm);\n    mon->waitGreeting = true;\n    mon->cb = cb;\n    mon->callbackOpaque = opaque;\n\n    if (virSetCloseExec(mon->fd) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Unable to set monitor close-on-exec flag\"));\n        goto cleanup;\n    }\n\n    mon->socket = g_socket_new_from_fd(fd, &gerr);\n    if (!mon->socket) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to create socket object: %s\"),\n                       gerr->message);\n        goto cleanup;\n    }\n\n    virObjectLock(mon);\n    qemuMonitorRegister(mon);\n\n    PROBE(QEMU_MONITOR_NEW,\n          \"mon=%p refs=%d fd=%d\",\n          mon, mon->parent.parent.u.s.refs, mon->fd);\n    virObjectUnlock(mon);\n\n    return mon;\n\n cleanup:\n    /* We don't want the 'destroy' callback invoked during\n     * cleanup from construction failure, because that can\n     * give a double-unref on virDomainObjPtr in the caller,\n     * so kill the callbacks now.\n     */\n    mon->cb = NULL;\n    /* The caller owns 'fd' on failure */\n    mon->fd = -1;\n    qemuMonitorClose(mon);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"domain is not running\")"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"domain is not running\""
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjIsActive",
          "args": [
            "vm"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.h",
          "lines": "2845-2849",
          "snippet": "static inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virresctrl.h\"",
            "#include \"virsavecookie.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virperf.h\"",
            "#include \"virgic.h\"",
            "#include \"virprocess.h\"",
            "#include \"virseclabel.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virbitmap.h\"",
            "#include \"device_conf.h\"",
            "#include \"virobject.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"numa_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virthread.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"capabilities.h\"",
            "#include \"virconftypes.h\"",
            "#include \"internal.h\"",
            "#include <libxml/xpath.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parser.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void virDomainMemoryDefFree(virDomainMemoryDefPtr def);",
            "void virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);",
            "unsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);",
            "unsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);",
            "bool virDomainDefHasMemoryHotplug(const virDomainDef *def);",
            "int virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);",
            "bool virDomainDefHasUSB(const virDomainDef *def);",
            "int virDomainObjCheckActive(virDomainObjPtr dom);",
            "bool virDomainDefHasVcpusOffline(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpusMax(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpus(const virDomainDef *def);",
            "virBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);",
            "void virDomainDefVcpuOrderClear(virDomainDefPtr def);",
            "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);",
            "void virDomainInputDefFree(virDomainInputDefPtr def);",
            "void virDomainDiskDefFree(virDomainDiskDefPtr def);",
            "void virDomainLeaseDefFree(virDomainLeaseDefPtr def);",
            "int virDomainDiskGetType(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetSource(virDomainDiskDef const *def);",
            "void virDomainDiskEmptySource(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetDriver(const virDomainDiskDef *def);",
            "int virDomainDiskGetFormat(virDomainDiskDefPtr def);",
            "void virDomainControllerDefFree(virDomainControllerDefPtr def);",
            "void virDomainFSDefFree(virDomainFSDefPtr def);",
            "void virDomainActualNetDefFree(virDomainActualNetDefPtr def);",
            "void virDomainNetDefClear(virDomainNetDefPtr def);",
            "void virDomainNetDefFree(virDomainNetDefPtr def);",
            "void virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);",
            "void virDomainChrDefFree(virDomainChrDefPtr def);",
            "void virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);",
            "void virDomainSoundDefFree(virDomainSoundDefPtr def);",
            "void virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);",
            "void virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);",
            "void virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);",
            "void virDomainVideoDefFree(virDomainVideoDefPtr def);",
            "void virDomainVideoDefClear(virDomainVideoDefPtr def);",
            "void virDomainHostdevDefClear(virDomainHostdevDefPtr def);",
            "void virDomainHostdevDefFree(virDomainHostdevDefPtr def);",
            "void virDomainHubDefFree(virDomainHubDefPtr def);",
            "void virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);",
            "void virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);",
            "void virDomainShmemDefFree(virDomainShmemDefPtr def);",
            "void virDomainDeviceDefFree(virDomainDeviceDefPtr def);",
            "void virDomainTPMDefFree(virDomainTPMDefPtr def);",
            "void virDomainRNGDefFree(virDomainRNGDefPtr def);",
            "int virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);",
            "int virDomainVideoDefaultType(const virDomainDef *def);",
            "void virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);",
            "int virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);",
            "bool\nvirDomainDefHasManagedPR(const virDomainDef *def);",
            "bool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);",
            "bool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);",
            "bool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virresctrl.h\"\n#include \"virsavecookie.h\"\n#include \"virtypedparam.h\"\n#include \"virperf.h\"\n#include \"virgic.h\"\n#include \"virprocess.h\"\n#include \"virseclabel.h\"\n#include \"virstoragefile.h\"\n#include \"virbitmap.h\"\n#include \"device_conf.h\"\n#include \"virobject.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevvlan.h\"\n#include \"virnetdevbandwidth.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virsysinfo.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"numa_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"networkcommon_conf.h\"\n#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virthread.h\"\n#include \"cpu_conf.h\"\n#include \"virstorageencryption.h\"\n#include \"capabilities.h\"\n#include \"virconftypes.h\"\n#include \"internal.h\"\n#include <libxml/xpath.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n\nvoid virDomainMemoryDefFree(virDomainMemoryDefPtr def);\nvoid virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);\nunsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);\nunsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);\nbool virDomainDefHasMemoryHotplug(const virDomainDef *def);\nint virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);\nbool virDomainDefHasUSB(const virDomainDef *def);\nint virDomainObjCheckActive(virDomainObjPtr dom);\nbool virDomainDefHasVcpusOffline(const virDomainDef *def);\nunsigned int virDomainDefGetVcpusMax(const virDomainDef *def);\nunsigned int virDomainDefGetVcpus(const virDomainDef *def);\nvirBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);\nvoid virDomainDefVcpuOrderClear(virDomainDefPtr def);\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);\nvoid virDomainInputDefFree(virDomainInputDefPtr def);\nvoid virDomainDiskDefFree(virDomainDiskDefPtr def);\nvoid virDomainLeaseDefFree(virDomainLeaseDefPtr def);\nint virDomainDiskGetType(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetSource(virDomainDiskDef const *def);\nvoid virDomainDiskEmptySource(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetDriver(const virDomainDiskDef *def);\nint virDomainDiskGetFormat(virDomainDiskDefPtr def);\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def);\nvoid virDomainFSDefFree(virDomainFSDefPtr def);\nvoid virDomainActualNetDefFree(virDomainActualNetDefPtr def);\nvoid virDomainNetDefClear(virDomainNetDefPtr def);\nvoid virDomainNetDefFree(virDomainNetDefPtr def);\nvoid virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);\nvoid virDomainChrDefFree(virDomainChrDefPtr def);\nvoid virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def);\nvoid virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);\nvoid virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);\nvoid virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def);\nvoid virDomainVideoDefClear(virDomainVideoDefPtr def);\nvoid virDomainHostdevDefClear(virDomainHostdevDefPtr def);\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def);\nvoid virDomainHubDefFree(virDomainHubDefPtr def);\nvoid virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);\nvoid virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);\nvoid virDomainShmemDefFree(virDomainShmemDefPtr def);\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def);\nvoid virDomainTPMDefFree(virDomainTPMDefPtr def);\nvoid virDomainRNGDefFree(virDomainRNGDefPtr def);\nint virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);\nint virDomainVideoDefaultType(const virDomainDef *def);\nvoid virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);\nint virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);\nbool\nvirDomainDefHasManagedPR(const virDomainDef *def);\nbool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);\nbool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);\nbool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);\n\nstatic inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "vm"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorOpenUnix",
          "args": [
            "config->data.nix.path",
            "vm->pid",
            "retry",
            "timeout"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorOpenUnix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "237-302",
          "snippet": "static int\nqemuMonitorOpenUnix(const char *monitor,\n                    pid_t cpid,\n                    bool retry,\n                    unsigned long long timeout)\n{\n    struct sockaddr_un addr;\n    int monfd;\n    virTimeBackOffVar timebackoff;\n    int ret = -1;\n\n    if ((monfd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"failed to create socket\"));\n        return -1;\n    }\n\n    memset(&addr, 0, sizeof(addr));\n    addr.sun_family = AF_UNIX;\n    if (virStrcpyStatic(addr.sun_path, monitor) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Monitor path %s too big for destination\"), monitor);\n        goto error;\n    }\n\n    if (retry) {\n        if (virTimeBackOffStart(&timebackoff, 1, timeout * 1000) < 0)\n            goto error;\n        while (virTimeBackOffWait(&timebackoff)) {\n            ret = connect(monfd, (struct sockaddr *)&addr, sizeof(addr));\n\n            if (ret == 0)\n                break;\n\n            if ((errno == ENOENT || errno == ECONNREFUSED) &&\n                (!cpid || virProcessKill(cpid, 0) == 0)) {\n                /* ENOENT       : Socket may not have shown up yet\n                 * ECONNREFUSED : Leftover socket hasn't been removed yet */\n                continue;\n            }\n\n            virReportSystemError(errno, \"%s\",\n                                 _(\"failed to connect to monitor socket\"));\n            goto error;\n        }\n\n        if (ret != 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"monitor socket did not show up\"));\n            goto error;\n        }\n    } else {\n        ret = connect(monfd, (struct sockaddr *) &addr, sizeof(addr));\n        if (ret < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"failed to connect to monitor socket\"));\n            goto error;\n        }\n    }\n\n    return monfd;\n\n error:\n    VIR_FORCE_CLOSE(monfd);\n    return -1;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic int\nqemuMonitorOpenUnix(const char *monitor,\n                    pid_t cpid,\n                    bool retry,\n                    unsigned long long timeout)\n{\n    struct sockaddr_un addr;\n    int monfd;\n    virTimeBackOffVar timebackoff;\n    int ret = -1;\n\n    if ((monfd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"failed to create socket\"));\n        return -1;\n    }\n\n    memset(&addr, 0, sizeof(addr));\n    addr.sun_family = AF_UNIX;\n    if (virStrcpyStatic(addr.sun_path, monitor) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Monitor path %s too big for destination\"), monitor);\n        goto error;\n    }\n\n    if (retry) {\n        if (virTimeBackOffStart(&timebackoff, 1, timeout * 1000) < 0)\n            goto error;\n        while (virTimeBackOffWait(&timebackoff)) {\n            ret = connect(monfd, (struct sockaddr *)&addr, sizeof(addr));\n\n            if (ret == 0)\n                break;\n\n            if ((errno == ENOENT || errno == ECONNREFUSED) &&\n                (!cpid || virProcessKill(cpid, 0) == 0)) {\n                /* ENOENT       : Socket may not have shown up yet\n                 * ECONNREFUSED : Leftover socket hasn't been removed yet */\n                continue;\n            }\n\n            virReportSystemError(errno, \"%s\",\n                                 _(\"failed to connect to monitor socket\"));\n            goto error;\n        }\n\n        if (ret != 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"monitor socket did not show up\"));\n            goto error;\n        }\n    } else {\n        ret = connect(monfd, (struct sockaddr *) &addr, sizeof(addr));\n        if (ret < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"failed to connect to monitor socket\"));\n            goto error;\n        }\n    }\n\n    return monfd;\n\n error:\n    VIR_FORCE_CLOSE(monfd);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "vm"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unable to handle monitor type: %s\")",
            "virDomainChrTypeToString(config->type)"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrTypeToString",
          "args": [
            "config->type"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "vm"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\n#define QEMU_DEFAULT_MONITOR_WAIT 30\n\nqemuMonitorPtr\nqemuMonitorOpen(virDomainObjPtr vm,\n                virDomainChrSourceDefPtr config,\n                bool retry,\n                unsigned long long timeout,\n                GMainContext *context,\n                qemuMonitorCallbacksPtr cb,\n                void *opaque)\n{\n    int fd = -1;\n    qemuMonitorPtr ret = NULL;\n\n    timeout += QEMU_DEFAULT_MONITOR_WAIT;\n\n    /* Hold an extra reference because we can't allow 'vm' to be\n     * deleted until the monitor gets its own reference. */\n    virObjectRef(vm);\n\n    if (config->type != VIR_DOMAIN_CHR_TYPE_UNIX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to handle monitor type: %s\"),\n                       virDomainChrTypeToString(config->type));\n        goto cleanup;\n    }\n\n    virObjectUnlock(vm);\n    fd = qemuMonitorOpenUnix(config->data.nix.path,\n                             vm->pid, retry, timeout);\n    virObjectLock(vm);\n\n    if (fd < 0)\n        goto cleanup;\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"domain is not running\"));\n        goto cleanup;\n    }\n\n    ret = qemuMonitorOpenInternal(vm, fd, context, cb, opaque);\n cleanup:\n    if (!ret)\n        VIR_FORCE_CLOSE(fd);\n    virObjectUnref(vm);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorOpenInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "658-732",
    "snippet": "static qemuMonitorPtr\nqemuMonitorOpenInternal(virDomainObjPtr vm,\n                        int fd,\n                        GMainContext *context,\n                        qemuMonitorCallbacksPtr cb,\n                        void *opaque)\n{\n    qemuMonitorPtr mon;\n    g_autoptr(GError) gerr = NULL;\n\n    if (!cb->eofNotify) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"EOF notify callback must be supplied\"));\n        return NULL;\n    }\n    if (!cb->errorNotify) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Error notify callback must be supplied\"));\n        return NULL;\n    }\n\n    if (qemuMonitorInitialize() < 0)\n        return NULL;\n\n    if (!(mon = virObjectLockableNew(qemuMonitorClass)))\n        return NULL;\n\n    if (virCondInit(&mon->notify) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot initialize monitor condition\"));\n        goto cleanup;\n    }\n    mon->fd = fd;\n    mon->context = g_main_context_ref(context);\n    mon->vm = virObjectRef(vm);\n    mon->waitGreeting = true;\n    mon->cb = cb;\n    mon->callbackOpaque = opaque;\n\n    if (virSetCloseExec(mon->fd) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Unable to set monitor close-on-exec flag\"));\n        goto cleanup;\n    }\n\n    mon->socket = g_socket_new_from_fd(fd, &gerr);\n    if (!mon->socket) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to create socket object: %s\"),\n                       gerr->message);\n        goto cleanup;\n    }\n\n    virObjectLock(mon);\n    qemuMonitorRegister(mon);\n\n    PROBE(QEMU_MONITOR_NEW,\n          \"mon=%p refs=%d fd=%d\",\n          mon, mon->parent.parent.u.s.refs, mon->fd);\n    virObjectUnlock(mon);\n\n    return mon;\n\n cleanup:\n    /* We don't want the 'destroy' callback invoked during\n     * cleanup from construction failure, because that can\n     * give a double-unref on virDomainObjPtr in the caller,\n     * so kill the callbacks now.\n     */\n    mon->cb = NULL;\n    /* The caller owns 'fd' on failure */\n    mon->fd = -1;\n    qemuMonitorClose(mon);\n    return NULL;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr qemuMonitorClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorClose",
          "args": [
            "mon"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "846-894",
          "snippet": "void\nqemuMonitorClose(qemuMonitorPtr mon)\n{\n    if (!mon)\n        return;\n\n    virObjectLock(mon);\n    PROBE(QEMU_MONITOR_CLOSE,\n          \"mon=%p refs=%d\", mon, mon->parent.parent.u.s.refs);\n\n    qemuMonitorSetDomainLogLocked(mon, NULL, NULL, NULL);\n\n    if (mon->socket) {\n        qemuMonitorUnregister(mon);\n        g_object_unref(mon->socket);\n        mon->socket = NULL;\n        mon->fd = -1;\n    }\n\n    /* In case another thread is waiting for its monitor command to be\n     * processed, we need to wake it up with appropriate error set.\n     */\n    if (mon->msg) {\n        if (mon->lastError.code == VIR_ERR_OK) {\n            virErrorPtr err;\n\n            virErrorPreserveLast(&err);\n\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"QEMU monitor was closed\"));\n            virCopyLastError(&mon->lastError);\n            if (err)\n                virErrorRestore(&err);\n            else\n                virResetLastError();\n        }\n        mon->msg->finished = 1;\n        virCondSignal(&mon->notify);\n    }\n\n    /* Propagate existing monitor error in case the current thread has no\n     * error set.\n     */\n    if (mon->lastError.code != VIR_ERR_OK && virGetLastErrorCode() == VIR_ERR_OK)\n        virSetError(&mon->lastError);\n\n    virObjectUnlock(mon);\n    virObjectUnref(mon);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorClose(qemuMonitorPtr mon)\n{\n    if (!mon)\n        return;\n\n    virObjectLock(mon);\n    PROBE(QEMU_MONITOR_CLOSE,\n          \"mon=%p refs=%d\", mon, mon->parent.parent.u.s.refs);\n\n    qemuMonitorSetDomainLogLocked(mon, NULL, NULL, NULL);\n\n    if (mon->socket) {\n        qemuMonitorUnregister(mon);\n        g_object_unref(mon->socket);\n        mon->socket = NULL;\n        mon->fd = -1;\n    }\n\n    /* In case another thread is waiting for its monitor command to be\n     * processed, we need to wake it up with appropriate error set.\n     */\n    if (mon->msg) {\n        if (mon->lastError.code == VIR_ERR_OK) {\n            virErrorPtr err;\n\n            virErrorPreserveLast(&err);\n\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"QEMU monitor was closed\"));\n            virCopyLastError(&mon->lastError);\n            if (err)\n                virErrorRestore(&err);\n            else\n                virResetLastError();\n        }\n        mon->msg->finished = 1;\n        virCondSignal(&mon->notify);\n    }\n\n    /* Propagate existing monitor error in case the current thread has no\n     * error set.\n     */\n    if (mon->lastError.code != VIR_ERR_OK && virGetLastErrorCode() == VIR_ERR_OK)\n        virSetError(&mon->lastError);\n\n    virObjectUnlock(mon);\n    virObjectUnref(mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mon"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "QEMU_MONITOR_NEW",
            "\"mon=%p refs=%d fd=%d\"",
            "mon",
            "mon->parent.parent.u.s.refs",
            "mon->fd"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorRegister",
          "args": [
            "mon"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "808-833",
          "snippet": "void\nqemuMonitorRegister(qemuMonitorPtr mon)\n{\n    GIOCondition cond = 0;\n\n    if (mon->lastError.code == VIR_ERR_OK) {\n        cond |= G_IO_IN;\n\n        if ((mon->msg && mon->msg->txOffset < mon->msg->txLength) &&\n            !mon->waitGreeting)\n            cond |= G_IO_OUT;\n    }\n\n    mon->watch = g_socket_create_source(mon->socket,\n                                        cond,\n                                        NULL);\n\n    virObjectRef(mon);\n    g_source_set_callback(mon->watch,\n                          (GSourceFunc)qemuMonitorIO,\n                          mon,\n                          (GDestroyNotify)virObjectUnref);\n\n    g_source_attach(mon->watch,\n                    mon->context);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorRegister(qemuMonitorPtr mon)\n{\n    GIOCondition cond = 0;\n\n    if (mon->lastError.code == VIR_ERR_OK) {\n        cond |= G_IO_IN;\n\n        if ((mon->msg && mon->msg->txOffset < mon->msg->txLength) &&\n            !mon->waitGreeting)\n            cond |= G_IO_OUT;\n    }\n\n    mon->watch = g_socket_create_source(mon->socket,\n                                        cond,\n                                        NULL);\n\n    virObjectRef(mon);\n    g_source_set_callback(mon->watch,\n                          (GSourceFunc)qemuMonitorIO,\n                          mon,\n                          (GDestroyNotify)virObjectUnref);\n\n    g_source_attach(mon->watch,\n                    mon->context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mon"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to create socket object: %s\")",
            "gerr->message"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to create socket object: %s\""
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_socket_new_from_fd",
          "args": [
            "fd",
            "&gerr"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to set monitor close-on-exec flag\")"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetCloseExec",
          "args": [
            "mon->fd"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "virSetCloseExec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "131-134",
          "snippet": "int virSetCloseExec(int fd)\n{\n    return virSetInherit(fd, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetCloseExec(int fd)\n{\n    return virSetInherit(fd, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "vm"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_main_context_ref",
          "args": [
            "context"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot initialize monitor condition\")"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCondInit",
          "args": [
            "&mon->notify"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "virCondInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "125-133",
          "snippet": "int virCondInit(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_init(&c->cond, NULL)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondInit(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_init(&c->cond, NULL)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "qemuMonitorClass"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorInitialize",
          "args": [],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Error notify callback must be supplied\")"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"EOF notify callback must be supplied\")"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic virClassPtr qemuMonitorClass;\n\nstatic qemuMonitorPtr\nqemuMonitorOpenInternal(virDomainObjPtr vm,\n                        int fd,\n                        GMainContext *context,\n                        qemuMonitorCallbacksPtr cb,\n                        void *opaque)\n{\n    qemuMonitorPtr mon;\n    g_autoptr(GError) gerr = NULL;\n\n    if (!cb->eofNotify) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"EOF notify callback must be supplied\"));\n        return NULL;\n    }\n    if (!cb->errorNotify) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Error notify callback must be supplied\"));\n        return NULL;\n    }\n\n    if (qemuMonitorInitialize() < 0)\n        return NULL;\n\n    if (!(mon = virObjectLockableNew(qemuMonitorClass)))\n        return NULL;\n\n    if (virCondInit(&mon->notify) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot initialize monitor condition\"));\n        goto cleanup;\n    }\n    mon->fd = fd;\n    mon->context = g_main_context_ref(context);\n    mon->vm = virObjectRef(vm);\n    mon->waitGreeting = true;\n    mon->cb = cb;\n    mon->callbackOpaque = opaque;\n\n    if (virSetCloseExec(mon->fd) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Unable to set monitor close-on-exec flag\"));\n        goto cleanup;\n    }\n\n    mon->socket = g_socket_new_from_fd(fd, &gerr);\n    if (!mon->socket) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to create socket object: %s\"),\n                       gerr->message);\n        goto cleanup;\n    }\n\n    virObjectLock(mon);\n    qemuMonitorRegister(mon);\n\n    PROBE(QEMU_MONITOR_NEW,\n          \"mon=%p refs=%d fd=%d\",\n          mon, mon->parent.parent.u.s.refs, mon->fd);\n    virObjectUnlock(mon);\n\n    return mon;\n\n cleanup:\n    /* We don't want the 'destroy' callback invoked during\n     * cleanup from construction failure, because that can\n     * give a double-unref on virDomainObjPtr in the caller,\n     * so kill the callbacks now.\n     */\n    mon->cb = NULL;\n    /* The caller owns 'fd' on failure */\n    mon->fd = -1;\n    qemuMonitorClose(mon);\n    return NULL;\n}"
  },
  {
    "function_name": "qemuMonitorIO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "518-655",
    "snippet": "static gboolean\nqemuMonitorIO(GSocket *socket G_GNUC_UNUSED,\n              GIOCondition cond,\n              gpointer opaque)\n{\n    qemuMonitorPtr mon = opaque;\n    bool error = false;\n    bool eof = false;\n    bool hangup = false;\n\n    virObjectRef(mon);\n\n    /* lock access to the monitor and protect fd */\n    virObjectLock(mon);\n#if DEBUG_IO\n    VIR_DEBUG(\"Monitor %p I/O on socket %p cond %d\", mon, socket, cond);\n#endif\n    if (mon->fd == -1 || !mon->watch) {\n        virObjectUnlock(mon);\n        virObjectUnref(mon);\n        return G_SOURCE_REMOVE;\n    }\n\n    if (mon->lastError.code != VIR_ERR_OK) {\n        if (cond & (G_IO_HUP | G_IO_ERR))\n            eof = true;\n        error = true;\n    } else {\n        if (cond & G_IO_OUT) {\n            if (qemuMonitorIOWrite(mon) < 0) {\n                error = true;\n                if (errno == ECONNRESET)\n                    hangup = true;\n            }\n        }\n\n        if (!error && cond & G_IO_IN) {\n            int got = qemuMonitorIORead(mon);\n            if (got < 0) {\n                error = true;\n                if (errno == ECONNRESET)\n                    hangup = true;\n            } else if (got == 0) {\n                eof = true;\n            } else {\n                /* Ignore hangup/error cond if we read some data, to\n                 * give time for that data to be consumed */\n                cond = 0;\n\n                if (qemuMonitorIOProcess(mon) < 0)\n                    error = true;\n            }\n        }\n\n        if (cond & G_IO_HUP) {\n            hangup = true;\n            if (!error) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"End of file from qemu monitor\"));\n                eof = true;\n            }\n        }\n\n        if (!error && !eof &&\n            cond & G_IO_ERR) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Invalid file descriptor while waiting for monitor\"));\n            eof = true;\n        }\n    }\n\n    if (error || eof) {\n        if (hangup && mon->logFunc != NULL) {\n            /* Check if an error message from qemu is available and if so, use\n             * it to overwrite the actual message. It's done only in early\n             * startup phases or during incoming migration when the message\n             * from qemu is certainly more interesting than a\n             * \"connection reset by peer\" message.\n             */\n            mon->logFunc(mon,\n                         _(\"qemu unexpectedly closed the monitor\"),\n                         mon->logOpaque);\n            virCopyLastError(&mon->lastError);\n            virResetLastError();\n        }\n\n        if (mon->lastError.code != VIR_ERR_OK) {\n            /* Already have an error, so clear any new error */\n            virResetLastError();\n        } else {\n            if (virGetLastErrorCode() == VIR_ERR_OK)\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Error while processing monitor IO\"));\n            virCopyLastError(&mon->lastError);\n            virResetLastError();\n        }\n\n        VIR_DEBUG(\"Error on monitor %s\", NULLSTR(mon->lastError.message));\n        /* If IO process resulted in an error & we have a message,\n         * then wakeup that waiter */\n        if (mon->msg && !mon->msg->finished) {\n            mon->msg->finished = 1;\n            virCondSignal(&mon->notify);\n        }\n    }\n\n    qemuMonitorUpdateWatch(mon);\n\n    /* We have to unlock to avoid deadlock against command thread,\n     * but is this safe ?  I think it is, because the callback\n     * will try to acquire the virDomainObjPtr mutex next */\n    if (eof) {\n        qemuMonitorEofNotifyCallback eofNotify = mon->cb->eofNotify;\n        virDomainObjPtr vm = mon->vm;\n\n        /* Make sure anyone waiting wakes up now */\n        virCondSignal(&mon->notify);\n        virObjectUnlock(mon);\n        VIR_DEBUG(\"Triggering EOF callback\");\n        (eofNotify)(mon, vm, mon->callbackOpaque);\n        virObjectUnref(mon);\n    } else if (error) {\n        qemuMonitorErrorNotifyCallback errorNotify = mon->cb->errorNotify;\n        virDomainObjPtr vm = mon->vm;\n\n        /* Make sure anyone waiting wakes up now */\n        virCondSignal(&mon->notify);\n        virObjectUnlock(mon);\n        VIR_DEBUG(\"Triggering error callback\");\n        (errorNotify)(mon, vm, mon->callbackOpaque);\n        virObjectUnref(mon);\n    } else {\n        virObjectUnlock(mon);\n        virObjectUnref(mon);\n    }\n\n    return G_SOURCE_REMOVE;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define DEBUG_IO 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "mon"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mon"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "mon",
            "vm",
            "mon->callbackOpaque"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Triggering error callback\""
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCondSignal",
          "args": [
            "&mon->notify"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "virCondSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "170-173",
          "snippet": "void virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "mon",
            "vm",
            "mon->callbackOpaque"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Triggering EOF callback\""
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorUpdateWatch",
          "args": [
            "mon"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorUpdateWatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "509-515",
          "snippet": "static void\nqemuMonitorUpdateWatch(qemuMonitorPtr mon)\n{\n    qemuMonitorUnregister(mon);\n    if (mon->socket)\n        qemuMonitorRegister(mon);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void\nqemuMonitorUpdateWatch(qemuMonitorPtr mon)\n{\n    qemuMonitorUnregister(mon);\n    if (mon->socket)\n        qemuMonitorRegister(mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Error on monitor %s\"",
            "NULLSTR(mon->lastError.message)"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "mon->lastError.message"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCopyLastError",
          "args": [
            "&mon->lastError"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "virCopyLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "370-389",
          "snippet": "int\nvirCopyLastError(virErrorPtr to)\n{\n    virErrorPtr err = virLastErrorObject();\n\n    if (!to)\n        return -1;\n\n    /* We can't guarantee caller has initialized it to zero */\n    memset(to, 0, sizeof(*to));\n    if (err) {\n        virCopyError(err, to);\n    } else {\n        virResetError(to);\n        to->code = VIR_ERR_NO_MEMORY;\n        to->domain = VIR_FROM_NONE;\n        to->level = VIR_ERR_ERROR;\n    }\n    return to->code;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirCopyLastError(virErrorPtr to)\n{\n    virErrorPtr err = virLastErrorObject();\n\n    if (!to)\n        return -1;\n\n    /* We can't guarantee caller has initialized it to zero */\n    memset(to, 0, sizeof(*to));\n    if (err) {\n        virCopyError(err, to);\n    } else {\n        virResetError(to);\n        to->code = VIR_ERR_NO_MEMORY;\n        to->domain = VIR_FROM_NONE;\n        to->level = VIR_ERR_ERROR;\n    }\n    return to->code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Error while processing monitor IO\")"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Error while processing monitor IO\""
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetLastErrorCode",
          "args": [],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorCode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "280-287",
          "snippet": "int\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mon->logFunc",
          "args": [
            "mon",
            "_(\"qemu unexpectedly closed the monitor\")",
            "mon->logOpaque"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid file descriptor while waiting for monitor\")"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"End of file from qemu monitor\")"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorIOProcess",
          "args": [
            "mon"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorIOProcess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "309-361",
          "snippet": "static int\nqemuMonitorIOProcess(qemuMonitorPtr mon)\n{\n    int len;\n    qemuMonitorMessagePtr msg = NULL;\n\n    /* See if there's a message & whether its ready for its reply\n     * ie whether its completed writing all its data */\n    if (mon->msg && mon->msg->txOffset == mon->msg->txLength)\n        msg = mon->msg;\n\n#if DEBUG_IO\n# if DEBUG_RAW_IO\n    char *str1 = qemuMonitorEscapeNonPrintable(msg ? msg->txBuffer : \"\");\n    char *str2 = qemuMonitorEscapeNonPrintable(mon->buffer);\n    VIR_ERROR(_(\"Process %d %p %p [[[[%s]]][[[%s]]]\"), (int)mon->bufferOffset, mon->msg, msg, str1, str2);\n    VIR_FREE(str1);\n    VIR_FREE(str2);\n# else\n    VIR_DEBUG(\"Process %d\", (int)mon->bufferOffset);\n# endif\n#endif\n\n    PROBE_QUIET(QEMU_MONITOR_IO_PROCESS, \"mon=%p buf=%s len=%zu\",\n                mon, mon->buffer, mon->bufferOffset);\n\n    len = qemuMonitorJSONIOProcess(mon,\n                                   mon->buffer, mon->bufferOffset,\n                                   msg);\n    if (len < 0)\n        return -1;\n\n    if (len && mon->waitGreeting)\n        mon->waitGreeting = false;\n\n    if (len < mon->bufferOffset) {\n        memmove(mon->buffer, mon->buffer + len, mon->bufferOffset - len);\n        mon->bufferOffset -= len;\n    } else {\n        VIR_FREE(mon->buffer);\n        mon->bufferOffset = mon->bufferLength = 0;\n    }\n#if DEBUG_IO\n    VIR_DEBUG(\"Process done %d used %d\", (int)mon->bufferOffset, len);\n#endif\n\n    /* As the monitor mutex was unlocked in qemuMonitorJSONIOProcess()\n     * while dealing with qemu event, mon->msg could be changed which\n     * means the above 'msg' may be invalid, thus we use 'mon->msg' here */\n    if (mon->msg && mon->msg->finished)\n        virCondBroadcast(&mon->notify);\n    return len;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define DEBUG_RAW_IO 0",
            "#define DEBUG_IO 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\n#define DEBUG_RAW_IO 0\n#define DEBUG_IO 0\n\nstatic int\nqemuMonitorIOProcess(qemuMonitorPtr mon)\n{\n    int len;\n    qemuMonitorMessagePtr msg = NULL;\n\n    /* See if there's a message & whether its ready for its reply\n     * ie whether its completed writing all its data */\n    if (mon->msg && mon->msg->txOffset == mon->msg->txLength)\n        msg = mon->msg;\n\n#if DEBUG_IO\n# if DEBUG_RAW_IO\n    char *str1 = qemuMonitorEscapeNonPrintable(msg ? msg->txBuffer : \"\");\n    char *str2 = qemuMonitorEscapeNonPrintable(mon->buffer);\n    VIR_ERROR(_(\"Process %d %p %p [[[[%s]]][[[%s]]]\"), (int)mon->bufferOffset, mon->msg, msg, str1, str2);\n    VIR_FREE(str1);\n    VIR_FREE(str2);\n# else\n    VIR_DEBUG(\"Process %d\", (int)mon->bufferOffset);\n# endif\n#endif\n\n    PROBE_QUIET(QEMU_MONITOR_IO_PROCESS, \"mon=%p buf=%s len=%zu\",\n                mon, mon->buffer, mon->bufferOffset);\n\n    len = qemuMonitorJSONIOProcess(mon,\n                                   mon->buffer, mon->bufferOffset,\n                                   msg);\n    if (len < 0)\n        return -1;\n\n    if (len && mon->waitGreeting)\n        mon->waitGreeting = false;\n\n    if (len < mon->bufferOffset) {\n        memmove(mon->buffer, mon->buffer + len, mon->bufferOffset - len);\n        mon->bufferOffset -= len;\n    } else {\n        VIR_FREE(mon->buffer);\n        mon->bufferOffset = mon->bufferLength = 0;\n    }\n#if DEBUG_IO\n    VIR_DEBUG(\"Process done %d used %d\", (int)mon->bufferOffset, len);\n#endif\n\n    /* As the monitor mutex was unlocked in qemuMonitorJSONIOProcess()\n     * while dealing with qemu event, mon->msg could be changed which\n     * means the above 'msg' may be invalid, thus we use 'mon->msg' here */\n    if (mon->msg && mon->msg->finished)\n        virCondBroadcast(&mon->notify);\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorIORead",
          "args": [
            "mon"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorIORead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "457-506",
          "snippet": "static int\nqemuMonitorIORead(qemuMonitorPtr mon)\n{\n    size_t avail = mon->bufferLength - mon->bufferOffset;\n    int ret = 0;\n\n    if (avail < 1024) {\n        if (mon->bufferLength >= QEMU_MONITOR_MAX_RESPONSE) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"QEMU monitor reply exceeds buffer size (%d bytes)\"),\n                           QEMU_MONITOR_MAX_RESPONSE);\n            return -1;\n        }\n        if (VIR_REALLOC_N(mon->buffer,\n                          mon->bufferLength + 1024) < 0)\n            return -1;\n        mon->bufferLength += 1024;\n        avail += 1024;\n    }\n\n    /* Read as much as we can get into our buffer,\n       until we block on EAGAIN, or hit EOF */\n    while (avail > 1) {\n        int got;\n        got = read(mon->fd,\n                   mon->buffer + mon->bufferOffset,\n                   avail - 1);\n        if (got < 0) {\n            if (errno == EAGAIN)\n                break;\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to read from monitor\"));\n            ret = -1;\n            break;\n        }\n        if (got == 0)\n            break;\n\n        ret += got;\n        avail -= got;\n        mon->bufferOffset += got;\n        mon->buffer[mon->bufferOffset] = '\\0';\n    }\n\n#if DEBUG_IO\n    VIR_DEBUG(\"Now read %d bytes of data\", (int)mon->bufferOffset);\n#endif\n\n    return ret;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define QEMU_MONITOR_MAX_RESPONSE (10 * 1024 * 1024)",
            "#define DEBUG_IO 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\n#define QEMU_MONITOR_MAX_RESPONSE (10 * 1024 * 1024)\n#define DEBUG_IO 0\n\nstatic int\nqemuMonitorIORead(qemuMonitorPtr mon)\n{\n    size_t avail = mon->bufferLength - mon->bufferOffset;\n    int ret = 0;\n\n    if (avail < 1024) {\n        if (mon->bufferLength >= QEMU_MONITOR_MAX_RESPONSE) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"QEMU monitor reply exceeds buffer size (%d bytes)\"),\n                           QEMU_MONITOR_MAX_RESPONSE);\n            return -1;\n        }\n        if (VIR_REALLOC_N(mon->buffer,\n                          mon->bufferLength + 1024) < 0)\n            return -1;\n        mon->bufferLength += 1024;\n        avail += 1024;\n    }\n\n    /* Read as much as we can get into our buffer,\n       until we block on EAGAIN, or hit EOF */\n    while (avail > 1) {\n        int got;\n        got = read(mon->fd,\n                   mon->buffer + mon->bufferOffset,\n                   avail - 1);\n        if (got < 0) {\n            if (errno == EAGAIN)\n                break;\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to read from monitor\"));\n            ret = -1;\n            break;\n        }\n        if (got == 0)\n            break;\n\n        ret += got;\n        avail -= got;\n        mon->bufferOffset += got;\n        mon->buffer[mon->bufferOffset] = '\\0';\n    }\n\n#if DEBUG_IO\n    VIR_DEBUG(\"Now read %d bytes of data\", (int)mon->bufferOffset);\n#endif\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorIOWrite",
          "args": [
            "mon"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorIOWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "410-448",
          "snippet": "static int\nqemuMonitorIOWrite(qemuMonitorPtr mon)\n{\n    int done;\n    char *buf;\n    size_t len;\n\n    /* If no active message, or fully transmitted, the no-op */\n    if (!mon->msg || mon->msg->txOffset == mon->msg->txLength)\n        return 0;\n\n    buf = mon->msg->txBuffer + mon->msg->txOffset;\n    len = mon->msg->txLength - mon->msg->txOffset;\n    if (mon->msg->txFD == -1)\n        done = write(mon->fd, buf, len);\n    else\n        done = qemuMonitorIOWriteWithFD(mon, buf, len, mon->msg->txFD);\n\n    PROBE(QEMU_MONITOR_IO_WRITE,\n          \"mon=%p buf=%s len=%zu ret=%d errno=%d\",\n          mon, buf, len, done, done < 0 ? errno : 0);\n\n    if (mon->msg->txFD != -1) {\n        PROBE(QEMU_MONITOR_IO_SEND_FD,\n              \"mon=%p fd=%d ret=%d errno=%d\",\n              mon, mon->msg->txFD, done, done < 0 ? errno : 0);\n    }\n\n    if (done < 0) {\n        if (errno == EAGAIN)\n            return 0;\n\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to write to monitor\"));\n        return -1;\n    }\n    mon->msg->txOffset += done;\n    return done;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic int\nqemuMonitorIOWrite(qemuMonitorPtr mon)\n{\n    int done;\n    char *buf;\n    size_t len;\n\n    /* If no active message, or fully transmitted, the no-op */\n    if (!mon->msg || mon->msg->txOffset == mon->msg->txLength)\n        return 0;\n\n    buf = mon->msg->txBuffer + mon->msg->txOffset;\n    len = mon->msg->txLength - mon->msg->txOffset;\n    if (mon->msg->txFD == -1)\n        done = write(mon->fd, buf, len);\n    else\n        done = qemuMonitorIOWriteWithFD(mon, buf, len, mon->msg->txFD);\n\n    PROBE(QEMU_MONITOR_IO_WRITE,\n          \"mon=%p buf=%s len=%zu ret=%d errno=%d\",\n          mon, buf, len, done, done < 0 ? errno : 0);\n\n    if (mon->msg->txFD != -1) {\n        PROBE(QEMU_MONITOR_IO_SEND_FD,\n              \"mon=%p fd=%d ret=%d errno=%d\",\n              mon, mon->msg->txFD, done, done < 0 ? errno : 0);\n    }\n\n    if (done < 0) {\n        if (errno == EAGAIN)\n            return 0;\n\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to write to monitor\"));\n        return -1;\n    }\n    mon->msg->txOffset += done;\n    return done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Monitor %p I/O on socket %p cond %d\"",
            "mon",
            "socket",
            "cond"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mon"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "mon"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\n#define DEBUG_IO 0\n\nstatic gboolean\nqemuMonitorIO(GSocket *socket G_GNUC_UNUSED,\n              GIOCondition cond,\n              gpointer opaque)\n{\n    qemuMonitorPtr mon = opaque;\n    bool error = false;\n    bool eof = false;\n    bool hangup = false;\n\n    virObjectRef(mon);\n\n    /* lock access to the monitor and protect fd */\n    virObjectLock(mon);\n#if DEBUG_IO\n    VIR_DEBUG(\"Monitor %p I/O on socket %p cond %d\", mon, socket, cond);\n#endif\n    if (mon->fd == -1 || !mon->watch) {\n        virObjectUnlock(mon);\n        virObjectUnref(mon);\n        return G_SOURCE_REMOVE;\n    }\n\n    if (mon->lastError.code != VIR_ERR_OK) {\n        if (cond & (G_IO_HUP | G_IO_ERR))\n            eof = true;\n        error = true;\n    } else {\n        if (cond & G_IO_OUT) {\n            if (qemuMonitorIOWrite(mon) < 0) {\n                error = true;\n                if (errno == ECONNRESET)\n                    hangup = true;\n            }\n        }\n\n        if (!error && cond & G_IO_IN) {\n            int got = qemuMonitorIORead(mon);\n            if (got < 0) {\n                error = true;\n                if (errno == ECONNRESET)\n                    hangup = true;\n            } else if (got == 0) {\n                eof = true;\n            } else {\n                /* Ignore hangup/error cond if we read some data, to\n                 * give time for that data to be consumed */\n                cond = 0;\n\n                if (qemuMonitorIOProcess(mon) < 0)\n                    error = true;\n            }\n        }\n\n        if (cond & G_IO_HUP) {\n            hangup = true;\n            if (!error) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"End of file from qemu monitor\"));\n                eof = true;\n            }\n        }\n\n        if (!error && !eof &&\n            cond & G_IO_ERR) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Invalid file descriptor while waiting for monitor\"));\n            eof = true;\n        }\n    }\n\n    if (error || eof) {\n        if (hangup && mon->logFunc != NULL) {\n            /* Check if an error message from qemu is available and if so, use\n             * it to overwrite the actual message. It's done only in early\n             * startup phases or during incoming migration when the message\n             * from qemu is certainly more interesting than a\n             * \"connection reset by peer\" message.\n             */\n            mon->logFunc(mon,\n                         _(\"qemu unexpectedly closed the monitor\"),\n                         mon->logOpaque);\n            virCopyLastError(&mon->lastError);\n            virResetLastError();\n        }\n\n        if (mon->lastError.code != VIR_ERR_OK) {\n            /* Already have an error, so clear any new error */\n            virResetLastError();\n        } else {\n            if (virGetLastErrorCode() == VIR_ERR_OK)\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Error while processing monitor IO\"));\n            virCopyLastError(&mon->lastError);\n            virResetLastError();\n        }\n\n        VIR_DEBUG(\"Error on monitor %s\", NULLSTR(mon->lastError.message));\n        /* If IO process resulted in an error & we have a message,\n         * then wakeup that waiter */\n        if (mon->msg && !mon->msg->finished) {\n            mon->msg->finished = 1;\n            virCondSignal(&mon->notify);\n        }\n    }\n\n    qemuMonitorUpdateWatch(mon);\n\n    /* We have to unlock to avoid deadlock against command thread,\n     * but is this safe ?  I think it is, because the callback\n     * will try to acquire the virDomainObjPtr mutex next */\n    if (eof) {\n        qemuMonitorEofNotifyCallback eofNotify = mon->cb->eofNotify;\n        virDomainObjPtr vm = mon->vm;\n\n        /* Make sure anyone waiting wakes up now */\n        virCondSignal(&mon->notify);\n        virObjectUnlock(mon);\n        VIR_DEBUG(\"Triggering EOF callback\");\n        (eofNotify)(mon, vm, mon->callbackOpaque);\n        virObjectUnref(mon);\n    } else if (error) {\n        qemuMonitorErrorNotifyCallback errorNotify = mon->cb->errorNotify;\n        virDomainObjPtr vm = mon->vm;\n\n        /* Make sure anyone waiting wakes up now */\n        virCondSignal(&mon->notify);\n        virObjectUnlock(mon);\n        VIR_DEBUG(\"Triggering error callback\");\n        (errorNotify)(mon, vm, mon->callbackOpaque);\n        virObjectUnref(mon);\n    } else {\n        virObjectUnlock(mon);\n        virObjectUnref(mon);\n    }\n\n    return G_SOURCE_REMOVE;\n}"
  },
  {
    "function_name": "qemuMonitorUpdateWatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "509-515",
    "snippet": "static void\nqemuMonitorUpdateWatch(qemuMonitorPtr mon)\n{\n    qemuMonitorUnregister(mon);\n    if (mon->socket)\n        qemuMonitorRegister(mon);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorRegister",
          "args": [
            "mon"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "808-833",
          "snippet": "void\nqemuMonitorRegister(qemuMonitorPtr mon)\n{\n    GIOCondition cond = 0;\n\n    if (mon->lastError.code == VIR_ERR_OK) {\n        cond |= G_IO_IN;\n\n        if ((mon->msg && mon->msg->txOffset < mon->msg->txLength) &&\n            !mon->waitGreeting)\n            cond |= G_IO_OUT;\n    }\n\n    mon->watch = g_socket_create_source(mon->socket,\n                                        cond,\n                                        NULL);\n\n    virObjectRef(mon);\n    g_source_set_callback(mon->watch,\n                          (GSourceFunc)qemuMonitorIO,\n                          mon,\n                          (GDestroyNotify)virObjectUnref);\n\n    g_source_attach(mon->watch,\n                    mon->context);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorRegister(qemuMonitorPtr mon)\n{\n    GIOCondition cond = 0;\n\n    if (mon->lastError.code == VIR_ERR_OK) {\n        cond |= G_IO_IN;\n\n        if ((mon->msg && mon->msg->txOffset < mon->msg->txLength) &&\n            !mon->waitGreeting)\n            cond |= G_IO_OUT;\n    }\n\n    mon->watch = g_socket_create_source(mon->socket,\n                                        cond,\n                                        NULL);\n\n    virObjectRef(mon);\n    g_source_set_callback(mon->watch,\n                          (GSourceFunc)qemuMonitorIO,\n                          mon,\n                          (GDestroyNotify)virObjectUnref);\n\n    g_source_attach(mon->watch,\n                    mon->context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorUnregister",
          "args": [
            "mon"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorUnregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "836-844",
          "snippet": "void\nqemuMonitorUnregister(qemuMonitorPtr mon)\n{\n    if (mon->watch) {\n        g_source_destroy(mon->watch);\n        g_source_unref(mon->watch);\n        mon->watch = NULL;\n    }\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorUnregister(qemuMonitorPtr mon)\n{\n    if (mon->watch) {\n        g_source_destroy(mon->watch);\n        g_source_unref(mon->watch);\n        mon->watch = NULL;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void\nqemuMonitorUpdateWatch(qemuMonitorPtr mon)\n{\n    qemuMonitorUnregister(mon);\n    if (mon->socket)\n        qemuMonitorRegister(mon);\n}"
  },
  {
    "function_name": "qemuMonitorIORead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "457-506",
    "snippet": "static int\nqemuMonitorIORead(qemuMonitorPtr mon)\n{\n    size_t avail = mon->bufferLength - mon->bufferOffset;\n    int ret = 0;\n\n    if (avail < 1024) {\n        if (mon->bufferLength >= QEMU_MONITOR_MAX_RESPONSE) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"QEMU monitor reply exceeds buffer size (%d bytes)\"),\n                           QEMU_MONITOR_MAX_RESPONSE);\n            return -1;\n        }\n        if (VIR_REALLOC_N(mon->buffer,\n                          mon->bufferLength + 1024) < 0)\n            return -1;\n        mon->bufferLength += 1024;\n        avail += 1024;\n    }\n\n    /* Read as much as we can get into our buffer,\n       until we block on EAGAIN, or hit EOF */\n    while (avail > 1) {\n        int got;\n        got = read(mon->fd,\n                   mon->buffer + mon->bufferOffset,\n                   avail - 1);\n        if (got < 0) {\n            if (errno == EAGAIN)\n                break;\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to read from monitor\"));\n            ret = -1;\n            break;\n        }\n        if (got == 0)\n            break;\n\n        ret += got;\n        avail -= got;\n        mon->bufferOffset += got;\n        mon->buffer[mon->bufferOffset] = '\\0';\n    }\n\n#if DEBUG_IO\n    VIR_DEBUG(\"Now read %d bytes of data\", (int)mon->bufferOffset);\n#endif\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define QEMU_MONITOR_MAX_RESPONSE (10 * 1024 * 1024)",
      "#define DEBUG_IO 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Now read %d bytes of data\"",
            "(int)mon->bufferOffset"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to read from monitor\")"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to read from monitor\""
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "mon->fd",
            "mon->buffer + mon->bufferOffset",
            "avail - 1"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessDetectIOThreadPIDs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "2434-2495",
          "snippet": "static int\nqemuProcessDetectIOThreadPIDs(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorIOThreadInfoPtr *iothreads = NULL;\n    int niothreads = 0;\n    int ret = -1;\n    size_t i;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_OBJECT_IOTHREAD)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Get the list of IOThreads from qemu */\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n    niothreads = qemuMonitorGetIOThreads(priv->mon, &iothreads);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        goto cleanup;\n    if (niothreads < 0)\n        goto cleanup;\n\n    if (niothreads != vm->def->niothreadids) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"got wrong number of IOThread pids from QEMU monitor. \"\n                         \"got %d, wanted %zu\"),\n                       niothreads, vm->def->niothreadids);\n        goto cleanup;\n    }\n\n    /* Nothing to do */\n    if (niothreads == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    for (i = 0; i < niothreads; i++) {\n        virDomainIOThreadIDDefPtr iothrid;\n\n        if (!(iothrid = virDomainIOThreadIDFind(vm->def,\n                                                iothreads[i]->iothread_id))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"iothread %d not found\"),\n                           iothreads[i]->iothread_id);\n            goto cleanup;\n        }\n        iothrid->thread_id = iothreads[i]->thread_id;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (iothreads) {\n        for (i = 0; i < niothreads; i++)\n            VIR_FREE(iothreads[i]);\n        VIR_FREE(iothreads);\n    }\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nqemuProcessDetectIOThreadPIDs(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorIOThreadInfoPtr *iothreads = NULL;\n    int niothreads = 0;\n    int ret = -1;\n    size_t i;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_OBJECT_IOTHREAD)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Get the list of IOThreads from qemu */\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n    niothreads = qemuMonitorGetIOThreads(priv->mon, &iothreads);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        goto cleanup;\n    if (niothreads < 0)\n        goto cleanup;\n\n    if (niothreads != vm->def->niothreadids) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"got wrong number of IOThread pids from QEMU monitor. \"\n                         \"got %d, wanted %zu\"),\n                       niothreads, vm->def->niothreadids);\n        goto cleanup;\n    }\n\n    /* Nothing to do */\n    if (niothreads == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    for (i = 0; i < niothreads; i++) {\n        virDomainIOThreadIDDefPtr iothrid;\n\n        if (!(iothrid = virDomainIOThreadIDFind(vm->def,\n                                                iothreads[i]->iothread_id))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"iothread %d not found\"),\n                           iothreads[i]->iothread_id);\n            goto cleanup;\n        }\n        iothrid->thread_id = iothreads[i]->thread_id;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (iothreads) {\n        for (i = 0; i < niothreads; i++)\n            VIR_FREE(iothreads[i]);\n        VIR_FREE(iothreads);\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "mon->buffer",
            "mon->bufferLength + 1024"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"QEMU monitor reply exceeds buffer size (%d bytes)\")",
            "QEMU_MONITOR_MAX_RESPONSE"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\n#define QEMU_MONITOR_MAX_RESPONSE (10 * 1024 * 1024)\n#define DEBUG_IO 0\n\nstatic int\nqemuMonitorIORead(qemuMonitorPtr mon)\n{\n    size_t avail = mon->bufferLength - mon->bufferOffset;\n    int ret = 0;\n\n    if (avail < 1024) {\n        if (mon->bufferLength >= QEMU_MONITOR_MAX_RESPONSE) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"QEMU monitor reply exceeds buffer size (%d bytes)\"),\n                           QEMU_MONITOR_MAX_RESPONSE);\n            return -1;\n        }\n        if (VIR_REALLOC_N(mon->buffer,\n                          mon->bufferLength + 1024) < 0)\n            return -1;\n        mon->bufferLength += 1024;\n        avail += 1024;\n    }\n\n    /* Read as much as we can get into our buffer,\n       until we block on EAGAIN, or hit EOF */\n    while (avail > 1) {\n        int got;\n        got = read(mon->fd,\n                   mon->buffer + mon->bufferOffset,\n                   avail - 1);\n        if (got < 0) {\n            if (errno == EAGAIN)\n                break;\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to read from monitor\"));\n            ret = -1;\n            break;\n        }\n        if (got == 0)\n            break;\n\n        ret += got;\n        avail -= got;\n        mon->bufferOffset += got;\n        mon->buffer[mon->bufferOffset] = '\\0';\n    }\n\n#if DEBUG_IO\n    VIR_DEBUG(\"Now read %d bytes of data\", (int)mon->bufferOffset);\n#endif\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorIOWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "410-448",
    "snippet": "static int\nqemuMonitorIOWrite(qemuMonitorPtr mon)\n{\n    int done;\n    char *buf;\n    size_t len;\n\n    /* If no active message, or fully transmitted, the no-op */\n    if (!mon->msg || mon->msg->txOffset == mon->msg->txLength)\n        return 0;\n\n    buf = mon->msg->txBuffer + mon->msg->txOffset;\n    len = mon->msg->txLength - mon->msg->txOffset;\n    if (mon->msg->txFD == -1)\n        done = write(mon->fd, buf, len);\n    else\n        done = qemuMonitorIOWriteWithFD(mon, buf, len, mon->msg->txFD);\n\n    PROBE(QEMU_MONITOR_IO_WRITE,\n          \"mon=%p buf=%s len=%zu ret=%d errno=%d\",\n          mon, buf, len, done, done < 0 ? errno : 0);\n\n    if (mon->msg->txFD != -1) {\n        PROBE(QEMU_MONITOR_IO_SEND_FD,\n              \"mon=%p fd=%d ret=%d errno=%d\",\n              mon, mon->msg->txFD, done, done < 0 ? errno : 0);\n    }\n\n    if (done < 0) {\n        if (errno == EAGAIN)\n            return 0;\n\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to write to monitor\"));\n        return -1;\n    }\n    mon->msg->txOffset += done;\n    return done;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to write to monitor\")"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to write to monitor\""
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "QEMU_MONITOR_IO_SEND_FD",
            "\"mon=%p fd=%d ret=%d errno=%d\"",
            "mon",
            "mon->msg->txFD",
            "done",
            "done < 0 ? errno : 0"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "QEMU_MONITOR_IO_WRITE",
            "\"mon=%p buf=%s len=%zu ret=%d errno=%d\"",
            "mon",
            "buf",
            "len",
            "done",
            "done < 0 ? errno : 0"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorIOWriteWithFD",
          "args": [
            "mon",
            "buf",
            "len",
            "mon->msg->txFD"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorIOWriteWithFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "365-403",
          "snippet": "static int\nqemuMonitorIOWriteWithFD(qemuMonitorPtr mon,\n                         const char *data,\n                         size_t len,\n                         int fd)\n{\n    struct msghdr msg;\n    struct iovec iov[1];\n    int ret;\n    char control[CMSG_SPACE(sizeof(int))];\n    struct cmsghdr *cmsg;\n\n    memset(&msg, 0, sizeof(msg));\n    memset(control, 0, sizeof(control));\n\n    iov[0].iov_base = (void *)data;\n    iov[0].iov_len = len;\n\n    msg.msg_iov = iov;\n    msg.msg_iovlen = 1;\n\n    msg.msg_control = control;\n    msg.msg_controllen = sizeof(control);\n\n    cmsg = CMSG_FIRSTHDR(&msg);\n    /* Some static analyzers, like clang 2.6-0.6.pre2, fail to see\n       that our use of CMSG_FIRSTHDR will not return NULL.  */\n    sa_assert(cmsg);\n    cmsg->cmsg_len = CMSG_LEN(sizeof(int));\n    cmsg->cmsg_level = SOL_SOCKET;\n    cmsg->cmsg_type = SCM_RIGHTS;\n    memcpy(CMSG_DATA(cmsg), &fd, sizeof(int));\n\n    do {\n        ret = sendmsg(mon->fd, &msg, 0);\n    } while (ret < 0 && errno == EINTR);\n\n    return ret;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic int\nqemuMonitorIOWriteWithFD(qemuMonitorPtr mon,\n                         const char *data,\n                         size_t len,\n                         int fd)\n{\n    struct msghdr msg;\n    struct iovec iov[1];\n    int ret;\n    char control[CMSG_SPACE(sizeof(int))];\n    struct cmsghdr *cmsg;\n\n    memset(&msg, 0, sizeof(msg));\n    memset(control, 0, sizeof(control));\n\n    iov[0].iov_base = (void *)data;\n    iov[0].iov_len = len;\n\n    msg.msg_iov = iov;\n    msg.msg_iovlen = 1;\n\n    msg.msg_control = control;\n    msg.msg_controllen = sizeof(control);\n\n    cmsg = CMSG_FIRSTHDR(&msg);\n    /* Some static analyzers, like clang 2.6-0.6.pre2, fail to see\n       that our use of CMSG_FIRSTHDR will not return NULL.  */\n    sa_assert(cmsg);\n    cmsg->cmsg_len = CMSG_LEN(sizeof(int));\n    cmsg->cmsg_level = SOL_SOCKET;\n    cmsg->cmsg_type = SCM_RIGHTS;\n    memcpy(CMSG_DATA(cmsg), &fd, sizeof(int));\n\n    do {\n        ret = sendmsg(mon->fd, &msg, 0);\n    } while (ret < 0 && errno == EINTR);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "mon->fd",
            "buf",
            "len"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobRewriteConfigDiskSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "662-701",
          "snippet": "static void\nqemuBlockJobRewriteConfigDiskSource(virDomainObjPtr vm,\n                                    virDomainDiskDefPtr disk,\n                                    virStorageSourcePtr newsrc)\n{\n    virDomainDiskDefPtr persistDisk = NULL;\n    g_autoptr(virStorageSource) copy = NULL;\n    virStorageSourcePtr n;\n\n    if (!vm->newDef)\n        return;\n\n    if (!(persistDisk = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return;\n\n    if (!virStorageSourceIsSameLocation(disk->src, persistDisk->src))\n        return;\n\n    if (!(copy = virStorageSourceCopy(newsrc, true)) ||\n        virStorageSourceInitChainElement(copy, persistDisk->src, true) < 0) {\n        VIR_WARN(\"Unable to update persistent definition on vm %s after block job\",\n                 vm->def->name);\n        return;\n    }\n\n    for (n = copy; virStorageSourceIsBacking(n); n = n->backingStore) {\n        qemuBlockJobCleanStorageSourceRuntime(n);\n\n        /* discard any detected backing store */\n        if (virStorageSourceIsBacking(n->backingStore) &&\n            n->backingStore->detected) {\n            virObjectUnref(n->backingStore);\n            n->backingStore = NULL;\n            break;\n        }\n    }\n\n    virObjectUnref(persistDisk->src);\n    persistDisk->src = g_steal_pointer(&copy);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobRewriteConfigDiskSource(virDomainObjPtr vm,\n                                    virDomainDiskDefPtr disk,\n                                    virStorageSourcePtr newsrc)\n{\n    virDomainDiskDefPtr persistDisk = NULL;\n    g_autoptr(virStorageSource) copy = NULL;\n    virStorageSourcePtr n;\n\n    if (!vm->newDef)\n        return;\n\n    if (!(persistDisk = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return;\n\n    if (!virStorageSourceIsSameLocation(disk->src, persistDisk->src))\n        return;\n\n    if (!(copy = virStorageSourceCopy(newsrc, true)) ||\n        virStorageSourceInitChainElement(copy, persistDisk->src, true) < 0) {\n        VIR_WARN(\"Unable to update persistent definition on vm %s after block job\",\n                 vm->def->name);\n        return;\n    }\n\n    for (n = copy; virStorageSourceIsBacking(n); n = n->backingStore) {\n        qemuBlockJobCleanStorageSourceRuntime(n);\n\n        /* discard any detected backing store */\n        if (virStorageSourceIsBacking(n->backingStore) &&\n            n->backingStore->detected) {\n            virObjectUnref(n->backingStore);\n            n->backingStore = NULL;\n            break;\n        }\n    }\n\n    virObjectUnref(persistDisk->src);\n    persistDisk->src = g_steal_pointer(&copy);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic int\nqemuMonitorIOWrite(qemuMonitorPtr mon)\n{\n    int done;\n    char *buf;\n    size_t len;\n\n    /* If no active message, or fully transmitted, the no-op */\n    if (!mon->msg || mon->msg->txOffset == mon->msg->txLength)\n        return 0;\n\n    buf = mon->msg->txBuffer + mon->msg->txOffset;\n    len = mon->msg->txLength - mon->msg->txOffset;\n    if (mon->msg->txFD == -1)\n        done = write(mon->fd, buf, len);\n    else\n        done = qemuMonitorIOWriteWithFD(mon, buf, len, mon->msg->txFD);\n\n    PROBE(QEMU_MONITOR_IO_WRITE,\n          \"mon=%p buf=%s len=%zu ret=%d errno=%d\",\n          mon, buf, len, done, done < 0 ? errno : 0);\n\n    if (mon->msg->txFD != -1) {\n        PROBE(QEMU_MONITOR_IO_SEND_FD,\n              \"mon=%p fd=%d ret=%d errno=%d\",\n              mon, mon->msg->txFD, done, done < 0 ? errno : 0);\n    }\n\n    if (done < 0) {\n        if (errno == EAGAIN)\n            return 0;\n\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to write to monitor\"));\n        return -1;\n    }\n    mon->msg->txOffset += done;\n    return done;\n}"
  },
  {
    "function_name": "qemuMonitorIOWriteWithFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "365-403",
    "snippet": "static int\nqemuMonitorIOWriteWithFD(qemuMonitorPtr mon,\n                         const char *data,\n                         size_t len,\n                         int fd)\n{\n    struct msghdr msg;\n    struct iovec iov[1];\n    int ret;\n    char control[CMSG_SPACE(sizeof(int))];\n    struct cmsghdr *cmsg;\n\n    memset(&msg, 0, sizeof(msg));\n    memset(control, 0, sizeof(control));\n\n    iov[0].iov_base = (void *)data;\n    iov[0].iov_len = len;\n\n    msg.msg_iov = iov;\n    msg.msg_iovlen = 1;\n\n    msg.msg_control = control;\n    msg.msg_controllen = sizeof(control);\n\n    cmsg = CMSG_FIRSTHDR(&msg);\n    /* Some static analyzers, like clang 2.6-0.6.pre2, fail to see\n       that our use of CMSG_FIRSTHDR will not return NULL.  */\n    sa_assert(cmsg);\n    cmsg->cmsg_len = CMSG_LEN(sizeof(int));\n    cmsg->cmsg_level = SOL_SOCKET;\n    cmsg->cmsg_type = SCM_RIGHTS;\n    memcpy(CMSG_DATA(cmsg), &fd, sizeof(int));\n\n    do {\n        ret = sendmsg(mon->fd, &msg, 0);\n    } while (ret < 0 && errno == EINTR);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendmsg",
          "args": [
            "mon->fd",
            "&msg",
            "0"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "CMSG_DATA(cmsg)",
            "&fd",
            "sizeof(int)"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_DATA",
          "args": [
            "cmsg"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_LEN",
          "args": [
            "sizeof(int)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sa_assert",
          "args": [
            "cmsg"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_FIRSTHDR",
          "args": [
            "&msg"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "control",
            "0",
            "sizeof(control)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&msg",
            "0",
            "sizeof(msg)"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_SPACE",
          "args": [
            "sizeof(int)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic int\nqemuMonitorIOWriteWithFD(qemuMonitorPtr mon,\n                         const char *data,\n                         size_t len,\n                         int fd)\n{\n    struct msghdr msg;\n    struct iovec iov[1];\n    int ret;\n    char control[CMSG_SPACE(sizeof(int))];\n    struct cmsghdr *cmsg;\n\n    memset(&msg, 0, sizeof(msg));\n    memset(control, 0, sizeof(control));\n\n    iov[0].iov_base = (void *)data;\n    iov[0].iov_len = len;\n\n    msg.msg_iov = iov;\n    msg.msg_iovlen = 1;\n\n    msg.msg_control = control;\n    msg.msg_controllen = sizeof(control);\n\n    cmsg = CMSG_FIRSTHDR(&msg);\n    /* Some static analyzers, like clang 2.6-0.6.pre2, fail to see\n       that our use of CMSG_FIRSTHDR will not return NULL.  */\n    sa_assert(cmsg);\n    cmsg->cmsg_len = CMSG_LEN(sizeof(int));\n    cmsg->cmsg_level = SOL_SOCKET;\n    cmsg->cmsg_type = SCM_RIGHTS;\n    memcpy(CMSG_DATA(cmsg), &fd, sizeof(int));\n\n    do {\n        ret = sendmsg(mon->fd, &msg, 0);\n    } while (ret < 0 && errno == EINTR);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMonitorIOProcess",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "309-361",
    "snippet": "static int\nqemuMonitorIOProcess(qemuMonitorPtr mon)\n{\n    int len;\n    qemuMonitorMessagePtr msg = NULL;\n\n    /* See if there's a message & whether its ready for its reply\n     * ie whether its completed writing all its data */\n    if (mon->msg && mon->msg->txOffset == mon->msg->txLength)\n        msg = mon->msg;\n\n#if DEBUG_IO\n# if DEBUG_RAW_IO\n    char *str1 = qemuMonitorEscapeNonPrintable(msg ? msg->txBuffer : \"\");\n    char *str2 = qemuMonitorEscapeNonPrintable(mon->buffer);\n    VIR_ERROR(_(\"Process %d %p %p [[[[%s]]][[[%s]]]\"), (int)mon->bufferOffset, mon->msg, msg, str1, str2);\n    VIR_FREE(str1);\n    VIR_FREE(str2);\n# else\n    VIR_DEBUG(\"Process %d\", (int)mon->bufferOffset);\n# endif\n#endif\n\n    PROBE_QUIET(QEMU_MONITOR_IO_PROCESS, \"mon=%p buf=%s len=%zu\",\n                mon, mon->buffer, mon->bufferOffset);\n\n    len = qemuMonitorJSONIOProcess(mon,\n                                   mon->buffer, mon->bufferOffset,\n                                   msg);\n    if (len < 0)\n        return -1;\n\n    if (len && mon->waitGreeting)\n        mon->waitGreeting = false;\n\n    if (len < mon->bufferOffset) {\n        memmove(mon->buffer, mon->buffer + len, mon->bufferOffset - len);\n        mon->bufferOffset -= len;\n    } else {\n        VIR_FREE(mon->buffer);\n        mon->bufferOffset = mon->bufferLength = 0;\n    }\n#if DEBUG_IO\n    VIR_DEBUG(\"Process done %d used %d\", (int)mon->bufferOffset, len);\n#endif\n\n    /* As the monitor mutex was unlocked in qemuMonitorJSONIOProcess()\n     * while dealing with qemu event, mon->msg could be changed which\n     * means the above 'msg' may be invalid, thus we use 'mon->msg' here */\n    if (mon->msg && mon->msg->finished)\n        virCondBroadcast(&mon->notify);\n    return len;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define DEBUG_RAW_IO 0",
      "#define DEBUG_IO 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCondBroadcast",
          "args": [
            "&mon->notify"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "virCondBroadcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "175-178",
          "snippet": "void virCondBroadcast(virCondPtr c)\n{\n    pthread_cond_broadcast(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondBroadcast(virCondPtr c)\n{\n    pthread_cond_broadcast(&c->cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Process done %d used %d\"",
            "(int)mon->bufferOffset",
            "len"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mon->buffer"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "mon->buffer",
            "mon->buffer + len",
            "mon->bufferOffset - len"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorJSONIOProcess",
          "args": [
            "mon",
            "mon->buffer",
            "mon->bufferOffset",
            "msg"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJSONIOProcess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor_json.c",
          "lines": "260-293",
          "snippet": "int qemuMonitorJSONIOProcess(qemuMonitorPtr mon,\n                             const char *data,\n                             size_t len,\n                             qemuMonitorMessagePtr msg)\n{\n    int used = 0;\n    /*VIR_DEBUG(\"Data %d bytes [%s]\", len, data);*/\n\n    while (used < len) {\n        char *nl = strstr(data + used, LINE_ENDING);\n\n        if (nl) {\n            int got = nl - (data + used);\n            char *line;\n            line = g_strndup(data + used, got);\n            used += got + strlen(LINE_ENDING);\n            line[got] = '\\0'; /* kill \\n */\n            if (qemuMonitorJSONIOProcessLine(mon, line, msg) < 0) {\n                VIR_FREE(line);\n                return -1;\n            }\n\n            VIR_FREE(line);\n        } else {\n            break;\n        }\n    }\n\n#if DEBUG_IO\n    VIR_DEBUG(\"Total used %d bytes out of %zd available in buffer\", used, len);\n#endif\n\n    return used;\n}",
          "includes": [
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virsocket.h\"",
            "#include \"virenum.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LINE_ENDING \"\\r\\n\""
          ],
          "globals_used": [
            "static void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);",
            "static void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"libvirt_qemu_probes.h\"\n#include \"virsocket.h\"\n#include \"virenum.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_monitor_json.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\n#define LINE_ENDING \"\\r\\n\"\n\nstatic void qemuMonitorJSONHandleShutdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleReset(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePowerdown(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleStop(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleResume(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRTCChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleWatchdog(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleIOError(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleVNCDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEConnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEInitialize(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSPICEDisconnect(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleTrayChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMWakeup(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspend(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobCanceled(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockJobReady(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleJobStatusChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBalloonChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePMSuspendDisk(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestCrashloaded(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleGuestPanic(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDeviceDeleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleNicRxFilterChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSerialChange(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleSpiceMigrated(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationStatus(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleMigrationPass(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleAcpiOstInfo(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleBlockThreshold(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleDumpCompleted(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandlePRManagerStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\nstatic void qemuMonitorJSONHandleRdmaGidStatusChanged(qemuMonitorPtr mon, virJSONValuePtr data);\n\nint qemuMonitorJSONIOProcess(qemuMonitorPtr mon,\n                             const char *data,\n                             size_t len,\n                             qemuMonitorMessagePtr msg)\n{\n    int used = 0;\n    /*VIR_DEBUG(\"Data %d bytes [%s]\", len, data);*/\n\n    while (used < len) {\n        char *nl = strstr(data + used, LINE_ENDING);\n\n        if (nl) {\n            int got = nl - (data + used);\n            char *line;\n            line = g_strndup(data + used, got);\n            used += got + strlen(LINE_ENDING);\n            line[got] = '\\0'; /* kill \\n */\n            if (qemuMonitorJSONIOProcessLine(mon, line, msg) < 0) {\n                VIR_FREE(line);\n                return -1;\n            }\n\n            VIR_FREE(line);\n        } else {\n            break;\n        }\n    }\n\n#if DEBUG_IO\n    VIR_DEBUG(\"Total used %d bytes out of %zd available in buffer\", used, len);\n#endif\n\n    return used;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE_QUIET",
          "args": [
            "QEMU_MONITOR_IO_PROCESS",
            "\"mon=%p buf=%s len=%zu\"",
            "mon",
            "mon->buffer",
            "mon->bufferOffset"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Process %d\"",
            "(int)mon->bufferOffset"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str2"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str1"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Process %d %p %p [[[[%s]]][[[%s]]]\")",
            "(int)mon->bufferOffset",
            "mon->msg",
            "msg",
            "str1",
            "str2"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Process %d %p %p [[[[%s]]][[[%s]]]\""
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorEscapeNonPrintable",
          "args": [
            "mon->buffer"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorEscapeNonPrintable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "200-214",
          "snippet": "static char *\nqemuMonitorEscapeNonPrintable(const char *text)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    for (i = 0; text[i] != '\\0'; i++) {\n        if (g_ascii_isprint(text[i]) ||\n            text[i] == '\\n' ||\n            (text[i] == '\\r' && text[i + 1] == '\\n'))\n            virBufferAddChar(&buf, text[i]);\n        else\n            virBufferAsprintf(&buf, \"0x%02x\", text[i]);\n    }\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic char *\nqemuMonitorEscapeNonPrintable(const char *text)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    for (i = 0; text[i] != '\\0'; i++) {\n        if (g_ascii_isprint(text[i]) ||\n            text[i] == '\\n' ||\n            (text[i] == '\\r' && text[i + 1] == '\\n'))\n            virBufferAddChar(&buf, text[i]);\n        else\n            virBufferAsprintf(&buf, \"0x%02x\", text[i]);\n    }\n    return virBufferContentAndReset(&buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\n#define DEBUG_RAW_IO 0\n#define DEBUG_IO 0\n\nstatic int\nqemuMonitorIOProcess(qemuMonitorPtr mon)\n{\n    int len;\n    qemuMonitorMessagePtr msg = NULL;\n\n    /* See if there's a message & whether its ready for its reply\n     * ie whether its completed writing all its data */\n    if (mon->msg && mon->msg->txOffset == mon->msg->txLength)\n        msg = mon->msg;\n\n#if DEBUG_IO\n# if DEBUG_RAW_IO\n    char *str1 = qemuMonitorEscapeNonPrintable(msg ? msg->txBuffer : \"\");\n    char *str2 = qemuMonitorEscapeNonPrintable(mon->buffer);\n    VIR_ERROR(_(\"Process %d %p %p [[[[%s]]][[[%s]]]\"), (int)mon->bufferOffset, mon->msg, msg, str1, str2);\n    VIR_FREE(str1);\n    VIR_FREE(str2);\n# else\n    VIR_DEBUG(\"Process %d\", (int)mon->bufferOffset);\n# endif\n#endif\n\n    PROBE_QUIET(QEMU_MONITOR_IO_PROCESS, \"mon=%p buf=%s len=%zu\",\n                mon, mon->buffer, mon->bufferOffset);\n\n    len = qemuMonitorJSONIOProcess(mon,\n                                   mon->buffer, mon->bufferOffset,\n                                   msg);\n    if (len < 0)\n        return -1;\n\n    if (len && mon->waitGreeting)\n        mon->waitGreeting = false;\n\n    if (len < mon->bufferOffset) {\n        memmove(mon->buffer, mon->buffer + len, mon->bufferOffset - len);\n        mon->bufferOffset -= len;\n    } else {\n        VIR_FREE(mon->buffer);\n        mon->bufferOffset = mon->bufferLength = 0;\n    }\n#if DEBUG_IO\n    VIR_DEBUG(\"Process done %d used %d\", (int)mon->bufferOffset, len);\n#endif\n\n    /* As the monitor mutex was unlocked in qemuMonitorJSONIOProcess()\n     * while dealing with qemu event, mon->msg could be changed which\n     * means the above 'msg' may be invalid, thus we use 'mon->msg' here */\n    if (mon->msg && mon->msg->finished)\n        virCondBroadcast(&mon->notify);\n    return len;\n}"
  },
  {
    "function_name": "qemuMonitorOpenUnix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "237-302",
    "snippet": "static int\nqemuMonitorOpenUnix(const char *monitor,\n                    pid_t cpid,\n                    bool retry,\n                    unsigned long long timeout)\n{\n    struct sockaddr_un addr;\n    int monfd;\n    virTimeBackOffVar timebackoff;\n    int ret = -1;\n\n    if ((monfd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"failed to create socket\"));\n        return -1;\n    }\n\n    memset(&addr, 0, sizeof(addr));\n    addr.sun_family = AF_UNIX;\n    if (virStrcpyStatic(addr.sun_path, monitor) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Monitor path %s too big for destination\"), monitor);\n        goto error;\n    }\n\n    if (retry) {\n        if (virTimeBackOffStart(&timebackoff, 1, timeout * 1000) < 0)\n            goto error;\n        while (virTimeBackOffWait(&timebackoff)) {\n            ret = connect(monfd, (struct sockaddr *)&addr, sizeof(addr));\n\n            if (ret == 0)\n                break;\n\n            if ((errno == ENOENT || errno == ECONNREFUSED) &&\n                (!cpid || virProcessKill(cpid, 0) == 0)) {\n                /* ENOENT       : Socket may not have shown up yet\n                 * ECONNREFUSED : Leftover socket hasn't been removed yet */\n                continue;\n            }\n\n            virReportSystemError(errno, \"%s\",\n                                 _(\"failed to connect to monitor socket\"));\n            goto error;\n        }\n\n        if (ret != 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"monitor socket did not show up\"));\n            goto error;\n        }\n    } else {\n        ret = connect(monfd, (struct sockaddr *) &addr, sizeof(addr));\n        if (ret < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"failed to connect to monitor socket\"));\n            goto error;\n        }\n    }\n\n    return monfd;\n\n error:\n    VIR_FORCE_CLOSE(monfd);\n    return -1;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "monfd"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"failed to connect to monitor socket\")"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to connect to monitor socket\""
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "monfd",
            "(struct sockaddr *) &addr",
            "sizeof(addr)"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "vir_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "216-232",
          "snippet": "int\nvir_connect(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (connect(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_connect(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (connect(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"monitor socket did not show up\")"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"failed to connect to monitor socket\")"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virProcessKill",
          "args": [
            "cpid",
            "0"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessKillPainfully",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "437-440",
          "snippet": "int virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTimeBackOffWait",
          "args": [
            "&timebackoff"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "virTimeBackOffWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtime.c",
          "lines": "379-410",
          "snippet": "bool\nvirTimeBackOffWait(virTimeBackOffVar *var)\n{\n    unsigned long long next, t = 0;\n\n    ignore_value(virTimeMillisNowRaw(&t));\n\n    VIR_DEBUG(\"t=%llu, limit=%llu\", t, var->limit_t);\n\n    if (t > var->limit_t)\n        return 0;               /* ends the while loop */\n\n    /* Compute next wait time. Cap at VIR_TIME_BACKOFF_CAP\n     * to avoid long useless sleeps. */\n    next = var->next;\n    if (var->next < VIR_TIME_BACKOFF_CAP)\n        var->next *= 2;\n    else if (var->next > VIR_TIME_BACKOFF_CAP)\n        var->next = VIR_TIME_BACKOFF_CAP;\n\n    /* If sleeping would take us beyond the limit, then shorten the\n     * sleep.  This is so we always run the body just before the final\n     * timeout.\n     */\n    if (t + next > var->limit_t)\n        next = var->limit_t - t;\n\n    VIR_DEBUG(\"sleeping for %llu ms\", next);\n\n    g_usleep(next * 1000);\n    return 1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtime.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_TIME_BACKOFF_CAP 1000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtime.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <config.h>\n\n#define VIR_TIME_BACKOFF_CAP 1000\n\nbool\nvirTimeBackOffWait(virTimeBackOffVar *var)\n{\n    unsigned long long next, t = 0;\n\n    ignore_value(virTimeMillisNowRaw(&t));\n\n    VIR_DEBUG(\"t=%llu, limit=%llu\", t, var->limit_t);\n\n    if (t > var->limit_t)\n        return 0;               /* ends the while loop */\n\n    /* Compute next wait time. Cap at VIR_TIME_BACKOFF_CAP\n     * to avoid long useless sleeps. */\n    next = var->next;\n    if (var->next < VIR_TIME_BACKOFF_CAP)\n        var->next *= 2;\n    else if (var->next > VIR_TIME_BACKOFF_CAP)\n        var->next = VIR_TIME_BACKOFF_CAP;\n\n    /* If sleeping would take us beyond the limit, then shorten the\n     * sleep.  This is so we always run the body just before the final\n     * timeout.\n     */\n    if (t + next > var->limit_t)\n        next = var->limit_t - t;\n\n    VIR_DEBUG(\"sleeping for %llu ms\", next);\n\n    g_usleep(next * 1000);\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTimeBackOffStart",
          "args": [
            "&timebackoff",
            "1",
            "timeout * 1000"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "virTimeBackOffStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtime.c",
          "lines": "335-345",
          "snippet": "int\nvirTimeBackOffStart(virTimeBackOffVar *var,\n                    unsigned long long first, unsigned long long timeout)\n{\n    if (virTimeMillisNow(&var->start_t) < 0)\n        return -1;\n\n    var->next = first;\n    var->limit_t = var->start_t + timeout;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtime.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtime.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirTimeBackOffStart(virTimeBackOffVar *var,\n                    unsigned long long first, unsigned long long timeout)\n{\n    if (virTimeMillisNow(&var->start_t) < 0)\n        return -1;\n\n    var->next = first;\n    var->limit_t = var->start_t + timeout;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Monitor path %s too big for destination\")",
            "monitor"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "addr.sun_path",
            "monitor"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&addr",
            "0",
            "sizeof(addr)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"failed to create socket\")"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "vir_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "351-367",
          "snippet": "int\nvir_socket(int domain, int type, int protocol)\n{\n    SOCKET sk;\n\n    /* We have to use WSASocket() instead of socket(), to create\n     * non-overlapped IO sockets. Overlapped IO sockets cannot\n     * be used with read/write.\n     */\n    sk = WSASocket(domain, type, protocol, NULL, 0, 0);\n    if (sk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(sk);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_socket(int domain, int type, int protocol)\n{\n    SOCKET sk;\n\n    /* We have to use WSASocket() instead of socket(), to create\n     * non-overlapped IO sockets. Overlapped IO sockets cannot\n     * be used with read/write.\n     */\n    sk = WSASocket(domain, type, protocol, NULL, 0, 0);\n    if (sk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(sk);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic int\nqemuMonitorOpenUnix(const char *monitor,\n                    pid_t cpid,\n                    bool retry,\n                    unsigned long long timeout)\n{\n    struct sockaddr_un addr;\n    int monfd;\n    virTimeBackOffVar timebackoff;\n    int ret = -1;\n\n    if ((monfd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"failed to create socket\"));\n        return -1;\n    }\n\n    memset(&addr, 0, sizeof(addr));\n    addr.sun_family = AF_UNIX;\n    if (virStrcpyStatic(addr.sun_path, monitor) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Monitor path %s too big for destination\"), monitor);\n        goto error;\n    }\n\n    if (retry) {\n        if (virTimeBackOffStart(&timebackoff, 1, timeout * 1000) < 0)\n            goto error;\n        while (virTimeBackOffWait(&timebackoff)) {\n            ret = connect(monfd, (struct sockaddr *)&addr, sizeof(addr));\n\n            if (ret == 0)\n                break;\n\n            if ((errno == ENOENT || errno == ECONNREFUSED) &&\n                (!cpid || virProcessKill(cpid, 0) == 0)) {\n                /* ENOENT       : Socket may not have shown up yet\n                 * ECONNREFUSED : Leftover socket hasn't been removed yet */\n                continue;\n            }\n\n            virReportSystemError(errno, \"%s\",\n                                 _(\"failed to connect to monitor socket\"));\n            goto error;\n        }\n\n        if (ret != 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"monitor socket did not show up\"));\n            goto error;\n        }\n    } else {\n        ret = connect(monfd, (struct sockaddr *) &addr, sizeof(addr));\n        if (ret < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"failed to connect to monitor socket\"));\n            goto error;\n        }\n    }\n\n    return monfd;\n\n error:\n    VIR_FORCE_CLOSE(monfd);\n    return -1;\n}"
  },
  {
    "function_name": "qemuMonitorDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "218-234",
    "snippet": "static void\nqemuMonitorDispose(void *obj)\n{\n    qemuMonitorPtr mon = obj;\n\n    VIR_DEBUG(\"mon=%p\", mon);\n    if (mon->cb && mon->cb->destroy)\n        (mon->cb->destroy)(mon, mon->vm, mon->callbackOpaque);\n    virObjectUnref(mon->vm);\n\n    g_main_context_unref(mon->context);\n    virResetError(&mon->lastError);\n    virCondDestroy(&mon->notify);\n    VIR_FREE(mon->buffer);\n    virJSONValueFree(mon->options);\n    VIR_FREE(mon->balloonpath);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qemuMonitorDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mon->balloonpath"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueFree",
          "args": [
            "mon->options"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "391-423",
          "snippet": "void\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvoid\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mon->buffer"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCondDestroy",
          "args": [
            "&mon->notify"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "virCondDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "135-143",
          "snippet": "int virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetError",
          "args": [
            "&mon->lastError"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "virResetError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "466-476",
          "snippet": "void\nvirResetError(virErrorPtr err)\n{\n    if (err == NULL)\n        return;\n    VIR_FREE(err->message);\n    VIR_FREE(err->str1);\n    VIR_FREE(err->str2);\n    VIR_FREE(err->str3);\n    memset(err, 0, sizeof(virError));\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetError(virErrorPtr err)\n{\n    if (err == NULL)\n        return;\n    VIR_FREE(err->message);\n    VIR_FREE(err->str1);\n    VIR_FREE(err->str2);\n    VIR_FREE(err->str3);\n    memset(err, 0, sizeof(virError));\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_main_context_unref",
          "args": [
            "mon->context"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "mon->vm"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "mon",
            "mon->vm",
            "mon->callbackOpaque"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"mon=%p\"",
            "mon"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic void qemuMonitorDispose(void *obj);\n\nstatic void\nqemuMonitorDispose(void *obj)\n{\n    qemuMonitorPtr mon = obj;\n\n    VIR_DEBUG(\"mon=%p\", mon);\n    if (mon->cb && mon->cb->destroy)\n        (mon->cb->destroy)(mon, mon->vm, mon->callbackOpaque);\n    virObjectUnref(mon->vm);\n\n    g_main_context_unref(mon->context);\n    virResetError(&mon->lastError);\n    virCondDestroy(&mon->notify);\n    VIR_FREE(mon->buffer);\n    virJSONValueFree(mon->options);\n    VIR_FREE(mon->balloonpath);\n}"
  },
  {
    "function_name": "qemuMonitorEscapeNonPrintable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "200-214",
    "snippet": "static char *\nqemuMonitorEscapeNonPrintable(const char *text)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    for (i = 0; text[i] != '\\0'; i++) {\n        if (g_ascii_isprint(text[i]) ||\n            text[i] == '\\n' ||\n            (text[i] == '\\r' && text[i + 1] == '\\n'))\n            virBufferAddChar(&buf, text[i]);\n        else\n            virBufferAsprintf(&buf, \"0x%02x\", text[i]);\n    }\n    return virBufferContentAndReset(&buf);\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"0x%02x\"",
            "text[i]"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddChar",
          "args": [
            "&buf",
            "text[i]"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "206-210",
          "snippet": "void\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_ascii_isprint",
          "args": [
            "text[i]"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic char *\nqemuMonitorEscapeNonPrintable(const char *text)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    for (i = 0; text[i] != '\\0'; i++) {\n        if (g_ascii_isprint(text[i]) ||\n            text[i] == '\\n' ||\n            (text[i] == '\\r' && text[i + 1] == '\\n'))\n            virBufferAddChar(&buf, text[i]);\n        else\n            virBufferAsprintf(&buf, \"0x%02x\", text[i]);\n    }\n    return virBufferContentAndReset(&buf);\n}"
  },
  {
    "function_name": "qemuMonitorOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
    "lines": "150-156",
    "snippet": "static int qemuMonitorOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(qemuMonitor, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"qemu_monitor_priv.h\"",
      "# include \"libvirt_qemu_probes.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virprobe.h\"",
      "#include \"virobject.h\"",
      "#include \"virprocess.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor_json.h\"",
      "#include \"qemu_monitor_text.h\"",
      "#include \"qemu_monitor.h\"",
      "#include <gio/gio.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "qemuMonitor",
            "virClassForObjectLockable()"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObjectLockable",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "116-123",
          "snippet": "virClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectLockableClass;\n\nvirClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nstatic int qemuMonitorOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(qemuMonitor, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}"
  }
]