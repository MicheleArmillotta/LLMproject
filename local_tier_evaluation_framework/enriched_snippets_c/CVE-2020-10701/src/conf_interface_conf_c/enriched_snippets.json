[
  {
    "function_name": "virInterfaceDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "1130-1140",
    "snippet": "char *\nvirInterfaceDefFormat(const virInterfaceDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virInterfaceDefDevFormat(&buf, def, VIR_INTERFACE_TYPE_LAST) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n    return virBufferContentAndReset(&buf);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefDevFormat",
          "args": [
            "&buf",
            "def",
            "VIR_INTERFACE_TYPE_LAST"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefDevFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "1062-1127",
          "snippet": "static int\nvirInterfaceDefDevFormat(virBufferPtr buf,\n                         const virInterfaceDef *def,\n                         virInterfaceType parentIfType)\n{\n    const char *type = NULL;\n\n    if (def == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virInterfaceDefFormat NULL def\"));\n        return -1;\n    }\n\n    if ((def->name == NULL) && (def->type != VIR_INTERFACE_TYPE_VLAN)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virInterfaceDefFormat missing interface name\"));\n        return -1;\n    }\n\n    if (!(type = virInterfaceTypeToString(def->type))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected interface type %d\"), def->type);\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<interface type='%s' \", type);\n    if (def->name != NULL)\n        virBufferEscapeString(buf, \"name='%s'\", def->name);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (parentIfType == VIR_INTERFACE_TYPE_LAST) {\n        /* these elements are only valid on top-level interfaces - IP\n         * address info (\"protocol\") only makes sense for the\n         * top-level, and subordinate interfaces inherit the toplevel\n         * setting for mtu and start mode, which cannot be overridden.\n         */\n        virInterfaceStartmodeDefFormat(buf, def->startmode);\n        if (def->mtu)\n            virBufferAsprintf(buf, \"<mtu size='%d'/>\\n\", def->mtu);\n        virInterfaceProtocolDefFormat(buf, def);\n    }\n\n    if (def->type != VIR_INTERFACE_TYPE_BRIDGE)\n        virInterfaceLinkFormat(buf, &def->lnk);\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_ETHERNET:\n            if (def->mac)\n                virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", def->mac);\n            break;\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            virInterfaceBridgeDefFormat(buf, def);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            virInterfaceBondDefFormat(buf, def);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            virInterfaceVlanDefFormat(buf, def);\n            break;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</interface>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt, int parentIfType);",
            "static int\nvirInterfaceDefDevFormat(virBufferPtr buf, const virInterfaceDef *def,\n                         virInterfaceType parentIfType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt, int parentIfType);\nstatic int\nvirInterfaceDefDevFormat(virBufferPtr buf, const virInterfaceDef *def,\n                         virInterfaceType parentIfType);\n\nstatic int\nvirInterfaceDefDevFormat(virBufferPtr buf,\n                         const virInterfaceDef *def,\n                         virInterfaceType parentIfType)\n{\n    const char *type = NULL;\n\n    if (def == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virInterfaceDefFormat NULL def\"));\n        return -1;\n    }\n\n    if ((def->name == NULL) && (def->type != VIR_INTERFACE_TYPE_VLAN)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virInterfaceDefFormat missing interface name\"));\n        return -1;\n    }\n\n    if (!(type = virInterfaceTypeToString(def->type))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected interface type %d\"), def->type);\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<interface type='%s' \", type);\n    if (def->name != NULL)\n        virBufferEscapeString(buf, \"name='%s'\", def->name);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (parentIfType == VIR_INTERFACE_TYPE_LAST) {\n        /* these elements are only valid on top-level interfaces - IP\n         * address info (\"protocol\") only makes sense for the\n         * top-level, and subordinate interfaces inherit the toplevel\n         * setting for mtu and start mode, which cannot be overridden.\n         */\n        virInterfaceStartmodeDefFormat(buf, def->startmode);\n        if (def->mtu)\n            virBufferAsprintf(buf, \"<mtu size='%d'/>\\n\", def->mtu);\n        virInterfaceProtocolDefFormat(buf, def);\n    }\n\n    if (def->type != VIR_INTERFACE_TYPE_BRIDGE)\n        virInterfaceLinkFormat(buf, &def->lnk);\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_ETHERNET:\n            if (def->mac)\n                virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", def->mac);\n            break;\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            virInterfaceBridgeDefFormat(buf, def);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            virInterfaceBondDefFormat(buf, def);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            virInterfaceVlanDefFormat(buf, def);\n            break;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</interface>\\n\");\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nchar *\nvirInterfaceDefFormat(const virInterfaceDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virInterfaceDefDevFormat(&buf, def, VIR_INTERFACE_TYPE_LAST) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n    return virBufferContentAndReset(&buf);\n}"
  },
  {
    "function_name": "virInterfaceDefDevFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "1062-1127",
    "snippet": "static int\nvirInterfaceDefDevFormat(virBufferPtr buf,\n                         const virInterfaceDef *def,\n                         virInterfaceType parentIfType)\n{\n    const char *type = NULL;\n\n    if (def == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virInterfaceDefFormat NULL def\"));\n        return -1;\n    }\n\n    if ((def->name == NULL) && (def->type != VIR_INTERFACE_TYPE_VLAN)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virInterfaceDefFormat missing interface name\"));\n        return -1;\n    }\n\n    if (!(type = virInterfaceTypeToString(def->type))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected interface type %d\"), def->type);\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<interface type='%s' \", type);\n    if (def->name != NULL)\n        virBufferEscapeString(buf, \"name='%s'\", def->name);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (parentIfType == VIR_INTERFACE_TYPE_LAST) {\n        /* these elements are only valid on top-level interfaces - IP\n         * address info (\"protocol\") only makes sense for the\n         * top-level, and subordinate interfaces inherit the toplevel\n         * setting for mtu and start mode, which cannot be overridden.\n         */\n        virInterfaceStartmodeDefFormat(buf, def->startmode);\n        if (def->mtu)\n            virBufferAsprintf(buf, \"<mtu size='%d'/>\\n\", def->mtu);\n        virInterfaceProtocolDefFormat(buf, def);\n    }\n\n    if (def->type != VIR_INTERFACE_TYPE_BRIDGE)\n        virInterfaceLinkFormat(buf, &def->lnk);\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_ETHERNET:\n            if (def->mac)\n                virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", def->mac);\n            break;\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            virInterfaceBridgeDefFormat(buf, def);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            virInterfaceBondDefFormat(buf, def);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            virInterfaceVlanDefFormat(buf, def);\n            break;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</interface>\\n\");\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt, int parentIfType);",
      "static int\nvirInterfaceDefDevFormat(virBufferPtr buf, const virInterfaceDef *def,\n                         virInterfaceType parentIfType);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</interface>\\n\""
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceVlanDefFormat",
          "args": [
            "buf",
            "def"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceVlanDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "963-985",
          "snippet": "static int\nvirInterfaceVlanDefFormat(virBufferPtr buf,\n                          const virInterfaceDef *def)\n{\n    if (def->data.vlan.tag == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"vlan misses the tag name\"));\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<vlan tag='%s'\", def->data.vlan.tag);\n    if (def->data.vlan.dev_name != NULL) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<interface name='%s'/>\\n\",\n                          def->data.vlan.dev_name);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</vlan>\\n\");\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceVlanDefFormat(virBufferPtr buf,\n                          const virInterfaceDef *def)\n{\n    if (def->data.vlan.tag == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"vlan misses the tag name\"));\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<vlan tag='%s'\", def->data.vlan.tag);\n    if (def->data.vlan.dev_name != NULL) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<interface name='%s'/>\\n\",\n                          def->data.vlan.dev_name);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</vlan>\\n\");\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceBondDefFormat",
          "args": [
            "buf",
            "def"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceBondDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "898-960",
          "snippet": "static int\nvirInterfaceBondDefFormat(virBufferPtr buf,\n                          const virInterfaceDef *def)\n{\n    size_t i;\n    int ret = 0;\n\n    virBufferAddLit(buf, \"<bond\");\n    if (def->data.bond.mode == VIR_INTERFACE_BOND_BALRR)\n        virBufferAddLit(buf, \" mode='balance-rr'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_ABACKUP)\n        virBufferAddLit(buf, \" mode='active-backup'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_BALXOR)\n        virBufferAddLit(buf, \" mode='balance-xor'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_BCAST)\n        virBufferAddLit(buf, \" mode='broadcast'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_8023AD)\n        virBufferAddLit(buf, \" mode='802.3ad'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_BALTLB)\n        virBufferAddLit(buf, \" mode='balance-tlb'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_BALALB)\n        virBufferAddLit(buf, \" mode='balance-alb'\");\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (def->data.bond.monit == VIR_INTERFACE_BOND_MONIT_MII) {\n        virBufferAsprintf(buf, \"<miimon freq='%d'\",\n                          def->data.bond.frequency);\n        if (def->data.bond.downdelay > 0)\n            virBufferAsprintf(buf, \" downdelay='%d'\", def->data.bond.downdelay);\n        if (def->data.bond.updelay > 0)\n            virBufferAsprintf(buf, \" updelay='%d'\", def->data.bond.updelay);\n        if (def->data.bond.carrier == VIR_INTERFACE_BOND_MII_IOCTL)\n            virBufferAddLit(buf, \" carrier='ioctl'\");\n        else if (def->data.bond.carrier == VIR_INTERFACE_BOND_MII_NETIF)\n            virBufferAddLit(buf, \" carrier='netif'\");\n        virBufferAddLit(buf, \"/>\\n\");\n    } else if (def->data.bond.monit == VIR_INTERFACE_BOND_MONIT_ARP) {\n        if (def->data.bond.target == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"bond arp monitoring has no target\"));\n            return -1;\n        }\n        virBufferAsprintf(buf, \"<arpmon interval='%d' target='%s'\",\n                          def->data.bond.interval, def->data.bond.target);\n        if (def->data.bond.validate == VIR_INTERFACE_BOND_ARP_ACTIVE)\n            virBufferAddLit(buf, \" validate='active'\");\n        else if (def->data.bond.validate == VIR_INTERFACE_BOND_ARP_BACKUP)\n            virBufferAddLit(buf, \" validate='backup'\");\n        else if (def->data.bond.validate == VIR_INTERFACE_BOND_ARP_ALL)\n            virBufferAddLit(buf, \" validate='all'\");\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n    for (i = 0; i < def->data.bond.nbItf; i++) {\n        if (virInterfaceDefDevFormat(buf, def->data.bond.itf[i],\n                                     VIR_INTERFACE_TYPE_BOND) < 0)\n            ret = -1;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</bond>\\n\");\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceBondDefFormat(virBufferPtr buf,\n                          const virInterfaceDef *def)\n{\n    size_t i;\n    int ret = 0;\n\n    virBufferAddLit(buf, \"<bond\");\n    if (def->data.bond.mode == VIR_INTERFACE_BOND_BALRR)\n        virBufferAddLit(buf, \" mode='balance-rr'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_ABACKUP)\n        virBufferAddLit(buf, \" mode='active-backup'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_BALXOR)\n        virBufferAddLit(buf, \" mode='balance-xor'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_BCAST)\n        virBufferAddLit(buf, \" mode='broadcast'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_8023AD)\n        virBufferAddLit(buf, \" mode='802.3ad'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_BALTLB)\n        virBufferAddLit(buf, \" mode='balance-tlb'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_BALALB)\n        virBufferAddLit(buf, \" mode='balance-alb'\");\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (def->data.bond.monit == VIR_INTERFACE_BOND_MONIT_MII) {\n        virBufferAsprintf(buf, \"<miimon freq='%d'\",\n                          def->data.bond.frequency);\n        if (def->data.bond.downdelay > 0)\n            virBufferAsprintf(buf, \" downdelay='%d'\", def->data.bond.downdelay);\n        if (def->data.bond.updelay > 0)\n            virBufferAsprintf(buf, \" updelay='%d'\", def->data.bond.updelay);\n        if (def->data.bond.carrier == VIR_INTERFACE_BOND_MII_IOCTL)\n            virBufferAddLit(buf, \" carrier='ioctl'\");\n        else if (def->data.bond.carrier == VIR_INTERFACE_BOND_MII_NETIF)\n            virBufferAddLit(buf, \" carrier='netif'\");\n        virBufferAddLit(buf, \"/>\\n\");\n    } else if (def->data.bond.monit == VIR_INTERFACE_BOND_MONIT_ARP) {\n        if (def->data.bond.target == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"bond arp monitoring has no target\"));\n            return -1;\n        }\n        virBufferAsprintf(buf, \"<arpmon interval='%d' target='%s'\",\n                          def->data.bond.interval, def->data.bond.target);\n        if (def->data.bond.validate == VIR_INTERFACE_BOND_ARP_ACTIVE)\n            virBufferAddLit(buf, \" validate='active'\");\n        else if (def->data.bond.validate == VIR_INTERFACE_BOND_ARP_BACKUP)\n            virBufferAddLit(buf, \" validate='backup'\");\n        else if (def->data.bond.validate == VIR_INTERFACE_BOND_ARP_ALL)\n            virBufferAddLit(buf, \" validate='all'\");\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n    for (i = 0; i < def->data.bond.nbItf; i++) {\n        if (virInterfaceDefDevFormat(buf, def->data.bond.itf[i],\n                                     VIR_INTERFACE_TYPE_BOND) < 0)\n            ret = -1;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</bond>\\n\");\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceBridgeDefFormat",
          "args": [
            "buf",
            "def"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceBridgeDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "869-895",
          "snippet": "static int\nvirInterfaceBridgeDefFormat(virBufferPtr buf,\n                            const virInterfaceDef *def)\n{\n    size_t i;\n    int ret = 0;\n\n    virBufferAddLit(buf, \"<bridge\");\n    if (def->data.bridge.stp == 1)\n        virBufferAddLit(buf, \" stp='on'\");\n    else if (def->data.bridge.stp == 0)\n        virBufferAddLit(buf, \" stp='off'\");\n    if (def->data.bridge.delay != NULL)\n        virBufferAsprintf(buf, \" delay='%s'\", def->data.bridge.delay);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < def->data.bridge.nbItf; i++) {\n        if (virInterfaceDefDevFormat(buf, def->data.bridge.itf[i],\n                                     VIR_INTERFACE_TYPE_BRIDGE) < 0)\n            ret = -1;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</bridge>\\n\");\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceBridgeDefFormat(virBufferPtr buf,\n                            const virInterfaceDef *def)\n{\n    size_t i;\n    int ret = 0;\n\n    virBufferAddLit(buf, \"<bridge\");\n    if (def->data.bridge.stp == 1)\n        virBufferAddLit(buf, \" stp='on'\");\n    else if (def->data.bridge.stp == 0)\n        virBufferAddLit(buf, \" stp='off'\");\n    if (def->data.bridge.delay != NULL)\n        virBufferAsprintf(buf, \" delay='%s'\", def->data.bridge.delay);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < def->data.bridge.nbItf; i++) {\n        if (virInterfaceDefDevFormat(buf, def->data.bridge.itf[i],\n                                     VIR_INTERFACE_TYPE_BRIDGE) < 0)\n            ret = -1;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</bridge>\\n\");\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<mac address='%s'/>\\n\"",
            "def->mac"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceLinkFormat",
          "args": [
            "buf",
            "&def->lnk"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceLinkFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "646-663",
          "snippet": "int\nvirInterfaceLinkFormat(virBufferPtr buf,\n                       const virNetDevIfLink *lnk)\n{\n    if (!lnk->speed && !lnk->state) {\n        /* If there's nothing to format, return early. */\n        return 0;\n    }\n\n    virBufferAddLit(buf, \"<link\");\n    if (lnk->speed)\n        virBufferAsprintf(buf, \" speed='%u'\", lnk->speed);\n    if (lnk->state)\n        virBufferAsprintf(buf, \" state='%s'\",\n                          virNetDevIfStateTypeToString(lnk->state));\n    virBufferAddLit(buf, \"/>\\n\");\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirInterfaceLinkFormat(virBufferPtr buf,\n                       const virNetDevIfLink *lnk)\n{\n    if (!lnk->speed && !lnk->state) {\n        /* If there's nothing to format, return early. */\n        return 0;\n    }\n\n    virBufferAddLit(buf, \"<link\");\n    if (lnk->speed)\n        virBufferAsprintf(buf, \" speed='%u'\", lnk->speed);\n    if (lnk->state)\n        virBufferAsprintf(buf, \" state='%s'\",\n                          virNetDevIfStateTypeToString(lnk->state));\n    virBufferAddLit(buf, \"/>\\n\");\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceProtocolDefFormat",
          "args": [
            "buf",
            "def"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceProtocolDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "988-1032",
          "snippet": "static int\nvirInterfaceProtocolDefFormat(virBufferPtr buf,\n                              const virInterfaceDef *def)\n{\n    size_t i, j;\n\n    for (i = 0; i < def->nprotos; i++) {\n\n        virBufferAsprintf(buf, \"<protocol family='%s'>\\n\",\n                          def->protos[i]->family);\n        virBufferAdjustIndent(buf, 2);\n\n        if (def->protos[i]->autoconf)\n            virBufferAddLit(buf, \"<autoconf/>\\n\");\n        if (def->protos[i]->dhcp) {\n            if (def->protos[i]->peerdns == 0)\n                virBufferAddLit(buf, \"<dhcp peerdns='no'/>\\n\");\n            else if (def->protos[i]->peerdns == 1)\n                virBufferAddLit(buf, \"<dhcp peerdns='yes'/>\\n\");\n            else\n                virBufferAddLit(buf, \"<dhcp/>\\n\");\n        }\n\n        for (j = 0; j < def->protos[i]->nips; j++) {\n            if (def->protos[i]->ips[j]->address != NULL) {\n\n                virBufferAsprintf(buf, \"<ip address='%s'\",\n                                  def->protos[i]->ips[j]->address);\n                if (def->protos[i]->ips[j]->prefix != 0) {\n                    virBufferAsprintf(buf, \" prefix='%d'\",\n                                      def->protos[i]->ips[j]->prefix);\n                }\n                virBufferAddLit(buf, \"/>\\n\");\n            }\n        }\n        if (def->protos[i]->gateway != NULL) {\n            virBufferAsprintf(buf, \"<route gateway='%s'/>\\n\",\n                              def->protos[i]->gateway);\n        }\n\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</protocol>\\n\");\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceProtocolDefFormat(virBufferPtr buf,\n                              const virInterfaceDef *def)\n{\n    size_t i, j;\n\n    for (i = 0; i < def->nprotos; i++) {\n\n        virBufferAsprintf(buf, \"<protocol family='%s'>\\n\",\n                          def->protos[i]->family);\n        virBufferAdjustIndent(buf, 2);\n\n        if (def->protos[i]->autoconf)\n            virBufferAddLit(buf, \"<autoconf/>\\n\");\n        if (def->protos[i]->dhcp) {\n            if (def->protos[i]->peerdns == 0)\n                virBufferAddLit(buf, \"<dhcp peerdns='no'/>\\n\");\n            else if (def->protos[i]->peerdns == 1)\n                virBufferAddLit(buf, \"<dhcp peerdns='yes'/>\\n\");\n            else\n                virBufferAddLit(buf, \"<dhcp/>\\n\");\n        }\n\n        for (j = 0; j < def->protos[i]->nips; j++) {\n            if (def->protos[i]->ips[j]->address != NULL) {\n\n                virBufferAsprintf(buf, \"<ip address='%s'\",\n                                  def->protos[i]->ips[j]->address);\n                if (def->protos[i]->ips[j]->prefix != 0) {\n                    virBufferAsprintf(buf, \" prefix='%d'\",\n                                      def->protos[i]->ips[j]->prefix);\n                }\n                virBufferAddLit(buf, \"/>\\n\");\n            }\n        }\n        if (def->protos[i]->gateway != NULL) {\n            virBufferAsprintf(buf, \"<route gateway='%s'/>\\n\",\n                              def->protos[i]->gateway);\n        }\n\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</protocol>\\n\");\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceStartmodeDefFormat",
          "args": [
            "buf",
            "def->startmode"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceStartmodeDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "1035-1059",
          "snippet": "static int\nvirInterfaceStartmodeDefFormat(virBufferPtr buf,\n                               virInterfaceStartMode startmode)\n{\n    const char *mode;\n    switch (startmode) {\n        case VIR_INTERFACE_START_UNSPECIFIED:\n            return 0;\n        case VIR_INTERFACE_START_NONE:\n            mode = \"none\";\n            break;\n        case VIR_INTERFACE_START_ONBOOT:\n            mode = \"onboot\";\n            break;\n        case VIR_INTERFACE_START_HOTPLUG:\n            mode = \"hotplug\";\n            break;\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"virInterfaceDefFormat unknown startmode\"));\n            return -1;\n    }\n    virBufferAsprintf(buf, \"<start mode='%s'/>\\n\", mode);\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceStartmodeDefFormat(virBufferPtr buf,\n                               virInterfaceStartMode startmode)\n{\n    const char *mode;\n    switch (startmode) {\n        case VIR_INTERFACE_START_UNSPECIFIED:\n            return 0;\n        case VIR_INTERFACE_START_NONE:\n            mode = \"none\";\n            break;\n        case VIR_INTERFACE_START_ONBOOT:\n            mode = \"onboot\";\n            break;\n        case VIR_INTERFACE_START_HOTPLUG:\n            mode = \"hotplug\";\n            break;\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"virInterfaceDefFormat unknown startmode\"));\n            return -1;\n    }\n    virBufferAsprintf(buf, \"<start mode='%s'/>\\n\", mode);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"name='%s'\"",
            "def->name"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected interface type %d\")",
            "def->type"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unexpected interface type %d\""
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceTypeToString",
          "args": [
            "def->type"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"virInterfaceDefFormat missing interface name\")"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"virInterfaceDefFormat NULL def\")"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt, int parentIfType);\nstatic int\nvirInterfaceDefDevFormat(virBufferPtr buf, const virInterfaceDef *def,\n                         virInterfaceType parentIfType);\n\nstatic int\nvirInterfaceDefDevFormat(virBufferPtr buf,\n                         const virInterfaceDef *def,\n                         virInterfaceType parentIfType)\n{\n    const char *type = NULL;\n\n    if (def == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virInterfaceDefFormat NULL def\"));\n        return -1;\n    }\n\n    if ((def->name == NULL) && (def->type != VIR_INTERFACE_TYPE_VLAN)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virInterfaceDefFormat missing interface name\"));\n        return -1;\n    }\n\n    if (!(type = virInterfaceTypeToString(def->type))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected interface type %d\"), def->type);\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<interface type='%s' \", type);\n    if (def->name != NULL)\n        virBufferEscapeString(buf, \"name='%s'\", def->name);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (parentIfType == VIR_INTERFACE_TYPE_LAST) {\n        /* these elements are only valid on top-level interfaces - IP\n         * address info (\"protocol\") only makes sense for the\n         * top-level, and subordinate interfaces inherit the toplevel\n         * setting for mtu and start mode, which cannot be overridden.\n         */\n        virInterfaceStartmodeDefFormat(buf, def->startmode);\n        if (def->mtu)\n            virBufferAsprintf(buf, \"<mtu size='%d'/>\\n\", def->mtu);\n        virInterfaceProtocolDefFormat(buf, def);\n    }\n\n    if (def->type != VIR_INTERFACE_TYPE_BRIDGE)\n        virInterfaceLinkFormat(buf, &def->lnk);\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_ETHERNET:\n            if (def->mac)\n                virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", def->mac);\n            break;\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            virInterfaceBridgeDefFormat(buf, def);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            virInterfaceBondDefFormat(buf, def);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            virInterfaceVlanDefFormat(buf, def);\n            break;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</interface>\\n\");\n\n    return 0;\n}"
  },
  {
    "function_name": "virInterfaceStartmodeDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "1035-1059",
    "snippet": "static int\nvirInterfaceStartmodeDefFormat(virBufferPtr buf,\n                               virInterfaceStartMode startmode)\n{\n    const char *mode;\n    switch (startmode) {\n        case VIR_INTERFACE_START_UNSPECIFIED:\n            return 0;\n        case VIR_INTERFACE_START_NONE:\n            mode = \"none\";\n            break;\n        case VIR_INTERFACE_START_ONBOOT:\n            mode = \"onboot\";\n            break;\n        case VIR_INTERFACE_START_HOTPLUG:\n            mode = \"hotplug\";\n            break;\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"virInterfaceDefFormat unknown startmode\"));\n            return -1;\n    }\n    virBufferAsprintf(buf, \"<start mode='%s'/>\\n\", mode);\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<start mode='%s'/>\\n\"",
            "mode"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"virInterfaceDefFormat unknown startmode\")"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"virInterfaceDefFormat unknown startmode\""
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceStartmodeDefFormat(virBufferPtr buf,\n                               virInterfaceStartMode startmode)\n{\n    const char *mode;\n    switch (startmode) {\n        case VIR_INTERFACE_START_UNSPECIFIED:\n            return 0;\n        case VIR_INTERFACE_START_NONE:\n            mode = \"none\";\n            break;\n        case VIR_INTERFACE_START_ONBOOT:\n            mode = \"onboot\";\n            break;\n        case VIR_INTERFACE_START_HOTPLUG:\n            mode = \"hotplug\";\n            break;\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"virInterfaceDefFormat unknown startmode\"));\n            return -1;\n    }\n    virBufferAsprintf(buf, \"<start mode='%s'/>\\n\", mode);\n    return 0;\n}"
  },
  {
    "function_name": "virInterfaceProtocolDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "988-1032",
    "snippet": "static int\nvirInterfaceProtocolDefFormat(virBufferPtr buf,\n                              const virInterfaceDef *def)\n{\n    size_t i, j;\n\n    for (i = 0; i < def->nprotos; i++) {\n\n        virBufferAsprintf(buf, \"<protocol family='%s'>\\n\",\n                          def->protos[i]->family);\n        virBufferAdjustIndent(buf, 2);\n\n        if (def->protos[i]->autoconf)\n            virBufferAddLit(buf, \"<autoconf/>\\n\");\n        if (def->protos[i]->dhcp) {\n            if (def->protos[i]->peerdns == 0)\n                virBufferAddLit(buf, \"<dhcp peerdns='no'/>\\n\");\n            else if (def->protos[i]->peerdns == 1)\n                virBufferAddLit(buf, \"<dhcp peerdns='yes'/>\\n\");\n            else\n                virBufferAddLit(buf, \"<dhcp/>\\n\");\n        }\n\n        for (j = 0; j < def->protos[i]->nips; j++) {\n            if (def->protos[i]->ips[j]->address != NULL) {\n\n                virBufferAsprintf(buf, \"<ip address='%s'\",\n                                  def->protos[i]->ips[j]->address);\n                if (def->protos[i]->ips[j]->prefix != 0) {\n                    virBufferAsprintf(buf, \" prefix='%d'\",\n                                      def->protos[i]->ips[j]->prefix);\n                }\n                virBufferAddLit(buf, \"/>\\n\");\n            }\n        }\n        if (def->protos[i]->gateway != NULL) {\n            virBufferAsprintf(buf, \"<route gateway='%s'/>\\n\",\n                              def->protos[i]->gateway);\n        }\n\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</protocol>\\n\");\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</protocol>\\n\""
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<route gateway='%s'/>\\n\"",
            "def->protos[i]->gateway"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<dhcp/>\\n\""
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<dhcp peerdns='yes'/>\\n\""
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<dhcp peerdns='no'/>\\n\""
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<autoconf/>\\n\""
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceProtocolDefFormat(virBufferPtr buf,\n                              const virInterfaceDef *def)\n{\n    size_t i, j;\n\n    for (i = 0; i < def->nprotos; i++) {\n\n        virBufferAsprintf(buf, \"<protocol family='%s'>\\n\",\n                          def->protos[i]->family);\n        virBufferAdjustIndent(buf, 2);\n\n        if (def->protos[i]->autoconf)\n            virBufferAddLit(buf, \"<autoconf/>\\n\");\n        if (def->protos[i]->dhcp) {\n            if (def->protos[i]->peerdns == 0)\n                virBufferAddLit(buf, \"<dhcp peerdns='no'/>\\n\");\n            else if (def->protos[i]->peerdns == 1)\n                virBufferAddLit(buf, \"<dhcp peerdns='yes'/>\\n\");\n            else\n                virBufferAddLit(buf, \"<dhcp/>\\n\");\n        }\n\n        for (j = 0; j < def->protos[i]->nips; j++) {\n            if (def->protos[i]->ips[j]->address != NULL) {\n\n                virBufferAsprintf(buf, \"<ip address='%s'\",\n                                  def->protos[i]->ips[j]->address);\n                if (def->protos[i]->ips[j]->prefix != 0) {\n                    virBufferAsprintf(buf, \" prefix='%d'\",\n                                      def->protos[i]->ips[j]->prefix);\n                }\n                virBufferAddLit(buf, \"/>\\n\");\n            }\n        }\n        if (def->protos[i]->gateway != NULL) {\n            virBufferAsprintf(buf, \"<route gateway='%s'/>\\n\",\n                              def->protos[i]->gateway);\n        }\n\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</protocol>\\n\");\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virInterfaceVlanDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "963-985",
    "snippet": "static int\nvirInterfaceVlanDefFormat(virBufferPtr buf,\n                          const virInterfaceDef *def)\n{\n    if (def->data.vlan.tag == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"vlan misses the tag name\"));\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<vlan tag='%s'\", def->data.vlan.tag);\n    if (def->data.vlan.dev_name != NULL) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<interface name='%s'/>\\n\",\n                          def->data.vlan.dev_name);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</vlan>\\n\");\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</vlan>\\n\""
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<interface name='%s'/>\\n\"",
            "def->data.vlan.dev_name"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"vlan misses the tag name\")"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"vlan misses the tag name\""
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceVlanDefFormat(virBufferPtr buf,\n                          const virInterfaceDef *def)\n{\n    if (def->data.vlan.tag == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"vlan misses the tag name\"));\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<vlan tag='%s'\", def->data.vlan.tag);\n    if (def->data.vlan.dev_name != NULL) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<interface name='%s'/>\\n\",\n                          def->data.vlan.dev_name);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</vlan>\\n\");\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virInterfaceBondDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "898-960",
    "snippet": "static int\nvirInterfaceBondDefFormat(virBufferPtr buf,\n                          const virInterfaceDef *def)\n{\n    size_t i;\n    int ret = 0;\n\n    virBufferAddLit(buf, \"<bond\");\n    if (def->data.bond.mode == VIR_INTERFACE_BOND_BALRR)\n        virBufferAddLit(buf, \" mode='balance-rr'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_ABACKUP)\n        virBufferAddLit(buf, \" mode='active-backup'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_BALXOR)\n        virBufferAddLit(buf, \" mode='balance-xor'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_BCAST)\n        virBufferAddLit(buf, \" mode='broadcast'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_8023AD)\n        virBufferAddLit(buf, \" mode='802.3ad'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_BALTLB)\n        virBufferAddLit(buf, \" mode='balance-tlb'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_BALALB)\n        virBufferAddLit(buf, \" mode='balance-alb'\");\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (def->data.bond.monit == VIR_INTERFACE_BOND_MONIT_MII) {\n        virBufferAsprintf(buf, \"<miimon freq='%d'\",\n                          def->data.bond.frequency);\n        if (def->data.bond.downdelay > 0)\n            virBufferAsprintf(buf, \" downdelay='%d'\", def->data.bond.downdelay);\n        if (def->data.bond.updelay > 0)\n            virBufferAsprintf(buf, \" updelay='%d'\", def->data.bond.updelay);\n        if (def->data.bond.carrier == VIR_INTERFACE_BOND_MII_IOCTL)\n            virBufferAddLit(buf, \" carrier='ioctl'\");\n        else if (def->data.bond.carrier == VIR_INTERFACE_BOND_MII_NETIF)\n            virBufferAddLit(buf, \" carrier='netif'\");\n        virBufferAddLit(buf, \"/>\\n\");\n    } else if (def->data.bond.monit == VIR_INTERFACE_BOND_MONIT_ARP) {\n        if (def->data.bond.target == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"bond arp monitoring has no target\"));\n            return -1;\n        }\n        virBufferAsprintf(buf, \"<arpmon interval='%d' target='%s'\",\n                          def->data.bond.interval, def->data.bond.target);\n        if (def->data.bond.validate == VIR_INTERFACE_BOND_ARP_ACTIVE)\n            virBufferAddLit(buf, \" validate='active'\");\n        else if (def->data.bond.validate == VIR_INTERFACE_BOND_ARP_BACKUP)\n            virBufferAddLit(buf, \" validate='backup'\");\n        else if (def->data.bond.validate == VIR_INTERFACE_BOND_ARP_ALL)\n            virBufferAddLit(buf, \" validate='all'\");\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n    for (i = 0; i < def->data.bond.nbItf; i++) {\n        if (virInterfaceDefDevFormat(buf, def->data.bond.itf[i],\n                                     VIR_INTERFACE_TYPE_BOND) < 0)\n            ret = -1;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</bond>\\n\");\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</bond>\\n\""
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefDevFormat",
          "args": [
            "buf",
            "def->data.bond.itf[i]",
            "VIR_INTERFACE_TYPE_BOND"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefDevFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "1062-1127",
          "snippet": "static int\nvirInterfaceDefDevFormat(virBufferPtr buf,\n                         const virInterfaceDef *def,\n                         virInterfaceType parentIfType)\n{\n    const char *type = NULL;\n\n    if (def == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virInterfaceDefFormat NULL def\"));\n        return -1;\n    }\n\n    if ((def->name == NULL) && (def->type != VIR_INTERFACE_TYPE_VLAN)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virInterfaceDefFormat missing interface name\"));\n        return -1;\n    }\n\n    if (!(type = virInterfaceTypeToString(def->type))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected interface type %d\"), def->type);\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<interface type='%s' \", type);\n    if (def->name != NULL)\n        virBufferEscapeString(buf, \"name='%s'\", def->name);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (parentIfType == VIR_INTERFACE_TYPE_LAST) {\n        /* these elements are only valid on top-level interfaces - IP\n         * address info (\"protocol\") only makes sense for the\n         * top-level, and subordinate interfaces inherit the toplevel\n         * setting for mtu and start mode, which cannot be overridden.\n         */\n        virInterfaceStartmodeDefFormat(buf, def->startmode);\n        if (def->mtu)\n            virBufferAsprintf(buf, \"<mtu size='%d'/>\\n\", def->mtu);\n        virInterfaceProtocolDefFormat(buf, def);\n    }\n\n    if (def->type != VIR_INTERFACE_TYPE_BRIDGE)\n        virInterfaceLinkFormat(buf, &def->lnk);\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_ETHERNET:\n            if (def->mac)\n                virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", def->mac);\n            break;\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            virInterfaceBridgeDefFormat(buf, def);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            virInterfaceBondDefFormat(buf, def);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            virInterfaceVlanDefFormat(buf, def);\n            break;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</interface>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt, int parentIfType);",
            "static int\nvirInterfaceDefDevFormat(virBufferPtr buf, const virInterfaceDef *def,\n                         virInterfaceType parentIfType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt, int parentIfType);\nstatic int\nvirInterfaceDefDevFormat(virBufferPtr buf, const virInterfaceDef *def,\n                         virInterfaceType parentIfType);\n\nstatic int\nvirInterfaceDefDevFormat(virBufferPtr buf,\n                         const virInterfaceDef *def,\n                         virInterfaceType parentIfType)\n{\n    const char *type = NULL;\n\n    if (def == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virInterfaceDefFormat NULL def\"));\n        return -1;\n    }\n\n    if ((def->name == NULL) && (def->type != VIR_INTERFACE_TYPE_VLAN)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virInterfaceDefFormat missing interface name\"));\n        return -1;\n    }\n\n    if (!(type = virInterfaceTypeToString(def->type))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected interface type %d\"), def->type);\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<interface type='%s' \", type);\n    if (def->name != NULL)\n        virBufferEscapeString(buf, \"name='%s'\", def->name);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (parentIfType == VIR_INTERFACE_TYPE_LAST) {\n        /* these elements are only valid on top-level interfaces - IP\n         * address info (\"protocol\") only makes sense for the\n         * top-level, and subordinate interfaces inherit the toplevel\n         * setting for mtu and start mode, which cannot be overridden.\n         */\n        virInterfaceStartmodeDefFormat(buf, def->startmode);\n        if (def->mtu)\n            virBufferAsprintf(buf, \"<mtu size='%d'/>\\n\", def->mtu);\n        virInterfaceProtocolDefFormat(buf, def);\n    }\n\n    if (def->type != VIR_INTERFACE_TYPE_BRIDGE)\n        virInterfaceLinkFormat(buf, &def->lnk);\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_ETHERNET:\n            if (def->mac)\n                virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", def->mac);\n            break;\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            virInterfaceBridgeDefFormat(buf, def);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            virInterfaceBondDefFormat(buf, def);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            virInterfaceVlanDefFormat(buf, def);\n            break;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</interface>\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" validate='all'\""
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" validate='backup'\""
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" validate='active'\""
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<arpmon interval='%d' target='%s'\"",
            "def->data.bond.interval",
            "def->data.bond.target"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"bond arp monitoring has no target\")"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"bond arp monitoring has no target\""
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" carrier='netif'\""
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" carrier='ioctl'\""
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" mode='balance-alb'\""
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" mode='balance-tlb'\""
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" mode='802.3ad'\""
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" mode='broadcast'\""
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" mode='balance-xor'\""
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" mode='active-backup'\""
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" mode='balance-rr'\""
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<bond\""
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceBondDefFormat(virBufferPtr buf,\n                          const virInterfaceDef *def)\n{\n    size_t i;\n    int ret = 0;\n\n    virBufferAddLit(buf, \"<bond\");\n    if (def->data.bond.mode == VIR_INTERFACE_BOND_BALRR)\n        virBufferAddLit(buf, \" mode='balance-rr'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_ABACKUP)\n        virBufferAddLit(buf, \" mode='active-backup'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_BALXOR)\n        virBufferAddLit(buf, \" mode='balance-xor'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_BCAST)\n        virBufferAddLit(buf, \" mode='broadcast'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_8023AD)\n        virBufferAddLit(buf, \" mode='802.3ad'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_BALTLB)\n        virBufferAddLit(buf, \" mode='balance-tlb'\");\n    else if (def->data.bond.mode == VIR_INTERFACE_BOND_BALALB)\n        virBufferAddLit(buf, \" mode='balance-alb'\");\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (def->data.bond.monit == VIR_INTERFACE_BOND_MONIT_MII) {\n        virBufferAsprintf(buf, \"<miimon freq='%d'\",\n                          def->data.bond.frequency);\n        if (def->data.bond.downdelay > 0)\n            virBufferAsprintf(buf, \" downdelay='%d'\", def->data.bond.downdelay);\n        if (def->data.bond.updelay > 0)\n            virBufferAsprintf(buf, \" updelay='%d'\", def->data.bond.updelay);\n        if (def->data.bond.carrier == VIR_INTERFACE_BOND_MII_IOCTL)\n            virBufferAddLit(buf, \" carrier='ioctl'\");\n        else if (def->data.bond.carrier == VIR_INTERFACE_BOND_MII_NETIF)\n            virBufferAddLit(buf, \" carrier='netif'\");\n        virBufferAddLit(buf, \"/>\\n\");\n    } else if (def->data.bond.monit == VIR_INTERFACE_BOND_MONIT_ARP) {\n        if (def->data.bond.target == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"bond arp monitoring has no target\"));\n            return -1;\n        }\n        virBufferAsprintf(buf, \"<arpmon interval='%d' target='%s'\",\n                          def->data.bond.interval, def->data.bond.target);\n        if (def->data.bond.validate == VIR_INTERFACE_BOND_ARP_ACTIVE)\n            virBufferAddLit(buf, \" validate='active'\");\n        else if (def->data.bond.validate == VIR_INTERFACE_BOND_ARP_BACKUP)\n            virBufferAddLit(buf, \" validate='backup'\");\n        else if (def->data.bond.validate == VIR_INTERFACE_BOND_ARP_ALL)\n            virBufferAddLit(buf, \" validate='all'\");\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n    for (i = 0; i < def->data.bond.nbItf; i++) {\n        if (virInterfaceDefDevFormat(buf, def->data.bond.itf[i],\n                                     VIR_INTERFACE_TYPE_BOND) < 0)\n            ret = -1;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</bond>\\n\");\n    return ret;\n}"
  },
  {
    "function_name": "virInterfaceBridgeDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "869-895",
    "snippet": "static int\nvirInterfaceBridgeDefFormat(virBufferPtr buf,\n                            const virInterfaceDef *def)\n{\n    size_t i;\n    int ret = 0;\n\n    virBufferAddLit(buf, \"<bridge\");\n    if (def->data.bridge.stp == 1)\n        virBufferAddLit(buf, \" stp='on'\");\n    else if (def->data.bridge.stp == 0)\n        virBufferAddLit(buf, \" stp='off'\");\n    if (def->data.bridge.delay != NULL)\n        virBufferAsprintf(buf, \" delay='%s'\", def->data.bridge.delay);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < def->data.bridge.nbItf; i++) {\n        if (virInterfaceDefDevFormat(buf, def->data.bridge.itf[i],\n                                     VIR_INTERFACE_TYPE_BRIDGE) < 0)\n            ret = -1;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</bridge>\\n\");\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</bridge>\\n\""
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefDevFormat",
          "args": [
            "buf",
            "def->data.bridge.itf[i]",
            "VIR_INTERFACE_TYPE_BRIDGE"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefDevFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "1062-1127",
          "snippet": "static int\nvirInterfaceDefDevFormat(virBufferPtr buf,\n                         const virInterfaceDef *def,\n                         virInterfaceType parentIfType)\n{\n    const char *type = NULL;\n\n    if (def == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virInterfaceDefFormat NULL def\"));\n        return -1;\n    }\n\n    if ((def->name == NULL) && (def->type != VIR_INTERFACE_TYPE_VLAN)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virInterfaceDefFormat missing interface name\"));\n        return -1;\n    }\n\n    if (!(type = virInterfaceTypeToString(def->type))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected interface type %d\"), def->type);\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<interface type='%s' \", type);\n    if (def->name != NULL)\n        virBufferEscapeString(buf, \"name='%s'\", def->name);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (parentIfType == VIR_INTERFACE_TYPE_LAST) {\n        /* these elements are only valid on top-level interfaces - IP\n         * address info (\"protocol\") only makes sense for the\n         * top-level, and subordinate interfaces inherit the toplevel\n         * setting for mtu and start mode, which cannot be overridden.\n         */\n        virInterfaceStartmodeDefFormat(buf, def->startmode);\n        if (def->mtu)\n            virBufferAsprintf(buf, \"<mtu size='%d'/>\\n\", def->mtu);\n        virInterfaceProtocolDefFormat(buf, def);\n    }\n\n    if (def->type != VIR_INTERFACE_TYPE_BRIDGE)\n        virInterfaceLinkFormat(buf, &def->lnk);\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_ETHERNET:\n            if (def->mac)\n                virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", def->mac);\n            break;\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            virInterfaceBridgeDefFormat(buf, def);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            virInterfaceBondDefFormat(buf, def);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            virInterfaceVlanDefFormat(buf, def);\n            break;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</interface>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt, int parentIfType);",
            "static int\nvirInterfaceDefDevFormat(virBufferPtr buf, const virInterfaceDef *def,\n                         virInterfaceType parentIfType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt, int parentIfType);\nstatic int\nvirInterfaceDefDevFormat(virBufferPtr buf, const virInterfaceDef *def,\n                         virInterfaceType parentIfType);\n\nstatic int\nvirInterfaceDefDevFormat(virBufferPtr buf,\n                         const virInterfaceDef *def,\n                         virInterfaceType parentIfType)\n{\n    const char *type = NULL;\n\n    if (def == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virInterfaceDefFormat NULL def\"));\n        return -1;\n    }\n\n    if ((def->name == NULL) && (def->type != VIR_INTERFACE_TYPE_VLAN)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virInterfaceDefFormat missing interface name\"));\n        return -1;\n    }\n\n    if (!(type = virInterfaceTypeToString(def->type))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected interface type %d\"), def->type);\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"<interface type='%s' \", type);\n    if (def->name != NULL)\n        virBufferEscapeString(buf, \"name='%s'\", def->name);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (parentIfType == VIR_INTERFACE_TYPE_LAST) {\n        /* these elements are only valid on top-level interfaces - IP\n         * address info (\"protocol\") only makes sense for the\n         * top-level, and subordinate interfaces inherit the toplevel\n         * setting for mtu and start mode, which cannot be overridden.\n         */\n        virInterfaceStartmodeDefFormat(buf, def->startmode);\n        if (def->mtu)\n            virBufferAsprintf(buf, \"<mtu size='%d'/>\\n\", def->mtu);\n        virInterfaceProtocolDefFormat(buf, def);\n    }\n\n    if (def->type != VIR_INTERFACE_TYPE_BRIDGE)\n        virInterfaceLinkFormat(buf, &def->lnk);\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_ETHERNET:\n            if (def->mac)\n                virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", def->mac);\n            break;\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            virInterfaceBridgeDefFormat(buf, def);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            virInterfaceBondDefFormat(buf, def);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            virInterfaceVlanDefFormat(buf, def);\n            break;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</interface>\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\" delay='%s'\"",
            "def->data.bridge.delay"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" stp='off'\""
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" stp='on'\""
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<bridge\""
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceBridgeDefFormat(virBufferPtr buf,\n                            const virInterfaceDef *def)\n{\n    size_t i;\n    int ret = 0;\n\n    virBufferAddLit(buf, \"<bridge\");\n    if (def->data.bridge.stp == 1)\n        virBufferAddLit(buf, \" stp='on'\");\n    else if (def->data.bridge.stp == 0)\n        virBufferAddLit(buf, \" stp='off'\");\n    if (def->data.bridge.delay != NULL)\n        virBufferAsprintf(buf, \" delay='%s'\", def->data.bridge.delay);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < def->data.bridge.nbItf; i++) {\n        if (virInterfaceDefDevFormat(buf, def->data.bridge.itf[i],\n                                     VIR_INTERFACE_TYPE_BRIDGE) < 0)\n            ret = -1;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</bridge>\\n\");\n    return ret;\n}"
  },
  {
    "function_name": "virInterfaceDefParseFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "862-866",
    "snippet": "virInterfaceDefPtr\nvirInterfaceDefParseFile(const char *filename)\n{\n    return virInterfaceDefParse(NULL, filename);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virInterfaceDefParse",
          "args": [
            "NULL",
            "filename"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "839-852",
          "snippet": "static virInterfaceDefPtr\nvirInterfaceDefParse(const char *xmlStr,\n                     const char *filename)\n{\n    xmlDocPtr xml;\n    virInterfaceDefPtr def = NULL;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(interface_definition)\")))) {\n        def = virInterfaceDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virInterfaceDefPtr\nvirInterfaceDefParse(const char *xmlStr,\n                     const char *filename)\n{\n    xmlDocPtr xml;\n    virInterfaceDefPtr def = NULL;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(interface_definition)\")))) {\n        def = virInterfaceDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirInterfaceDefPtr\nvirInterfaceDefParseFile(const char *filename)\n{\n    return virInterfaceDefParse(NULL, filename);\n}"
  },
  {
    "function_name": "virInterfaceDefParseString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "855-859",
    "snippet": "virInterfaceDefPtr\nvirInterfaceDefParseString(const char *xmlStr)\n{\n    return virInterfaceDefParse(xmlStr, NULL);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virInterfaceDefParse",
          "args": [
            "xmlStr",
            "NULL"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "839-852",
          "snippet": "static virInterfaceDefPtr\nvirInterfaceDefParse(const char *xmlStr,\n                     const char *filename)\n{\n    xmlDocPtr xml;\n    virInterfaceDefPtr def = NULL;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(interface_definition)\")))) {\n        def = virInterfaceDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virInterfaceDefPtr\nvirInterfaceDefParse(const char *xmlStr,\n                     const char *filename)\n{\n    xmlDocPtr xml;\n    virInterfaceDefPtr def = NULL;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(interface_definition)\")))) {\n        def = virInterfaceDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirInterfaceDefPtr\nvirInterfaceDefParseString(const char *xmlStr)\n{\n    return virInterfaceDefParse(xmlStr, NULL);\n}"
  },
  {
    "function_name": "virInterfaceDefParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "839-852",
    "snippet": "static virInterfaceDefPtr\nvirInterfaceDefParse(const char *xmlStr,\n                     const char *filename)\n{\n    xmlDocPtr xml;\n    virInterfaceDefPtr def = NULL;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(interface_definition)\")))) {\n        def = virInterfaceDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xml"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseNode",
          "args": [
            "xml",
            "xmlDocGetRootElement(xml)"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "817-836",
          "snippet": "virInterfaceDefPtr\nvirInterfaceDefParseNode(xmlDocPtr xml,\n                         xmlNodePtr root)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"interface\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <interface>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virInterfaceDefParseXML(ctxt, VIR_INTERFACE_TYPE_LAST);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirInterfaceDefPtr\nvirInterfaceDefParseNode(xmlDocPtr xml,\n                         xmlNodePtr root)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"interface\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <interface>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virInterfaceDefParseXML(ctxt, VIR_INTERFACE_TYPE_LAST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlDocGetRootElement",
          "args": [
            "xml"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLParse",
          "args": [
            "filename",
            "xmlStr",
            "_(\"(interface_definition)\")"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"(interface_definition)\""
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virInterfaceDefPtr\nvirInterfaceDefParse(const char *xmlStr,\n                     const char *filename)\n{\n    xmlDocPtr xml;\n    virInterfaceDefPtr def = NULL;\n\n    if ((xml = virXMLParse(filename, xmlStr, _(\"(interface_definition)\")))) {\n        def = virInterfaceDefParseNode(xml, xmlDocGetRootElement(xml));\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}"
  },
  {
    "function_name": "virInterfaceDefParseNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "817-836",
    "snippet": "virInterfaceDefPtr\nvirInterfaceDefParseNode(xmlDocPtr xml,\n                         xmlNodePtr root)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"interface\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <interface>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virInterfaceDefParseXML(ctxt, VIR_INTERFACE_TYPE_LAST);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virInterfaceDefParseXML",
          "args": [
            "ctxt",
            "VIR_INTERFACE_TYPE_LAST"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "694-814",
          "snippet": "static virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt,\n                        int parentIfType)\n{\n    virInterfaceDefPtr def;\n    int type;\n    char *tmp;\n    xmlNodePtr cur = ctxt->node;\n    xmlNodePtr lnk;\n\n\n    /* check @type */\n    tmp = virXPathString(\"string(./@type)\", ctxt);\n    if (tmp == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"interface misses the type attribute\"));\n        return NULL;\n    }\n    type = virInterfaceTypeFromString(tmp);\n    if (type == -1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown interface type %s\"), tmp);\n        VIR_FREE(tmp);\n        return NULL;\n    }\n    VIR_FREE(tmp);\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (((parentIfType == VIR_INTERFACE_TYPE_BOND)\n         && (type != VIR_INTERFACE_TYPE_ETHERNET))\n        || ((parentIfType == VIR_INTERFACE_TYPE_BRIDGE)\n            && (type != VIR_INTERFACE_TYPE_ETHERNET)\n            && (type != VIR_INTERFACE_TYPE_BOND)\n            && (type != VIR_INTERFACE_TYPE_VLAN))\n        || (parentIfType == VIR_INTERFACE_TYPE_ETHERNET)\n        || (parentIfType == VIR_INTERFACE_TYPE_VLAN))\n        {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"interface has unsupported type '%s'\"),\n                       virInterfaceTypeToString(type));\n        goto error;\n    }\n    def->type = type;\n\n    if (virInterfaceDefParseName(def, ctxt) < 0)\n       goto error;\n\n    if (parentIfType == VIR_INTERFACE_TYPE_LAST) {\n        /* only recognize these in toplevel bond interfaces */\n        if (virInterfaceDefParseStartMode(def, ctxt) < 0)\n            goto error;\n        if (virInterfaceDefParseMtu(def, ctxt) < 0)\n            goto error;\n        if (virInterfaceDefParseIfAdressing(def, ctxt) < 0)\n            goto error;\n    }\n\n    if (type != VIR_INTERFACE_TYPE_BRIDGE) {\n        /* link status makes no sense for a bridge */\n        lnk = virXPathNode(\"./link\", ctxt);\n        if (lnk && virInterfaceLinkParseXML(lnk, &def->lnk) < 0)\n            goto error;\n    }\n\n    switch (type) {\n        case VIR_INTERFACE_TYPE_ETHERNET:\n            if ((tmp = virXPathString(\"string(./mac/@address)\", ctxt)))\n                def->mac = tmp;\n            break;\n        case VIR_INTERFACE_TYPE_BRIDGE: {\n            xmlNodePtr bridge;\n\n            if (!(bridge = virXPathNode(\"./bridge[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"bridge interface misses the bridge element\"));\n                goto error;\n            }\n            ctxt->node = bridge;\n            if (virInterfaceDefParseBridge(def, ctxt) < 0)\n                goto error;\n            break;\n        }\n        case VIR_INTERFACE_TYPE_BOND: {\n            xmlNodePtr bond;\n\n            if (!(bond = virXPathNode(\"./bond[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"bond interface misses the bond element\"));\n                goto error;\n            }\n            ctxt->node = bond;\n            if (virInterfaceDefParseBond(def, ctxt)  < 0)\n                goto error;\n            break;\n        }\n        case VIR_INTERFACE_TYPE_VLAN: {\n            xmlNodePtr vlan;\n\n            if (!(vlan = virXPathNode(\"./vlan[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"vlan interface misses the vlan element\"));\n                goto error;\n            }\n            ctxt->node = vlan;\n            if (virInterfaceDefParseVlan(def, ctxt)  < 0)\n                goto error;\n            break;\n        }\n\n    }\n\n    ctxt->node = cur;\n    return def;\n\n error:\n    ctxt->node = cur;\n    virInterfaceDefFree(def);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt, int parentIfType);",
            "static int\nvirInterfaceDefDevFormat(virBufferPtr buf, const virInterfaceDef *def,\n                         virInterfaceType parentIfType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt, int parentIfType);\nstatic int\nvirInterfaceDefDevFormat(virBufferPtr buf, const virInterfaceDef *def,\n                         virInterfaceType parentIfType);\n\nstatic virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt,\n                        int parentIfType)\n{\n    virInterfaceDefPtr def;\n    int type;\n    char *tmp;\n    xmlNodePtr cur = ctxt->node;\n    xmlNodePtr lnk;\n\n\n    /* check @type */\n    tmp = virXPathString(\"string(./@type)\", ctxt);\n    if (tmp == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"interface misses the type attribute\"));\n        return NULL;\n    }\n    type = virInterfaceTypeFromString(tmp);\n    if (type == -1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown interface type %s\"), tmp);\n        VIR_FREE(tmp);\n        return NULL;\n    }\n    VIR_FREE(tmp);\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (((parentIfType == VIR_INTERFACE_TYPE_BOND)\n         && (type != VIR_INTERFACE_TYPE_ETHERNET))\n        || ((parentIfType == VIR_INTERFACE_TYPE_BRIDGE)\n            && (type != VIR_INTERFACE_TYPE_ETHERNET)\n            && (type != VIR_INTERFACE_TYPE_BOND)\n            && (type != VIR_INTERFACE_TYPE_VLAN))\n        || (parentIfType == VIR_INTERFACE_TYPE_ETHERNET)\n        || (parentIfType == VIR_INTERFACE_TYPE_VLAN))\n        {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"interface has unsupported type '%s'\"),\n                       virInterfaceTypeToString(type));\n        goto error;\n    }\n    def->type = type;\n\n    if (virInterfaceDefParseName(def, ctxt) < 0)\n       goto error;\n\n    if (parentIfType == VIR_INTERFACE_TYPE_LAST) {\n        /* only recognize these in toplevel bond interfaces */\n        if (virInterfaceDefParseStartMode(def, ctxt) < 0)\n            goto error;\n        if (virInterfaceDefParseMtu(def, ctxt) < 0)\n            goto error;\n        if (virInterfaceDefParseIfAdressing(def, ctxt) < 0)\n            goto error;\n    }\n\n    if (type != VIR_INTERFACE_TYPE_BRIDGE) {\n        /* link status makes no sense for a bridge */\n        lnk = virXPathNode(\"./link\", ctxt);\n        if (lnk && virInterfaceLinkParseXML(lnk, &def->lnk) < 0)\n            goto error;\n    }\n\n    switch (type) {\n        case VIR_INTERFACE_TYPE_ETHERNET:\n            if ((tmp = virXPathString(\"string(./mac/@address)\", ctxt)))\n                def->mac = tmp;\n            break;\n        case VIR_INTERFACE_TYPE_BRIDGE: {\n            xmlNodePtr bridge;\n\n            if (!(bridge = virXPathNode(\"./bridge[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"bridge interface misses the bridge element\"));\n                goto error;\n            }\n            ctxt->node = bridge;\n            if (virInterfaceDefParseBridge(def, ctxt) < 0)\n                goto error;\n            break;\n        }\n        case VIR_INTERFACE_TYPE_BOND: {\n            xmlNodePtr bond;\n\n            if (!(bond = virXPathNode(\"./bond[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"bond interface misses the bond element\"));\n                goto error;\n            }\n            ctxt->node = bond;\n            if (virInterfaceDefParseBond(def, ctxt)  < 0)\n                goto error;\n            break;\n        }\n        case VIR_INTERFACE_TYPE_VLAN: {\n            xmlNodePtr vlan;\n\n            if (!(vlan = virXPathNode(\"./vlan[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"vlan interface misses the vlan element\"));\n                goto error;\n            }\n            ctxt->node = vlan;\n            if (virInterfaceDefParseVlan(def, ctxt)  < 0)\n                goto error;\n            break;\n        }\n\n    }\n\n    ctxt->node = cur;\n    return def;\n\n error:\n    ctxt->node = cur;\n    virInterfaceDefFree(def);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLXPathContextNew",
          "args": [
            "xml"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLXPathContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "48-59",
          "snippet": "xmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unexpected root element <%s>, \"\n                         \"expecting <interface>\")",
            "root->name"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unexpected root element <%s>, \"\n                         \"expecting <interface>\""
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLNodeNameEqual",
          "args": [
            "root",
            "\"interface\""
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeNameEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1013-1018",
          "snippet": "bool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirInterfaceDefPtr\nvirInterfaceDefParseNode(xmlDocPtr xml,\n                         xmlNodePtr root)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"interface\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <interface>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virInterfaceDefParseXML(ctxt, VIR_INTERFACE_TYPE_LAST);\n}"
  },
  {
    "function_name": "virInterfaceDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "694-814",
    "snippet": "static virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt,\n                        int parentIfType)\n{\n    virInterfaceDefPtr def;\n    int type;\n    char *tmp;\n    xmlNodePtr cur = ctxt->node;\n    xmlNodePtr lnk;\n\n\n    /* check @type */\n    tmp = virXPathString(\"string(./@type)\", ctxt);\n    if (tmp == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"interface misses the type attribute\"));\n        return NULL;\n    }\n    type = virInterfaceTypeFromString(tmp);\n    if (type == -1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown interface type %s\"), tmp);\n        VIR_FREE(tmp);\n        return NULL;\n    }\n    VIR_FREE(tmp);\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (((parentIfType == VIR_INTERFACE_TYPE_BOND)\n         && (type != VIR_INTERFACE_TYPE_ETHERNET))\n        || ((parentIfType == VIR_INTERFACE_TYPE_BRIDGE)\n            && (type != VIR_INTERFACE_TYPE_ETHERNET)\n            && (type != VIR_INTERFACE_TYPE_BOND)\n            && (type != VIR_INTERFACE_TYPE_VLAN))\n        || (parentIfType == VIR_INTERFACE_TYPE_ETHERNET)\n        || (parentIfType == VIR_INTERFACE_TYPE_VLAN))\n        {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"interface has unsupported type '%s'\"),\n                       virInterfaceTypeToString(type));\n        goto error;\n    }\n    def->type = type;\n\n    if (virInterfaceDefParseName(def, ctxt) < 0)\n       goto error;\n\n    if (parentIfType == VIR_INTERFACE_TYPE_LAST) {\n        /* only recognize these in toplevel bond interfaces */\n        if (virInterfaceDefParseStartMode(def, ctxt) < 0)\n            goto error;\n        if (virInterfaceDefParseMtu(def, ctxt) < 0)\n            goto error;\n        if (virInterfaceDefParseIfAdressing(def, ctxt) < 0)\n            goto error;\n    }\n\n    if (type != VIR_INTERFACE_TYPE_BRIDGE) {\n        /* link status makes no sense for a bridge */\n        lnk = virXPathNode(\"./link\", ctxt);\n        if (lnk && virInterfaceLinkParseXML(lnk, &def->lnk) < 0)\n            goto error;\n    }\n\n    switch (type) {\n        case VIR_INTERFACE_TYPE_ETHERNET:\n            if ((tmp = virXPathString(\"string(./mac/@address)\", ctxt)))\n                def->mac = tmp;\n            break;\n        case VIR_INTERFACE_TYPE_BRIDGE: {\n            xmlNodePtr bridge;\n\n            if (!(bridge = virXPathNode(\"./bridge[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"bridge interface misses the bridge element\"));\n                goto error;\n            }\n            ctxt->node = bridge;\n            if (virInterfaceDefParseBridge(def, ctxt) < 0)\n                goto error;\n            break;\n        }\n        case VIR_INTERFACE_TYPE_BOND: {\n            xmlNodePtr bond;\n\n            if (!(bond = virXPathNode(\"./bond[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"bond interface misses the bond element\"));\n                goto error;\n            }\n            ctxt->node = bond;\n            if (virInterfaceDefParseBond(def, ctxt)  < 0)\n                goto error;\n            break;\n        }\n        case VIR_INTERFACE_TYPE_VLAN: {\n            xmlNodePtr vlan;\n\n            if (!(vlan = virXPathNode(\"./vlan[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"vlan interface misses the vlan element\"));\n                goto error;\n            }\n            ctxt->node = vlan;\n            if (virInterfaceDefParseVlan(def, ctxt)  < 0)\n                goto error;\n            break;\n        }\n\n    }\n\n    ctxt->node = cur;\n    return def;\n\n error:\n    ctxt->node = cur;\n    virInterfaceDefFree(def);\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt, int parentIfType);",
      "static int\nvirInterfaceDefDevFormat(virBufferPtr buf, const virInterfaceDef *def,\n                         virInterfaceType parentIfType);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "def"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseVlan",
          "args": [
            "def",
            "ctxt"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseVlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "672-691",
          "snippet": "static int\nvirInterfaceDefParseVlan(virInterfaceDefPtr def,\n                         xmlXPathContextPtr ctxt)\n{\n    def->data.vlan.tag = virXPathString(\"string(./@tag)\", ctxt);\n    if (def->data.vlan.tag == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"vlan interface misses the tag attribute\"));\n        return -1;\n    }\n\n    def->data.vlan.dev_name =\n         virXPathString(\"string(./interface/@name)\", ctxt);\n    if (def->data.vlan.dev_name == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"vlan interface misses name attribute\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseVlan(virInterfaceDefPtr def,\n                         xmlXPathContextPtr ctxt)\n{\n    def->data.vlan.tag = virXPathString(\"string(./@tag)\", ctxt);\n    if (def->data.vlan.tag == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"vlan interface misses the tag attribute\"));\n        return -1;\n    }\n\n    def->data.vlan.dev_name =\n         virXPathString(\"string(./interface/@name)\", ctxt);\n    if (def->data.vlan.dev_name == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"vlan interface misses name attribute\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"vlan interface misses the vlan element\")"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"vlan interface misses the vlan element\""
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./vlan[1]\"",
            "ctxt"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseBond",
          "args": [
            "def",
            "ctxt"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseBond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "599-669",
          "snippet": "static int\nvirInterfaceDefParseBond(virInterfaceDefPtr def,\n                         xmlXPathContextPtr ctxt)\n{\n    int res;\n\n    def->data.bond.mode = virInterfaceDefParseBondMode(ctxt);\n    if (def->data.bond.mode < 0)\n        return -1;\n\n    if (virInterfaceDefParseBondItfs(def, ctxt) != 0)\n        return -1;\n\n    if (virXPathNode(\"./miimon[1]\", ctxt) != NULL) {\n        def->data.bond.monit = VIR_INTERFACE_BOND_MONIT_MII;\n\n        res = virXPathInt(\"string(./miimon/@freq)\", ctxt,\n                          &def->data.bond.frequency);\n        if ((res == -2) || (res == -1)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface miimon freq missing or invalid\"));\n            return -1;\n        }\n\n        res = virXPathInt(\"string(./miimon/@downdelay)\", ctxt,\n                          &def->data.bond.downdelay);\n        if (res == -2) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface miimon downdelay invalid\"));\n            return -1;\n        }\n\n        res = virXPathInt(\"string(./miimon/@updelay)\", ctxt,\n                          &def->data.bond.updelay);\n        if (res == -2) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface miimon updelay invalid\"));\n            return -1;\n        }\n\n        def->data.bond.carrier = virInterfaceDefParseBondMiiCarrier(ctxt);\n        if (def->data.bond.carrier < 0)\n            return -1;\n\n    } else if (virXPathNode(\"./arpmon[1]\", ctxt) != NULL) {\n\n        def->data.bond.monit = VIR_INTERFACE_BOND_MONIT_ARP;\n\n        res = virXPathInt(\"string(./arpmon/@interval)\", ctxt,\n                          &def->data.bond.interval);\n        if ((res == -2) || (res == -1)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface arpmon interval missing or invalid\"));\n            return -1;\n        }\n\n        def->data.bond.target =\n            virXPathString(\"string(./arpmon/@target)\", ctxt);\n        if (def->data.bond.target == NULL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface arpmon target missing\"));\n            return -1;\n        }\n\n        def->data.bond.validate = virInterfaceDefParseBondArpValid(ctxt);\n        if (def->data.bond.validate < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseBond(virInterfaceDefPtr def,\n                         xmlXPathContextPtr ctxt)\n{\n    int res;\n\n    def->data.bond.mode = virInterfaceDefParseBondMode(ctxt);\n    if (def->data.bond.mode < 0)\n        return -1;\n\n    if (virInterfaceDefParseBondItfs(def, ctxt) != 0)\n        return -1;\n\n    if (virXPathNode(\"./miimon[1]\", ctxt) != NULL) {\n        def->data.bond.monit = VIR_INTERFACE_BOND_MONIT_MII;\n\n        res = virXPathInt(\"string(./miimon/@freq)\", ctxt,\n                          &def->data.bond.frequency);\n        if ((res == -2) || (res == -1)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface miimon freq missing or invalid\"));\n            return -1;\n        }\n\n        res = virXPathInt(\"string(./miimon/@downdelay)\", ctxt,\n                          &def->data.bond.downdelay);\n        if (res == -2) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface miimon downdelay invalid\"));\n            return -1;\n        }\n\n        res = virXPathInt(\"string(./miimon/@updelay)\", ctxt,\n                          &def->data.bond.updelay);\n        if (res == -2) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface miimon updelay invalid\"));\n            return -1;\n        }\n\n        def->data.bond.carrier = virInterfaceDefParseBondMiiCarrier(ctxt);\n        if (def->data.bond.carrier < 0)\n            return -1;\n\n    } else if (virXPathNode(\"./arpmon[1]\", ctxt) != NULL) {\n\n        def->data.bond.monit = VIR_INTERFACE_BOND_MONIT_ARP;\n\n        res = virXPathInt(\"string(./arpmon/@interval)\", ctxt,\n                          &def->data.bond.interval);\n        if ((res == -2) || (res == -1)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface arpmon interval missing or invalid\"));\n            return -1;\n        }\n\n        def->data.bond.target =\n            virXPathString(\"string(./arpmon/@target)\", ctxt);\n        if (def->data.bond.target == NULL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface arpmon target missing\"));\n            return -1;\n        }\n\n        def->data.bond.validate = virInterfaceDefParseBondArpValid(ctxt);\n        if (def->data.bond.validate < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"bond interface misses the bond element\")"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseBridge",
          "args": [
            "def",
            "ctxt"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseBridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "496-553",
          "snippet": "static int\nvirInterfaceDefParseBridge(virInterfaceDefPtr def,\n                           xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr *interfaces = NULL;\n    xmlNodePtr bridge;\n    virInterfaceDefPtr itf;\n    char *tmp = NULL;\n    int nbItf;\n    size_t i;\n    int ret = 0;\n\n    bridge = ctxt->node;\n    def->data.bridge.stp = -1;\n    if ((tmp = virXMLPropString(bridge, \"stp\"))) {\n        if (STREQ(tmp, \"on\")) {\n            def->data.bridge.stp = 1;\n        } else if (STREQ(tmp, \"off\")) {\n            def->data.bridge.stp = 0;\n        } else {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge interface stp should be on or off got %s\"),\n                           tmp);\n            goto error;\n        }\n    }\n    def->data.bridge.delay = virXMLPropString(bridge, \"delay\");\n\n    nbItf = virXPathNodeSet(\"./interface\", ctxt, &interfaces);\n    if (nbItf < 0) {\n        ret = -1;\n        goto error;\n    }\n    if (nbItf > 0) {\n        if (VIR_ALLOC_N(def->data.bridge.itf, nbItf) < 0) {\n            ret = -1;\n            goto error;\n        }\n        def->data.bridge.nbItf = nbItf;\n\n        for (i = 0; i < nbItf; i++) {\n            ctxt->node = interfaces[i];\n            itf = virInterfaceDefParseXML(ctxt, VIR_INTERFACE_TYPE_BRIDGE);\n            if (itf == NULL) {\n                ret = -1;\n                def->data.bridge.nbItf = i;\n                goto error;\n            }\n            def->data.bridge.itf[i] = itf;\n        }\n    }\n\n error:\n    VIR_FREE(tmp);\n    VIR_FREE(interfaces);\n    ctxt->node = bridge;\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseBridge(virInterfaceDefPtr def,\n                           xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr *interfaces = NULL;\n    xmlNodePtr bridge;\n    virInterfaceDefPtr itf;\n    char *tmp = NULL;\n    int nbItf;\n    size_t i;\n    int ret = 0;\n\n    bridge = ctxt->node;\n    def->data.bridge.stp = -1;\n    if ((tmp = virXMLPropString(bridge, \"stp\"))) {\n        if (STREQ(tmp, \"on\")) {\n            def->data.bridge.stp = 1;\n        } else if (STREQ(tmp, \"off\")) {\n            def->data.bridge.stp = 0;\n        } else {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge interface stp should be on or off got %s\"),\n                           tmp);\n            goto error;\n        }\n    }\n    def->data.bridge.delay = virXMLPropString(bridge, \"delay\");\n\n    nbItf = virXPathNodeSet(\"./interface\", ctxt, &interfaces);\n    if (nbItf < 0) {\n        ret = -1;\n        goto error;\n    }\n    if (nbItf > 0) {\n        if (VIR_ALLOC_N(def->data.bridge.itf, nbItf) < 0) {\n            ret = -1;\n            goto error;\n        }\n        def->data.bridge.nbItf = nbItf;\n\n        for (i = 0; i < nbItf; i++) {\n            ctxt->node = interfaces[i];\n            itf = virInterfaceDefParseXML(ctxt, VIR_INTERFACE_TYPE_BRIDGE);\n            if (itf == NULL) {\n                ret = -1;\n                def->data.bridge.nbItf = i;\n                goto error;\n            }\n            def->data.bridge.itf[i] = itf;\n        }\n    }\n\n error:\n    VIR_FREE(tmp);\n    VIR_FREE(interfaces);\n    ctxt->node = bridge;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"bridge interface misses the bridge element\")"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./mac/@address)\"",
            "ctxt"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceLinkParseXML",
          "args": [
            "lnk",
            "&def->lnk"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceLinkParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "610-644",
          "snippet": "int\nvirInterfaceLinkParseXML(xmlNodePtr node,\n                         virNetDevIfLinkPtr lnk)\n{\n    int ret = -1;\n    char *stateStr, *speedStr;\n    int state;\n\n    stateStr = virXMLPropString(node, \"state\");\n    speedStr = virXMLPropString(node, \"speed\");\n\n    if (stateStr) {\n        if ((state = virNetDevIfStateTypeFromString(stateStr)) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown link state: %s\"),\n                           stateStr);\n            goto cleanup;\n        }\n        lnk->state = state;\n    }\n\n    if (speedStr &&\n        virStrToLong_ui(speedStr, NULL, 10, &lnk->speed) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Unable to parse link speed: %s\"),\n                       speedStr);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(stateStr);\n    VIR_FREE(speedStr);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirInterfaceLinkParseXML(xmlNodePtr node,\n                         virNetDevIfLinkPtr lnk)\n{\n    int ret = -1;\n    char *stateStr, *speedStr;\n    int state;\n\n    stateStr = virXMLPropString(node, \"state\");\n    speedStr = virXMLPropString(node, \"speed\");\n\n    if (stateStr) {\n        if ((state = virNetDevIfStateTypeFromString(stateStr)) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown link state: %s\"),\n                           stateStr);\n            goto cleanup;\n        }\n        lnk->state = state;\n    }\n\n    if (speedStr &&\n        virStrToLong_ui(speedStr, NULL, 10, &lnk->speed) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Unable to parse link speed: %s\"),\n                       speedStr);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(stateStr);\n    VIR_FREE(speedStr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseIfAdressing",
          "args": [
            "def",
            "ctxt"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseIfAdressing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "425-493",
          "snippet": "static int\nvirInterfaceDefParseIfAdressing(virInterfaceDefPtr def,\n                                xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr save;\n    xmlNodePtr *protoNodes = NULL;\n    int nProtoNodes, pp, ret = -1;\n    char *tmp;\n\n    save = ctxt->node;\n\n    nProtoNodes = virXPathNodeSet(\"./protocol\", ctxt, &protoNodes);\n    if (nProtoNodes < 0)\n        goto error;\n\n    if (nProtoNodes == 0) {\n        /* no protocols is an acceptable outcome */\n        return 0;\n    }\n\n    if (VIR_ALLOC_N(def->protos, nProtoNodes) < 0)\n        goto error;\n\n    def->nprotos = 0;\n    for (pp = 0; pp < nProtoNodes; pp++) {\n\n        virInterfaceProtocolDefPtr proto;\n\n        if (VIR_ALLOC(proto) < 0)\n            goto error;\n\n        ctxt->node = protoNodes[pp];\n        tmp = virXPathString(\"string(./@family)\", ctxt);\n        if (tmp == NULL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"protocol misses the family attribute\"));\n            virInterfaceProtocolDefFree(proto);\n            goto error;\n        }\n        proto->family = tmp;\n        if (STREQ(tmp, \"ipv4\")) {\n            ret = virInterfaceDefParseProtoIPv4(proto, ctxt);\n            if (ret != 0) {\n                virInterfaceProtocolDefFree(proto);\n                goto error;\n            }\n        } else if (STREQ(tmp, \"ipv6\")) {\n            ret = virInterfaceDefParseProtoIPv6(proto, ctxt);\n            if (ret != 0) {\n                virInterfaceProtocolDefFree(proto);\n                goto error;\n            }\n        } else {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unsupported protocol family '%s'\"), tmp);\n            virInterfaceProtocolDefFree(proto);\n            goto error;\n        }\n        def->protos[def->nprotos++] = proto;\n    }\n\n    ret = 0;\n\n error:\n    VIR_FREE(protoNodes);\n    ctxt->node = save;\n    return ret;\n\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseIfAdressing(virInterfaceDefPtr def,\n                                xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr save;\n    xmlNodePtr *protoNodes = NULL;\n    int nProtoNodes, pp, ret = -1;\n    char *tmp;\n\n    save = ctxt->node;\n\n    nProtoNodes = virXPathNodeSet(\"./protocol\", ctxt, &protoNodes);\n    if (nProtoNodes < 0)\n        goto error;\n\n    if (nProtoNodes == 0) {\n        /* no protocols is an acceptable outcome */\n        return 0;\n    }\n\n    if (VIR_ALLOC_N(def->protos, nProtoNodes) < 0)\n        goto error;\n\n    def->nprotos = 0;\n    for (pp = 0; pp < nProtoNodes; pp++) {\n\n        virInterfaceProtocolDefPtr proto;\n\n        if (VIR_ALLOC(proto) < 0)\n            goto error;\n\n        ctxt->node = protoNodes[pp];\n        tmp = virXPathString(\"string(./@family)\", ctxt);\n        if (tmp == NULL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"protocol misses the family attribute\"));\n            virInterfaceProtocolDefFree(proto);\n            goto error;\n        }\n        proto->family = tmp;\n        if (STREQ(tmp, \"ipv4\")) {\n            ret = virInterfaceDefParseProtoIPv4(proto, ctxt);\n            if (ret != 0) {\n                virInterfaceProtocolDefFree(proto);\n                goto error;\n            }\n        } else if (STREQ(tmp, \"ipv6\")) {\n            ret = virInterfaceDefParseProtoIPv6(proto, ctxt);\n            if (ret != 0) {\n                virInterfaceProtocolDefFree(proto);\n                goto error;\n            }\n        } else {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unsupported protocol family '%s'\"), tmp);\n            virInterfaceProtocolDefFree(proto);\n            goto error;\n        }\n        def->protos[def->nprotos++] = proto;\n    }\n\n    ret = 0;\n\n error:\n    VIR_FREE(protoNodes);\n    ctxt->node = save;\n    return ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseMtu",
          "args": [
            "def",
            "ctxt"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseMtu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "135-151",
          "snippet": "static int\nvirInterfaceDefParseMtu(virInterfaceDefPtr def,\n                        xmlXPathContextPtr ctxt)\n{\n    unsigned long mtu;\n    int ret;\n\n    ret = virXPathULong(\"string(./mtu/@size)\", ctxt, &mtu);\n    if ((ret == -2) || ((ret == 0) && (mtu > 100000))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"interface mtu value is improper\"));\n        return -1;\n    } else if (ret == 0) {\n        def->mtu = (unsigned int) mtu;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseMtu(virInterfaceDefPtr def,\n                        xmlXPathContextPtr ctxt)\n{\n    unsigned long mtu;\n    int ret;\n\n    ret = virXPathULong(\"string(./mtu/@size)\", ctxt, &mtu);\n    if ((ret == -2) || ((ret == 0) && (mtu > 100000))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"interface mtu value is improper\"));\n        return -1;\n    } else if (ret == 0) {\n        def->mtu = (unsigned int) mtu;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseStartMode",
          "args": [
            "def",
            "ctxt"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseStartMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "154-177",
          "snippet": "static int\nvirInterfaceDefParseStartMode(virInterfaceDefPtr def,\n                              xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n\n    tmp = virXPathString(\"string(./start/@mode)\", ctxt);\n    if (tmp == NULL) {\n        def->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    } else if (STREQ(tmp, \"onboot\")) {\n        def->startmode = VIR_INTERFACE_START_ONBOOT;\n    } else if (STREQ(tmp, \"hotplug\")) {\n        def->startmode = VIR_INTERFACE_START_HOTPLUG;\n    } else if (STREQ(tmp, \"none\")) {\n        def->startmode = VIR_INTERFACE_START_NONE;\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unknown interface startmode %s\"), tmp);\n        VIR_FREE(tmp);\n        return -1;\n    }\n    VIR_FREE(tmp);\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseStartMode(virInterfaceDefPtr def,\n                              xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n\n    tmp = virXPathString(\"string(./start/@mode)\", ctxt);\n    if (tmp == NULL) {\n        def->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    } else if (STREQ(tmp, \"onboot\")) {\n        def->startmode = VIR_INTERFACE_START_ONBOOT;\n    } else if (STREQ(tmp, \"hotplug\")) {\n        def->startmode = VIR_INTERFACE_START_HOTPLUG;\n    } else if (STREQ(tmp, \"none\")) {\n        def->startmode = VIR_INTERFACE_START_NONE;\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unknown interface startmode %s\"), tmp);\n        VIR_FREE(tmp);\n        return -1;\n    }\n    VIR_FREE(tmp);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseName",
          "args": [
            "def",
            "ctxt"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "118-132",
          "snippet": "static int\nvirInterfaceDefParseName(virInterfaceDefPtr def,\n                         xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n\n    tmp = virXPathString(\"string(./@name)\", ctxt);\n    if (tmp == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\",  _(\"interface has no name\"));\n        return -1;\n    }\n    def->name = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseName(virInterfaceDefPtr def,\n                         xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n\n    tmp = virXPathString(\"string(./@name)\", ctxt);\n    if (tmp == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\",  _(\"interface has no name\"));\n        return -1;\n    }\n    def->name = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"interface has unsupported type '%s'\")",
            "virInterfaceTypeToString(type)"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceTypeToString",
          "args": [
            "type"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unknown interface type %s\")",
            "tmp"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceTypeFromString",
          "args": [
            "tmp"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"interface misses the type attribute\")"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt, int parentIfType);\nstatic int\nvirInterfaceDefDevFormat(virBufferPtr buf, const virInterfaceDef *def,\n                         virInterfaceType parentIfType);\n\nstatic virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt,\n                        int parentIfType)\n{\n    virInterfaceDefPtr def;\n    int type;\n    char *tmp;\n    xmlNodePtr cur = ctxt->node;\n    xmlNodePtr lnk;\n\n\n    /* check @type */\n    tmp = virXPathString(\"string(./@type)\", ctxt);\n    if (tmp == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"interface misses the type attribute\"));\n        return NULL;\n    }\n    type = virInterfaceTypeFromString(tmp);\n    if (type == -1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown interface type %s\"), tmp);\n        VIR_FREE(tmp);\n        return NULL;\n    }\n    VIR_FREE(tmp);\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (((parentIfType == VIR_INTERFACE_TYPE_BOND)\n         && (type != VIR_INTERFACE_TYPE_ETHERNET))\n        || ((parentIfType == VIR_INTERFACE_TYPE_BRIDGE)\n            && (type != VIR_INTERFACE_TYPE_ETHERNET)\n            && (type != VIR_INTERFACE_TYPE_BOND)\n            && (type != VIR_INTERFACE_TYPE_VLAN))\n        || (parentIfType == VIR_INTERFACE_TYPE_ETHERNET)\n        || (parentIfType == VIR_INTERFACE_TYPE_VLAN))\n        {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"interface has unsupported type '%s'\"),\n                       virInterfaceTypeToString(type));\n        goto error;\n    }\n    def->type = type;\n\n    if (virInterfaceDefParseName(def, ctxt) < 0)\n       goto error;\n\n    if (parentIfType == VIR_INTERFACE_TYPE_LAST) {\n        /* only recognize these in toplevel bond interfaces */\n        if (virInterfaceDefParseStartMode(def, ctxt) < 0)\n            goto error;\n        if (virInterfaceDefParseMtu(def, ctxt) < 0)\n            goto error;\n        if (virInterfaceDefParseIfAdressing(def, ctxt) < 0)\n            goto error;\n    }\n\n    if (type != VIR_INTERFACE_TYPE_BRIDGE) {\n        /* link status makes no sense for a bridge */\n        lnk = virXPathNode(\"./link\", ctxt);\n        if (lnk && virInterfaceLinkParseXML(lnk, &def->lnk) < 0)\n            goto error;\n    }\n\n    switch (type) {\n        case VIR_INTERFACE_TYPE_ETHERNET:\n            if ((tmp = virXPathString(\"string(./mac/@address)\", ctxt)))\n                def->mac = tmp;\n            break;\n        case VIR_INTERFACE_TYPE_BRIDGE: {\n            xmlNodePtr bridge;\n\n            if (!(bridge = virXPathNode(\"./bridge[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"bridge interface misses the bridge element\"));\n                goto error;\n            }\n            ctxt->node = bridge;\n            if (virInterfaceDefParseBridge(def, ctxt) < 0)\n                goto error;\n            break;\n        }\n        case VIR_INTERFACE_TYPE_BOND: {\n            xmlNodePtr bond;\n\n            if (!(bond = virXPathNode(\"./bond[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"bond interface misses the bond element\"));\n                goto error;\n            }\n            ctxt->node = bond;\n            if (virInterfaceDefParseBond(def, ctxt)  < 0)\n                goto error;\n            break;\n        }\n        case VIR_INTERFACE_TYPE_VLAN: {\n            xmlNodePtr vlan;\n\n            if (!(vlan = virXPathNode(\"./vlan[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"vlan interface misses the vlan element\"));\n                goto error;\n            }\n            ctxt->node = vlan;\n            if (virInterfaceDefParseVlan(def, ctxt)  < 0)\n                goto error;\n            break;\n        }\n\n    }\n\n    ctxt->node = cur;\n    return def;\n\n error:\n    ctxt->node = cur;\n    virInterfaceDefFree(def);\n    return NULL;\n}"
  },
  {
    "function_name": "virInterfaceDefParseVlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "672-691",
    "snippet": "static int\nvirInterfaceDefParseVlan(virInterfaceDefPtr def,\n                         xmlXPathContextPtr ctxt)\n{\n    def->data.vlan.tag = virXPathString(\"string(./@tag)\", ctxt);\n    if (def->data.vlan.tag == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"vlan interface misses the tag attribute\"));\n        return -1;\n    }\n\n    def->data.vlan.dev_name =\n         virXPathString(\"string(./interface/@name)\", ctxt);\n    if (def->data.vlan.dev_name == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"vlan interface misses name attribute\"));\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"vlan interface misses name attribute\")"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"vlan interface misses name attribute\""
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./interface/@name)\"",
            "ctxt"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"vlan interface misses the tag attribute\")"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseVlan(virInterfaceDefPtr def,\n                         xmlXPathContextPtr ctxt)\n{\n    def->data.vlan.tag = virXPathString(\"string(./@tag)\", ctxt);\n    if (def->data.vlan.tag == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"vlan interface misses the tag attribute\"));\n        return -1;\n    }\n\n    def->data.vlan.dev_name =\n         virXPathString(\"string(./interface/@name)\", ctxt);\n    if (def->data.vlan.dev_name == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"vlan interface misses name attribute\"));\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virInterfaceDefParseBond",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "599-669",
    "snippet": "static int\nvirInterfaceDefParseBond(virInterfaceDefPtr def,\n                         xmlXPathContextPtr ctxt)\n{\n    int res;\n\n    def->data.bond.mode = virInterfaceDefParseBondMode(ctxt);\n    if (def->data.bond.mode < 0)\n        return -1;\n\n    if (virInterfaceDefParseBondItfs(def, ctxt) != 0)\n        return -1;\n\n    if (virXPathNode(\"./miimon[1]\", ctxt) != NULL) {\n        def->data.bond.monit = VIR_INTERFACE_BOND_MONIT_MII;\n\n        res = virXPathInt(\"string(./miimon/@freq)\", ctxt,\n                          &def->data.bond.frequency);\n        if ((res == -2) || (res == -1)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface miimon freq missing or invalid\"));\n            return -1;\n        }\n\n        res = virXPathInt(\"string(./miimon/@downdelay)\", ctxt,\n                          &def->data.bond.downdelay);\n        if (res == -2) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface miimon downdelay invalid\"));\n            return -1;\n        }\n\n        res = virXPathInt(\"string(./miimon/@updelay)\", ctxt,\n                          &def->data.bond.updelay);\n        if (res == -2) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface miimon updelay invalid\"));\n            return -1;\n        }\n\n        def->data.bond.carrier = virInterfaceDefParseBondMiiCarrier(ctxt);\n        if (def->data.bond.carrier < 0)\n            return -1;\n\n    } else if (virXPathNode(\"./arpmon[1]\", ctxt) != NULL) {\n\n        def->data.bond.monit = VIR_INTERFACE_BOND_MONIT_ARP;\n\n        res = virXPathInt(\"string(./arpmon/@interval)\", ctxt,\n                          &def->data.bond.interval);\n        if ((res == -2) || (res == -1)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface arpmon interval missing or invalid\"));\n            return -1;\n        }\n\n        def->data.bond.target =\n            virXPathString(\"string(./arpmon/@target)\", ctxt);\n        if (def->data.bond.target == NULL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface arpmon target missing\"));\n            return -1;\n        }\n\n        def->data.bond.validate = virInterfaceDefParseBondArpValid(ctxt);\n        if (def->data.bond.validate < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virInterfaceDefParseBondArpValid",
          "args": [
            "ctxt"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseBondArpValid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "236-258",
          "snippet": "static int\nvirInterfaceDefParseBondArpValid(xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n    int ret = 0;\n\n    tmp = virXPathString(\"string(./arpmon/@validate)\", ctxt);\n    if (tmp == NULL)\n        return VIR_INTERFACE_BOND_ARP_NONE;\n    if (STREQ(tmp, \"active\")) {\n        ret = VIR_INTERFACE_BOND_ARP_ACTIVE;\n    } else if (STREQ(tmp, \"backup\")) {\n        ret = VIR_INTERFACE_BOND_ARP_BACKUP;\n    } else if (STREQ(tmp, \"all\")) {\n        ret = VIR_INTERFACE_BOND_ARP_ALL;\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unknown arp bonding validate %s\"), tmp);\n        ret = -1;\n    }\n    VIR_FREE(tmp);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseBondArpValid(xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n    int ret = 0;\n\n    tmp = virXPathString(\"string(./arpmon/@validate)\", ctxt);\n    if (tmp == NULL)\n        return VIR_INTERFACE_BOND_ARP_NONE;\n    if (STREQ(tmp, \"active\")) {\n        ret = VIR_INTERFACE_BOND_ARP_ACTIVE;\n    } else if (STREQ(tmp, \"backup\")) {\n        ret = VIR_INTERFACE_BOND_ARP_BACKUP;\n    } else if (STREQ(tmp, \"all\")) {\n        ret = VIR_INTERFACE_BOND_ARP_ALL;\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unknown arp bonding validate %s\"), tmp);\n        ret = -1;\n    }\n    VIR_FREE(tmp);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"bond interface arpmon target missing\")"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"bond interface arpmon target missing\""
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./arpmon/@target)\"",
            "ctxt"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"bond interface arpmon interval missing or invalid\")"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathInt",
          "args": [
            "\"string(./arpmon/@interval)\"",
            "ctxt",
            "&def->data.bond.interval"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "223-238",
          "snippet": "int\nvirXPathInt(const char *xpath,\n            xmlXPathContextPtr ctxt,\n            int *value)\n{\n    long tmp;\n    int ret;\n\n    ret = virXPathLongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathInt(const char *xpath,\n            xmlXPathContextPtr ctxt,\n            int *value)\n{\n    long tmp;\n    int ret;\n\n    ret = virXPathLongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./arpmon[1]\"",
            "ctxt"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseBondMiiCarrier",
          "args": [
            "ctxt"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseBondMiiCarrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "213-233",
          "snippet": "static int\nvirInterfaceDefParseBondMiiCarrier(xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n    int ret = 0;\n\n    tmp = virXPathString(\"string(./miimon/@carrier)\", ctxt);\n    if (tmp == NULL)\n        return VIR_INTERFACE_BOND_MII_NONE;\n    if (STREQ(tmp, \"ioctl\")) {\n        ret = VIR_INTERFACE_BOND_MII_IOCTL;\n    } else if (STREQ(tmp, \"netif\")) {\n        ret = VIR_INTERFACE_BOND_MII_NETIF;\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unknown mii bonding carrier %s\"), tmp);\n        ret = -1;\n    }\n    VIR_FREE(tmp);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseBondMiiCarrier(xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n    int ret = 0;\n\n    tmp = virXPathString(\"string(./miimon/@carrier)\", ctxt);\n    if (tmp == NULL)\n        return VIR_INTERFACE_BOND_MII_NONE;\n    if (STREQ(tmp, \"ioctl\")) {\n        ret = VIR_INTERFACE_BOND_MII_IOCTL;\n    } else if (STREQ(tmp, \"netif\")) {\n        ret = VIR_INTERFACE_BOND_MII_NETIF;\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unknown mii bonding carrier %s\"), tmp);\n        ret = -1;\n    }\n    VIR_FREE(tmp);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"bond interface miimon updelay invalid\")"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"bond interface miimon downdelay invalid\")"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"bond interface miimon freq missing or invalid\")"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseBondItfs",
          "args": [
            "def",
            "ctxt"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseBondItfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "556-596",
          "snippet": "static int\nvirInterfaceDefParseBondItfs(virInterfaceDefPtr def,\n                             xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr *interfaces = NULL;\n    xmlNodePtr bond = ctxt->node;\n    virInterfaceDefPtr itf;\n    int nbItf;\n    size_t i;\n    int ret = -1;\n\n    nbItf = virXPathNodeSet(\"./interface\", ctxt, &interfaces);\n    if (nbItf < 0)\n        goto cleanup;\n\n    if (nbItf == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->data.bond.itf, nbItf) < 0)\n        goto cleanup;\n\n    def->data.bond.nbItf = nbItf;\n\n    for (i = 0; i < nbItf; i++) {\n        ctxt->node = interfaces[i];\n        itf = virInterfaceDefParseXML(ctxt, VIR_INTERFACE_TYPE_BOND);\n        if (itf == NULL) {\n            def->data.bond.nbItf = i;\n            goto cleanup;\n        }\n        def->data.bond.itf[i] = itf;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(interfaces);\n    ctxt->node = bond;\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseBondItfs(virInterfaceDefPtr def,\n                             xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr *interfaces = NULL;\n    xmlNodePtr bond = ctxt->node;\n    virInterfaceDefPtr itf;\n    int nbItf;\n    size_t i;\n    int ret = -1;\n\n    nbItf = virXPathNodeSet(\"./interface\", ctxt, &interfaces);\n    if (nbItf < 0)\n        goto cleanup;\n\n    if (nbItf == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->data.bond.itf, nbItf) < 0)\n        goto cleanup;\n\n    def->data.bond.nbItf = nbItf;\n\n    for (i = 0; i < nbItf; i++) {\n        ctxt->node = interfaces[i];\n        itf = virInterfaceDefParseXML(ctxt, VIR_INTERFACE_TYPE_BOND);\n        if (itf == NULL) {\n            def->data.bond.nbItf = i;\n            goto cleanup;\n        }\n        def->data.bond.itf[i] = itf;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(interfaces);\n    ctxt->node = bond;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseBondMode",
          "args": [
            "ctxt"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseBondMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "180-210",
          "snippet": "static int\nvirInterfaceDefParseBondMode(xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n    int ret = 0;\n\n    tmp = virXPathString(\"string(./@mode)\", ctxt);\n    if (tmp == NULL)\n        return VIR_INTERFACE_BOND_NONE;\n    if (STREQ(tmp, \"balance-rr\")) {\n        ret = VIR_INTERFACE_BOND_BALRR;\n    } else if (STREQ(tmp, \"active-backup\")) {\n        ret = VIR_INTERFACE_BOND_ABACKUP;\n    } else if (STREQ(tmp, \"balance-xor\")) {\n        ret = VIR_INTERFACE_BOND_BALXOR;\n    } else if (STREQ(tmp, \"broadcast\")) {\n        ret = VIR_INTERFACE_BOND_BCAST;\n    } else if (STREQ(tmp, \"802.3ad\")) {\n        ret = VIR_INTERFACE_BOND_8023AD;\n    } else if (STREQ(tmp, \"balance-tlb\")) {\n        ret = VIR_INTERFACE_BOND_BALTLB;\n    } else if (STREQ(tmp, \"balance-alb\")) {\n        ret = VIR_INTERFACE_BOND_BALALB;\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unknown bonding mode %s\"), tmp);\n        ret = -1;\n    }\n    VIR_FREE(tmp);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseBondMode(xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n    int ret = 0;\n\n    tmp = virXPathString(\"string(./@mode)\", ctxt);\n    if (tmp == NULL)\n        return VIR_INTERFACE_BOND_NONE;\n    if (STREQ(tmp, \"balance-rr\")) {\n        ret = VIR_INTERFACE_BOND_BALRR;\n    } else if (STREQ(tmp, \"active-backup\")) {\n        ret = VIR_INTERFACE_BOND_ABACKUP;\n    } else if (STREQ(tmp, \"balance-xor\")) {\n        ret = VIR_INTERFACE_BOND_BALXOR;\n    } else if (STREQ(tmp, \"broadcast\")) {\n        ret = VIR_INTERFACE_BOND_BCAST;\n    } else if (STREQ(tmp, \"802.3ad\")) {\n        ret = VIR_INTERFACE_BOND_8023AD;\n    } else if (STREQ(tmp, \"balance-tlb\")) {\n        ret = VIR_INTERFACE_BOND_BALTLB;\n    } else if (STREQ(tmp, \"balance-alb\")) {\n        ret = VIR_INTERFACE_BOND_BALALB;\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unknown bonding mode %s\"), tmp);\n        ret = -1;\n    }\n    VIR_FREE(tmp);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseBond(virInterfaceDefPtr def,\n                         xmlXPathContextPtr ctxt)\n{\n    int res;\n\n    def->data.bond.mode = virInterfaceDefParseBondMode(ctxt);\n    if (def->data.bond.mode < 0)\n        return -1;\n\n    if (virInterfaceDefParseBondItfs(def, ctxt) != 0)\n        return -1;\n\n    if (virXPathNode(\"./miimon[1]\", ctxt) != NULL) {\n        def->data.bond.monit = VIR_INTERFACE_BOND_MONIT_MII;\n\n        res = virXPathInt(\"string(./miimon/@freq)\", ctxt,\n                          &def->data.bond.frequency);\n        if ((res == -2) || (res == -1)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface miimon freq missing or invalid\"));\n            return -1;\n        }\n\n        res = virXPathInt(\"string(./miimon/@downdelay)\", ctxt,\n                          &def->data.bond.downdelay);\n        if (res == -2) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface miimon downdelay invalid\"));\n            return -1;\n        }\n\n        res = virXPathInt(\"string(./miimon/@updelay)\", ctxt,\n                          &def->data.bond.updelay);\n        if (res == -2) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface miimon updelay invalid\"));\n            return -1;\n        }\n\n        def->data.bond.carrier = virInterfaceDefParseBondMiiCarrier(ctxt);\n        if (def->data.bond.carrier < 0)\n            return -1;\n\n    } else if (virXPathNode(\"./arpmon[1]\", ctxt) != NULL) {\n\n        def->data.bond.monit = VIR_INTERFACE_BOND_MONIT_ARP;\n\n        res = virXPathInt(\"string(./arpmon/@interval)\", ctxt,\n                          &def->data.bond.interval);\n        if ((res == -2) || (res == -1)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface arpmon interval missing or invalid\"));\n            return -1;\n        }\n\n        def->data.bond.target =\n            virXPathString(\"string(./arpmon/@target)\", ctxt);\n        if (def->data.bond.target == NULL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"bond interface arpmon target missing\"));\n            return -1;\n        }\n\n        def->data.bond.validate = virInterfaceDefParseBondArpValid(ctxt);\n        if (def->data.bond.validate < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virInterfaceDefParseBondItfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "556-596",
    "snippet": "static int\nvirInterfaceDefParseBondItfs(virInterfaceDefPtr def,\n                             xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr *interfaces = NULL;\n    xmlNodePtr bond = ctxt->node;\n    virInterfaceDefPtr itf;\n    int nbItf;\n    size_t i;\n    int ret = -1;\n\n    nbItf = virXPathNodeSet(\"./interface\", ctxt, &interfaces);\n    if (nbItf < 0)\n        goto cleanup;\n\n    if (nbItf == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->data.bond.itf, nbItf) < 0)\n        goto cleanup;\n\n    def->data.bond.nbItf = nbItf;\n\n    for (i = 0; i < nbItf; i++) {\n        ctxt->node = interfaces[i];\n        itf = virInterfaceDefParseXML(ctxt, VIR_INTERFACE_TYPE_BOND);\n        if (itf == NULL) {\n            def->data.bond.nbItf = i;\n            goto cleanup;\n        }\n        def->data.bond.itf[i] = itf;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(interfaces);\n    ctxt->node = bond;\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "interfaces"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseXML",
          "args": [
            "ctxt",
            "VIR_INTERFACE_TYPE_BOND"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "694-814",
          "snippet": "static virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt,\n                        int parentIfType)\n{\n    virInterfaceDefPtr def;\n    int type;\n    char *tmp;\n    xmlNodePtr cur = ctxt->node;\n    xmlNodePtr lnk;\n\n\n    /* check @type */\n    tmp = virXPathString(\"string(./@type)\", ctxt);\n    if (tmp == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"interface misses the type attribute\"));\n        return NULL;\n    }\n    type = virInterfaceTypeFromString(tmp);\n    if (type == -1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown interface type %s\"), tmp);\n        VIR_FREE(tmp);\n        return NULL;\n    }\n    VIR_FREE(tmp);\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (((parentIfType == VIR_INTERFACE_TYPE_BOND)\n         && (type != VIR_INTERFACE_TYPE_ETHERNET))\n        || ((parentIfType == VIR_INTERFACE_TYPE_BRIDGE)\n            && (type != VIR_INTERFACE_TYPE_ETHERNET)\n            && (type != VIR_INTERFACE_TYPE_BOND)\n            && (type != VIR_INTERFACE_TYPE_VLAN))\n        || (parentIfType == VIR_INTERFACE_TYPE_ETHERNET)\n        || (parentIfType == VIR_INTERFACE_TYPE_VLAN))\n        {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"interface has unsupported type '%s'\"),\n                       virInterfaceTypeToString(type));\n        goto error;\n    }\n    def->type = type;\n\n    if (virInterfaceDefParseName(def, ctxt) < 0)\n       goto error;\n\n    if (parentIfType == VIR_INTERFACE_TYPE_LAST) {\n        /* only recognize these in toplevel bond interfaces */\n        if (virInterfaceDefParseStartMode(def, ctxt) < 0)\n            goto error;\n        if (virInterfaceDefParseMtu(def, ctxt) < 0)\n            goto error;\n        if (virInterfaceDefParseIfAdressing(def, ctxt) < 0)\n            goto error;\n    }\n\n    if (type != VIR_INTERFACE_TYPE_BRIDGE) {\n        /* link status makes no sense for a bridge */\n        lnk = virXPathNode(\"./link\", ctxt);\n        if (lnk && virInterfaceLinkParseXML(lnk, &def->lnk) < 0)\n            goto error;\n    }\n\n    switch (type) {\n        case VIR_INTERFACE_TYPE_ETHERNET:\n            if ((tmp = virXPathString(\"string(./mac/@address)\", ctxt)))\n                def->mac = tmp;\n            break;\n        case VIR_INTERFACE_TYPE_BRIDGE: {\n            xmlNodePtr bridge;\n\n            if (!(bridge = virXPathNode(\"./bridge[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"bridge interface misses the bridge element\"));\n                goto error;\n            }\n            ctxt->node = bridge;\n            if (virInterfaceDefParseBridge(def, ctxt) < 0)\n                goto error;\n            break;\n        }\n        case VIR_INTERFACE_TYPE_BOND: {\n            xmlNodePtr bond;\n\n            if (!(bond = virXPathNode(\"./bond[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"bond interface misses the bond element\"));\n                goto error;\n            }\n            ctxt->node = bond;\n            if (virInterfaceDefParseBond(def, ctxt)  < 0)\n                goto error;\n            break;\n        }\n        case VIR_INTERFACE_TYPE_VLAN: {\n            xmlNodePtr vlan;\n\n            if (!(vlan = virXPathNode(\"./vlan[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"vlan interface misses the vlan element\"));\n                goto error;\n            }\n            ctxt->node = vlan;\n            if (virInterfaceDefParseVlan(def, ctxt)  < 0)\n                goto error;\n            break;\n        }\n\n    }\n\n    ctxt->node = cur;\n    return def;\n\n error:\n    ctxt->node = cur;\n    virInterfaceDefFree(def);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt, int parentIfType);",
            "static int\nvirInterfaceDefDevFormat(virBufferPtr buf, const virInterfaceDef *def,\n                         virInterfaceType parentIfType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt, int parentIfType);\nstatic int\nvirInterfaceDefDevFormat(virBufferPtr buf, const virInterfaceDef *def,\n                         virInterfaceType parentIfType);\n\nstatic virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt,\n                        int parentIfType)\n{\n    virInterfaceDefPtr def;\n    int type;\n    char *tmp;\n    xmlNodePtr cur = ctxt->node;\n    xmlNodePtr lnk;\n\n\n    /* check @type */\n    tmp = virXPathString(\"string(./@type)\", ctxt);\n    if (tmp == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"interface misses the type attribute\"));\n        return NULL;\n    }\n    type = virInterfaceTypeFromString(tmp);\n    if (type == -1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown interface type %s\"), tmp);\n        VIR_FREE(tmp);\n        return NULL;\n    }\n    VIR_FREE(tmp);\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (((parentIfType == VIR_INTERFACE_TYPE_BOND)\n         && (type != VIR_INTERFACE_TYPE_ETHERNET))\n        || ((parentIfType == VIR_INTERFACE_TYPE_BRIDGE)\n            && (type != VIR_INTERFACE_TYPE_ETHERNET)\n            && (type != VIR_INTERFACE_TYPE_BOND)\n            && (type != VIR_INTERFACE_TYPE_VLAN))\n        || (parentIfType == VIR_INTERFACE_TYPE_ETHERNET)\n        || (parentIfType == VIR_INTERFACE_TYPE_VLAN))\n        {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"interface has unsupported type '%s'\"),\n                       virInterfaceTypeToString(type));\n        goto error;\n    }\n    def->type = type;\n\n    if (virInterfaceDefParseName(def, ctxt) < 0)\n       goto error;\n\n    if (parentIfType == VIR_INTERFACE_TYPE_LAST) {\n        /* only recognize these in toplevel bond interfaces */\n        if (virInterfaceDefParseStartMode(def, ctxt) < 0)\n            goto error;\n        if (virInterfaceDefParseMtu(def, ctxt) < 0)\n            goto error;\n        if (virInterfaceDefParseIfAdressing(def, ctxt) < 0)\n            goto error;\n    }\n\n    if (type != VIR_INTERFACE_TYPE_BRIDGE) {\n        /* link status makes no sense for a bridge */\n        lnk = virXPathNode(\"./link\", ctxt);\n        if (lnk && virInterfaceLinkParseXML(lnk, &def->lnk) < 0)\n            goto error;\n    }\n\n    switch (type) {\n        case VIR_INTERFACE_TYPE_ETHERNET:\n            if ((tmp = virXPathString(\"string(./mac/@address)\", ctxt)))\n                def->mac = tmp;\n            break;\n        case VIR_INTERFACE_TYPE_BRIDGE: {\n            xmlNodePtr bridge;\n\n            if (!(bridge = virXPathNode(\"./bridge[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"bridge interface misses the bridge element\"));\n                goto error;\n            }\n            ctxt->node = bridge;\n            if (virInterfaceDefParseBridge(def, ctxt) < 0)\n                goto error;\n            break;\n        }\n        case VIR_INTERFACE_TYPE_BOND: {\n            xmlNodePtr bond;\n\n            if (!(bond = virXPathNode(\"./bond[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"bond interface misses the bond element\"));\n                goto error;\n            }\n            ctxt->node = bond;\n            if (virInterfaceDefParseBond(def, ctxt)  < 0)\n                goto error;\n            break;\n        }\n        case VIR_INTERFACE_TYPE_VLAN: {\n            xmlNodePtr vlan;\n\n            if (!(vlan = virXPathNode(\"./vlan[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"vlan interface misses the vlan element\"));\n                goto error;\n            }\n            ctxt->node = vlan;\n            if (virInterfaceDefParseVlan(def, ctxt)  < 0)\n                goto error;\n            break;\n        }\n\n    }\n\n    ctxt->node = cur;\n    return def;\n\n error:\n    ctxt->node = cur;\n    virInterfaceDefFree(def);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->data.bond.itf",
            "nbItf"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./interface\"",
            "ctxt",
            "&interfaces"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseBondItfs(virInterfaceDefPtr def,\n                             xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr *interfaces = NULL;\n    xmlNodePtr bond = ctxt->node;\n    virInterfaceDefPtr itf;\n    int nbItf;\n    size_t i;\n    int ret = -1;\n\n    nbItf = virXPathNodeSet(\"./interface\", ctxt, &interfaces);\n    if (nbItf < 0)\n        goto cleanup;\n\n    if (nbItf == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->data.bond.itf, nbItf) < 0)\n        goto cleanup;\n\n    def->data.bond.nbItf = nbItf;\n\n    for (i = 0; i < nbItf; i++) {\n        ctxt->node = interfaces[i];\n        itf = virInterfaceDefParseXML(ctxt, VIR_INTERFACE_TYPE_BOND);\n        if (itf == NULL) {\n            def->data.bond.nbItf = i;\n            goto cleanup;\n        }\n        def->data.bond.itf[i] = itf;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(interfaces);\n    ctxt->node = bond;\n    return ret;\n}"
  },
  {
    "function_name": "virInterfaceDefParseBridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "496-553",
    "snippet": "static int\nvirInterfaceDefParseBridge(virInterfaceDefPtr def,\n                           xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr *interfaces = NULL;\n    xmlNodePtr bridge;\n    virInterfaceDefPtr itf;\n    char *tmp = NULL;\n    int nbItf;\n    size_t i;\n    int ret = 0;\n\n    bridge = ctxt->node;\n    def->data.bridge.stp = -1;\n    if ((tmp = virXMLPropString(bridge, \"stp\"))) {\n        if (STREQ(tmp, \"on\")) {\n            def->data.bridge.stp = 1;\n        } else if (STREQ(tmp, \"off\")) {\n            def->data.bridge.stp = 0;\n        } else {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge interface stp should be on or off got %s\"),\n                           tmp);\n            goto error;\n        }\n    }\n    def->data.bridge.delay = virXMLPropString(bridge, \"delay\");\n\n    nbItf = virXPathNodeSet(\"./interface\", ctxt, &interfaces);\n    if (nbItf < 0) {\n        ret = -1;\n        goto error;\n    }\n    if (nbItf > 0) {\n        if (VIR_ALLOC_N(def->data.bridge.itf, nbItf) < 0) {\n            ret = -1;\n            goto error;\n        }\n        def->data.bridge.nbItf = nbItf;\n\n        for (i = 0; i < nbItf; i++) {\n            ctxt->node = interfaces[i];\n            itf = virInterfaceDefParseXML(ctxt, VIR_INTERFACE_TYPE_BRIDGE);\n            if (itf == NULL) {\n                ret = -1;\n                def->data.bridge.nbItf = i;\n                goto error;\n            }\n            def->data.bridge.itf[i] = itf;\n        }\n    }\n\n error:\n    VIR_FREE(tmp);\n    VIR_FREE(interfaces);\n    ctxt->node = bridge;\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "interfaces"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseXML",
          "args": [
            "ctxt",
            "VIR_INTERFACE_TYPE_BRIDGE"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "694-814",
          "snippet": "static virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt,\n                        int parentIfType)\n{\n    virInterfaceDefPtr def;\n    int type;\n    char *tmp;\n    xmlNodePtr cur = ctxt->node;\n    xmlNodePtr lnk;\n\n\n    /* check @type */\n    tmp = virXPathString(\"string(./@type)\", ctxt);\n    if (tmp == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"interface misses the type attribute\"));\n        return NULL;\n    }\n    type = virInterfaceTypeFromString(tmp);\n    if (type == -1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown interface type %s\"), tmp);\n        VIR_FREE(tmp);\n        return NULL;\n    }\n    VIR_FREE(tmp);\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (((parentIfType == VIR_INTERFACE_TYPE_BOND)\n         && (type != VIR_INTERFACE_TYPE_ETHERNET))\n        || ((parentIfType == VIR_INTERFACE_TYPE_BRIDGE)\n            && (type != VIR_INTERFACE_TYPE_ETHERNET)\n            && (type != VIR_INTERFACE_TYPE_BOND)\n            && (type != VIR_INTERFACE_TYPE_VLAN))\n        || (parentIfType == VIR_INTERFACE_TYPE_ETHERNET)\n        || (parentIfType == VIR_INTERFACE_TYPE_VLAN))\n        {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"interface has unsupported type '%s'\"),\n                       virInterfaceTypeToString(type));\n        goto error;\n    }\n    def->type = type;\n\n    if (virInterfaceDefParseName(def, ctxt) < 0)\n       goto error;\n\n    if (parentIfType == VIR_INTERFACE_TYPE_LAST) {\n        /* only recognize these in toplevel bond interfaces */\n        if (virInterfaceDefParseStartMode(def, ctxt) < 0)\n            goto error;\n        if (virInterfaceDefParseMtu(def, ctxt) < 0)\n            goto error;\n        if (virInterfaceDefParseIfAdressing(def, ctxt) < 0)\n            goto error;\n    }\n\n    if (type != VIR_INTERFACE_TYPE_BRIDGE) {\n        /* link status makes no sense for a bridge */\n        lnk = virXPathNode(\"./link\", ctxt);\n        if (lnk && virInterfaceLinkParseXML(lnk, &def->lnk) < 0)\n            goto error;\n    }\n\n    switch (type) {\n        case VIR_INTERFACE_TYPE_ETHERNET:\n            if ((tmp = virXPathString(\"string(./mac/@address)\", ctxt)))\n                def->mac = tmp;\n            break;\n        case VIR_INTERFACE_TYPE_BRIDGE: {\n            xmlNodePtr bridge;\n\n            if (!(bridge = virXPathNode(\"./bridge[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"bridge interface misses the bridge element\"));\n                goto error;\n            }\n            ctxt->node = bridge;\n            if (virInterfaceDefParseBridge(def, ctxt) < 0)\n                goto error;\n            break;\n        }\n        case VIR_INTERFACE_TYPE_BOND: {\n            xmlNodePtr bond;\n\n            if (!(bond = virXPathNode(\"./bond[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"bond interface misses the bond element\"));\n                goto error;\n            }\n            ctxt->node = bond;\n            if (virInterfaceDefParseBond(def, ctxt)  < 0)\n                goto error;\n            break;\n        }\n        case VIR_INTERFACE_TYPE_VLAN: {\n            xmlNodePtr vlan;\n\n            if (!(vlan = virXPathNode(\"./vlan[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"vlan interface misses the vlan element\"));\n                goto error;\n            }\n            ctxt->node = vlan;\n            if (virInterfaceDefParseVlan(def, ctxt)  < 0)\n                goto error;\n            break;\n        }\n\n    }\n\n    ctxt->node = cur;\n    return def;\n\n error:\n    ctxt->node = cur;\n    virInterfaceDefFree(def);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt, int parentIfType);",
            "static int\nvirInterfaceDefDevFormat(virBufferPtr buf, const virInterfaceDef *def,\n                         virInterfaceType parentIfType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt, int parentIfType);\nstatic int\nvirInterfaceDefDevFormat(virBufferPtr buf, const virInterfaceDef *def,\n                         virInterfaceType parentIfType);\n\nstatic virInterfaceDefPtr\nvirInterfaceDefParseXML(xmlXPathContextPtr ctxt,\n                        int parentIfType)\n{\n    virInterfaceDefPtr def;\n    int type;\n    char *tmp;\n    xmlNodePtr cur = ctxt->node;\n    xmlNodePtr lnk;\n\n\n    /* check @type */\n    tmp = virXPathString(\"string(./@type)\", ctxt);\n    if (tmp == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"interface misses the type attribute\"));\n        return NULL;\n    }\n    type = virInterfaceTypeFromString(tmp);\n    if (type == -1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown interface type %s\"), tmp);\n        VIR_FREE(tmp);\n        return NULL;\n    }\n    VIR_FREE(tmp);\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (((parentIfType == VIR_INTERFACE_TYPE_BOND)\n         && (type != VIR_INTERFACE_TYPE_ETHERNET))\n        || ((parentIfType == VIR_INTERFACE_TYPE_BRIDGE)\n            && (type != VIR_INTERFACE_TYPE_ETHERNET)\n            && (type != VIR_INTERFACE_TYPE_BOND)\n            && (type != VIR_INTERFACE_TYPE_VLAN))\n        || (parentIfType == VIR_INTERFACE_TYPE_ETHERNET)\n        || (parentIfType == VIR_INTERFACE_TYPE_VLAN))\n        {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"interface has unsupported type '%s'\"),\n                       virInterfaceTypeToString(type));\n        goto error;\n    }\n    def->type = type;\n\n    if (virInterfaceDefParseName(def, ctxt) < 0)\n       goto error;\n\n    if (parentIfType == VIR_INTERFACE_TYPE_LAST) {\n        /* only recognize these in toplevel bond interfaces */\n        if (virInterfaceDefParseStartMode(def, ctxt) < 0)\n            goto error;\n        if (virInterfaceDefParseMtu(def, ctxt) < 0)\n            goto error;\n        if (virInterfaceDefParseIfAdressing(def, ctxt) < 0)\n            goto error;\n    }\n\n    if (type != VIR_INTERFACE_TYPE_BRIDGE) {\n        /* link status makes no sense for a bridge */\n        lnk = virXPathNode(\"./link\", ctxt);\n        if (lnk && virInterfaceLinkParseXML(lnk, &def->lnk) < 0)\n            goto error;\n    }\n\n    switch (type) {\n        case VIR_INTERFACE_TYPE_ETHERNET:\n            if ((tmp = virXPathString(\"string(./mac/@address)\", ctxt)))\n                def->mac = tmp;\n            break;\n        case VIR_INTERFACE_TYPE_BRIDGE: {\n            xmlNodePtr bridge;\n\n            if (!(bridge = virXPathNode(\"./bridge[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"bridge interface misses the bridge element\"));\n                goto error;\n            }\n            ctxt->node = bridge;\n            if (virInterfaceDefParseBridge(def, ctxt) < 0)\n                goto error;\n            break;\n        }\n        case VIR_INTERFACE_TYPE_BOND: {\n            xmlNodePtr bond;\n\n            if (!(bond = virXPathNode(\"./bond[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"bond interface misses the bond element\"));\n                goto error;\n            }\n            ctxt->node = bond;\n            if (virInterfaceDefParseBond(def, ctxt)  < 0)\n                goto error;\n            break;\n        }\n        case VIR_INTERFACE_TYPE_VLAN: {\n            xmlNodePtr vlan;\n\n            if (!(vlan = virXPathNode(\"./vlan[1]\", ctxt))) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               \"%s\", _(\"vlan interface misses the vlan element\"));\n                goto error;\n            }\n            ctxt->node = vlan;\n            if (virInterfaceDefParseVlan(def, ctxt)  < 0)\n                goto error;\n            break;\n        }\n\n    }\n\n    ctxt->node = cur;\n    return def;\n\n error:\n    ctxt->node = cur;\n    virInterfaceDefFree(def);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->data.bridge.itf",
            "nbItf"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./interface\"",
            "ctxt",
            "&interfaces"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "bridge",
            "\"delay\""
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"bridge interface stp should be on or off got %s\")",
            "tmp"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"bridge interface stp should be on or off got %s\""
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"off\""
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"on\""
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseBridge(virInterfaceDefPtr def,\n                           xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr *interfaces = NULL;\n    xmlNodePtr bridge;\n    virInterfaceDefPtr itf;\n    char *tmp = NULL;\n    int nbItf;\n    size_t i;\n    int ret = 0;\n\n    bridge = ctxt->node;\n    def->data.bridge.stp = -1;\n    if ((tmp = virXMLPropString(bridge, \"stp\"))) {\n        if (STREQ(tmp, \"on\")) {\n            def->data.bridge.stp = 1;\n        } else if (STREQ(tmp, \"off\")) {\n            def->data.bridge.stp = 0;\n        } else {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"bridge interface stp should be on or off got %s\"),\n                           tmp);\n            goto error;\n        }\n    }\n    def->data.bridge.delay = virXMLPropString(bridge, \"delay\");\n\n    nbItf = virXPathNodeSet(\"./interface\", ctxt, &interfaces);\n    if (nbItf < 0) {\n        ret = -1;\n        goto error;\n    }\n    if (nbItf > 0) {\n        if (VIR_ALLOC_N(def->data.bridge.itf, nbItf) < 0) {\n            ret = -1;\n            goto error;\n        }\n        def->data.bridge.nbItf = nbItf;\n\n        for (i = 0; i < nbItf; i++) {\n            ctxt->node = interfaces[i];\n            itf = virInterfaceDefParseXML(ctxt, VIR_INTERFACE_TYPE_BRIDGE);\n            if (itf == NULL) {\n                ret = -1;\n                def->data.bridge.nbItf = i;\n                goto error;\n            }\n            def->data.bridge.itf[i] = itf;\n        }\n    }\n\n error:\n    VIR_FREE(tmp);\n    VIR_FREE(interfaces);\n    ctxt->node = bridge;\n    return ret;\n}"
  },
  {
    "function_name": "virInterfaceDefParseIfAdressing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "425-493",
    "snippet": "static int\nvirInterfaceDefParseIfAdressing(virInterfaceDefPtr def,\n                                xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr save;\n    xmlNodePtr *protoNodes = NULL;\n    int nProtoNodes, pp, ret = -1;\n    char *tmp;\n\n    save = ctxt->node;\n\n    nProtoNodes = virXPathNodeSet(\"./protocol\", ctxt, &protoNodes);\n    if (nProtoNodes < 0)\n        goto error;\n\n    if (nProtoNodes == 0) {\n        /* no protocols is an acceptable outcome */\n        return 0;\n    }\n\n    if (VIR_ALLOC_N(def->protos, nProtoNodes) < 0)\n        goto error;\n\n    def->nprotos = 0;\n    for (pp = 0; pp < nProtoNodes; pp++) {\n\n        virInterfaceProtocolDefPtr proto;\n\n        if (VIR_ALLOC(proto) < 0)\n            goto error;\n\n        ctxt->node = protoNodes[pp];\n        tmp = virXPathString(\"string(./@family)\", ctxt);\n        if (tmp == NULL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"protocol misses the family attribute\"));\n            virInterfaceProtocolDefFree(proto);\n            goto error;\n        }\n        proto->family = tmp;\n        if (STREQ(tmp, \"ipv4\")) {\n            ret = virInterfaceDefParseProtoIPv4(proto, ctxt);\n            if (ret != 0) {\n                virInterfaceProtocolDefFree(proto);\n                goto error;\n            }\n        } else if (STREQ(tmp, \"ipv6\")) {\n            ret = virInterfaceDefParseProtoIPv6(proto, ctxt);\n            if (ret != 0) {\n                virInterfaceProtocolDefFree(proto);\n                goto error;\n            }\n        } else {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unsupported protocol family '%s'\"), tmp);\n            virInterfaceProtocolDefFree(proto);\n            goto error;\n        }\n        def->protos[def->nprotos++] = proto;\n    }\n\n    ret = 0;\n\n error:\n    VIR_FREE(protoNodes);\n    ctxt->node = save;\n    return ret;\n\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "protoNodes"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceProtocolDefFree",
          "args": [
            "proto"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceProtocolDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "57-70",
          "snippet": "static void\nvirInterfaceProtocolDefFree(virInterfaceProtocolDefPtr def)\n{\n    size_t i;\n\n    if (def == NULL)\n        return;\n    for (i = 0; i < def->nips; i++)\n        virInterfaceIPDefFree(def->ips[i]);\n    VIR_FREE(def->ips);\n    VIR_FREE(def->family);\n    VIR_FREE(def->gateway);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic void\nvirInterfaceProtocolDefFree(virInterfaceProtocolDefPtr def)\n{\n    size_t i;\n\n    if (def == NULL)\n        return;\n    for (i = 0; i < def->nips; i++)\n        virInterfaceIPDefFree(def->ips[i]);\n    VIR_FREE(def->ips);\n    VIR_FREE(def->family);\n    VIR_FREE(def->gateway);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unsupported protocol family '%s'\")",
            "tmp"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported protocol family '%s'\""
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseProtoIPv6",
          "args": [
            "proto",
            "ctxt"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseProtoIPv6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "369-422",
          "snippet": "static int\nvirInterfaceDefParseProtoIPv6(virInterfaceProtocolDefPtr def,\n                              xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr dhcp, autoconf;\n    xmlNodePtr *ipNodes = NULL;\n    int nipNodes, ret = -1;\n    size_t i;\n    char *tmp;\n\n    tmp = virXPathString(\"string(./route[1]/@gateway)\", ctxt);\n    def->gateway = tmp;\n\n    autoconf = virXPathNode(\"./autoconf\", ctxt);\n    if (autoconf != NULL)\n        def->autoconf = 1;\n\n    dhcp = virXPathNode(\"./dhcp\", ctxt);\n    if (dhcp != NULL) {\n        if (virInterfaceDefParseDhcp(def, dhcp, ctxt) < 0)\n            return -1;\n    }\n\n    nipNodes = virXPathNodeSet(\"./ip\", ctxt, &ipNodes);\n    if (nipNodes < 0)\n        return -1;\n    if (ipNodes == NULL)\n        return 0;\n\n    if (VIR_ALLOC_N(def->ips, nipNodes) < 0)\n        goto error;\n\n    def->nips = 0;\n    for (i = 0; i < nipNodes; i++) {\n\n        virInterfaceIPDefPtr ip;\n\n        if (VIR_ALLOC(ip) < 0)\n            goto error;\n\n        ctxt->node = ipNodes[i];\n        if (virInterfaceDefParseIP(ip, ctxt) < 0) {\n            virInterfaceIPDefFree(ip);\n            goto error;\n        }\n        def->ips[def->nips++] = ip;\n    }\n\n    ret = 0;\n\n error:\n    VIR_FREE(ipNodes);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseProtoIPv6(virInterfaceProtocolDefPtr def,\n                              xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr dhcp, autoconf;\n    xmlNodePtr *ipNodes = NULL;\n    int nipNodes, ret = -1;\n    size_t i;\n    char *tmp;\n\n    tmp = virXPathString(\"string(./route[1]/@gateway)\", ctxt);\n    def->gateway = tmp;\n\n    autoconf = virXPathNode(\"./autoconf\", ctxt);\n    if (autoconf != NULL)\n        def->autoconf = 1;\n\n    dhcp = virXPathNode(\"./dhcp\", ctxt);\n    if (dhcp != NULL) {\n        if (virInterfaceDefParseDhcp(def, dhcp, ctxt) < 0)\n            return -1;\n    }\n\n    nipNodes = virXPathNodeSet(\"./ip\", ctxt, &ipNodes);\n    if (nipNodes < 0)\n        return -1;\n    if (ipNodes == NULL)\n        return 0;\n\n    if (VIR_ALLOC_N(def->ips, nipNodes) < 0)\n        goto error;\n\n    def->nips = 0;\n    for (i = 0; i < nipNodes; i++) {\n\n        virInterfaceIPDefPtr ip;\n\n        if (VIR_ALLOC(ip) < 0)\n            goto error;\n\n        ctxt->node = ipNodes[i];\n        if (virInterfaceDefParseIP(ip, ctxt) < 0) {\n            virInterfaceIPDefFree(ip);\n            goto error;\n        }\n        def->ips[def->nips++] = ip;\n    }\n\n    ret = 0;\n\n error:\n    VIR_FREE(ipNodes);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"ipv6\""
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseProtoIPv4",
          "args": [
            "proto",
            "ctxt"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseProtoIPv4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "317-366",
          "snippet": "static int\nvirInterfaceDefParseProtoIPv4(virInterfaceProtocolDefPtr def,\n                              xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr dhcp;\n    xmlNodePtr *ipNodes = NULL;\n    int nipNodes, ret = -1;\n    size_t i;\n    char *tmp;\n\n    tmp = virXPathString(\"string(./route[1]/@gateway)\", ctxt);\n    def->gateway = tmp;\n\n    dhcp = virXPathNode(\"./dhcp\", ctxt);\n    if (dhcp != NULL) {\n        if (virInterfaceDefParseDhcp(def, dhcp, ctxt) < 0)\n            return -1;\n    }\n\n    nipNodes = virXPathNodeSet(\"./ip\", ctxt, &ipNodes);\n    if (nipNodes < 0)\n        return -1;\n    if (ipNodes == NULL)\n        return 0;\n\n    if (VIR_ALLOC_N(def->ips, nipNodes) < 0)\n        goto error;\n\n    def->nips = 0;\n    for (i = 0; i < nipNodes; i++) {\n\n        virInterfaceIPDefPtr ip;\n\n        if (VIR_ALLOC(ip) < 0)\n            goto error;\n\n        ctxt->node = ipNodes[i];\n        if (virInterfaceDefParseIP(ip, ctxt) < 0) {\n            virInterfaceIPDefFree(ip);\n            goto error;\n        }\n        def->ips[def->nips++] = ip;\n    }\n\n    ret = 0;\n\n error:\n    VIR_FREE(ipNodes);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseProtoIPv4(virInterfaceProtocolDefPtr def,\n                              xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr dhcp;\n    xmlNodePtr *ipNodes = NULL;\n    int nipNodes, ret = -1;\n    size_t i;\n    char *tmp;\n\n    tmp = virXPathString(\"string(./route[1]/@gateway)\", ctxt);\n    def->gateway = tmp;\n\n    dhcp = virXPathNode(\"./dhcp\", ctxt);\n    if (dhcp != NULL) {\n        if (virInterfaceDefParseDhcp(def, dhcp, ctxt) < 0)\n            return -1;\n    }\n\n    nipNodes = virXPathNodeSet(\"./ip\", ctxt, &ipNodes);\n    if (nipNodes < 0)\n        return -1;\n    if (ipNodes == NULL)\n        return 0;\n\n    if (VIR_ALLOC_N(def->ips, nipNodes) < 0)\n        goto error;\n\n    def->nips = 0;\n    for (i = 0; i < nipNodes; i++) {\n\n        virInterfaceIPDefPtr ip;\n\n        if (VIR_ALLOC(ip) < 0)\n            goto error;\n\n        ctxt->node = ipNodes[i];\n        if (virInterfaceDefParseIP(ip, ctxt) < 0) {\n            virInterfaceIPDefFree(ip);\n            goto error;\n        }\n        def->ips[def->nips++] = ip;\n    }\n\n    ret = 0;\n\n error:\n    VIR_FREE(ipNodes);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"ipv4\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"protocol misses the family attribute\")"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./@family)\"",
            "ctxt"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "proto"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->protos",
            "nProtoNodes"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./protocol\"",
            "ctxt",
            "&protoNodes"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseIfAdressing(virInterfaceDefPtr def,\n                                xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr save;\n    xmlNodePtr *protoNodes = NULL;\n    int nProtoNodes, pp, ret = -1;\n    char *tmp;\n\n    save = ctxt->node;\n\n    nProtoNodes = virXPathNodeSet(\"./protocol\", ctxt, &protoNodes);\n    if (nProtoNodes < 0)\n        goto error;\n\n    if (nProtoNodes == 0) {\n        /* no protocols is an acceptable outcome */\n        return 0;\n    }\n\n    if (VIR_ALLOC_N(def->protos, nProtoNodes) < 0)\n        goto error;\n\n    def->nprotos = 0;\n    for (pp = 0; pp < nProtoNodes; pp++) {\n\n        virInterfaceProtocolDefPtr proto;\n\n        if (VIR_ALLOC(proto) < 0)\n            goto error;\n\n        ctxt->node = protoNodes[pp];\n        tmp = virXPathString(\"string(./@family)\", ctxt);\n        if (tmp == NULL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"protocol misses the family attribute\"));\n            virInterfaceProtocolDefFree(proto);\n            goto error;\n        }\n        proto->family = tmp;\n        if (STREQ(tmp, \"ipv4\")) {\n            ret = virInterfaceDefParseProtoIPv4(proto, ctxt);\n            if (ret != 0) {\n                virInterfaceProtocolDefFree(proto);\n                goto error;\n            }\n        } else if (STREQ(tmp, \"ipv6\")) {\n            ret = virInterfaceDefParseProtoIPv6(proto, ctxt);\n            if (ret != 0) {\n                virInterfaceProtocolDefFree(proto);\n                goto error;\n            }\n        } else {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unsupported protocol family '%s'\"), tmp);\n            virInterfaceProtocolDefFree(proto);\n            goto error;\n        }\n        def->protos[def->nprotos++] = proto;\n    }\n\n    ret = 0;\n\n error:\n    VIR_FREE(protoNodes);\n    ctxt->node = save;\n    return ret;\n\n}"
  },
  {
    "function_name": "virInterfaceDefParseProtoIPv6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "369-422",
    "snippet": "static int\nvirInterfaceDefParseProtoIPv6(virInterfaceProtocolDefPtr def,\n                              xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr dhcp, autoconf;\n    xmlNodePtr *ipNodes = NULL;\n    int nipNodes, ret = -1;\n    size_t i;\n    char *tmp;\n\n    tmp = virXPathString(\"string(./route[1]/@gateway)\", ctxt);\n    def->gateway = tmp;\n\n    autoconf = virXPathNode(\"./autoconf\", ctxt);\n    if (autoconf != NULL)\n        def->autoconf = 1;\n\n    dhcp = virXPathNode(\"./dhcp\", ctxt);\n    if (dhcp != NULL) {\n        if (virInterfaceDefParseDhcp(def, dhcp, ctxt) < 0)\n            return -1;\n    }\n\n    nipNodes = virXPathNodeSet(\"./ip\", ctxt, &ipNodes);\n    if (nipNodes < 0)\n        return -1;\n    if (ipNodes == NULL)\n        return 0;\n\n    if (VIR_ALLOC_N(def->ips, nipNodes) < 0)\n        goto error;\n\n    def->nips = 0;\n    for (i = 0; i < nipNodes; i++) {\n\n        virInterfaceIPDefPtr ip;\n\n        if (VIR_ALLOC(ip) < 0)\n            goto error;\n\n        ctxt->node = ipNodes[i];\n        if (virInterfaceDefParseIP(ip, ctxt) < 0) {\n            virInterfaceIPDefFree(ip);\n            goto error;\n        }\n        def->ips[def->nips++] = ip;\n    }\n\n    ret = 0;\n\n error:\n    VIR_FREE(ipNodes);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ipNodes"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceIPDefFree",
          "args": [
            "ip"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceIPDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "47-54",
          "snippet": "static void\nvirInterfaceIPDefFree(virInterfaceIPDefPtr def)\n{\n    if (def == NULL)\n        return;\n    VIR_FREE(def->address);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic void\nvirInterfaceIPDefFree(virInterfaceIPDefPtr def)\n{\n    if (def == NULL)\n        return;\n    VIR_FREE(def->address);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseIP",
          "args": [
            "ip",
            "ctxt"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseIP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "292-314",
          "snippet": "static int\nvirInterfaceDefParseIP(virInterfaceIPDefPtr def,\n                       xmlXPathContextPtr ctxt)\n{\n    int ret = 0;\n    char *tmp;\n    long l;\n\n    tmp = virXPathString(\"string(./@address)\", ctxt);\n    def->address = tmp;\n    if (tmp != NULL) {\n        ret = virXPathLong(\"string(./@prefix)\", ctxt, &l);\n        if (ret == 0) {\n            def->prefix = (int) l;\n        } else if (ret == -2) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"Invalid ip address prefix value\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseIP(virInterfaceIPDefPtr def,\n                       xmlXPathContextPtr ctxt)\n{\n    int ret = 0;\n    char *tmp;\n    long l;\n\n    tmp = virXPathString(\"string(./@address)\", ctxt);\n    def->address = tmp;\n    if (tmp != NULL) {\n        ret = virXPathLong(\"string(./@prefix)\", ctxt, &l);\n        if (ret == 0) {\n            def->prefix = (int) l;\n        } else if (ret == -2) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"Invalid ip address prefix value\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ip"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->ips",
            "nipNodes"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./ip\"",
            "ctxt",
            "&ipNodes"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseDhcp",
          "args": [
            "def",
            "dhcp",
            "ctxt"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseDhcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "261-289",
          "snippet": "static int\nvirInterfaceDefParseDhcp(virInterfaceProtocolDefPtr def,\n                         xmlNodePtr dhcp, xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr save;\n    char *tmp;\n    int ret = 0;\n\n    def->dhcp = 1;\n    save = ctxt->node;\n    ctxt->node = dhcp;\n    def->peerdns = -1;\n    /* Not much to do in the current version */\n    tmp = virXPathString(\"string(./@peerdns)\", ctxt);\n    if (tmp) {\n        bool state = false;\n        if (virStringParseYesNo(tmp, &state) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown dhcp peerdns value %s\"), tmp);\n            ret = -1;\n        } else {\n            def->peerdns = state ? 1 : 0;\n        }\n        VIR_FREE(tmp);\n    }\n\n    ctxt->node = save;\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseDhcp(virInterfaceProtocolDefPtr def,\n                         xmlNodePtr dhcp, xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr save;\n    char *tmp;\n    int ret = 0;\n\n    def->dhcp = 1;\n    save = ctxt->node;\n    ctxt->node = dhcp;\n    def->peerdns = -1;\n    /* Not much to do in the current version */\n    tmp = virXPathString(\"string(./@peerdns)\", ctxt);\n    if (tmp) {\n        bool state = false;\n        if (virStringParseYesNo(tmp, &state) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown dhcp peerdns value %s\"), tmp);\n            ret = -1;\n        } else {\n            def->peerdns = state ? 1 : 0;\n        }\n        VIR_FREE(tmp);\n    }\n\n    ctxt->node = save;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./dhcp\"",
            "ctxt"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./route[1]/@gateway)\"",
            "ctxt"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseProtoIPv6(virInterfaceProtocolDefPtr def,\n                              xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr dhcp, autoconf;\n    xmlNodePtr *ipNodes = NULL;\n    int nipNodes, ret = -1;\n    size_t i;\n    char *tmp;\n\n    tmp = virXPathString(\"string(./route[1]/@gateway)\", ctxt);\n    def->gateway = tmp;\n\n    autoconf = virXPathNode(\"./autoconf\", ctxt);\n    if (autoconf != NULL)\n        def->autoconf = 1;\n\n    dhcp = virXPathNode(\"./dhcp\", ctxt);\n    if (dhcp != NULL) {\n        if (virInterfaceDefParseDhcp(def, dhcp, ctxt) < 0)\n            return -1;\n    }\n\n    nipNodes = virXPathNodeSet(\"./ip\", ctxt, &ipNodes);\n    if (nipNodes < 0)\n        return -1;\n    if (ipNodes == NULL)\n        return 0;\n\n    if (VIR_ALLOC_N(def->ips, nipNodes) < 0)\n        goto error;\n\n    def->nips = 0;\n    for (i = 0; i < nipNodes; i++) {\n\n        virInterfaceIPDefPtr ip;\n\n        if (VIR_ALLOC(ip) < 0)\n            goto error;\n\n        ctxt->node = ipNodes[i];\n        if (virInterfaceDefParseIP(ip, ctxt) < 0) {\n            virInterfaceIPDefFree(ip);\n            goto error;\n        }\n        def->ips[def->nips++] = ip;\n    }\n\n    ret = 0;\n\n error:\n    VIR_FREE(ipNodes);\n    return ret;\n}"
  },
  {
    "function_name": "virInterfaceDefParseProtoIPv4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "317-366",
    "snippet": "static int\nvirInterfaceDefParseProtoIPv4(virInterfaceProtocolDefPtr def,\n                              xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr dhcp;\n    xmlNodePtr *ipNodes = NULL;\n    int nipNodes, ret = -1;\n    size_t i;\n    char *tmp;\n\n    tmp = virXPathString(\"string(./route[1]/@gateway)\", ctxt);\n    def->gateway = tmp;\n\n    dhcp = virXPathNode(\"./dhcp\", ctxt);\n    if (dhcp != NULL) {\n        if (virInterfaceDefParseDhcp(def, dhcp, ctxt) < 0)\n            return -1;\n    }\n\n    nipNodes = virXPathNodeSet(\"./ip\", ctxt, &ipNodes);\n    if (nipNodes < 0)\n        return -1;\n    if (ipNodes == NULL)\n        return 0;\n\n    if (VIR_ALLOC_N(def->ips, nipNodes) < 0)\n        goto error;\n\n    def->nips = 0;\n    for (i = 0; i < nipNodes; i++) {\n\n        virInterfaceIPDefPtr ip;\n\n        if (VIR_ALLOC(ip) < 0)\n            goto error;\n\n        ctxt->node = ipNodes[i];\n        if (virInterfaceDefParseIP(ip, ctxt) < 0) {\n            virInterfaceIPDefFree(ip);\n            goto error;\n        }\n        def->ips[def->nips++] = ip;\n    }\n\n    ret = 0;\n\n error:\n    VIR_FREE(ipNodes);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ipNodes"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceIPDefFree",
          "args": [
            "ip"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceIPDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "47-54",
          "snippet": "static void\nvirInterfaceIPDefFree(virInterfaceIPDefPtr def)\n{\n    if (def == NULL)\n        return;\n    VIR_FREE(def->address);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic void\nvirInterfaceIPDefFree(virInterfaceIPDefPtr def)\n{\n    if (def == NULL)\n        return;\n    VIR_FREE(def->address);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseIP",
          "args": [
            "ip",
            "ctxt"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseIP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "292-314",
          "snippet": "static int\nvirInterfaceDefParseIP(virInterfaceIPDefPtr def,\n                       xmlXPathContextPtr ctxt)\n{\n    int ret = 0;\n    char *tmp;\n    long l;\n\n    tmp = virXPathString(\"string(./@address)\", ctxt);\n    def->address = tmp;\n    if (tmp != NULL) {\n        ret = virXPathLong(\"string(./@prefix)\", ctxt, &l);\n        if (ret == 0) {\n            def->prefix = (int) l;\n        } else if (ret == -2) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"Invalid ip address prefix value\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseIP(virInterfaceIPDefPtr def,\n                       xmlXPathContextPtr ctxt)\n{\n    int ret = 0;\n    char *tmp;\n    long l;\n\n    tmp = virXPathString(\"string(./@address)\", ctxt);\n    def->address = tmp;\n    if (tmp != NULL) {\n        ret = virXPathLong(\"string(./@prefix)\", ctxt, &l);\n        if (ret == 0) {\n            def->prefix = (int) l;\n        } else if (ret == -2) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"Invalid ip address prefix value\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ip"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->ips",
            "nipNodes"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./ip\"",
            "ctxt",
            "&ipNodes"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseDhcp",
          "args": [
            "def",
            "dhcp",
            "ctxt"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseDhcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "261-289",
          "snippet": "static int\nvirInterfaceDefParseDhcp(virInterfaceProtocolDefPtr def,\n                         xmlNodePtr dhcp, xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr save;\n    char *tmp;\n    int ret = 0;\n\n    def->dhcp = 1;\n    save = ctxt->node;\n    ctxt->node = dhcp;\n    def->peerdns = -1;\n    /* Not much to do in the current version */\n    tmp = virXPathString(\"string(./@peerdns)\", ctxt);\n    if (tmp) {\n        bool state = false;\n        if (virStringParseYesNo(tmp, &state) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown dhcp peerdns value %s\"), tmp);\n            ret = -1;\n        } else {\n            def->peerdns = state ? 1 : 0;\n        }\n        VIR_FREE(tmp);\n    }\n\n    ctxt->node = save;\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseDhcp(virInterfaceProtocolDefPtr def,\n                         xmlNodePtr dhcp, xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr save;\n    char *tmp;\n    int ret = 0;\n\n    def->dhcp = 1;\n    save = ctxt->node;\n    ctxt->node = dhcp;\n    def->peerdns = -1;\n    /* Not much to do in the current version */\n    tmp = virXPathString(\"string(./@peerdns)\", ctxt);\n    if (tmp) {\n        bool state = false;\n        if (virStringParseYesNo(tmp, &state) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown dhcp peerdns value %s\"), tmp);\n            ret = -1;\n        } else {\n            def->peerdns = state ? 1 : 0;\n        }\n        VIR_FREE(tmp);\n    }\n\n    ctxt->node = save;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./dhcp\"",
            "ctxt"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./route[1]/@gateway)\"",
            "ctxt"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseProtoIPv4(virInterfaceProtocolDefPtr def,\n                              xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr dhcp;\n    xmlNodePtr *ipNodes = NULL;\n    int nipNodes, ret = -1;\n    size_t i;\n    char *tmp;\n\n    tmp = virXPathString(\"string(./route[1]/@gateway)\", ctxt);\n    def->gateway = tmp;\n\n    dhcp = virXPathNode(\"./dhcp\", ctxt);\n    if (dhcp != NULL) {\n        if (virInterfaceDefParseDhcp(def, dhcp, ctxt) < 0)\n            return -1;\n    }\n\n    nipNodes = virXPathNodeSet(\"./ip\", ctxt, &ipNodes);\n    if (nipNodes < 0)\n        return -1;\n    if (ipNodes == NULL)\n        return 0;\n\n    if (VIR_ALLOC_N(def->ips, nipNodes) < 0)\n        goto error;\n\n    def->nips = 0;\n    for (i = 0; i < nipNodes; i++) {\n\n        virInterfaceIPDefPtr ip;\n\n        if (VIR_ALLOC(ip) < 0)\n            goto error;\n\n        ctxt->node = ipNodes[i];\n        if (virInterfaceDefParseIP(ip, ctxt) < 0) {\n            virInterfaceIPDefFree(ip);\n            goto error;\n        }\n        def->ips[def->nips++] = ip;\n    }\n\n    ret = 0;\n\n error:\n    VIR_FREE(ipNodes);\n    return ret;\n}"
  },
  {
    "function_name": "virInterfaceDefParseIP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "292-314",
    "snippet": "static int\nvirInterfaceDefParseIP(virInterfaceIPDefPtr def,\n                       xmlXPathContextPtr ctxt)\n{\n    int ret = 0;\n    char *tmp;\n    long l;\n\n    tmp = virXPathString(\"string(./@address)\", ctxt);\n    def->address = tmp;\n    if (tmp != NULL) {\n        ret = virXPathLong(\"string(./@prefix)\", ctxt, &l);\n        if (ret == 0) {\n            def->prefix = (int) l;\n        } else if (ret == -2) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"Invalid ip address prefix value\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Invalid ip address prefix value\")"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid ip address prefix value\""
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathLong",
          "args": [
            "\"string(./@prefix)\"",
            "ctxt",
            "&l"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathLongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "444-476",
          "snippet": "int\nvirXPathLongLong(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathLongLong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ll((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathLongLong(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathLongLong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ll((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./@address)\"",
            "ctxt"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseIP(virInterfaceIPDefPtr def,\n                       xmlXPathContextPtr ctxt)\n{\n    int ret = 0;\n    char *tmp;\n    long l;\n\n    tmp = virXPathString(\"string(./@address)\", ctxt);\n    def->address = tmp;\n    if (tmp != NULL) {\n        ret = virXPathLong(\"string(./@prefix)\", ctxt, &l);\n        if (ret == 0) {\n            def->prefix = (int) l;\n        } else if (ret == -2) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           \"%s\", _(\"Invalid ip address prefix value\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virInterfaceDefParseDhcp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "261-289",
    "snippet": "static int\nvirInterfaceDefParseDhcp(virInterfaceProtocolDefPtr def,\n                         xmlNodePtr dhcp, xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr save;\n    char *tmp;\n    int ret = 0;\n\n    def->dhcp = 1;\n    save = ctxt->node;\n    ctxt->node = dhcp;\n    def->peerdns = -1;\n    /* Not much to do in the current version */\n    tmp = virXPathString(\"string(./@peerdns)\", ctxt);\n    if (tmp) {\n        bool state = false;\n        if (virStringParseYesNo(tmp, &state) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown dhcp peerdns value %s\"), tmp);\n            ret = -1;\n        } else {\n            def->peerdns = state ? 1 : 0;\n        }\n        VIR_FREE(tmp);\n    }\n\n    ctxt->node = save;\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unknown dhcp peerdns value %s\")",
            "tmp"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown dhcp peerdns value %s\""
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringParseYesNo",
          "args": [
            "tmp",
            "&state"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "virStringParseYesNo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1396-1406",
          "snippet": "int virStringParseYesNo(const char *str, bool *result)\n{\n    if (STREQ(str, \"yes\"))\n        *result = true;\n    else if (STREQ(str, \"no\"))\n        *result = false;\n    else\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint virStringParseYesNo(const char *str, bool *result)\n{\n    if (STREQ(str, \"yes\"))\n        *result = true;\n    else if (STREQ(str, \"no\"))\n        *result = false;\n    else\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./@peerdns)\"",
            "ctxt"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseDhcp(virInterfaceProtocolDefPtr def,\n                         xmlNodePtr dhcp, xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr save;\n    char *tmp;\n    int ret = 0;\n\n    def->dhcp = 1;\n    save = ctxt->node;\n    ctxt->node = dhcp;\n    def->peerdns = -1;\n    /* Not much to do in the current version */\n    tmp = virXPathString(\"string(./@peerdns)\", ctxt);\n    if (tmp) {\n        bool state = false;\n        if (virStringParseYesNo(tmp, &state) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown dhcp peerdns value %s\"), tmp);\n            ret = -1;\n        } else {\n            def->peerdns = state ? 1 : 0;\n        }\n        VIR_FREE(tmp);\n    }\n\n    ctxt->node = save;\n    return ret;\n}"
  },
  {
    "function_name": "virInterfaceDefParseBondArpValid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "236-258",
    "snippet": "static int\nvirInterfaceDefParseBondArpValid(xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n    int ret = 0;\n\n    tmp = virXPathString(\"string(./arpmon/@validate)\", ctxt);\n    if (tmp == NULL)\n        return VIR_INTERFACE_BOND_ARP_NONE;\n    if (STREQ(tmp, \"active\")) {\n        ret = VIR_INTERFACE_BOND_ARP_ACTIVE;\n    } else if (STREQ(tmp, \"backup\")) {\n        ret = VIR_INTERFACE_BOND_ARP_BACKUP;\n    } else if (STREQ(tmp, \"all\")) {\n        ret = VIR_INTERFACE_BOND_ARP_ALL;\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unknown arp bonding validate %s\"), tmp);\n        ret = -1;\n    }\n    VIR_FREE(tmp);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unknown arp bonding validate %s\")",
            "tmp"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown arp bonding validate %s\""
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"all\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"backup\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"active\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./arpmon/@validate)\"",
            "ctxt"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseBondArpValid(xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n    int ret = 0;\n\n    tmp = virXPathString(\"string(./arpmon/@validate)\", ctxt);\n    if (tmp == NULL)\n        return VIR_INTERFACE_BOND_ARP_NONE;\n    if (STREQ(tmp, \"active\")) {\n        ret = VIR_INTERFACE_BOND_ARP_ACTIVE;\n    } else if (STREQ(tmp, \"backup\")) {\n        ret = VIR_INTERFACE_BOND_ARP_BACKUP;\n    } else if (STREQ(tmp, \"all\")) {\n        ret = VIR_INTERFACE_BOND_ARP_ALL;\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unknown arp bonding validate %s\"), tmp);\n        ret = -1;\n    }\n    VIR_FREE(tmp);\n    return ret;\n}"
  },
  {
    "function_name": "virInterfaceDefParseBondMiiCarrier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "213-233",
    "snippet": "static int\nvirInterfaceDefParseBondMiiCarrier(xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n    int ret = 0;\n\n    tmp = virXPathString(\"string(./miimon/@carrier)\", ctxt);\n    if (tmp == NULL)\n        return VIR_INTERFACE_BOND_MII_NONE;\n    if (STREQ(tmp, \"ioctl\")) {\n        ret = VIR_INTERFACE_BOND_MII_IOCTL;\n    } else if (STREQ(tmp, \"netif\")) {\n        ret = VIR_INTERFACE_BOND_MII_NETIF;\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unknown mii bonding carrier %s\"), tmp);\n        ret = -1;\n    }\n    VIR_FREE(tmp);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unknown mii bonding carrier %s\")",
            "tmp"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown mii bonding carrier %s\""
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"netif\""
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"ioctl\""
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./miimon/@carrier)\"",
            "ctxt"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseBondMiiCarrier(xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n    int ret = 0;\n\n    tmp = virXPathString(\"string(./miimon/@carrier)\", ctxt);\n    if (tmp == NULL)\n        return VIR_INTERFACE_BOND_MII_NONE;\n    if (STREQ(tmp, \"ioctl\")) {\n        ret = VIR_INTERFACE_BOND_MII_IOCTL;\n    } else if (STREQ(tmp, \"netif\")) {\n        ret = VIR_INTERFACE_BOND_MII_NETIF;\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unknown mii bonding carrier %s\"), tmp);\n        ret = -1;\n    }\n    VIR_FREE(tmp);\n    return ret;\n}"
  },
  {
    "function_name": "virInterfaceDefParseBondMode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "180-210",
    "snippet": "static int\nvirInterfaceDefParseBondMode(xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n    int ret = 0;\n\n    tmp = virXPathString(\"string(./@mode)\", ctxt);\n    if (tmp == NULL)\n        return VIR_INTERFACE_BOND_NONE;\n    if (STREQ(tmp, \"balance-rr\")) {\n        ret = VIR_INTERFACE_BOND_BALRR;\n    } else if (STREQ(tmp, \"active-backup\")) {\n        ret = VIR_INTERFACE_BOND_ABACKUP;\n    } else if (STREQ(tmp, \"balance-xor\")) {\n        ret = VIR_INTERFACE_BOND_BALXOR;\n    } else if (STREQ(tmp, \"broadcast\")) {\n        ret = VIR_INTERFACE_BOND_BCAST;\n    } else if (STREQ(tmp, \"802.3ad\")) {\n        ret = VIR_INTERFACE_BOND_8023AD;\n    } else if (STREQ(tmp, \"balance-tlb\")) {\n        ret = VIR_INTERFACE_BOND_BALTLB;\n    } else if (STREQ(tmp, \"balance-alb\")) {\n        ret = VIR_INTERFACE_BOND_BALALB;\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unknown bonding mode %s\"), tmp);\n        ret = -1;\n    }\n    VIR_FREE(tmp);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unknown bonding mode %s\")",
            "tmp"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown bonding mode %s\""
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"balance-alb\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"balance-tlb\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"802.3ad\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"broadcast\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"balance-xor\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"active-backup\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"balance-rr\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./@mode)\"",
            "ctxt"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseBondMode(xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n    int ret = 0;\n\n    tmp = virXPathString(\"string(./@mode)\", ctxt);\n    if (tmp == NULL)\n        return VIR_INTERFACE_BOND_NONE;\n    if (STREQ(tmp, \"balance-rr\")) {\n        ret = VIR_INTERFACE_BOND_BALRR;\n    } else if (STREQ(tmp, \"active-backup\")) {\n        ret = VIR_INTERFACE_BOND_ABACKUP;\n    } else if (STREQ(tmp, \"balance-xor\")) {\n        ret = VIR_INTERFACE_BOND_BALXOR;\n    } else if (STREQ(tmp, \"broadcast\")) {\n        ret = VIR_INTERFACE_BOND_BCAST;\n    } else if (STREQ(tmp, \"802.3ad\")) {\n        ret = VIR_INTERFACE_BOND_8023AD;\n    } else if (STREQ(tmp, \"balance-tlb\")) {\n        ret = VIR_INTERFACE_BOND_BALTLB;\n    } else if (STREQ(tmp, \"balance-alb\")) {\n        ret = VIR_INTERFACE_BOND_BALALB;\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unknown bonding mode %s\"), tmp);\n        ret = -1;\n    }\n    VIR_FREE(tmp);\n    return ret;\n}"
  },
  {
    "function_name": "virInterfaceDefParseStartMode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "154-177",
    "snippet": "static int\nvirInterfaceDefParseStartMode(virInterfaceDefPtr def,\n                              xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n\n    tmp = virXPathString(\"string(./start/@mode)\", ctxt);\n    if (tmp == NULL) {\n        def->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    } else if (STREQ(tmp, \"onboot\")) {\n        def->startmode = VIR_INTERFACE_START_ONBOOT;\n    } else if (STREQ(tmp, \"hotplug\")) {\n        def->startmode = VIR_INTERFACE_START_HOTPLUG;\n    } else if (STREQ(tmp, \"none\")) {\n        def->startmode = VIR_INTERFACE_START_NONE;\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unknown interface startmode %s\"), tmp);\n        VIR_FREE(tmp);\n        return -1;\n    }\n    VIR_FREE(tmp);\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unknown interface startmode %s\")",
            "tmp"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown interface startmode %s\""
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"none\""
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"hotplug\""
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp",
            "\"onboot\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./start/@mode)\"",
            "ctxt"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseStartMode(virInterfaceDefPtr def,\n                              xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n\n    tmp = virXPathString(\"string(./start/@mode)\", ctxt);\n    if (tmp == NULL) {\n        def->startmode = VIR_INTERFACE_START_UNSPECIFIED;\n    } else if (STREQ(tmp, \"onboot\")) {\n        def->startmode = VIR_INTERFACE_START_ONBOOT;\n    } else if (STREQ(tmp, \"hotplug\")) {\n        def->startmode = VIR_INTERFACE_START_HOTPLUG;\n    } else if (STREQ(tmp, \"none\")) {\n        def->startmode = VIR_INTERFACE_START_NONE;\n    } else {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unknown interface startmode %s\"), tmp);\n        VIR_FREE(tmp);\n        return -1;\n    }\n    VIR_FREE(tmp);\n    return 0;\n}"
  },
  {
    "function_name": "virInterfaceDefParseMtu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "135-151",
    "snippet": "static int\nvirInterfaceDefParseMtu(virInterfaceDefPtr def,\n                        xmlXPathContextPtr ctxt)\n{\n    unsigned long mtu;\n    int ret;\n\n    ret = virXPathULong(\"string(./mtu/@size)\", ctxt, &mtu);\n    if ((ret == -2) || ((ret == 0) && (mtu > 100000))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"interface mtu value is improper\"));\n        return -1;\n    } else if (ret == 0) {\n        def->mtu = (unsigned int) mtu;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"interface mtu value is improper\")"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"interface mtu value is improper\""
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathULong",
          "args": [
            "\"string(./mtu/@size)\"",
            "ctxt",
            "&mtu"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "398-430",
          "snippet": "int\nvirXPathULongLong(const char *xpath,\n                  xmlXPathContextPtr ctxt,\n                  unsigned long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathULong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ull((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (unsigned long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathULongLong(const char *xpath,\n                  xmlXPathContextPtr ctxt,\n                  unsigned long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathULong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ull((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (unsigned long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseMtu(virInterfaceDefPtr def,\n                        xmlXPathContextPtr ctxt)\n{\n    unsigned long mtu;\n    int ret;\n\n    ret = virXPathULong(\"string(./mtu/@size)\", ctxt, &mtu);\n    if ((ret == -2) || ((ret == 0) && (mtu > 100000))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"interface mtu value is improper\"));\n        return -1;\n    } else if (ret == 0) {\n        def->mtu = (unsigned int) mtu;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virInterfaceDefParseName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "118-132",
    "snippet": "static int\nvirInterfaceDefParseName(virInterfaceDefPtr def,\n                         xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n\n    tmp = virXPathString(\"string(./@name)\", ctxt);\n    if (tmp == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\",  _(\"interface has no name\"));\n        return -1;\n    }\n    def->name = tmp;\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"interface has no name\")"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"interface has no name\""
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./@name)\"",
            "ctxt"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic int\nvirInterfaceDefParseName(virInterfaceDefPtr def,\n                         xmlXPathContextPtr ctxt)\n{\n    char *tmp;\n\n    tmp = virXPathString(\"string(./@name)\", ctxt);\n    if (tmp == NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\",  _(\"interface has no name\"));\n        return -1;\n    }\n    def->name = tmp;\n    return 0;\n}"
  },
  {
    "function_name": "virInterfaceDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "73-115",
    "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->protos"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceProtocolDefFree",
          "args": [
            "def->protos[pp]"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceProtocolDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "57-70",
          "snippet": "static void\nvirInterfaceProtocolDefFree(virInterfaceProtocolDefPtr def)\n{\n    size_t i;\n\n    if (def == NULL)\n        return;\n    for (i = 0; i < def->nips; i++)\n        virInterfaceIPDefFree(def->ips[i]);\n    VIR_FREE(def->ips);\n    VIR_FREE(def->family);\n    VIR_FREE(def->gateway);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic void\nvirInterfaceProtocolDefFree(virInterfaceProtocolDefPtr def)\n{\n    size_t i;\n\n    if (def == NULL)\n        return;\n    for (i = 0; i < def->nips; i++)\n        virInterfaceIPDefFree(def->ips[i]);\n    VIR_FREE(def->ips);\n    VIR_FREE(def->family);\n    VIR_FREE(def->gateway);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->data.vlan.dev_name"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->data.vlan.tag"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->data.bond.itf"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "def->data.bond.itf[i]"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->data.bond.target"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->data.bridge.itf"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->data.bridge.delay"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->mac"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->name"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
  },
  {
    "function_name": "virInterfaceProtocolDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "57-70",
    "snippet": "static void\nvirInterfaceProtocolDefFree(virInterfaceProtocolDefPtr def)\n{\n    size_t i;\n\n    if (def == NULL)\n        return;\n    for (i = 0; i < def->nips; i++)\n        virInterfaceIPDefFree(def->ips[i]);\n    VIR_FREE(def->ips);\n    VIR_FREE(def->family);\n    VIR_FREE(def->gateway);\n    VIR_FREE(def);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->gateway"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->family"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->ips"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceIPDefFree",
          "args": [
            "def->ips[i]"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceIPDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "47-54",
          "snippet": "static void\nvirInterfaceIPDefFree(virInterfaceIPDefPtr def)\n{\n    if (def == NULL)\n        return;\n    VIR_FREE(def->address);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic void\nvirInterfaceIPDefFree(virInterfaceIPDefPtr def)\n{\n    if (def == NULL)\n        return;\n    VIR_FREE(def->address);\n    VIR_FREE(def);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic void\nvirInterfaceProtocolDefFree(virInterfaceProtocolDefPtr def)\n{\n    size_t i;\n\n    if (def == NULL)\n        return;\n    for (i = 0; i < def->nips; i++)\n        virInterfaceIPDefFree(def->ips[i]);\n    VIR_FREE(def->ips);\n    VIR_FREE(def->family);\n    VIR_FREE(def->gateway);\n    VIR_FREE(def);\n}"
  },
  {
    "function_name": "virInterfaceIPDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
    "lines": "47-54",
    "snippet": "static void\nvirInterfaceIPDefFree(virInterfaceIPDefPtr def)\n{\n    if (def == NULL)\n        return;\n    VIR_FREE(def->address);\n    VIR_FREE(def);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->address"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic void\nvirInterfaceIPDefFree(virInterfaceIPDefPtr def)\n{\n    if (def == NULL)\n        return;\n    VIR_FREE(def->address);\n    VIR_FREE(def);\n}"
  }
]